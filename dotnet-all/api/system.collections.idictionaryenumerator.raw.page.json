{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">IDictionaryEnumerator</span>\r\n      Interface\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Enumerates the elements of a nongeneric dictionary.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(true)]\npublic interface IDictionaryEnumerator : System.Collections.IEnumerator</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Attributes</dt><dd>\r\n  \t\t<div class=\"cdlHolder\">\r\n  \t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>This code example shows how to define a dictionary enumerator that implements the IDictionaryEnumerator interface.  </p>\n<pre><code class=\"lang-cpp\" name=\"Dictionary#1\">using namespace System;\nusing namespace System::Collections;\n\n// This class implements a simple dictionary using an array of\n// DictionaryEntry objects (key/value pairs).\npublic ref class SimpleDictionary : public IDictionary\n{\n    // The array of items\nprivate:\n    array&lt;DictionaryEntry^&gt;^ items;\nprivate:\n    int itemsInUse;\n\n    // Construct the SimpleDictionary with the desired number of\n    // items. The number of items cannot change for the life time of\n    // this SimpleDictionary.\npublic:\n    SimpleDictionary(int size)\n    {\n        items = gcnew array&lt;DictionaryEntry^&gt;(size);\n    }\n\n    #pragma region IDictionary Members\npublic:\n    property virtual bool IsReadOnly\n    {\n        bool get()\n        {\n            return false;\n        }\n    }\npublic:\n    virtual bool Contains(Object^ key)\n    {\n        int index;\n        return TryGetIndexOfKey(key, &amp;index);\n    }\npublic:\n    virtual property bool IsFixedSize\n    {\n        bool get()\n        {\n            return false;\n        }\n    }\npublic:\n    virtual void Remove(Object^ key)\n    {\n        if (key == nullptr)\n        {\n            throw gcnew ArgumentNullException(&quot;key&quot;);\n        }\n        // Try to find the key in the DictionaryEntry array\n        int index;\n        if (TryGetIndexOfKey(key, &amp;index))\n        {\n            // If the key is found, slide all the items down.\n            Array::Copy(items, index + 1, items, index, itemsInUse -\n                index - 1);\n            itemsInUse--;\n        }\n        else\n        {\n            // If the key is not in the dictionary, just return.\n            return;\n        }\n    }\npublic:\n    virtual void Clear()\n    {\n        itemsInUse = 0;\n    }\npublic:\n    virtual void Add(Object^ key, Object^ value)\n    {\n        // Add the new key/value pair even if this key already exists\n        // in the dictionary.\n        if (itemsInUse == items-&gt;Length)\n        {\n            throw gcnew InvalidOperationException\n                (&quot;The dictionary cannot hold any more items.&quot;);\n        }\n        items[itemsInUse++] = gcnew DictionaryEntry(key, value);\n    }\npublic:\n    virtual property ICollection^ Keys\n    {\n        ICollection^ get()\n        {\n            // Return an array where each item is a key.\n            array&lt;Object^&gt;^ keys = gcnew array&lt;Object^&gt;(itemsInUse);\n            for (int i = 0; i &lt; itemsInUse; i++)\n            {\n                keys[i] = items[i]-&gt;Key;\n            }\n            return keys;\n        }\n    }\npublic:\n    virtual property ICollection^ Values\n    {\n        ICollection^ get()\n        {\n            // Return an array where each item is a value.\n            array&lt;Object^&gt;^ values = gcnew array&lt;Object^&gt;(itemsInUse);\n            for (int i = 0; i &lt; itemsInUse; i++)\n            {\n                values[i] = items[i]-&gt;Value;\n            }\n            return values;\n        }\n    }\npublic:\n    virtual property Object^ default[Object^]\n    {\n        Object^ get(Object^ key)\n        {\n            // If this key is in the dictionary, return its value.\n            int index;\n            if (TryGetIndexOfKey(key, &amp;index))\n            {\n                // The key was found; return its value.\n                return items[index]-&gt;Value;\n            }\n            else\n            {\n                // The key was not found; return null.\n                return nullptr;\n            }\n        }\n\n        void set(Object^ key, Object^ value)\n        {\n            // If this key is in the dictionary, change its value.\n            int index;\n            if (TryGetIndexOfKey(key, &amp;index))\n            {\n                // The key was found; change its value.\n                items[index]-&gt;Value = value;\n            }\n            else\n            {\n                // This key is not in the dictionary; add this\n                // key/value pair.\n                Add(key, value);\n            }\n        }\n    }\nprivate:\n    bool TryGetIndexOfKey(Object^ key, int* index)\n    {\n        for (*index = 0; *index &lt; itemsInUse; *index++)\n        {\n            // If the key is found, return true (the index is also\n            // returned).\n            if (items[*index]-&gt;Key-&gt;Equals(key))\n            {\n                return true;\n            }\n        }\n\n        // Key not found, return false (index should be ignored by\n        // the caller).\n        return false;\n    }\nprivate:\n    ref class SimpleDictionaryEnumerator : public IDictionaryEnumerator\n    {\n        // A copy of the SimpleDictionary object&#39;s key/value pairs.\nprivate:\n        array&lt;DictionaryEntry^&gt;^ items;\nprivate:\n        int index;\n\npublic:\n        SimpleDictionaryEnumerator(SimpleDictionary^ sd)\n        {\n            // Make a copy of the dictionary entries currently in the\n            // SimpleDictionary object.\n            items = gcnew array&lt;DictionaryEntry^&gt;(sd-&gt;Count);\n            Array::Copy(sd-&gt;items, 0, items, 0, sd-&gt;Count);\n            index = -1;\n        }\n\n        // Return the current item.\npublic:\n        virtual property Object^ Current\n        {\n            Object^ get()\n            {\n                ValidateIndex();\n                return items[index];\n            }\n        }\n\n        // Return the current dictionary entry.\npublic:\n        virtual property DictionaryEntry Entry\n        {\n            DictionaryEntry get()\n            {\n                return (DictionaryEntry) Current;\n            }\n        }\n\n        // Return the key of the current item.\npublic:\n        virtual property Object^ Key\n        {\n            Object^ get()\n            {\n                ValidateIndex();\n\t\t\t\treturn items[index]-&gt;Key;\n            }\n        }\n\n        // Return the value of the current item.\npublic:\n        virtual property Object^ Value\n        {\n            Object^ get()\n            {\n                ValidateIndex();\n                return items[index]-&gt;Value;\n            }\n        }\n\n        // Advance to the next item.\npublic:\n        virtual bool MoveNext()\n        {\n            if (index &lt; items-&gt;Length - 1)\n            {\n                index++;\n                return true;\n            }\n            return false;\n        }\n\n        // Validate the enumeration index and throw an exception if\n        // the index is out of range.\nprivate:\n        void ValidateIndex()\n        {\n            if (index &lt; 0 || index &gt;= items-&gt;Length)\n            {\n                throw gcnew InvalidOperationException\n                    (&quot;Enumerator is before or after the collection.&quot;);\n            }\n        }\n\n        // Reset the index to restart the enumeration.\npublic:\n        virtual void Reset()\n        {\n            index = -1;\n        }\n    };\npublic:\n    virtual IDictionaryEnumerator^ GetEnumerator()\n    {\n        // Construct and return an enumerator.\n        return gcnew SimpleDictionaryEnumerator(this);\n    }\n    #pragma endregion\n\n    #pragma region ICollection Members\npublic:\n    virtual property bool IsSynchronized\n    {\n        bool get()\n        {\n            return false;\n        }\n    }\n\npublic:\n    virtual property Object^ SyncRoot\n    {\n        Object^ get()\n        {\n            throw gcnew NotImplementedException();\n        }\n    }\n\npublic:\n    virtual property int Count\n    {\n        int get()\n        {\n            return itemsInUse;\n        }\n    }\n\npublic:\n    virtual void CopyTo(Array^ array, int index)\n    {\n        throw gcnew NotImplementedException();\n    }\n    #pragma endregion\n\n    #pragma region IEnumerable Members\n\n    virtual IEnumerator^ IEnumerable_GetEnumerator() \n        = IEnumerable::GetEnumerator\n    {\n        // Construct and return an enumerator.\n        return ((IDictionary^)this)-&gt;GetEnumerator();\n    }\n    #pragma endregion\n};\n\nint main()\n{\n    // Create a dictionary that contains no more than three\n    // entries.\n    IDictionary^ d = gcnew SimpleDictionary(3);\n\n    // Add three people and their ages to the dictionary.\n    d-&gt;Add(&quot;Jeff&quot;, 40);\n    d-&gt;Add(&quot;Kristin&quot;, 34);\n    d-&gt;Add(&quot;Aidan&quot;, 1);\n\n    Console::WriteLine(&quot;Number of elements in dictionary = {0}&quot;,\n        d-&gt;Count);\n\n    Console::WriteLine(&quot;Does dictionary contain &#39;Jeff&#39;? {0}&quot;,\n        d-&gt;Contains(&quot;Jeff&quot;));\n    Console::WriteLine(&quot;Jeff&#39;s age is {0}&quot;, d[&quot;Jeff&quot;]);\n\n    // Display every entry&#39;s key and value.\n    for each (DictionaryEntry^ de in d)\n    {\n        Console::WriteLine(&quot;{0} is {1} years old.&quot;, de-&gt;Key,\n            de-&gt;Value);\n    }\n\n    // Remove an entry that exists.\n    d-&gt;Remove(&quot;Jeff&quot;);\n\n    // Remove an entry that does not exist, but do not throw an\n    // exception.\n    d-&gt;Remove(&quot;Max&quot;);\n\n    // Show the names (keys) of the people in the dictionary.\n    for each (String^ s in d-&gt;Keys)\n    {\n        Console::WriteLine(s);\n    }\n\n    // Show the ages (values) of the people in the dictionary.\n    for each (int age in d-&gt;Values)\n    {\n        Console::WriteLine(age);\n    }\n}\n\n// This code produces the following output.\n//\n// Number of elements in dictionary = 3\n// Does dictionary contain &#39;Jeff&#39;? True\n// Jeff&#39;s age is 40\n// Jeff is 40 years old.\n// Kristin is 34 years old.\n// Aidan is 1 years old.\n// Kristin\n// Aidan\n// 34\n// 1\n</code></pre><pre><code class=\"lang-cs\" name=\"Dictionary#1\">using System;\nusing System.Collections;\n\n// This class implements a simple dictionary using an array of DictionaryEntry objects (key/value pairs).\npublic class SimpleDictionary : IDictionary\n{\n    // The array of items\n    private DictionaryEntry[] items;\n    private Int32 ItemsInUse = 0;\n\n    // Construct the SimpleDictionary with the desired number of items.\n    // The number of items cannot change for the life time of this SimpleDictionary.\n    public SimpleDictionary(Int32 numItems)\n    {\n        items = new DictionaryEntry[numItems];\n    }\n\n\n    #region IDictionary Members\n    public bool IsReadOnly { get { return false; } }\n    public bool Contains(object key)\n    {\n       Int32 index;\n       return TryGetIndexOfKey(key, out index);\n    }\n    public bool IsFixedSize { get { return false; } }\n    public void Remove(object key)\n    {\n        if (key == null) throw new ArgumentNullException(&quot;key&quot;);\n        // Try to find the key in the DictionaryEntry array\n        Int32 index;\n        if (TryGetIndexOfKey(key, out index))\n        {\n            // If the key is found, slide all the items up.\n            Array.Copy(items, index + 1, items, index, ItemsInUse - index - 1);\n            ItemsInUse--;\n        } \n        else\n        {\n            // If the key is not in the dictionary, just return. \n        }\n    }\n    public void Clear() { ItemsInUse = 0; }\n    public void Add(object key, object value) \n    {\n        // Add the new key/value pair even if this key already exists in the dictionary.\n        if (ItemsInUse == items.Length)\n            throw new InvalidOperationException(&quot;The dictionary cannot hold any more items.&quot;);\n        items[ItemsInUse++] = new DictionaryEntry(key, value);\n    }\n    public ICollection Keys\n    {\n        get\n        {\n            // Return an array where each item is a key.\n            Object[] keys = new Object[ItemsInUse];\n            for (Int32 n = 0; n &lt; ItemsInUse; n++)\n                keys[n] = items[n].Key;\n            return keys;\n        }\n    }\n    public ICollection Values\n    {\n        get\n        {\n            // Return an array where each item is a value.\n            Object[] values = new Object[ItemsInUse];\n            for (Int32 n = 0; n &lt; ItemsInUse; n++)\n                values[n] = items[n].Value;\n            return values;\n        }\n    }\n    public object this[object key]\n    {\n        get\n        {   \n            // If this key is in the dictionary, return its value.\n            Int32 index;\n            if (TryGetIndexOfKey(key, out index))\n            {\n                // The key was found; return its value.\n                return items[index].Value;\n            } \n            else\n            {\n                // The key was not found; return null.\n                return null;\n            }\n        }\n\n        set\n        {\n            // If this key is in the dictionary, change its value. \n            Int32 index;\n            if (TryGetIndexOfKey(key, out index))\n            {\n                // The key was found; change its value.\n                items[index].Value = value;\n            } \n            else\n            {\n                // This key is not in the dictionary; add this key/value pair.\n                Add(key, value);\n            }\n        }\n    }\n    private Boolean TryGetIndexOfKey(Object key, out Int32 index)\n    {\n        for (index = 0; index &lt; ItemsInUse; index++)\n        {\n            // If the key is found, return true (the index is also returned).\n            if (items[index].Key.Equals(key)) return true;\n        }\n      \n        // Key not found, return false (index should be ignored by the caller).\n        return false;\n    }\n    private class SimpleDictionaryEnumerator : IDictionaryEnumerator\n    {\n        // A copy of the SimpleDictionary object&#39;s key/value pairs.\n        DictionaryEntry[] items;\n        Int32 index = -1;\n\n        public SimpleDictionaryEnumerator(SimpleDictionary sd)\n        {\n            // Make a copy of the dictionary entries currently in the SimpleDictionary object.\n            items = new DictionaryEntry[sd.Count];\n            Array.Copy(sd.items, 0, items, 0, sd.Count);\n        }\n\n        // Return the current item.\n        public Object Current { get { ValidateIndex(); return items[index]; } }\n\n        // Return the current dictionary entry.\n        public DictionaryEntry Entry\n        {\n            get { return (DictionaryEntry) Current; }\n        }\n\n        // Return the key of the current item.\n        public Object Key { get { ValidateIndex();  return items[index].Key; } }\n\n        // Return the value of the current item.\n        public Object Value { get { ValidateIndex();  return items[index].Value; } }\n\n        // Advance to the next item.\n        public Boolean MoveNext()\n        {\n            if (index &lt; items.Length - 1) { index++; return true; }\n            return false;\n        }\n\n        // Validate the enumeration index and throw an exception if the index is out of range.\n        private void ValidateIndex()\n        {\n            if (index &lt; 0 || index &gt;= items.Length)\n            throw new InvalidOperationException(&quot;Enumerator is before or after the collection.&quot;);\n        }\n\n        // Reset the index to restart the enumeration.\n        public void Reset()\n        {\n            index = -1;\n        }\n    }\n    public IDictionaryEnumerator GetEnumerator()\n    {\n        // Construct and return an enumerator.\n        return new SimpleDictionaryEnumerator(this);\n    }\n    #endregion\n\n    #region ICollection Members\n    public bool IsSynchronized { get { return false; } }\n    public object SyncRoot { get { throw new NotImplementedException(); } }\n    public int Count { get { return ItemsInUse; } }\n    public void CopyTo(Array array, int index) { throw new NotImplementedException(); }\n    #endregion\n\n    #region IEnumerable Members\n    IEnumerator IEnumerable.GetEnumerator() \n    {\n        // Construct and return an enumerator.\n        return ((IDictionary)this).GetEnumerator();\n    }\n    #endregion\n}\n\npublic sealed class App\n{\n    static void Main()\n    {\n        // Create a dictionary that contains no more than three entries.\n        IDictionary d = new SimpleDictionary(3);\n\n        // Add three people and their ages to the dictionary.\n        d.Add(&quot;Jeff&quot;, 40);\n        d.Add(&quot;Kristin&quot;, 34);\n        d.Add(&quot;Aidan&quot;, 1);\n\n        Console.WriteLine(&quot;Number of elements in dictionary = {0}&quot;, d.Count);\n\n        Console.WriteLine(&quot;Does dictionary contain &#39;Jeff&#39;? {0}&quot;, d.Contains(&quot;Jeff&quot;));\n        Console.WriteLine(&quot;Jeff&#39;s age is {0}&quot;, d[&quot;Jeff&quot;]);\n\n        // Display every entry&#39;s key and value.\n        foreach (DictionaryEntry de in d)\n        {\n            Console.WriteLine(&quot;{0} is {1} years old.&quot;, de.Key, de.Value);\n        }\n\n        // Remove an entry that exists.\n        d.Remove(&quot;Jeff&quot;);\n\n        // Remove an entry that does not exist, but do not throw an exception.\n        d.Remove(&quot;Max&quot;);\n\n        // Show the names (keys) of the people in the dictionary.\n        foreach (String s in d.Keys)\n            Console.WriteLine(s);\n\n        // Show the ages (values) of the people in the dictionary.\n        foreach (Int32 age in d.Values)\n            Console.WriteLine(age);\n    }\n}\n\n// This code produces the following output.\n//\n// Number of elements in dictionary = 3\n// Does dictionary contain &#39;Jeff&#39;? True\n// Jeff&#39;s age is 40\n// Jeff is 40 years old.\n// Kristin is 34 years old.\n// Aidan is 1 years old.\n// Kristin\n// Aidan\n// 34\n// 1\n</code></pre><pre><code class=\"lang-vb\" name=\"Dictionary#1\">Imports System\nImports System.Collections\n\n&#39; This class implements a simple dictionary using an array of DictionaryEntry objects (key/value pairs).\nPublic Class SimpleDictionary\n    Implements IDictionary\n\n    &#39; The array of items\n    Dim items() As DictionaryEntry\n    Dim ItemsInUse As Integer = 0\n\n    &#39; Construct the SimpleDictionary with the desired number of items.\n    &#39; The number of items cannot change for the life time of this SimpleDictionary.\n    Public Sub New(ByVal numItems As Integer)\n        items = New DictionaryEntry(numItems - 1) {}\n    End Sub\n\n    &#39; IDictionary Members\n    Public ReadOnly Property IsReadOnly() As Boolean Implements IDictionary.IsReadOnly\n        Get\n            Return False\n        End Get\n    End Property\n\n    Public Function Contains(ByVal key As Object) As Boolean Implements IDictionary.Contains\n        Dim index As Integer\n        Return TryGetIndexOfKey(key, index)\n    End Function\n\n    Public ReadOnly Property IsFixedSize() As Boolean Implements IDictionary.IsFixedSize\n        Get\n            Return False\n        End Get\n    End Property\n\n    Public Sub Remove(ByVal key As Object) Implements IDictionary.Remove\n        If key = Nothing Then\n            Throw New ArgumentNullException(&quot;key&quot;)\n        End If\n        &#39; Try to find the key in the DictionaryEntry array\n        Dim index As Integer\n        If TryGetIndexOfKey(key, index) Then\n\n            &#39; If the key is found, slide all the items up.\n            Array.Copy(items, index + 1, items, index, (ItemsInUse - index) - 1)\n            ItemsInUse = ItemsInUse - 1\n        Else\n\n            &#39; If the key is not in the dictionary, just return. \n        End If\n    End Sub\n\n    Public Sub Clear() Implements IDictionary.Clear\n        ItemsInUse = 0\n    End Sub\n\n    Public Sub Add(ByVal key As Object, ByVal value As Object) Implements IDictionary.Add\n\n        &#39; Add the new key/value pair even if this key already exists in the dictionary.\n        If ItemsInUse = items.Length Then\n            Throw New InvalidOperationException(&quot;The dictionary cannot hold any more items.&quot;)\n        End If\n        items(ItemsInUse) = New DictionaryEntry(key, value)\n        ItemsInUse = ItemsInUse + 1\n    End Sub\n\n    Public ReadOnly Property Keys() As ICollection Implements IDictionary.Keys\n        Get\n\n            &#39; Return an array where each item is a key.\n            &#39; Note: Declaring keyArray() to have a size of ItemsInUse - 1\n            &#39;       ensures that the array is properly sized, in VB.NET\n            &#39;       declaring an array of size N creates an array with\n            &#39;       0 through N elements, including N, as opposed to N - 1\n            &#39;       which is the default behavior in C# and C++.\n            Dim keyArray() As Object = New Object(ItemsInUse - 1) {}\n            Dim n As Integer\n            For n = 0 To ItemsInUse - 1\n                keyArray(n) = items(n).Key\n            Next n\n\n            Return keyArray\n        End Get\n    End Property\n\n    Public ReadOnly Property Values() As ICollection Implements IDictionary.Values\n        Get\n            &#39; Return an array where each item is a value.\n            Dim valueArray() As Object = New Object(ItemsInUse - 1) {}\n            Dim n As Integer\n            For n = 0 To ItemsInUse - 1\n                valueArray(n) = items(n).Value\n            Next n\n\n            Return valueArray\n        End Get\n    End Property\n\n    Public Property Item(ByVal key As Object) As Object Implements IDictionary.Item\n        Get\n\n            &#39; If this key is in the dictionary, return its value.\n            Dim index As Integer\n            If TryGetIndexOfKey(key, index) Then\n\n                &#39; The key was found return its value.\n                Return items(index).Value\n            Else\n\n                &#39; The key was not found return null.\n                Return Nothing\n            End If\n        End Get\n\n        Set(ByVal value As Object)\n            &#39; If this key is in the dictionary, change its value. \n            Dim index As Integer\n            If TryGetIndexOfKey(key, index) Then\n\n                &#39; The key was found change its value.\n                items(index).Value = value\n            Else\n\n                &#39; This key is not in the dictionary add this key/value pair.\n                Add(key, value)\n            End If\n        End Set\n    End Property\n\n    Private Function TryGetIndexOfKey(ByVal key As Object, ByRef index As Integer) As Boolean\n        For index = 0 To ItemsInUse - 1\n            &#39; If the key is found, return true (the index is also returned).\n            If items(index).Key.Equals(key) Then\n                Return True\n            End If\n        Next index\n\n        &#39; Key not found, return false (index should be ignored by the caller).\n        Return False\n    End Function\n\n    Private Class SimpleDictionaryEnumerator\n        Implements IDictionaryEnumerator\n\n        &#39; A copy of the SimpleDictionary object&#39;s key/value pairs.\n        Dim items() As DictionaryEntry\n        Dim index As Integer = -1\n\n        Public Sub New(ByVal sd As SimpleDictionary)\n            &#39; Make a copy of the dictionary entries currently in the SimpleDictionary object.\n            items = New DictionaryEntry(sd.Count - 1) {}\n            Array.Copy(sd.items, 0, items, 0, sd.Count)\n        End Sub\n\n        &#39; Return the current item.\n        Public ReadOnly Property Current() As Object Implements IDictionaryEnumerator.Current\n            Get\n                ValidateIndex()\n                Return items(index)\n            End Get\n        End Property\n\n        &#39; Return the current dictionary entry.\n        Public ReadOnly Property Entry() As DictionaryEntry Implements IDictionaryEnumerator.Entry\n            Get\n                Return Current\n            End Get\n        End Property\n\n        &#39; Return the key of the current item.\n        Public ReadOnly Property Key() As Object Implements IDictionaryEnumerator.Key\n            Get\n                ValidateIndex()\n                Return items(index).Key\n            End Get\n        End Property\n\n        &#39; Return the value of the current item.\n        Public ReadOnly Property Value() As Object Implements IDictionaryEnumerator.Value\n            Get\n                ValidateIndex()\n                Return items(index).Value\n            End Get\n        End Property\n\n        &#39; Advance to the next item.\n        Public Function MoveNext() As Boolean Implements IDictionaryEnumerator.MoveNext\n            If index &lt; items.Length - 1 Then\n                index = index + 1\n                Return True\n            End If\n\n            Return False\n        End Function\n\n        &#39; Validate the enumeration index and throw an exception if the index is out of range.\n        Private Sub ValidateIndex()\n            If index &lt; 0 Or index &gt;= items.Length Then\n                Throw New InvalidOperationException(&quot;Enumerator is before or after the collection.&quot;)\n            End If\n        End Sub\n\n        &#39; Reset the index to restart the enumeration.\n        Public Sub Reset() Implements IDictionaryEnumerator.Reset\n            index = -1\n        End Sub\n\n    End Class\n\n    Public Function GetEnumerator() As IDictionaryEnumerator Implements IDictionary.GetEnumerator\n\n        &#39;Construct and return an enumerator.\n        Return New SimpleDictionaryEnumerator(Me)\n    End Function\n\n\n    &#39; ICollection Members\n    Public ReadOnly Property IsSynchronized() As Boolean Implements IDictionary.IsSynchronized\n        Get\n            Return False\n        End Get\n    End Property\n\n    Public ReadOnly Property SyncRoot() As Object Implements IDictionary.SyncRoot\n        Get\n            Throw New NotImplementedException()\n        End Get\n    End Property\n\n    Public ReadOnly Property Count() As Integer Implements IDictionary.Count\n        Get\n            Return ItemsInUse\n        End Get\n    End Property\n\n    Public Sub CopyTo(ByVal array As Array, ByVal index As Integer) Implements IDictionary.CopyTo\n        Throw New NotImplementedException()\n    End Sub\n\n    &#39; IEnumerable Members\n    Public Function GetEnumerator1() As IEnumerator Implements IEnumerable.GetEnumerator\n\n        &#39; Construct and return an enumerator.\n        Return Me.GetEnumerator()\n    End Function\nEnd Class\n\nPublic NotInheritable Class App\n    Public Shared Sub Main()\n        &#39; Create a dictionary that contains no more than three entries.\n        Dim d As IDictionary = New SimpleDictionary(3)\n\n        &#39; Add three people and their ages to the dictionary.\n        d.Add(&quot;Jeff&quot;, 40)\n        d.Add(&quot;Kristin&quot;, 34)\n        d.Add(&quot;Aidan&quot;, 1)\n\n        Console.WriteLine(&quot;Number of elements in dictionary = {0}&quot;, d.Count)\n\n        Console.WriteLine(&quot;Does dictionary contain &#39;Jeff&#39;? {0}&quot;, d.Contains(&quot;Jeff&quot;))\n        Console.WriteLine(&quot;Jeff&#39;s age is {0}&quot;, d(&quot;Jeff&quot;))\n\n        &#39; Display every entry&#39;s key and value.\n        Dim de As DictionaryEntry\n        For Each de In d\n            Console.WriteLine(&quot;{0} is {1} years old.&quot;, de.Key, de.Value)\n        Next\n\n        &#39; Remove an entry that exists.\n        d.Remove(&quot;Jeff&quot;)\n\n        &#39; Remove an entry that does not exist, but do not throw an exception.\n        d.Remove(&quot;Max&quot;)\n\n        &#39; Show the names (keys) of the people in the dictionary.\n        Dim s As String\n\n        For Each s In d.Keys\n            Console.WriteLine(s)\n        Next\n\n        &#39; Show the ages (values) of the people in the dictionary.\n        Dim age As Integer\n        For Each age In d.Values\n            Console.WriteLine(age)\n        Next\n\n    End Sub\nEnd Class\n\n&#39; This code produces the following output.\n&#39;\n&#39; Number of elements in dictionary = 3\n&#39; Does dictionary contain &#39;Jeff&#39;? True\n&#39; Jeff&#39;s age is 40\n&#39; Jeff is 40 years old.\n&#39; Kristin is 34 years old.\n&#39; Aidan is 1 years old.\n&#39; Kristin\n&#39; Aidan\n&#39; 34\n&#39; 1\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>[Visual Basic, C#]  </p>\n<p> The <code>foreach</code> statement of the C# language (<code>for each</code> in Visual Basic) hides the complexity of the enumerators.  Therefore, using <code>foreach</code> is recommended instead of directly manipulating the enumerator.  </p>\n<p> Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.  </p>\n<p> Initially, the enumerator is positioned before the first element in the collection. The <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Reset_\" data-linktype=\"relative-path\">Reset</a> method also brings the enumerator back to this position. At this position, calling the <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Current_\" data-linktype=\"relative-path\">Current</a> property throws an exception. Therefore, you must call the <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> method to advance the enumerator to the first element of the collection before reading the value of <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Current_\" data-linktype=\"relative-path\">Current</a>.  </p>\n<p> <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Current_\" data-linktype=\"relative-path\">Current</a> returns the same object until either <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> or <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Reset_\" data-linktype=\"relative-path\">Reset</a> is called. <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> sets <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Current_\" data-linktype=\"relative-path\">Current</a> to the next element.  </p>\n<p> If <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> passes the end of the collection, the enumerator is positioned after the last element in the collection and <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> returns <code>false</code>. When the enumerator is at this position, subsequent calls to <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> also return <code>false</code>. If the last call to <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> returned <code>false</code>, calling <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Current_\" data-linktype=\"relative-path\">Current</a> throws an exception. To set <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Current_\" data-linktype=\"relative-path\">Current</a> to the first element of the collection again, you can call <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Reset_\" data-linktype=\"relative-path\">Reset</a> followed by <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a>.  </p>\n<p> An enumerator remains valid as long as the collection remains unchanged. If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and the next call to <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> or <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Reset_\" data-linktype=\"relative-path\">Reset</a> throws an <a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a>. If the collection is modified between <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> and <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Current_\" data-linktype=\"relative-path\">Current</a>, <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Current_\" data-linktype=\"relative-path\">Current</a> returns the element that it is set to, even if the enumerator is already invalidated.  </p>\n<p> The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure. Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception. To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Properties\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_IDictionaryEnumerator_Entry_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_IDictionaryEnumerator_Entry\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Entry</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets both the key and the value of the current dictionary entry.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Collections.DictionaryEntry Entry { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.dictionaryentry\" data-linktype=\"relative-path\">DictionaryEntry</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <a class=\"xref\" href=\"system.collections.dictionaryentry\" data-linktype=\"relative-path\">DictionaryEntry</a> containing both the key and the value of the current dictionary entry.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <a class=\"xref\" href=\"system.collections.idictionaryenumerator\" data-linktype=\"relative-path\">IDictionaryEnumerator</a> is positioned before the first entry of the dictionary or after the last entry.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>After an enumerator is created or after the <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Reset_\" data-linktype=\"relative-path\">Reset</a> method is called, the <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> method must be called to advance the enumerator to the first element of the collection before reading the value of the Entry property; otherwise, Entry is undefined.  </p>\n<p> Entry also throws an exception if the last call to <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> returned <code>false</code>, which indicates the end of the collection.  </p>\n<p> Entry does not move the position of the enumerator, and consecutive calls to Entry return the same object until either <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> or <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Reset_\" data-linktype=\"relative-path\">Reset</a> is called.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_IDictionaryEnumerator_Key_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_IDictionaryEnumerator_Key\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Key</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets the key of the current dictionary entry.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public object Key { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The key of the current element of the enumeration.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <a class=\"xref\" href=\"system.collections.idictionaryenumerator\" data-linktype=\"relative-path\">IDictionaryEnumerator</a> is positioned before the first entry of the dictionary or after the last entry.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>After an enumerator is created or after the <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Reset_\" data-linktype=\"relative-path\">Reset</a> method is called, the <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> method must be called to advance the enumerator to the first element of the collection before reading the value of the Key property; otherwise, Key is undefined.  </p>\n<p> Key also throws an exception if the last call to <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> returned <code>false</code>, which indicates the end of the collection.  </p>\n<p> Key does not move the position of the enumerator, and consecutive calls to Key return the same object until either <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> or <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Reset_\" data-linktype=\"relative-path\">Reset</a> is called.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_IDictionaryEnumerator_Value_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_IDictionaryEnumerator_Value\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Value</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets the value of the current dictionary entry.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public object Value { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The value of the current element of the enumeration.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <a class=\"xref\" href=\"system.collections.idictionaryenumerator\" data-linktype=\"relative-path\">IDictionaryEnumerator</a> is positioned before the first entry of the dictionary or after the last entry.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>After an enumerator is created or after the <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Reset_\" data-linktype=\"relative-path\">Reset</a> method is called, the <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> method must be called to advance the enumerator to the first element of the collection before reading the value of the Value property; otherwise, Value is undefined.  </p>\n<p> Value also throws an exception if the last call to <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> returned <code>false</code>, which indicates the end of the collection.  </p>\n<p> Value does not move the position of the enumerator, and consecutive calls to Value return the same object until either <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> or <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Reset_\" data-linktype=\"relative-path\">Reset</a> is called.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Collections.IDictionaryEnumerator.yml\">\r\n<meta name=\"APIName\" content=\"System.Collections.IDictionaryEnumerator\">\r\n<meta name=\"APIName\" content=\"System.Collections.IDictionaryEnumerator.Entry\">\r\n<meta name=\"APIName\" content=\"System.Collections.IDictionaryEnumerator.Key\">\r\n<meta name=\"APIName\" content=\"System.Collections.IDictionaryEnumerator.Value\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-31 05:47 AM\">\r\n<meta name=\"document_id\" content=\"f4552ee2-e42b-e5bd-e67c-aec889ae061c\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Enumerates the elements of a nongeneric dictionary.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.collections/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Collections.IDictionaryEnumerator\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Collections.IDictionaryEnumerator.yml","open_to_public_contributors":false,"api_name":["System.Collections.IDictionaryEnumerator","System.Collections.IDictionaryEnumerator.Entry","System.Collections.IDictionaryEnumerator.Key","System.Collections.IDictionaryEnumerator.Value"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Collections.IDictionaryEnumerator","System::Collections::IDictionaryEnumerator","System.Collections.IDictionaryEnumerator.Entry","System::Collections::IDictionaryEnumerator::Entry","System.Collections.IDictionaryEnumerator.Key","System::Collections::IDictionaryEnumerator::Key","System.Collections.IDictionaryEnumerator.Value","System::Collections::IDictionaryEnumerator::Value"],"dev_langs":["csharp"],"updated_at":"2017-03-31 05:47 AM","document_id":"f4552ee2-e42b-e5bd-e67c-aec889ae061c","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Collections/IDictionaryEnumerator.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"IDictionaryEnumerator interface | Microsoft Docs","_op_ogTitle":"IDictionaryEnumerator interface","description":"Enumerates the elements of a nongeneric dictionary.\n","toc_asset_id":"api/_splitted/System.Collections/toc.json","toc_rel":"_splitted/System.Collections/toc.json","source_url":"","ms.assetid":"System.Collections.IDictionaryEnumerator","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.collections.idictionaryenumerator","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.collections.idictionaryenumerator","fileRelativePath":"api/System.Collections.IDictionaryEnumerator.html"},"themesRelativePathToOutputRoot":"_themes/"}