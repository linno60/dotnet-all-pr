{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">SpinLock</span>\r\n      Struct\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop repeatedly checking until the lock becomes available.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Diagnostics.DebuggerDisplay(&quot;IsHeld = {IsHeld}&quot;)]\n[System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.SpinLock/SystemThreading_SpinLockDebugView))]\n[System.Runtime.InteropServices.ComVisible(false)]\npublic struct SpinLock</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.valuetype\" data-linktype=\"relative-path\">ValueType</a></span></div><span class=\"lang-csharp\">SpinLock</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Attributes</dt><dd>\r\n  \t\t<div class=\"cdlHolder\">\r\n  \t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.diagnostics.debuggerdisplayattribute\" title=\"System.Diagnostics.DebuggerDisplayAttribute\" data-linktype=\"relative-path\">DebuggerDisplayAttribute</a></span>\r\n  \t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.diagnostics.debuggertypeproxyattribute\" title=\"System.Diagnostics.DebuggerTypeProxyAttribute\" data-linktype=\"relative-path\">DebuggerTypeProxyAttribute</a></span>\r\n  \t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following example shows how to use a SpinLock:  </p>\n<pre><code class=\"lang-vb\" name=\"System.Threading.SpinLock#01\">Imports System.Text\nImports System.Threading\nImports System.Threading.Tasks\n\n\nModule SpinLockDemo\n\n    &#39; Demonstrates:\n    &#39; Default SpinLock construction ()\n    &#39; SpinLock.Enter(ref bool)\n    &#39; SpinLock.Exit()\n    Private Sub SpinLockSample1()\n        Dim sl As New SpinLock()\n\n        Dim sb As New StringBuilder()\n\n        &#39; Action taken by each parallel job.\n        &#39; Append to the StringBuilder 10000 times, protecting\n        &#39; access to sb with a SpinLock.\n        Dim action As Action =\n            Sub()\n                Dim gotLock As Boolean = False\n                For i As Integer = 0 To 9999\n                    gotLock = False\n                    Try\n                        sl.Enter(gotLock)\n                        sb.Append((i Mod 10).ToString())\n                    Finally\n                        &#39; Only give up the lock if you actually acquired it\n                        If gotLock Then\n                            sl.[Exit]()\n                        End If\n                    End Try\n                Next\n            End Sub\n\n        &#39; Invoke 3 concurrent instances of the action above\n        Parallel.Invoke(action, action, action)\n\n        &#39; Check/Show the results\n        Console.WriteLine(&quot;sb.Length = {0} (should be 30000)&quot;, sb.Length)\n        Console.WriteLine(&quot;number of occurrences of &#39;5&#39; in sb: {0} (should be 3000)&quot;, sb.ToString().Where(Function(c) (c = &quot;5&quot;c)).Count())\n    End Sub\n\n    &#39; Demonstrates:\n    &#39; Default SpinLock constructor (tracking thread owner)\n    &#39; SpinLock.Enter(ref bool)\n    &#39; SpinLock.Exit() throwing exception\n    &#39; SpinLock.IsHeld\n    &#39; SpinLock.IsHeldByCurrentThread\n    &#39; SpinLock.IsThreadOwnerTrackingEnabled\n    Private Sub SpinLockSample2()\n        &#39; Instantiate a SpinLock\n        Dim sl As New SpinLock()\n\n        &#39; These MRESs help to sequence the two jobs below\n        Dim mre1 As New ManualResetEventSlim(False)\n        Dim mre2 As New ManualResetEventSlim(False)\n        Dim lockTaken As Boolean = False\n\n        Dim taskA As Task = Task.Factory.StartNew(\n            Sub()\n                Try\n                    sl.Enter(lockTaken)\n                    Console.WriteLine(&quot;Task A: entered SpinLock&quot;)\n                    mre1.[Set]()\n                    &#39; Signal Task B to commence with its logic\n                    &#39; Wait for Task B to complete its logic\n                    &#39; (Normally, you would not want to perform such a potentially\n                    &#39; heavyweight operation while holding a SpinLock, but we do it\n                    &#39; here to more effectively show off SpinLock properties in\n                    &#39; taskB.)\n                    mre2.Wait()\n                Finally\n                    If lockTaken Then\n                        sl.[Exit]()\n                    End If\n                End Try\n            End Sub)\n\n        Dim taskB As Task = Task.Factory.StartNew(\n            Sub()\n                mre1.Wait()\n                &#39; wait for Task A to signal me\n                Console.WriteLine(&quot;Task B: sl.IsHeld = {0} (should be true)&quot;, sl.IsHeld)\n                Console.WriteLine(&quot;Task B: sl.IsHeldByCurrentThread = {0} (should be false)&quot;, sl.IsHeldByCurrentThread)\n                Console.WriteLine(&quot;Task B: sl.IsThreadOwnerTrackingEnabled = {0} (should be true)&quot;, sl.IsThreadOwnerTrackingEnabled)\n\n                Try\n                    sl.[Exit]()\n                    Console.WriteLine(&quot;Task B: Released sl, should not have been able to!&quot;)\n                Catch e As Exception\n                    Console.WriteLine(&quot;Task B: sl.Exit resulted in exception, as expected: {0}&quot;, e.Message)\n                End Try\n\n                &#39; Signal Task A to exit the SpinLock\n                mre2.[Set]()\n            End Sub)\n\n        &#39; Wait for task completion and clean up\n        Task.WaitAll(taskA, taskB)\n        mre1.Dispose()\n        mre2.Dispose()\n    End Sub\n\n    &#39; Demonstrates:\n    &#39; SpinLock constructor(false) -- thread ownership not tracked\n    Private Sub SpinLockSample3()\n        &#39; Create SpinLock that does not track ownership/threadIDs\n        Dim sl As New SpinLock(False)\n\n        &#39; Used to synchronize with the Task below\n        Dim mres As New ManualResetEventSlim(False)\n\n        &#39; We will verify that the Task below runs on a separate thread\n        Console.WriteLine(&quot;main thread id = {0}&quot;, Thread.CurrentThread.ManagedThreadId)\n\n        &#39; Now enter the SpinLock.  Ordinarily, you would not want to spend so\n        &#39; much time holding a SpinLock, but we do it here for the purpose of \n        &#39; demonstrating that a non-ownership-tracking SpinLock can be exited \n        &#39; by a different thread than that which was used to enter it.\n        Dim lockTaken As Boolean = False\n        sl.Enter(lockTaken)\n\n        &#39; Create a separate Task\n        Dim worker As Task = Task.Factory.StartNew(\n            Sub()\n                Console.WriteLine(&quot;worker task thread id = {0} (should be different than main thread id)&quot;, Thread.CurrentThread.ManagedThreadId)\n\n                &#39; Now exit the SpinLock\n                Try\n                    sl.[Exit]()\n                    Console.WriteLine(&quot;worker task: successfully exited SpinLock, as expected&quot;)\n                Catch e As Exception\n                    Console.WriteLine(&quot;worker task: unexpected failure in exiting SpinLock: {0}&quot;, e.Message)\n                End Try\n\n                &#39; Notify main thread to continue\n                mres.[Set]()\n            End Sub)\n\n        &#39; Do this instead of worker.Wait(), because worker.Wait() could inline the worker Task,\n        &#39; causing it to be run on the same thread. The purpose of this example is to show that\n        &#39; a different thread can exit the SpinLock created (without thread tracking) on your thread.\n        mres.Wait()\n\n        &#39; now Wait() on worker and clean up\n        worker.Wait()\n        mres.Dispose()\n    End Sub\n\n\nEnd Module\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.SpinLock#01\">using System;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\n\n\nclass SpinLockDemo\n{\n\n\n    // Demonstrates:\n    //      Default SpinLock construction ()\n    //      SpinLock.Enter(ref bool)\n    //      SpinLock.Exit()\n    static void SpinLockSample1()\n    {\n        SpinLock sl = new SpinLock();\n\n        StringBuilder sb = new StringBuilder();\n\n        // Action taken by each parallel job.\n        // Append to the StringBuilder 10000 times, protecting\n        // access to sb with a SpinLock.\n        Action action = () =&gt;\n        {\n            bool gotLock = false;\n            for (int i = 0; i &lt; 10000; i++)\n            {\n                gotLock = false;\n                try\n                {\n                    sl.Enter(ref gotLock);\n                    sb.Append((i % 10).ToString());\n                }\n                finally\n                {\n                    // Only give up the lock if you actually acquired it\n                    if (gotLock) sl.Exit();\n                }\n            }\n        };\n\n        // Invoke 3 concurrent instances of the action above\n        Parallel.Invoke(action, action, action);\n\n        // Check/Show the results\n        Console.WriteLine(&quot;sb.Length = {0} (should be 30000)&quot;, sb.Length);\n        Console.WriteLine(&quot;number of occurrences of &#39;5&#39; in sb: {0} (should be 3000)&quot;,\n            sb.ToString().Where(c =&gt; (c == &#39;5&#39;)).Count());\n    }\n\n    // Demonstrates:\n    //      Default SpinLock constructor (tracking thread owner)\n    //      SpinLock.Enter(ref bool)\n    //      SpinLock.Exit() throwing exception\n    //      SpinLock.IsHeld\n    //      SpinLock.IsHeldByCurrentThread\n    //      SpinLock.IsThreadOwnerTrackingEnabled\n    static void SpinLockSample2()\n    {\n        // Instantiate a SpinLock\n        SpinLock sl = new SpinLock();\n\n        // These MRESs help to sequence the two jobs below\n        ManualResetEventSlim mre1 = new ManualResetEventSlim(false);\n        ManualResetEventSlim mre2 = new ManualResetEventSlim(false);\n        bool lockTaken = false;\n\n        Task taskA = Task.Factory.StartNew(() =&gt;\n        {\n            try\n            {\n                sl.Enter(ref lockTaken);\n                Console.WriteLine(&quot;Task A: entered SpinLock&quot;);\n                mre1.Set(); // Signal Task B to commence with its logic\n\n                // Wait for Task B to complete its logic\n                // (Normally, you would not want to perform such a potentially\n                // heavyweight operation while holding a SpinLock, but we do it\n                // here to more effectively show off SpinLock properties in\n                // taskB.)\n                mre2.Wait();\n            }\n            finally\n            {\n                if (lockTaken) sl.Exit();\n            }\n        });\n\n        Task taskB = Task.Factory.StartNew(() =&gt;\n        {\n            mre1.Wait(); // wait for Task A to signal me\n            Console.WriteLine(&quot;Task B: sl.IsHeld = {0} (should be true)&quot;, sl.IsHeld);\n            Console.WriteLine(&quot;Task B: sl.IsHeldByCurrentThread = {0} (should be false)&quot;, sl.IsHeldByCurrentThread);\n            Console.WriteLine(&quot;Task B: sl.IsThreadOwnerTrackingEnabled = {0} (should be true)&quot;, sl.IsThreadOwnerTrackingEnabled);\n\n            try\n            {\n                sl.Exit();\n                Console.WriteLine(&quot;Task B: Released sl, should not have been able to!&quot;);\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(&quot;Task B: sl.Exit resulted in exception, as expected: {0}&quot;, e.Message);\n            }\n\n            mre2.Set(); // Signal Task A to exit the SpinLock\n        });\n\n        // Wait for task completion and clean up\n        Task.WaitAll(taskA, taskB);\n        mre1.Dispose();\n        mre2.Dispose();\n    }\n\n    // Demonstrates:\n    //      SpinLock constructor(false) -- thread ownership not tracked\n    static void SpinLockSample3()\n    {\n        // Create SpinLock that does not track ownership/threadIDs\n        SpinLock sl = new SpinLock(false);\n\n        // Used to synchronize with the Task below\n        ManualResetEventSlim mres = new ManualResetEventSlim(false);\n\n        // We will verify that the Task below runs on a separate thread\n        Console.WriteLine(&quot;main thread id = {0}&quot;, Thread.CurrentThread.ManagedThreadId);\n\n        // Now enter the SpinLock.  Ordinarily, you would not want to spend so\n        // much time holding a SpinLock, but we do it here for the purpose of \n        // demonstrating that a non-ownership-tracking SpinLock can be exited \n        // by a different thread than that which was used to enter it.\n        bool lockTaken = false;\n        sl.Enter(ref lockTaken);\n\n        // Create a separate Task from which to Exit() the SpinLock\n        Task worker = Task.Factory.StartNew(() =&gt;\n        {\n            Console.WriteLine(&quot;worker task thread id = {0} (should be different than main thread id)&quot;,\n                Thread.CurrentThread.ManagedThreadId);\n\n            // Now exit the SpinLock\n            try\n            {\n                sl.Exit();\n                Console.WriteLine(&quot;worker task: successfully exited SpinLock, as expected&quot;);\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(&quot;worker task: unexpected failure in exiting SpinLock: {0}&quot;, e.Message);\n            }\n\n            // Notify main thread to continue\n            mres.Set();\n        });\n\n        // Do this instead of worker.Wait(), because worker.Wait() could inline the worker Task,\n        // causing it to be run on the same thread.  The purpose of this example is to show that\n        // a different thread can exit the SpinLock created (without thread tracking) on your thread.\n        mres.Wait();\n\n        // now Wait() on worker and clean up\n        worker.Wait();\n        mres.Dispose();\n    }\n\n}\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>For an example of how to use a Spin Lock, see <a href=\"../Topic/How%20to:%20Use%20SpinLock%20for%20Low-Level%20Synchronization.md\" data-linktype=\"relative-path\">How to: Use SpinLock for Low-Level Synchronization</a>.  </p>\n<p> Spin locks can be used for leaf-level locks where the object allocation implied by using a <a class=\"xref\" href=\"system.threading.monitor\" data-linktype=\"relative-path\">Monitor</a>, in size or due to garbage collection pressure, is overly expensive. A spin lock can be useful in to avoid blocking; however, if you expect a significant amount of blocking, you should probably not use spin locks due to excessive spinning. Spinning can be beneficial when locks are fine-grained and large in number (for example, a lock per node in a linked list) and also when lock hold-times are always extremely short. In general, while holding a spin lock, one should avoid any of these actions:  </p>\n<ul>\n<li><p>blocking,  </p>\n</li>\n<li><p>calling anything that itself may block,  </p>\n</li>\n<li><p>holding more than one spin lock at once,  </p>\n</li>\n<li><p>making dynamically dispatched calls (interface and virtuals),  </p>\n</li>\n<li><p>making statically dispatched calls into any code one doesn&#39;t own, or  </p>\n</li>\n<li><p>allocating memory.  </p>\n</li>\n</ul>\n<p> SpinLock should only be used after you have been determined that doing so will improve an application&#39;s performance. It is also important to note that SpinLock is a value type, for performance reasons. For this reason, you must be very careful not to accidentally copy a SpinLock instance, as the two instances (the original and the copy) would then be completely independent of one another, which would likely lead to erroneous behavior of the application. If a SpinLock instance must be passed around, it should be passed by reference rather than by value.  </p>\n<p> Do not store SpinLock instances in readonly fields.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Constructors\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_SpinLock__ctor_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_SpinLock__ctor_System_Boolean_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">SpinLock(Boolean)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.spinlock\" data-linktype=\"relative-path\">SpinLock</a> structure with the option to track thread IDs to improve debugging.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public SpinLock (bool enableThreadOwnerTracking);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>enableThreadOwnerTracking</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>Whether to capture and use thread IDs for debugging purposes.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.diagnostics.debuggerdisplayattribute\" title=\"System.Diagnostics.DebuggerDisplayAttribute\" data-linktype=\"relative-path\">DebuggerDisplayAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.diagnostics.debuggertypeproxyattribute\" title=\"System.Diagnostics.DebuggerTypeProxyAttribute\" data-linktype=\"relative-path\">DebuggerTypeProxyAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The default constructor for <a class=\"xref\" href=\"system.threading.spinlock\" data-linktype=\"relative-path\">SpinLock</a> tracks thread ownership.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Properties\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_SpinLock_IsHeld_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_SpinLock_IsHeld\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">IsHeld</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets whether the lock is currently held by any thread.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public bool IsHeld { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>true if the lock is currently held by any thread; otherwise false.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><span class=\"xref\">get: System.Runtime.ConstrainedExecution.ReliabilityContract</span></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_SpinLock_IsHeldByCurrentThread_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_SpinLock_IsHeldByCurrentThread\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">IsHeldByCurrentThread</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets whether the lock is held by the current thread.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public bool IsHeldByCurrentThread { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>true if the lock is held by the current thread; otherwise false.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><span class=\"xref\">get: System.Runtime.ConstrainedExecution.ReliabilityContract</span></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>Thread ownership tracking is disabled.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>If the lock was initialized to track owner threads, this will return whether the lock is acquired by the current thread. It is invalid to use this property when the lock was initialized to not track thread ownership.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_SpinLock_IsThreadOwnerTrackingEnabled_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_SpinLock_IsThreadOwnerTrackingEnabled\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">IsThreadOwnerTrackingEnabled</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets whether thread ownership tracking is enabled for this instance.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public bool IsThreadOwnerTrackingEnabled { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>true if thread ownership tracking is enabled for this instance; otherwise false.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><span class=\"xref\">get: System.Runtime.ConstrainedExecution.ReliabilityContract</span></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Methods\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_SpinLock_Enter_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_SpinLock_Enter_System_Boolean__\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Enter(Boolean)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Acquires the lock in a reliable manner, such that even if an exception occurs within the method call, <code>lockTaken</code> can be examined reliably to determine whether the lock was acquired.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void Enter (ref bool lockTaken);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>lockTaken</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>True if the lock is acquired; otherwise, false. <code>lockTaken</code> must be initialized to false prior to calling this method.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.diagnostics.debuggerdisplayattribute\" title=\"System.Diagnostics.DebuggerDisplayAttribute\" data-linktype=\"relative-path\">DebuggerDisplayAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.diagnostics.debuggertypeproxyattribute\" title=\"System.Diagnostics.DebuggerTypeProxyAttribute\" data-linktype=\"relative-path\">DebuggerTypeProxyAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>lockTaken</code> argument must be initialized to false prior to calling Enter.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.lockrecursionexception\" data-linktype=\"relative-path\">LockRecursionException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>Thread ownership tracking is enabled, and the current thread has already acquired this lock.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p><a class=\"xref\" href=\"system.threading.spinlock\" data-linktype=\"relative-path\">SpinLock</a> is a non-reentrant lock, meaning that if a thread holds the lock, it is not allowed to enter the lock again. If thread ownership tracking is enabled (whether it&#39;s enabled is available through <a class=\"xref\" href=\"system.threading.spinlock#System_Threading_SpinLock_IsThreadOwnerTrackingEnabled_\" data-linktype=\"relative-path\">IsThreadOwnerTrackingEnabled</a>), an exception will be thrown when a thread tries to re-enter a lock it already holds. However, if thread ownership tracking is disabled, attempting to enter a lock already held will result in deadlock.  </p>\n<p> If you call <a class=\"xref\" href=\"system.threading.spinlock#System_Threading_SpinLock_Exit_\" data-linktype=\"relative-path\">Exit</a> without having first called Enter the internal state of the <a class=\"xref\" href=\"system.threading.spinlock\" data-linktype=\"relative-path\">SpinLock</a> can become corrupted.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_SpinLock_Exit_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_SpinLock_Exit\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Exit()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Releases the lock.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void Exit ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.constrainedexecution.reliabilitycontractattribute\" title=\"System.Runtime.ConstrainedExecution.ReliabilityContractAttribute\" data-linktype=\"relative-path\">ReliabilityContractAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.synchronizationlockexception\" data-linktype=\"relative-path\">SynchronizationLockException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>Thread ownership tracking is enabled, and the current thread is not the owner of this lock.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The default overload of Exit provides the same behavior as if calling <a class=\"xref\" href=\"system.threading.spinlock#System_Threading_SpinLock_Exit_\" data-linktype=\"relative-path\">Exit</a> using true as the argument.  </p>\n<p> If you call Exit without having first called <a class=\"xref\" href=\"system.threading.spinlock#System_Threading_SpinLock_Enter_\" data-linktype=\"relative-path\">Enter</a> the internal state of the <a class=\"xref\" href=\"system.threading.spinlock\" data-linktype=\"relative-path\">SpinLock</a> can become corrupted.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_SpinLock_Exit_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_SpinLock_Exit_System_Boolean_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Exit(Boolean)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Releases the lock.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void Exit (bool useMemoryBarrier);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>useMemoryBarrier</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A Boolean value that indicates whether a memory fence should be issued in order to immediately publish the exit operation to other threads.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.constrainedexecution.reliabilitycontractattribute\" title=\"System.Runtime.ConstrainedExecution.ReliabilityContractAttribute\" data-linktype=\"relative-path\">ReliabilityContractAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.synchronizationlockexception\" data-linktype=\"relative-path\">SynchronizationLockException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>Thread ownership tracking is enabled, and the current thread is not the owner of this lock.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Calling Exit with the <code>useMemoryBarrier</code> argument set to true will improve the fairness of the lock at the expense of some performance. The default <a class=\"xref\" href=\"system.threading.spinlock#System_Threading_SpinLock_Exit_\" data-linktype=\"relative-path\">Exit</a> overload behaves as if specifying true for <code>useMemoryBarrier</code>.  </p>\n<p> If you call <a class=\"xref\" href=\"system.threading.spinlock#System_Threading_SpinLock_Exit_\" data-linktype=\"relative-path\">Exit</a> without having first called <a class=\"xref\" href=\"system.threading.spinlock#System_Threading_SpinLock_Enter_\" data-linktype=\"relative-path\">Enter</a> the internal state of the <a class=\"xref\" href=\"system.threading.spinlock\" data-linktype=\"relative-path\">SpinLock</a> can become corrupted.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_SpinLock_TryEnter_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_SpinLock_TryEnter_System_Boolean__\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">TryEnter(Boolean)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <code>lockTaken</code> can be examined reliably to determine whether the lock was acquired.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void TryEnter (ref bool lockTaken);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>lockTaken</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>True if the lock is acquired; otherwise, false. <code>lockTaken</code> must be initialized to false prior to calling this method.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.diagnostics.debuggerdisplayattribute\" title=\"System.Diagnostics.DebuggerDisplayAttribute\" data-linktype=\"relative-path\">DebuggerDisplayAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.diagnostics.debuggertypeproxyattribute\" title=\"System.Diagnostics.DebuggerTypeProxyAttribute\" data-linktype=\"relative-path\">DebuggerTypeProxyAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>lockTaken</code> argument must be initialized to false prior to calling TryEnter.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.lockrecursionexception\" data-linktype=\"relative-path\">LockRecursionException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>Thread ownership tracking is enabled, and the current thread has already acquired this lock.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Unlike <a class=\"xref\" href=\"system.threading.spinlock#System_Threading_SpinLock_Enter_\" data-linktype=\"relative-path\">Enter</a>, TryEnter will not block waiting for the lock to be available. If the lock is not available when TryEnter is called, it will return immediately without any further spinning.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_SpinLock_TryEnter_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_SpinLock_TryEnter_System_Int32_System_Boolean__\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">TryEnter(Int32, Boolean)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <code>lockTaken</code> can be examined reliably to determine whether the lock was acquired.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void TryEnter (int millisecondsTimeout, ref bool lockTaken);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>millisecondsTimeout</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The number of milliseconds to wait, or <a class=\"xref\" href=\"system.threading.timeout#System_Threading_Timeout_Infinite\" data-linktype=\"relative-path\">Infinite</a> (-1) to wait indefinitely.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>lockTaken</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>True if the lock is acquired; otherwise, false. <code>lockTaken</code> must be initialized to false prior to calling this method.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.diagnostics.debuggerdisplayattribute\" title=\"System.Diagnostics.DebuggerDisplayAttribute\" data-linktype=\"relative-path\">DebuggerDisplayAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.diagnostics.debuggertypeproxyattribute\" title=\"System.Diagnostics.DebuggerTypeProxyAttribute\" data-linktype=\"relative-path\">DebuggerTypeProxyAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>lockTaken</code> argument must be initialized to false prior to calling TryEnter.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.lockrecursionexception\" data-linktype=\"relative-path\">LockRecursionException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>Thread ownership tracking is enabled, and the current thread has already acquired this lock.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Unlike <a class=\"xref\" href=\"system.threading.spinlock#System_Threading_SpinLock_Enter_\" data-linktype=\"relative-path\">Enter</a>, TryEnter will not block indefinitely waiting for the lock to be available. It will block until either the lock is available or until the <code>millisecondsTimeout</code> has expired.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_SpinLock_TryEnter_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_SpinLock_TryEnter_System_TimeSpan_System_Boolean__\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">TryEnter(TimeSpan, Boolean)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <code>lockTaken</code> can be examined reliably to determine whether the lock was acquired.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void TryEnter (TimeSpan timeout, ref bool lockTaken);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>timeout</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents the number of milliseconds to wait, or a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents -1 milliseconds to wait indefinitely.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>lockTaken</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>True if the lock is acquired; otherwise, false. <code>lockTaken</code> must be initialized to false prior to calling this method.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.diagnostics.debuggerdisplayattribute\" title=\"System.Diagnostics.DebuggerDisplayAttribute\" data-linktype=\"relative-path\">DebuggerDisplayAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.diagnostics.debuggertypeproxyattribute\" title=\"System.Diagnostics.DebuggerTypeProxyAttribute\" data-linktype=\"relative-path\">DebuggerTypeProxyAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">MaxValue</a> milliseconds.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>lockTaken</code> argument must be initialized to false prior to calling TryEnter.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.lockrecursionexception\" data-linktype=\"relative-path\">LockRecursionException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>Thread ownership tracking is enabled, and the current thread has already acquired this lock.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Unlike <a class=\"xref\" href=\"system.threading.spinlock#System_Threading_SpinLock_Enter_\" data-linktype=\"relative-path\">Enter</a>, TryEnter will not block indefinitely waiting for the lock to be available. It will block until either the lock is available or until the <code>timeout</code> has expired.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \t<h2 class=\"accented\">Thread Safety</h2>\r\n  \tAll members of SpinLock are thread-safe and may be used from multiple threads concurrently.\r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Threading.SpinLock.yml\">\r\n<meta name=\"APIName\" content=\"System.Threading.SpinLock\">\r\n<meta name=\"APIName\" content=\"System.Threading.SpinLock..ctor\">\r\n<meta name=\"APIName\" content=\"System.Threading.SpinLock.Enter\">\r\n<meta name=\"APIName\" content=\"System.Threading.SpinLock.Exit\">\r\n<meta name=\"APIName\" content=\"System.Threading.SpinLock.IsHeld\">\r\n<meta name=\"APIName\" content=\"System.Threading.SpinLock.IsHeldByCurrentThread\">\r\n<meta name=\"APIName\" content=\"System.Threading.SpinLock.IsThreadOwnerTrackingEnabled\">\r\n<meta name=\"APIName\" content=\"System.Threading.SpinLock.TryEnter\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-31 05:47 AM\">\r\n<meta name=\"document_id\" content=\"0450b537-7ac6-6695-0e6b-80099e20a32b\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop repeatedly checking until the lock becomes available.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.threading/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Threading.SpinLock\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Threading.SpinLock.yml","open_to_public_contributors":false,"api_name":["System.Threading.SpinLock","System.Threading.SpinLock..ctor","System.Threading.SpinLock.Enter","System.Threading.SpinLock.Exit","System.Threading.SpinLock.IsHeld","System.Threading.SpinLock.IsHeldByCurrentThread","System.Threading.SpinLock.IsThreadOwnerTrackingEnabled","System.Threading.SpinLock.TryEnter"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Threading.SpinLock","System::Threading::SpinLock","System.Threading.SpinLock.#ctor","System::Threading::SpinLock::#ctor","System.Threading.SpinLock.Enter","System::Threading::SpinLock::Enter","System.Threading.SpinLock.Exit","System::Threading::SpinLock::Exit","System.Threading.SpinLock.IsHeld","System::Threading::SpinLock::IsHeld","System.Threading.SpinLock.IsHeldByCurrentThread","System::Threading::SpinLock::IsHeldByCurrentThread","System.Threading.SpinLock.IsThreadOwnerTrackingEnabled","System::Threading::SpinLock::IsThreadOwnerTrackingEnabled","System.Threading.SpinLock.TryEnter","System::Threading::SpinLock::TryEnter"],"dev_langs":["csharp"],"updated_at":"2017-03-31 05:47 AM","document_id":"0450b537-7ac6-6695-0e6b-80099e20a32b","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Threading/SpinLock.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"SpinLock struct | Microsoft Docs","_op_ogTitle":"SpinLock struct","description":"Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop repeatedly checking until the lock becomes available.\n","toc_asset_id":"api/_splitted/System.Threading/toc.json","toc_rel":"_splitted/System.Threading/toc.json","source_url":"","ms.assetid":"System.Threading.SpinLock","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.threading.spinlock","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.threading.spinlock","fileRelativePath":"api/System.Threading.SpinLock.html"},"themesRelativePathToOutputRoot":"_themes/"}