{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">SafeHandle</span>\r\n    \t\t\t\tClass\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Represents a wrapper class for operating system handles. This class must be inherited.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Security.SecurityCritical]\npublic abstract class SafeHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtime.constrainedexecution.criticalfinalizerobject\" data-linktype=\"relative-path\">CriticalFinalizerObject</a></span></div><span class=\"lang-csharp\">SafeHandle</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Derived</dt><dd>\r\n  \t\t<div class=\"cdlHolder\">\r\n        \t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"microsoft.win32.safehandles.safeaccesstokenhandle\" data-linktype=\"relative-path\">SafeAccessTokenHandle</a></span></div>\r\n        \t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"microsoft.win32.safehandles.safehandleminusoneisinvalid\" data-linktype=\"relative-path\">SafeHandleMinusOneIsInvalid</a></span></div>\r\n        \t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"microsoft.win32.safehandles.safehandlezeroorminusoneisinvalid\" data-linktype=\"relative-path\">SafeHandleZeroOrMinusOneIsInvalid</a></span></div>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Attributes</dt><dd>\r\n  \t\t<div class=\"cdlHolder\">\r\n  \t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitycriticalattribute\" title=\"System.Security.SecurityCriticalAttribute\" data-linktype=\"relative-path\">SecurityCriticalAttribute</a></span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \t<h3 class=\"accented\">Inherited Members</h3>\r\n  \t<h4 class=\"accented\"></h4>\r\n  \t<div class=\"cdlHolder\">\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a></span></div>\r\n  \t</div>\r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following code example creates a custom safe handle for an operating system file handle, deriving from <a class=\"xref\" href=\"microsoft.win32.safehandles.safehandlezeroorminusoneisinvalid\" data-linktype=\"relative-path\">SafeHandleZeroOrMinusOneIsInvalid</a>. It reads bytes from a file and displays their hexadecimal values. It also contains a fault testing harness that causes the thread to abort, but the handle value is freed.  When using an <a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a> to represent handles, the handle is occasionally leaked due to the asynchronous thread abort.  </p>\n<p> You will need a text file in the same folder as the compiled application. Assuming that you name the application &quot;HexViewer&quot;, the command line usage is:  </p>\n<p> <code>HexViewer &lt;filename&gt; -Fault</code>  </p>\n<p> Optionally specify <code>-Fault</code> to intentionally attempt to leak the handle by aborting the thread in a certain window. Use the Windows Perform.exe tool to monitor handle counts while injecting faults.  </p>\n<pre><code class=\"lang-cs\" name=\"SafeHandle#1\">using System;\nusing System.Runtime.InteropServices;\nusing System.IO;\nusing System.ComponentModel;\nusing System.Security.Permissions;\nusing System.Security;\nusing System.Threading;\nusing Microsoft.Win32.SafeHandles;\nusing System.Runtime.ConstrainedExecution;\n\nnamespace SafeHandleDemo\n{\n    [SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode = true)]\n    [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]\n    internal class MySafeFileHandle : SafeHandleZeroOrMinusOneIsInvalid\n    {\n        // Create a SafeHandle, informing the base class\n        // that this SafeHandle instance &quot;owns&quot; the handle,\n        // and therefore SafeHandle should call\n        // our ReleaseHandle method when the SafeHandle\n        // is no longer in use.\n        private MySafeFileHandle()\n            : base(true)\n        {\n        }\n        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]\n        override protected bool ReleaseHandle()\n        {\n            // Here, we must obey all rules for constrained execution regions.\n            return NativeMethods.CloseHandle(handle);\n            // If ReleaseHandle failed, it can be reported via the\n            // &quot;releaseHandleFailed&quot; managed debugging assistant (MDA).  This\n            // MDA is disabled by default, but can be enabled in a debugger\n            // or during testing to diagnose handle corruption problems.\n            // We do not throw an exception because most code could not recover\n            // from the problem.\n        }\n    }\n\n    [SuppressUnmanagedCodeSecurity()]\n    internal static class NativeMethods\n    {\n        // Win32 constants for accessing files.\n        internal const int GENERIC_READ = unchecked((int)0x80000000);\n\n        // Allocate a file object in the kernel, then return a handle to it.\n        [DllImport(&quot;kernel32&quot;, SetLastError = true, CharSet = CharSet.Unicode)]\n        internal extern static MySafeFileHandle CreateFile(String fileName,\n           int dwDesiredAccess, System.IO.FileShare dwShareMode,\n           IntPtr securityAttrs_MustBeZero, System.IO.FileMode dwCreationDisposition,\n           int dwFlagsAndAttributes, IntPtr hTemplateFile_MustBeZero);\n\n        // Use the file handle.\n        [DllImport(&quot;kernel32&quot;, SetLastError = true)]\n        internal extern static int ReadFile(MySafeFileHandle handle, byte[] bytes,\n           int numBytesToRead, out int numBytesRead, IntPtr overlapped_MustBeZero);\n\n        // Free the kernel&#39;s file object (close the file).\n        [DllImport(&quot;kernel32&quot;, SetLastError = true)]\n        [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]\n        internal extern static bool CloseHandle(IntPtr handle);\n    }\n\n    // The MyFileReader class is a sample class that accesses an operating system\n    // resource and implements IDisposable. This is useful to show the types of\n    // transformation required to make your resource wrapping classes\n    // more resilient. Note the Dispose and Finalize implementations.\n    // Consider this a simulation of System.IO.FileStream.\n    public class MyFileReader : IDisposable\n    {\n        // _handle is set to null to indicate disposal of this instance.\n        private MySafeFileHandle _handle;\n\n        public MyFileReader(String fileName)\n        {\n            // Security permission check.\n            String fullPath = Path.GetFullPath(fileName);\n            new FileIOPermission(FileIOPermissionAccess.Read, fullPath).Demand();\n\n            // Open a file, and save its handle in _handle.\n            // Note that the most optimized code turns into two processor\n            // instructions: 1) a call, and 2) moving the return value into\n            // the _handle field.  With SafeHandle, the CLR&#39;s platform invoke\n            // marshaling layer will store the handle into the SafeHandle\n            // object in an atomic fashion. There is still the problem\n            // that the SafeHandle object may not be stored in _handle, but\n            // the real operating system handle value has been safely stored\n            // in a critical finalizable object, ensuring against leaking\n            // the handle even if there is an asynchronous exception.\n\n            MySafeFileHandle tmpHandle;\n            tmpHandle = NativeMethods.CreateFile(fileName, NativeMethods.GENERIC_READ,\n                FileShare.Read, IntPtr.Zero, FileMode.Open, 0, IntPtr.Zero);\n\n            // An async exception here will cause us to run our finalizer with\n            // a null _handle, but MySafeFileHandle&#39;s ReleaseHandle code will\n            // be invoked to free the handle.\n\n            // This call to Sleep, run from the fault injection code in Main,\n            // will help trigger a race. But it will not cause a handle leak\n            // because the handle is already stored in a SafeHandle instance.\n            // Critical finalization then guarantees that freeing the handle,\n            // even during an unexpected AppDomain unload.\n            Thread.Sleep(500);\n            _handle = tmpHandle;  // Makes _handle point to a critical finalizable object.\n\n            // Determine if file is opened successfully.\n            if (_handle.IsInvalid)\n                throw new Win32Exception(Marshal.GetLastWin32Error(), fileName);\n        }\n\n        public void Dispose()  // Follow the Dispose pattern - public nonvirtual.\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n\n        // No finalizer is needed. The finalizer on SafeHandle\n        // will clean up the MySafeFileHandle instance,\n        // if it hasn&#39;t already been disposed.\n        // Howerver, there may be a need for a subclass to\n        // introduce a finalizer, so Dispose is properly implemented here.\n        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]\n        protected virtual void Dispose(bool disposing)\n        {\n            // Note there are three interesting states here:\n            // 1) CreateFile failed, _handle contains an invalid handle\n            // 2) We called Dispose already, _handle is closed.\n            // 3) _handle is null, due to an async exception before\n            //    calling CreateFile. Note that the finalizer runs\n            //    if the constructor fails.\n            if (_handle != null &amp;&amp; !_handle.IsInvalid)\n            {\n                // Free the handle\n                _handle.Dispose();\n            }\n            // SafeHandle records the fact that we&#39;ve called Dispose.\n        }\n\n\n        [SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]\n        public byte[] ReadContents(int length)\n        {\n            if (_handle.IsInvalid)  // Is the handle disposed?\n                throw new ObjectDisposedException(&quot;FileReader is closed&quot;);\n\n            // This sample code will not work for all files.\n            byte[] bytes = new byte[length];\n            int numRead = 0;\n            int r = NativeMethods.ReadFile(_handle, bytes, length, out numRead, IntPtr.Zero);\n            // Since we removed MyFileReader&#39;s finalizer, we no longer need to\n            // call GC.KeepAlive here.  Platform invoke will keep the SafeHandle\n            // instance alive for the duration of the call.\n            if (r == 0)\n                throw new Win32Exception(Marshal.GetLastWin32Error());\n            if (numRead &lt; length)\n            {\n                byte[] newBytes = new byte[numRead];\n                Array.Copy(bytes, newBytes, numRead);\n                bytes = newBytes;\n            }\n            return bytes;\n        }\n    }\n\n    static class Program\n    {\n        // Testing harness that injects faults.\n        private static bool _printToConsole = false;\n        private static bool _workerStarted = false;\n\n        private static void Usage()\n        {\n            Console.WriteLine(&quot;Usage:&quot;);\n            // Assumes that application is named HexViwer&quot;\n            Console.WriteLine(&quot;HexViewer &lt;fileName&gt; [-fault]&quot;);\n            Console.WriteLine(&quot; -fault Runs hex viewer repeatedly, injecting faults.&quot;);\n        }\n\n        private static void ViewInHex(Object fileName)\n        {\n            _workerStarted = true;\n            byte[] bytes;\n            using (MyFileReader reader = new MyFileReader((String)fileName))\n            {\n                bytes = reader.ReadContents(20);\n            }  // Using block calls Dispose() for us here.\n\n            if (_printToConsole)\n            {\n                // Print up to 20 bytes.\n                int printNBytes = Math.Min(20, bytes.Length);\n                Console.WriteLine(&quot;First {0} bytes of {1} in hex&quot;, printNBytes, fileName);\n                for (int i = 0; i &lt; printNBytes; i++)\n                    Console.Write(&quot;{0:x} &quot;, bytes[i]);\n                Console.WriteLine();\n            }\n        }\n\n        static void Main(string[] args)\n        {\n            if (args.Length == 0 || args.Length &gt; 2 ||\n                args[0] == &quot;-?&quot; || args[0] == &quot;/?&quot;)\n            {\n                Usage();\n                return;\n            }\n\n            String fileName = args[0];\n            bool injectFaultMode = args.Length &gt; 1;\n            if (!injectFaultMode)\n            {\n                _printToConsole = true;\n                ViewInHex(fileName);\n            }\n            else\n            {\n                Console.WriteLine(&quot;Injecting faults - watch handle count in perfmon (press Ctrl-C when done)&quot;);\n                int numIterations = 0;\n                while (true)\n                {\n                    _workerStarted = false;\n                    Thread t = new Thread(new ParameterizedThreadStart(ViewInHex));\n                    t.Start(fileName);\n                    Thread.Sleep(1);\n                    while (!_workerStarted)\n                    {\n                        Thread.Sleep(0);\n                    }\n                    t.Abort();  // Normal applications should not do this.\n                    numIterations++;\n                    if (numIterations % 10 == 0)\n                        GC.Collect();\n                    if (numIterations % 10000 == 0)\n                        Console.WriteLine(numIterations);\n                }\n            }\n\n        }\n    }\n}\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>The SafeHandle class provides critical finalization of handle resources, preventing handles from being reclaimed prematurely by garbage collection and from being recycled by Windows to reference unintended unmanaged objects.  </p>\n<p> This topic includes the following sections:  </p>\n<p> <a href=\"#Why\" data-linktype=\"self-bookmark\">Why SafeHandle?</a><br> <a href=\"#Does\" data-linktype=\"self-bookmark\">What SafeHandle does</a><br> <a href=\"#Derived\" data-linktype=\"self-bookmark\">Classes derived from SafeHandle</a>  </p>\n<p><a name=\"Why\"></a>   </p>\n<h3 class=\"accented\" id=\"why-safehandle\">Why SafeHandle?</h3>\n<p> Before the .NET Framework version 2.0, all operating system handles could only be encapsulated in the <a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a> managed wrapper object. While this was a convenient way to interoperate with native code, handles could be leaked by asynchronous exceptions, such as a thread aborting unexpectedly or a stack overflow. These asynchronous exceptions are an obstacle to cleaning up operating system resources, and they can occur almost anywhere in your app.  </p>\n<p> Although overrides to the <a class=\"xref\" href=\"system.object#System_Object_Finalize_\" data-linktype=\"relative-path\">Finalize</a> method allow cleanup of unmanaged resources when an object is being garbage collected, in some circumstances, finalizable objects can be reclaimed by garbage collection while executing a method within a platform invoke call. If a finalizer frees the handle passed to that platform invoke call, it could lead to handle corruption. The handle could also be reclaimed while your method is blocked during a platform invoke call, such as while reading a file.  </p>\n<p> More critically, because Windows aggressively recycles handles, a handle could be recycled and point to another resource that might contain sensitive data. This is known as a recycle attack and can potentially corrupt data and be a security threat.  </p>\n<p><a name=\"Does\"></a>   </p>\n<h3 class=\"accented\" id=\"what-safehandle-does\">What SafeHandle does</h3>\n<p> The SafeHandle class simplifies several of these object lifetime issues, and is integrated with platform invoke so that operating system resources are not leaked. The SafeHandle class resolves object lifetime issues by assigning and releasing handles without interruption. It contains a critical finalizer that ensures that the handle is closed and is guaranteed to run during unexpected <a class=\"xref\" href=\"system.appdomain\" data-linktype=\"relative-path\">AppDomain</a> unloads, even in cases when the platform invoke call is assumed to be in a corrupted state.  </p>\n<p> Because SafeHandle inherits from <a class=\"xref\" href=\"system.runtime.constrainedexecution.criticalfinalizerobject\" data-linktype=\"relative-path\">CriticalFinalizerObject</a>, all the noncritical finalizers are called before any of the critical finalizers. The finalizers are called on objects that are no longer live during the same garbage collection pass. For example, a <a class=\"xref\" href=\"system.io.filestream\" data-linktype=\"relative-path\">FileStream</a> object can run a normal finalizer to flush out existing buffered data without the risk of the handle being leaked or recycled. This very weak ordering between critical and noncritical finalizers is not intended for general use. It exists primarily to assist in the migration of existing libraries by allowing those libraries to use SafeHandle without altering their semantics. Additionally, the critical finalizer and anything it calls, such as the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_ReleaseHandle\" data-linktype=\"relative-path\">System.Runtime.InteropServices.SafeHandle.ReleaseHandle()</a> method, must be in a constrained execution region. This imposes constraints on what code can be written within the finalizer&#39;s call graph.  </p>\n<p> Platform invoke operations automatically increment the reference count of handles encapsulated by a SafeHandle and decrement them upon completion. This ensures that the handle will not be recycled or closed unexpectedly.  </p>\n<p> You can specify ownership of the underlying handle when constructing SafeHandle objects by supplying a value to the <code>ownsHandle</code> argument in the SafeHandle class constructor. This controls whether the SafeHandle object will release the handle after the object has been disposed.  This is useful for handles with peculiar lifetime requirements or for consuming a handle whose lifetime is controlled by someone else.  </p>\n<p><a name=\"Derived\"></a>   </p>\n<h3 class=\"accented\" id=\"classes-derived-from-safehandle\">Classes derived from SafeHandle</h3>\n<p> SafeHandle is an abstract wrapper class for operating system handles. Deriving from this class is difficult. Instead, use the derived classes in the <a class=\"xref\" href=\"microsoft.win32.safehandles\" data-linktype=\"relative-path\">Microsoft.Win32.SafeHandles</a> namespace that provide safe handles for the following:  </p>\n<ul>\n<li><p>Files (the <a class=\"xref\" href=\"microsoft.win32.safehandles.safefilehandle\" data-linktype=\"relative-path\">SafeFileHandle</a> class).  </p>\n</li>\n<li><p>Memory mapped files (the <a class=\"xref\" href=\"microsoft.win32.safehandles.safememorymappedfilehandle\" data-linktype=\"relative-path\">SafeMemoryMappedFileHandle</a> class).  </p>\n</li>\n<li><p>Pipes (the <a class=\"xref\" href=\"microsoft.win32.safehandles.safepipehandle\" data-linktype=\"relative-path\">SafePipeHandle</a> class).  </p>\n</li>\n<li><p>Memory views (the <a class=\"xref\" href=\"microsoft.win32.safehandles.safememorymappedviewhandle\" data-linktype=\"relative-path\">SafeMemoryMappedViewHandle</a> class).  </p>\n</li>\n<li><p>Cryptography constructs (the <a class=\"xref\" href=\"microsoft.win32.safehandles.safencrypthandle\" data-linktype=\"relative-path\">SafeNCryptHandle</a>, <a class=\"xref\" href=\"microsoft.win32.safehandles.safencryptkeyhandle\" data-linktype=\"relative-path\">SafeNCryptKeyHandle</a>, <a class=\"xref\" href=\"microsoft.win32.safehandles.safencryptproviderhandle\" data-linktype=\"relative-path\">SafeNCryptProviderHandle</a>, and <a class=\"xref\" href=\"microsoft.win32.safehandles.safencryptsecrethandle\" data-linktype=\"relative-path\">SafeNCryptSecretHandle</a> classes).  </p>\n</li>\n<li><p>Processes (the <a class=\"xref\" href=\"microsoft.win32.safehandles.safeprocesshandle\" data-linktype=\"relative-path\">SafeProcessHandle</a> class).  </p>\n</li>\n<li><p>Registry keys (the <a class=\"xref\" href=\"microsoft.win32.safehandles.saferegistryhandle\" data-linktype=\"relative-path\">SafeRegistryHandle</a> class).  </p>\n</li>\n<li><p>Wait handles (the <a class=\"xref\" href=\"microsoft.win32.safehandles.safewaithandle\" data-linktype=\"relative-path\">SafeWaitHandle</a> class).</p>\n</li>\n</ul>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Constructors\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Runtime_InteropServices_SafeHandle__ctor_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_InteropServices_SafeHandle__ctor_System_IntPtr_System_Boolean_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">SafeHandle(IntPtr, Boolean)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Initializes a new instance of the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> class with the specified invalid handle value.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">protected SafeHandle (IntPtr invalidHandleValue, bool ownsHandle);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>invalidHandleValue</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The value of an invalid handle (usually 0 or -1).  Your implementation of <span class=\"xref\">stem.Runtime.InteropServices.SafeHandle.IsInvalid*</span> should return <code>true</code> for this value.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>ownsHandle</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> to reliably let <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> release the handle during the finalization phase; otherwise, <code>false</code> (not recommended).</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.constrainedexecution.reliabilitycontractattribute\" title=\"System.Runtime.ConstrainedExecution.ReliabilityContractAttribute\" data-linktype=\"relative-path\">ReliabilityContractAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.typeloadexception\" data-linktype=\"relative-path\">TypeLoadException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The derived class resides in an assembly without unmanaged code access permission.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>If the <code>ownsHandle</code> parameter is <code>false</code>, <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_ReleaseHandle_\" data-linktype=\"relative-path\">ReleaseHandle</a> is never called; thus, it is not recommended to use this parameter value as your code may leak resources.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Fields\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_InteropServices_SafeHandle_handle\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">handle</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Specifies the handle to be wrapped.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">protected IntPtr handle;</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitycriticalattribute\" title=\"System.Security.SecurityCriticalAttribute\" data-linktype=\"relative-path\">SecurityCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Do not expose the handle publicly (that is, outside of the derived class).</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Properties\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Runtime_InteropServices_SafeHandle_IsClosed_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_InteropServices_SafeHandle_IsClosed\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">IsClosed</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets a value indicating whether the handle is closed.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public bool IsClosed { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if the handle is closed; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><span class=\"xref\">get: System.Runtime.ConstrainedExecution.ReliabilityContract</span></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The IsClosed method returns a value indicating whether the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> object&#39;s handle is no longer associated with a native resource. This differs from the definition of the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_IsInvalid_\" data-linktype=\"relative-path\">IsInvalid</a> property, which computes whether a given handle is always considered invalid. The IsClosed method returns a <code>true</code> value in the following cases:  </p>\n<ul>\n<li><p>The <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_SetHandleAsInvalid_\" data-linktype=\"relative-path\">SetHandleAsInvalid</a> method was called.  </p>\n</li>\n<li><p>The <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_Dispose_\" data-linktype=\"relative-path\">Dispose</a> method or <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_Close_\" data-linktype=\"relative-path\">Close</a> method was called and there are no references to the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> object on other threads.</p>\n</li>\n</ul>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Runtime_InteropServices_SafeHandle_IsInvalid_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_InteropServices_SafeHandle_IsInvalid\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">IsInvalid</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>When overridden in a derived class, gets a value indicating whether the handle value is invalid.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public abstract bool IsInvalid { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if the handle value is invalid; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><span class=\"xref\">get: System.Runtime.ConstrainedExecution.ReliabilityContract</span></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Derived classes must implement the IsInvalid property so that the common language runtime can determine whether critical finalization is required. Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid). These classes can then be further derived for specific safe handle types.  </p>\n<p> Unlike the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_IsClosed_\" data-linktype=\"relative-path\">IsClosed</a> property, which reports whether the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> object has finished using the underlying handle, the IsInvalid property calculates whether the given handle value is always considered invalid. Therefore, the IsInvalid property always returns the same value for any one handle value.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Methods\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Runtime_InteropServices_SafeHandle_Close_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_InteropServices_SafeHandle_Close\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Close()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Marks the handle for releasing and freeing resources.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void Close ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.constrainedexecution.reliabilitycontractattribute\" title=\"System.Runtime.ConstrainedExecution.ReliabilityContractAttribute\" data-linktype=\"relative-path\">ReliabilityContractAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitycriticalattribute\" title=\"System.Security.SecurityCriticalAttribute\" data-linktype=\"relative-path\">SecurityCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Calling the Close or <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_Dispose_\" data-linktype=\"relative-path\">Dispose</a> method allows the resources to be freed. This might not happen immediately if other threads are using the same safe handle object, but will happen as soon as that is no longer the case. Although most classes that use the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory). In this case, the class can provide a finalizer that is guaranteed to run before the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> critical finalizer runs.  </p>\n<p> Call the Close or <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_Dispose_\" data-linktype=\"relative-path\">Dispose</a> method when you are finished using the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> object.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Always call Close or <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_Dispose_\" data-linktype=\"relative-path\">Dispose</a> before you release your last reference to the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> object. Otherwise, the resources it is using will not be freed until the garbage collector calls the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> object&#39;s <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_Finalize_\" data-linktype=\"relative-path\">Finalize</a> method.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Runtime_InteropServices_SafeHandle_DangerousAddRef_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_InteropServices_SafeHandle_DangerousAddRef_System_Boolean__\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">DangerousAddRef(Boolean)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Manually increments the reference counter on <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> instances.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void DangerousAddRef (ref bool success);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>success</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if the reference counter was successfully incremented; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.constrainedexecution.reliabilitycontractattribute\" title=\"System.Runtime.ConstrainedExecution.ReliabilityContractAttribute\" data-linktype=\"relative-path\">ReliabilityContractAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitycriticalattribute\" title=\"System.Security.SecurityCriticalAttribute\" data-linktype=\"relative-path\">SecurityCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The DangerousAddRef method prevents the common language runtime from reclaiming memory used by a handle (which occurs when the runtime calls the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_ReleaseHandle_\" data-linktype=\"relative-path\">ReleaseHandle</a> method). You can use this method to manually increment the reference count on a <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> instance. DangerousAddRef returns a Boolean value using a <code>ref</code> parameter (<code>success</code>) that indicates whether the reference count was incremented successfully. This allows your program logic to back out in case of failure. You should set <code>success</code> to <code>false</code> before calling DangerousAddRef. If <code>success</code> is <code>true</code>, avoid resource leaks by matching the call to DangerousAddRef with a corresponding call to <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_DangerousRelease_\" data-linktype=\"relative-path\">DangerousRelease</a>.  </p>\n<div class=\"CAUTION\"><h5>Caution</h5><p> This method is intended for advanced users and must always be used carefully. To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Runtime_InteropServices_SafeHandle_DangerousGetHandle_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_InteropServices_SafeHandle_DangerousGetHandle\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">DangerousGetHandle()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Returns the value of the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_handle\" data-linktype=\"relative-path\">handle</a> field.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public IntPtr DangerousGetHandle ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>An <code>IntPtr</code> representing the value of the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_handle\" data-linktype=\"relative-path\">handle</a> field. If the handle has been marked invalid with <span class=\"xref\">stem.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid*</span>, this method still returns the original handle value, which can be a stale value.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.constrainedexecution.reliabilitycontractattribute\" title=\"System.Runtime.ConstrainedExecution.ReliabilityContractAttribute\" data-linktype=\"relative-path\">ReliabilityContractAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>You can use this method to retrieve the actual handle value from an instance of the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> derived class. This method is needed for backwards compatibility because many properties in the .NET Framework return <code>IntPtr</code> handle types. <code>IntPtr</code> handle types are platform-specific types used to represent a pointer or a handle.  </p>\n<div class=\"CAUTION\"><h5>Caution</h5><p> Using the DangerousGetHandle method can pose security risks because, if the handle has been marked as invalid with <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_SetHandleAsInvalid_\" data-linktype=\"relative-path\">SetHandleAsInvalid</a>, DangerousGetHandle still returns the original, potentially stale handle value. The returned handle can also be recycled at any point. At best, this means the handle might suddenly stop working. At worst, if the handle or the resource that the handle represents is exposed to untrusted code, this can lead to a recycling security attack on the reused or returned handle. For example, an untrusted caller can query data on the handle just returned and receive information for an entirely unrelated resource. See the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_\" data-linktype=\"relative-path\">DangerousAddRef</a> and the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_DangerousRelease_\" data-linktype=\"relative-path\">DangerousRelease</a> methods for more information about using the DangerousGetHandle methodsafely.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Runtime_InteropServices_SafeHandle_DangerousRelease_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_InteropServices_SafeHandle_DangerousRelease\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">DangerousRelease()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Manually decrements the reference counter on a <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> instance.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void DangerousRelease ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.constrainedexecution.reliabilitycontractattribute\" title=\"System.Runtime.ConstrainedExecution.ReliabilityContractAttribute\" data-linktype=\"relative-path\">ReliabilityContractAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitycriticalattribute\" title=\"System.Security.SecurityCriticalAttribute\" data-linktype=\"relative-path\">SecurityCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The DangerousRelease method is the counterpart to <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_\" data-linktype=\"relative-path\">DangerousAddRef</a>. You should always match a call to the DangerousRelease method with a successful call to <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_\" data-linktype=\"relative-path\">DangerousAddRef</a>.  </p>\n<div class=\"CAUTION\"><h5>Caution</h5><p> This method is intended for advanced users and must always be used carefully. To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing. In the same way that unmatched <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_\" data-linktype=\"relative-path\">DangerousAddRef</a> calls can cause resource leaks, unmatched DangerousRelease calls can cause invalid handle states to become visible to other threads. Do not expose <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_DangerousAddRef_\" data-linktype=\"relative-path\">DangerousAddRef</a> or DangerousRelease calls to untrusted code.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Runtime_InteropServices_SafeHandle_Dispose_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_InteropServices_SafeHandle_Dispose\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Dispose()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Releases all resources used by the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> class.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void Dispose ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.constrainedexecution.reliabilitycontractattribute\" title=\"System.Runtime.ConstrainedExecution.ReliabilityContractAttribute\" data-linktype=\"relative-path\">ReliabilityContractAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitysafecriticalattribute\" title=\"System.Security.SecuritySafeCriticalAttribute\" data-linktype=\"relative-path\">SecuritySafeCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Calling the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_Close_\" data-linktype=\"relative-path\">Close</a> or Dispose method allows the resources to be freed. This might not happen immediately if other threads are using the same instance of the safe handle, but will happen as soon as that is no longer the case. Although most classes using <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory). In this case, they can provide a finalizer that is guaranteed to run before the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> critical finalizer runs.  </p>\n<p> Call the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_Close_\" data-linktype=\"relative-path\">Close</a> or Dispose method when you are finished using the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> object. The <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_Close_\" data-linktype=\"relative-path\">Close</a> method leaves the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> object in an unusable state.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Always call the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_Close_\" data-linktype=\"relative-path\">Close</a> or Dispose method before you release your last reference to the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> object. Otherwise, the resources it is using will not be freed until the garbage collector calls the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> object&#39;s <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_Finalize_\" data-linktype=\"relative-path\">Finalize</a> method.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Runtime_InteropServices_SafeHandle_Dispose_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_InteropServices_SafeHandle_Dispose_System_Boolean_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Dispose(Boolean)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Releases the unmanaged resources used by the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> class specifying whether to perform a normal dispose operation.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">protected virtual void Dispose (bool disposing);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>disposing</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> for a normal dispose operation; <code>false</code> to finalize the handle.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.constrainedexecution.reliabilitycontractattribute\" title=\"System.Runtime.ConstrainedExecution.ReliabilityContractAttribute\" data-linktype=\"relative-path\">ReliabilityContractAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitycriticalattribute\" title=\"System.Security.SecurityCriticalAttribute\" data-linktype=\"relative-path\">SecurityCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>You should never explicitly call the Dispose method with the <code>disposing</code> parameter set to <code>false</code>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Runtime_InteropServices_SafeHandle_Finalize_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_InteropServices_SafeHandle_Finalize\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Finalize()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Frees all resources associated with the handle.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">~SafeHandle ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitysafecriticalattribute\" title=\"System.Security.SecuritySafeCriticalAttribute\" data-linktype=\"relative-path\">SecuritySafeCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The Finalize method is the destructor for the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> class. Application code should not call this method directly.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Runtime_InteropServices_SafeHandle_ReleaseHandle_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_InteropServices_SafeHandle_ReleaseHandle\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">ReleaseHandle()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>When overridden in a derived class, executes the code required to free the handle.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">protected abstract bool ReleaseHandle ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if the handle is released successfully; otherwise, in the event of a catastrophic failure,<code>false</code>. In this case, it generates a <a href=\"../topic/releasehandlefailed%20mda\" data-linktype=\"relative-path\">releaseHandleFailed</a> Managed Debugging Assistant.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.constrainedexecution.reliabilitycontractattribute\" title=\"System.Runtime.ConstrainedExecution.ReliabilityContractAttribute\" data-linktype=\"relative-path\">ReliabilityContractAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The ReleaseHandle method is guaranteed to be called only once and only if the handle is valid as defined by the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_IsInvalid_\" data-linktype=\"relative-path\">IsInvalid</a> property. Implement this method in your <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> derived classes to execute any code that is required to free the handle. Because one of the functions of <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> is to guarantee prevention of resource leaks, the code in your implementation of ReleaseHandle must never fail. The garbage collector calls ReleaseHandleafter normal finalizers have been run for objects that were garbage collected at the same time. The garbage collector guarantees the resources to invoke this method and that the method will not be interrupted while it is in progress. This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph). Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden ReleaseHandle method. In particular, apply the <a class=\"xref\" href=\"system.runtime.constrainedexecution.reliabilitycontractattribute\" data-linktype=\"relative-path\">ReliabilityContractAttribute</a> attribute to any methods you call from ReleaseHandle. In most cases this code should be:  </p>\n<p> <code>ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)</code>  </p>\n<p> Additionally, for simple cleanup (for example, calling the Win32 API <code>CloseHandle</code> on a file handle) you can check the return value for the single platform invoke call. For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail. You must ensure that your program logic has fallback code for each of those cases.  </p>\n<p> If ReleaseHandle returns <code>false</code> for any reason, it generates a <a href=\"../topic/releasehandlefailed%20mda\" data-linktype=\"relative-path\">releaseHandleFailed</a> Managed Debugging Assistant.  This helps you detect cases where your attempt to release resources fails.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Runtime_InteropServices_SafeHandle_SetHandle_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_InteropServices_SafeHandle_SetHandle_System_IntPtr_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">SetHandle(IntPtr)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Sets the handle to the specified pre-existing handle.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">protected void SetHandle (IntPtr handle);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>handle</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The pre-existing handle to use.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.constrainedexecution.reliabilitycontractattribute\" title=\"System.Runtime.ConstrainedExecution.ReliabilityContractAttribute\" data-linktype=\"relative-path\">ReliabilityContractAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Use the SetHandle method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling output handles in a structure.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Runtime_InteropServices_SafeHandle_SetHandleAsInvalid_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_InteropServices_SafeHandle_SetHandleAsInvalid\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">SetHandleAsInvalid()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Marks a handle as no longer used.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void SetHandleAsInvalid ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.constrainedexecution.reliabilitycontractattribute\" title=\"System.Runtime.ConstrainedExecution.ReliabilityContractAttribute\" data-linktype=\"relative-path\">ReliabilityContractAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitycriticalattribute\" title=\"System.Security.SecurityCriticalAttribute\" data-linktype=\"relative-path\">SecurityCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Call the SetHandleAsInvalid method only when you know that your handle no longer references a resource. Doing so does not change the value of the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_handle\" data-linktype=\"relative-path\">handle</a> field; it only marks the handle as closed. The handle might then contain a potentially stale value. The effect of this call is that no attempt is made to free the resources.  </p>\n<p> As with the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_SetHandle_\" data-linktype=\"relative-path\">SetHandle</a> method, use SetHandleAsInvalid only if you need to support a pre-existing handle.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Runtime.InteropServices.SafeHandle.yml\">\r\n<meta name=\"APIName\" content=\"System.Runtime.InteropServices.SafeHandle\">\r\n<meta name=\"APIName\" content=\"System.Runtime.InteropServices.SafeHandle..ctor\">\r\n<meta name=\"APIName\" content=\"System.Runtime.InteropServices.SafeHandle.Close\">\r\n<meta name=\"APIName\" content=\"System.Runtime.InteropServices.SafeHandle.DangerousAddRef\">\r\n<meta name=\"APIName\" content=\"System.Runtime.InteropServices.SafeHandle.DangerousGetHandle\">\r\n<meta name=\"APIName\" content=\"System.Runtime.InteropServices.SafeHandle.DangerousRelease\">\r\n<meta name=\"APIName\" content=\"System.Runtime.InteropServices.SafeHandle.Dispose\">\r\n<meta name=\"APIName\" content=\"System.Runtime.InteropServices.SafeHandle.Finalize\">\r\n<meta name=\"APIName\" content=\"System.Runtime.InteropServices.SafeHandle.handle\">\r\n<meta name=\"APIName\" content=\"System.Runtime.InteropServices.SafeHandle.IsClosed\">\r\n<meta name=\"APIName\" content=\"System.Runtime.InteropServices.SafeHandle.IsInvalid\">\r\n<meta name=\"APIName\" content=\"System.Runtime.InteropServices.SafeHandle.ReleaseHandle\">\r\n<meta name=\"APIName\" content=\"System.Runtime.InteropServices.SafeHandle.SetHandle\">\r\n<meta name=\"APIName\" content=\"System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-04-01 05:59 PM\">\r\n<meta name=\"document_id\" content=\"1fb963eb-45ce-6987-522c-b33758dcafba\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Represents a wrapper class for operating system handles. This class must be inherited.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.runtime.interopservices/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Runtime.InteropServices.SafeHandle\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","uhfHeaderId":"MSDocsHeader-DotNet","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Runtime.InteropServices.SafeHandle.yml","open_to_public_contributors":false,"api_name":["System.Runtime.InteropServices.SafeHandle","System.Runtime.InteropServices.SafeHandle..ctor","System.Runtime.InteropServices.SafeHandle.Close","System.Runtime.InteropServices.SafeHandle.DangerousAddRef","System.Runtime.InteropServices.SafeHandle.DangerousGetHandle","System.Runtime.InteropServices.SafeHandle.DangerousRelease","System.Runtime.InteropServices.SafeHandle.Dispose","System.Runtime.InteropServices.SafeHandle.Finalize","System.Runtime.InteropServices.SafeHandle.handle","System.Runtime.InteropServices.SafeHandle.IsClosed","System.Runtime.InteropServices.SafeHandle.IsInvalid","System.Runtime.InteropServices.SafeHandle.ReleaseHandle","System.Runtime.InteropServices.SafeHandle.SetHandle","System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Runtime.InteropServices.SafeHandle","System::Runtime::InteropServices::SafeHandle","System.Runtime.InteropServices.SafeHandle.#ctor","System::Runtime::InteropServices::SafeHandle::#ctor","System.Runtime.InteropServices.SafeHandle.Close","System::Runtime::InteropServices::SafeHandle::Close","System.Runtime.InteropServices.SafeHandle.DangerousAddRef","System::Runtime::InteropServices::SafeHandle::DangerousAddRef","System.Runtime.InteropServices.SafeHandle.DangerousGetHandle","System::Runtime::InteropServices::SafeHandle::DangerousGetHandle","System.Runtime.InteropServices.SafeHandle.DangerousRelease","System::Runtime::InteropServices::SafeHandle::DangerousRelease","System.Runtime.InteropServices.SafeHandle.Dispose","System::Runtime::InteropServices::SafeHandle::Dispose","System.Runtime.InteropServices.SafeHandle.Finalize","System::Runtime::InteropServices::SafeHandle::Finalize","System.Runtime.InteropServices.SafeHandle.handle","System::Runtime::InteropServices::SafeHandle::handle","System.Runtime.InteropServices.SafeHandle.IsClosed","System::Runtime::InteropServices::SafeHandle::IsClosed","System.Runtime.InteropServices.SafeHandle.IsInvalid","System::Runtime::InteropServices::SafeHandle::IsInvalid","System.Runtime.InteropServices.SafeHandle.ReleaseHandle","System::Runtime::InteropServices::SafeHandle::ReleaseHandle","System.Runtime.InteropServices.SafeHandle.SetHandle","System::Runtime::InteropServices::SafeHandle::SetHandle","System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid","System::Runtime::InteropServices::SafeHandle::SetHandleAsInvalid"],"dev_langs":["csharp"],"updated_at":"2017-04-01 05:59 PM","document_id":"1fb963eb-45ce-6987-522c-b33758dcafba","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"SafeHandle class | Microsoft Docs","_op_ogTitle":"SafeHandle class","description":"Represents a wrapper class for operating system handles. This class must be inherited.\n","toc_asset_id":"api/_splitted/System.Runtime.InteropServices/toc.json","toc_rel":"_splitted/System.Runtime.InteropServices/toc.json","source_url":"","ms.assetid":"System.Runtime.InteropServices.SafeHandle","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.safehandle","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.safehandle","fileRelativePath":"api/System.Runtime.InteropServices.SafeHandle.html"},"themesRelativePathToOutputRoot":"_themes/"}