{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">LayoutKind</span>\r\n      Enum\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Controls the layout of an object when exported to unmanaged code.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\r\n  \t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(true)]\npublic enum LayoutKind</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.valuetype\" data-linktype=\"relative-path\">ValueType</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.enum\" data-linktype=\"relative-path\">Enum</a></span></div><span class=\"lang-csharp\">LayoutKind</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following example shows the managed declaration of the <code>PtInRect</code> function, which checks whether a point lies within a rectangle, and defines a <code>Point</code> structure with Sequential layout and a <code>Rect</code> structure with Explicit layout.  </p>\n<pre><code class=\"lang-cs\" name=\"LayoutKind#1\">enum Bool\n{\n   False = 0,\n   True\n};\n[StructLayout(LayoutKind.Sequential)]\npublic struct Point \n{\n   public int x;\n   public int y;\n}   \n\n[StructLayout(LayoutKind.Explicit)]\npublic struct Rect \n{\n   [FieldOffset(0)] public int left;\n   [FieldOffset(4)] public int top;\n   [FieldOffset(8)] public int right;\n   [FieldOffset(12)] public int bottom;\n}   \n\nclass LibWrapper\n{\n   [DllImport(&quot;user32.dll&quot;, CallingConvention=CallingConvention.StdCall)]\n   public static extern Bool PtInRect(ref Rect r, Point p);\n};\n\nclass TestApplication\n{\n   public static void Main()\n   {\n      try\n      {\n         Bool bPointInRect = 0;\n         Rect myRect = new Rect();\n         myRect.left = 10;\n         myRect.right = 100;\n         myRect.top = 10;\n         myRect.bottom = 100;\n         Point myPoint = new Point();\n         myPoint.x = 50;\n         myPoint.y = 50;\n         bPointInRect = LibWrapper.PtInRect(ref myRect, myPoint);\n         if(bPointInRect == Bool.True)\n            Console.WriteLine(&quot;Point lies within the Rect&quot;);\n         else\n            Console.WriteLine(&quot;Point did not lie within the Rect&quot;);\n      }\n      catch(Exception e)\n      {\n         Console.WriteLine(&quot;Exception : &quot; + e.Message);\n      }\n   }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"LayoutKind#1\">enum class Bool\n{\n   False = 0,\n   True\n};\n\n\n[StructLayout(LayoutKind::Sequential)]\nvalue struct Point\n{\npublic:\n   int x;\n   int y;\n};\n\n\n[StructLayout(LayoutKind::Explicit)]\nvalue struct Rect\n{\npublic:\n\n   [FieldOffset(0)]\n   int left;\n\n   [FieldOffset(4)]\n   int top;\n\n   [FieldOffset(8)]\n   int right;\n\n   [FieldOffset(12)]\n   int bottom;\n};\n\nref class LibWrapper\n{\npublic:\n\n   [DllImport(&quot;user32.dll&quot;,CallingConvention=CallingConvention::StdCall)]\n   static Bool PtInRect( Rect * r, Point p );\n};\n\nint main()\n{\n   try\n   {\n      Bool bPointInRect = (Bool)0;\n      Rect myRect = Rect(  );\n      myRect.left = 10;\n      myRect.right = 100;\n      myRect.top = 10;\n      myRect.bottom = 100;\n      Point myPoint = Point(  );\n      myPoint.x = 50;\n      myPoint.y = 50;\n      bPointInRect = LibWrapper::PtInRect(  &amp;myRect, myPoint );\n      if ( bPointInRect == Bool::True )\n            Console::WriteLine( &quot;Point lies within the Rect&quot; );\n      else\n            Console::WriteLine( &quot;Point did not lie within the Rect&quot; );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception : {0}&quot;, e-&gt;Message );\n   }\n\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"LayoutKind#1\">&#39;  The program shows a managed declaration of the PtInRect function and defines Point\n&#39;  structure with sequential layout and Rect structure with explicit layout. The PtInRect\n&#39;  checks the point lies within the rectangle or not.\nImports System\nImports System.Runtime.InteropServices\n\n   Enum Bool\n      [False] = 0\n      [True]\n   End Enum \n   &lt;StructLayout(LayoutKind.Sequential)&gt;  _\n   Public Structure Point\n      Public x As Integer\n      Public y As Integer\n   End Structure \n   \n   &lt;StructLayout(LayoutKind.Explicit)&gt;  _   \n   Public Structure Rect\n      &lt;FieldOffset(0)&gt; Public left As Integer\n      &lt;FieldOffset(4)&gt; Public top As Integer\n      &lt;FieldOffset(8)&gt; Public right As Integer\n      &lt;FieldOffset(12)&gt; Public bottom As Integer\n   End Structure \n   \n   \n   Class LibWrapper\n      \n      &lt;DllImport(&quot;user32.dll&quot;, CallingConvention := CallingConvention.StdCall)&gt;  _\n      Public Shared Function PtInRect(ByRef r As Rect, p As Point) As Bool\n      End Function\t\n   End Class &#39;LibWrapper\n   \n   \n   Class TestApplication\n      \n      Public Shared Sub Main()\n         Try\n            Dim bPointInRect As Bool = 0\n            Dim myRect As New Rect()\n            myRect.left = 10\n            myRect.right = 100\n            myRect.top = 10\n            myRect.bottom = 100\n            Dim myPoint As New Point()\n            myPoint.x = 50\n            myPoint.y = 50\n            bPointInRect = LibWrapper.PtInRect(myRect, myPoint)\n            If bPointInRect = Bool.True Then\n               Console.WriteLine(&quot;Point lies within the Rect&quot;)\n            Else\n               Console.WriteLine(&quot;Point did not lie within the Rect&quot;)\n            End If\n         Catch e As Exception\n            Console.WriteLine((&quot;Exception : &quot; + e.Message.ToString()))\n         End Try\n      End Sub \n   End Class \n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>This enumeration is used with <a class=\"xref\" href=\"system.runtime.interopservices.structlayoutattribute\" data-linktype=\"relative-path\">StructLayoutAttribute</a>. The common language runtime uses the <code>Auto</code> layout value by default. To reduce layout-related problems associated with the <code>Auto</code> value, C#, Visual Basic, and C++ compilers specify <code>Sequential</code> layout for value types.  </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> The <a class=\"xref\" href=\"system.runtime.interopservices.structlayoutattribute#System_Runtime_InteropServices_StructLayoutAttribute_Pack\" data-linktype=\"relative-path\">System.Runtime.InteropServices.StructLayoutAttribute.Pack</a> field controls the alignment of data fields, and thus affects the layout regardless of the LayoutKind value you specify. By default, the value of <a class=\"xref\" href=\"system.runtime.interopservices.structlayoutattribute#System_Runtime_InteropServices_StructLayoutAttribute_Pack\" data-linktype=\"relative-path\">Pack</a> is 0, which indicates the default packing size for the current platform. For example, when you use the <code>Explicit</code> layout value and specify field alignments on byte boundaries, you must set <a class=\"xref\" href=\"system.runtime.interopservices.structlayoutattribute#System_Runtime_InteropServices_StructLayoutAttribute_Pack\" data-linktype=\"relative-path\">Pack</a> to 1 to get the desired result.</p>\n</div>\n\r\n  \r\n      \t<h2 class=\"accented\">Fields\r\n      </h2>\r\n      <table class=\"nameValue\">\r\n      \t<tr><td id=\"System_Runtime_InteropServices_LayoutKind_Auto\">\r\n      \t\t\t<span class=\"lang-csharp\">Auto</span>\r\n      \t</td>\r\n      \t<td><p>The runtime automatically chooses an appropriate layout for the members of an object in unmanaged memory. Objects defined with this enumeration member cannot be exposed outside of managed code. Attempting to do so generates an exception.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Runtime_InteropServices_LayoutKind_Explicit\">\r\n      \t\t\t<span class=\"lang-csharp\">Explicit</span>\r\n      \t</td>\r\n      \t<td><p>The precise position of each member of an object in unmanaged memory is explicitly controlled, subject to the setting of the <a class=\"xref\" href=\"system.runtime.interopservices.structlayoutattribute#System_Runtime_InteropServices_StructLayoutAttribute_Pack\" data-linktype=\"relative-path\">Pack</a> field. Each member must use the <a class=\"xref\" href=\"system.runtime.interopservices.fieldoffsetattribute\" data-linktype=\"relative-path\">FieldOffsetAttribute</a> to indicate the position of that field within the type.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Runtime_InteropServices_LayoutKind_Sequential\">\r\n      \t\t\t<span class=\"lang-csharp\">Sequential</span>\r\n      \t</td>\r\n      \t<td><p>The members of the object are laid out sequentially, in the order in which they appear when exported to unmanaged memory. The members are laid out according to the packing specified in <a class=\"xref\" href=\"system.runtime.interopservices.structlayoutattribute#System_Runtime_InteropServices_StructLayoutAttribute_Pack\" data-linktype=\"relative-path\">Pack</a>, and can be noncontiguous.</p>\n</td>\r\n      \t</tr>\r\n      </table>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Runtime.InteropServices.LayoutKind.yml\">\r\n<meta name=\"APIName\" content=\"System.Runtime.InteropServices.LayoutKind\">\r\n<meta name=\"APIName\" content=\"System.Runtime.InteropServices.LayoutKind.Auto\">\r\n<meta name=\"APIName\" content=\"System.Runtime.InteropServices.LayoutKind.Explicit\">\r\n<meta name=\"APIName\" content=\"System.Runtime.InteropServices.LayoutKind.Sequential\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-28 03:03 AM\">\r\n<meta name=\"document_id\" content=\"14fe43be-1e3e-604c-fbe7-8e13109501de\">\r\n<meta name=\"internalonly\" content=\"false\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Controls the layout of an object when exported to unmanaged code.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.runtime.interopservices/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Runtime.InteropServices.LayoutKind\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Runtime.InteropServices.LayoutKind.yml","open_to_public_contributors":false,"api_name":["System.Runtime.InteropServices.LayoutKind","System.Runtime.InteropServices.LayoutKind.Auto","System.Runtime.InteropServices.LayoutKind.Explicit","System.Runtime.InteropServices.LayoutKind.Sequential"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Runtime.InteropServices.LayoutKind","System::Runtime::InteropServices::LayoutKind","System.Runtime.InteropServices.LayoutKind.Auto","System::Runtime::InteropServices::LayoutKind::Auto","System.Runtime.InteropServices.LayoutKind.Explicit","System::Runtime::InteropServices::LayoutKind::Explicit","System.Runtime.InteropServices.LayoutKind.Sequential","System::Runtime::InteropServices::LayoutKind::Sequential"],"dev_langs":["csharp"],"updated_at":"2017-03-28 03:03 AM","document_id":"14fe43be-1e3e-604c-fbe7-8e13109501de","content_git_url":"https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/LayoutKind.xml","internalonly":false,"layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"LayoutKind enum | Microsoft Docs","_op_ogTitle":"LayoutKind enum","description":"Controls the layout of an object when exported to unmanaged code.\n","toc_asset_id":"api/_splitted/System.Runtime.InteropServices/toc.json","toc_rel":"_splitted/System.Runtime.InteropServices/toc.json","source_url":"","ms.assetid":"System.Runtime.InteropServices.LayoutKind","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.layoutkind","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.layoutkind","fileRelativePath":"api/System.Runtime.InteropServices.LayoutKind.html"},"themesRelativePathToOutputRoot":"_themes/"}