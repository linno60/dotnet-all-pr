{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">StreamingContextStates</span>\r\n      Enum\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Defines a set of flags that specifies the source or destination context for the stream during serialization.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\r\n  \t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Flags]\n[System.Runtime.InteropServices.ComVisible(true)]\npublic enum StreamingContextStates</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.valuetype\" data-linktype=\"relative-path\">ValueType</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.enum\" data-linktype=\"relative-path\">Enum</a></span></div><span class=\"lang-csharp\">StreamingContextStates</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Attributes</dt><dd>\r\n  \t\t<div class=\"cdlHolder\">\r\n  \t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.flagsattribute\" title=\"System.FlagsAttribute\" data-linktype=\"relative-path\">FlagsAttribute</a></span>\r\n  \t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following code example demonstrates the use of the StreamingContextStates enum.  </p>\n<pre><code class=\"lang-vb\" name=\"StreamingContext Example#1\">Imports System\nImports System.IO\nImports System.Collections\nImports System.Runtime.Serialization.Formatters.Binary\nImports System.Runtime.Serialization\nImports System.Runtime.InteropServices\nImports System.Security.Permissions\n\n&lt;Assembly: SecurityPermission( _\nSecurityAction.RequestMinimum, Execution:=True)&gt; \n&#39; This class includes several Win32 interop definitions.\nFriend Class Win32\n    Public Shared ReadOnly InvalidHandleValue As New IntPtr(-1)\n    Public Const FILE_MAP_WRITE As Int32 = 2\n    Public Const PAGE_READWRITE As Int32 = &amp;H4\n\n    &lt;DllImport(&quot;Kernel32&quot;, CharSet:=CharSet.Unicode)&gt; _\n    Public Shared Function CreateFileMapping(ByVal hFile As IntPtr, _\n                                             ByVal pAttributes As IntPtr, _\n                                             ByVal flProtect As Int32, _\n                                             ByVal dwMaximumSizeHigh As Int32, _\n                                             ByVal dwMaximumSizeLow As Int32, _\n                                             ByVal pName As String) As IntPtr\n    End Function\n\n    &lt;DllImport(&quot;Kernel32&quot;, CharSet:=CharSet.Unicode)&gt; _\n    Public Shared Function OpenFileMapping(ByVal dwDesiredAccess As Int32, _\n                                           ByVal bInheritHandle As Boolean, _\n                                           ByVal name As String) As IntPtr\n    End Function\n\n    &lt;DllImport(&quot;Kernel32&quot;, CharSet:=CharSet.Unicode)&gt; _\n    Public Shared Function CloseHandle(ByVal handle As IntPtr) As Boolean\n    End Function\n\n    &lt;DllImport(&quot;Kernel32&quot;, CharSet:=CharSet.Unicode)&gt; _\n    Public Shared Function MapViewOfFile(ByVal hFileMappingObject As IntPtr, _\n                                         ByVal dwDesiredAccess As Int32, _\n                                         ByVal dwFileOffsetHigh As Int32, _\n                                         ByVal dwFileOffsetLow As Int32, _\n                                         ByVal dwNumberOfBytesToMap As IntPtr) _\n                                         As IntPtr\n    End Function\n\n    &lt;DllImport(&quot;Kernel32&quot;, CharSet:=CharSet.Unicode)&gt; _\n    Public Shared Function UnmapViewOfFile(ByVal address As IntPtr) As Boolean\n    End Function\n\n    &lt;DllImport(&quot;Kernel32&quot;, CharSet:=CharSet.Unicode)&gt; _\n    Public Shared Function DuplicateHandle(ByVal hSourceProcessHandle As IntPtr, _\n                                           ByVal hSourceHandle As IntPtr, _\n                                           ByVal hTargetProcessHandle As IntPtr, _\n                                           ByRef lpTargetHandle As IntPtr, _\n                                           ByVal dwDesiredAccess As Int32, _\n                                           ByVal bInheritHandle As Boolean, _\n                                           ByVal dwOptions As Int32) As Boolean\n    End Function\n\n    Public Const DUPLICATE_CLOSE_SOURCE As Int32 = &amp;H1\n    Public Const DUPLICATE_SAME_ACCESS As Int32 = &amp;H2\n\n    &lt;DllImport(&quot;Kernel32&quot;, CharSet:=CharSet.Unicode)&gt; Public Shared Function GetCurrentProcess() As IntPtr\n    End Function\nEnd Class\n\n\n&#39; This class wraps memory that can be simultaneously \n&#39; shared by multiple AppDomains and Processes.\n&lt;Serializable()&gt; Public NotInheritable Class SharedMemory\n    Implements ISerializable\n    Implements IDisposable\n\n    &#39; The handle and string that identify \n    &#39; the Windows file-mapping object.\n    Private m_hFileMap As IntPtr = IntPtr.Zero\n    Private m_name As String\n\n    &#39; The address of the memory-mapped file-mapping object.\n    Private m_address As IntPtr\n    &lt;SecurityPermissionAttribute(SecurityAction.LinkDemand, _\n    Flags:=SecurityPermissionFlag.UnmanagedCode)&gt; _\n    Public Function GetByte(ByVal offset As Int32) As Byte\n        Dim b(0) As Byte\n        Marshal.Copy(New IntPtr(m_address.ToInt64() + offset), b, 0, 1)\n        Return b(0)\n    End Function\n\n    &lt;SecurityPermissionAttribute(SecurityAction.LinkDemand, _\n    Flags:=SecurityPermissionFlag.UnmanagedCode)&gt; _\n    Public Sub SetByte(ByVal offset As Int32, ByVal value As Byte)\n        Dim b(0) As Byte\n        b(0) = value\n        Marshal.Copy(b, 0, New IntPtr(m_address.ToInt64() + offset), 1)\n    End Sub\n\n\n    &#39; The constructors.\n    Public Sub New(ByVal size As Int32)\n        Me.New(size, Nothing)\n    End Sub\n\n    Public Sub New(ByVal size As Int32, ByVal name As String)\n        m_hFileMap = Win32.CreateFileMapping(Win32.InvalidHandleValue, _\n           IntPtr.Zero, Win32.PAGE_READWRITE, 0, size, name)\n        If (m_hFileMap.Equals(IntPtr.Zero)) Then _\n           Throw New Exception(&quot;Could not create memory-mapped file.&quot;)\n        m_name = name\n        m_address = Win32.MapViewOfFile(m_hFileMap, _\n           Win32.FILE_MAP_WRITE, 0, 0, IntPtr.Zero)\n    End Sub\n\n\n    &#39; The cleanup methods.\n    Public Sub Dispose() Implements IDisposable.Dispose\n        GC.SuppressFinalize(Me)\n        Dispose(True)\n    End Sub\n\n    Private Sub Dispose(ByVal disposing As Boolean)\n        Win32.UnmapViewOfFile(m_address)\n        Win32.CloseHandle(m_hFileMap)\n        m_address = IntPtr.Zero\n        m_hFileMap = IntPtr.Zero\n    End Sub\n\n    Protected Overrides Sub Finalize()\n        Dispose(False)\n    End Sub\n\n\n    &#39; Private helper methods.\n    Private Shared Function AllFlagsSet(ByVal flags As Int32, _\n                                        ByVal flagsToTest As Int32) As Boolean\n        Return (flags And flagsToTest) = flagsToTest\n    End Function\n\n    Private Shared Function AnyFlagsSet(ByVal flags As Int32, _\n                                        ByVal flagsToTest As Int32) As Boolean\n        Return (flags And flagsToTest) &lt;&gt; 0\n    End Function\n\n\n    &#39; The security attribute demands that code that calls  \n    &#39; this method have permission to perform serialization.\n    &lt;SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter:=True)&gt; _\n    Sub GetObjectData(ByVal info As SerializationInfo, _\n                      ByVal context As StreamingContext) _\n                      Implements ISerializable.GetObjectData\n        &#39; The context&#39;s State member indicates where the object will be deserialized.\n\n        &#39; A SharedMemory object cannot be serialized \n        &#39; to any of the following destinations.\n        Const InvalidDestinations As StreamingContextStates = _\n           StreamingContextStates.CrossMachine Or _\n           StreamingContextStates.File Or _\n           StreamingContextStates.Other Or _\n           StreamingContextStates.Persistence Or _\n           StreamingContextStates.Remoting\n        If AnyFlagsSet(CType(context.State, Int32), _\n                       CType(InvalidDestinations, Int32)) Then\n            Throw New SerializationException(&quot;The SharedMemory object &quot; &amp; _\n               &quot;cannot be serialized to any of the following streaming contexts: &quot; _\n               &amp; InvalidDestinations)\n        End If\n\n        Const DeserializableByHandle As StreamingContextStates = _\n                 StreamingContextStates.Clone Or _\n                 StreamingContextStates.CrossAppDomain\n\n        If AnyFlagsSet(CType(context.State, Int32), _\n              CType(DeserializableByHandle, Int32)) Then\n            info.AddValue(&quot;hFileMap&quot;, m_hFileMap)\n        End If\n\n        Const DeserializableByName As StreamingContextStates = _\n                 StreamingContextStates.CrossProcess   &#39; The same computer.\n        If AnyFlagsSet(CType(context.State, Int32), CType(DeserializableByName, _\n                       Int32)) Then\n            If m_name = Nothing Then\n                Throw New SerializationException(&quot;The SharedMemory object &quot; &amp; _\n                   &quot;cannot be serialized CrossProcess because it was not constructed &quot; &amp; _\n                   &quot;with a String name.&quot;)\n            End If\n            info.AddValue(&quot;name&quot;, m_name)\n        End If\n    End Sub\n\n    Private Sub New(ByVal info As SerializationInfo, ByVal context As StreamingContext)\n        &#39; The context&#39;s State member indicates where the object was serialized from.\n\n        Const InvalidSources As StreamingContextStates = _\n                 StreamingContextStates.CrossMachine Or _\n                 StreamingContextStates.File Or _\n                 StreamingContextStates.Other Or _\n                 StreamingContextStates.Persistence Or _\n                 StreamingContextStates.Remoting\n\n        If AnyFlagsSet(CType(context.State, Int32), CType(InvalidSources, Int32)) Then\n            Throw New SerializationException(&quot;The SharedMemory object &quot; &amp; _\n               &quot;cannot be deserialized from any of the following stream contexts: &quot; &amp; _\n               InvalidSources)\n        End If\n\n        Const SerializedByHandle As StreamingContextStates = _\n                 StreamingContextStates.Clone Or _\n                 StreamingContextStates.CrossAppDomain &#39; The same process.\n        If AnyFlagsSet(CType(context.State, Int32), _\n              CType(SerializedByHandle, Int32)) Then\n            Try\n                Win32.DuplicateHandle(Win32.GetCurrentProcess(), _\n                   CType(info.GetValue(&quot;hFileMap&quot;, GetType(IntPtr)), IntPtr), _\n                      Win32.GetCurrentProcess(), m_hFileMap, 0, False, _\n                      Win32.DUPLICATE_SAME_ACCESS)\n            Catch e As SerializationException\n                Throw New SerializationException(&quot;A SharedMemory was not &quot; &amp; _\n                   &quot;serialized using any of the following streaming contexts: &quot; &amp; _\n                   SerializedByHandle)\n            End Try\n        End If\n\n        Const SerializedByName As StreamingContextStates = _\n                 StreamingContextStates.CrossProcess   &#39; The same computer.\n        If AnyFlagsSet(CType(context.State, Int32), _\n                       CType(SerializedByName, Int32)) Then\n            Try\n                m_name = info.GetString(&quot;name&quot;)\n            Catch e As SerializationException\n                Throw New SerializationException(&quot;A SharedMemory object &quot; &amp; _\n                   &quot;was not serialized using any of the following streaming contexts: &quot; &amp; _\n                   SerializedByName)\n            End Try\n            m_hFileMap = Win32.OpenFileMapping(Win32.FILE_MAP_WRITE, False, m_name)\n        End If\n        If Not m_hFileMap.Equals(IntPtr.Zero) Then\n            m_address = Win32.MapViewOfFile(m_hFileMap, _\n               Win32.FILE_MAP_WRITE, 0, 0, IntPtr.Zero)\n        Else\n            Throw New SerializationException(&quot;A SharedMemory object &quot; &amp; _\n               &quot;could not be deserialized.&quot;)\n        End If\n    End Sub\nEnd Class\n\nClass App\n    &lt;STAThread()&gt; Shared Sub Main()\n        Serialize()\n        Console.WriteLine()\n        Deserialize()\n    End Sub\n\n    Shared Sub Serialize()\n        &#39; Create a hashtable of values that will eventually be serialized.\n        Dim sm As New SharedMemory(1024, &quot;MyMemory&quot;)\n        Dim x As Int32\n        For x = 0 To 99\n            sm.SetByte(x, x)\n        Next\n\n        Dim b(9) As Byte\n        For x = 0 To b.Length - 1\n            b(x) = sm.GetByte(x)\n        Next\n        Console.WriteLine(BitConverter.ToString(b))\n\n        &#39; To serialize the hashtable (and its key/value pairs), you must first \n        &#39; open a stream for writing. Use a file stream here.\n        Dim fs As New FileStream(&quot;DataFile.dat&quot;, FileMode.Create)\n\n        &#39; Construct a BinaryFormatter telling it where \n        &#39; the objects will be serialized to.\n        Dim formatter As New BinaryFormatter(Nothing, _\n           New StreamingContext(StreamingContextStates.CrossAppDomain))\n        Try\n            formatter.Serialize(fs, sm)\n        Catch e As SerializationException\n            Console.WriteLine(&quot;Failed to serialize. Reason: &quot; + e.Message)\n            Throw\n        Finally\n            fs.Close()\n        End Try\n    End Sub\n\n    Shared Sub Deserialize()\n        &#39; Declare the hashtable reference.\n        Dim sm As SharedMemory = Nothing\n\n        &#39; Open the file containing the data that you want to deserialize.\n        Dim fs As New FileStream(&quot;DataFile.dat&quot;, FileMode.Open)\n        Try\n            Dim Formatter As New BinaryFormatter(Nothing, _\n               New StreamingContext(StreamingContextStates.CrossAppDomain))\n\n            &#39; Deserialize the SharedMemory object from the file and \n            &#39; assign the reference to the local variable.\n            sm = DirectCast(Formatter.Deserialize(fs), SharedMemory)\n        Catch e As SerializationException\n            Console.WriteLine(&quot;Failed to deserialize. Reason: &quot; &amp; e.Message)\n        Finally\n            fs.Close()\n        End Try\n\n        &#39; To prove that the SharedMemory object deserialized correctly, \n        &#39; display some of its bytes to the console.\n        Dim b(9) As Byte\n        Dim x As Int32\n        For x = 0 To b.Length - 1\n            b(x) = sm.GetByte(x)\n        Next\n        Console.WriteLine(BitConverter.ToString(b))\n    End Sub\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"StreamingContext Example#1\">// Note: You must compile this file using the C# /unsafe switch.\nusing System;\nusing System.IO;\nusing System.Collections;\nusing System.Runtime.Serialization.Formatters.Binary;\nusing System.Runtime.Serialization;\nusing System.Runtime.InteropServices;\nusing System.Security.Permissions;\n\n[assembly: SecurityPermission(\nSecurityAction.RequestMinimum, Execution = true)]\n// This class includes several Win32 interop definitions.\ninternal class Win32\n{\n    public static readonly IntPtr InvalidHandleValue = new IntPtr(-1);\n    public const UInt32 FILE_MAP_WRITE = 2;\n    public const UInt32 PAGE_READWRITE = 0x04;\n\n    [DllImport(&quot;Kernel32&quot;,CharSet=CharSet.Unicode)]\n    public static extern IntPtr CreateFileMapping(IntPtr hFile,\n        IntPtr pAttributes, UInt32 flProtect,\n        UInt32 dwMaximumSizeHigh, UInt32 dwMaximumSizeLow, String pName);\n\n    [DllImport(&quot;Kernel32&quot;,CharSet=CharSet.Unicode)]\n    public static extern IntPtr OpenFileMapping(UInt32 dwDesiredAccess,\n        Boolean bInheritHandle, String name);\n\n    [DllImport(&quot;Kernel32&quot;,CharSet=CharSet.Unicode)]\n    public static extern Boolean CloseHandle(IntPtr handle);\n\n    [DllImport(&quot;Kernel32&quot;,CharSet=CharSet.Unicode)]\n    public static extern IntPtr MapViewOfFile(IntPtr hFileMappingObject,\n        UInt32 dwDesiredAccess,\n        UInt32 dwFileOffsetHigh, UInt32 dwFileOffsetLow,\n        IntPtr dwNumberOfBytesToMap);\n\n    [DllImport(&quot;Kernel32&quot;,CharSet=CharSet.Unicode)]\n    public static extern Boolean UnmapViewOfFile(IntPtr address);\n\n    [DllImport(&quot;Kernel32&quot;,CharSet=CharSet.Unicode)]\n    public static extern Boolean DuplicateHandle(IntPtr hSourceProcessHandle,\n        IntPtr hSourceHandle,\n        IntPtr hTargetProcessHandle, ref IntPtr lpTargetHandle,\n        UInt32 dwDesiredAccess, Boolean bInheritHandle, UInt32 dwOptions);\n    public const UInt32 DUPLICATE_CLOSE_SOURCE = 0x00000001;\n    public const UInt32 DUPLICATE_SAME_ACCESS = 0x00000002;\n\n    [DllImport(&quot;Kernel32&quot;,CharSet=CharSet.Unicode)]\n    public static extern IntPtr GetCurrentProcess();\n}\n\n\n// This class wraps memory that can be simultaneously \n// shared by multiple AppDomains and Processes.\n[Serializable]\npublic sealed class SharedMemory : ISerializable, IDisposable\n{\n    // The handle and string that identify \n    // the Windows file-mapping object.\n    private IntPtr m_hFileMap = IntPtr.Zero;\n    private String m_name;\n\n    // The address of the memory-mapped file-mapping object.\n    private IntPtr m_address;\n\n    public unsafe Byte* Address\n    {\n        get { return (Byte*)m_address; }\n    }\n\n    // The constructors.\n    public SharedMemory(Int32 size) : this(size, null) { }\n\n    public SharedMemory(Int32 size, String name)\n    {\n        m_hFileMap = Win32.CreateFileMapping(Win32.InvalidHandleValue,\n            IntPtr.Zero, Win32.PAGE_READWRITE,\n            0, unchecked((UInt32)size), name);\n        if (m_hFileMap == IntPtr.Zero)\n            throw new Exception(&quot;Could not create memory-mapped file.&quot;);\n        m_name = name;\n        m_address = Win32.MapViewOfFile(m_hFileMap, Win32.FILE_MAP_WRITE,\n            0, 0, IntPtr.Zero);\n    }\n\n    // The cleanup methods.\n    public void Dispose()\n    {\n        GC.SuppressFinalize(this);\n        Dispose(true);\n    }\n\n    private void Dispose(Boolean disposing)\n    {\n        Win32.UnmapViewOfFile(m_address);\n        Win32.CloseHandle(m_hFileMap);\n        m_address = IntPtr.Zero;\n        m_hFileMap = IntPtr.Zero;\n    }\n\n    ~SharedMemory()\n    {\n        Dispose(false);\n    }\n\n    // Private helper methods.\n    private static Boolean AllFlagsSet(Int32 flags, Int32 flagsToTest)\n    {\n        return (flags &amp; flagsToTest) == flagsToTest;\n    }\n\n    private static Boolean AnyFlagsSet(Int32 flags, Int32 flagsToTest)\n    {\n        return (flags &amp; flagsToTest) != 0;\n    }\n\n\n    // The security attribute demands that code that calls  \n    // this method have permission to perform serialization.\n    [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]\n    void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)\n    {\n        // The context&#39;s State member indicates\n        // where the object will be deserialized.\n\n        // A SharedMemory object cannot be serialized \n        // to any of the following destinations.\n        const StreamingContextStates InvalidDestinations =\n                  StreamingContextStates.CrossMachine |\n                  StreamingContextStates.File |\n                  StreamingContextStates.Other |\n                  StreamingContextStates.Persistence |\n                  StreamingContextStates.Remoting;\n        if (AnyFlagsSet((Int32)context.State, (Int32)InvalidDestinations))\n            throw new SerializationException(&quot;The SharedMemory object &quot; +\n                &quot;cannot be serialized to any of the following streaming contexts: &quot; +\n                InvalidDestinations);\n\n        const StreamingContextStates DeserializableByHandle =\n                  StreamingContextStates.Clone |\n            // The same process.\n                  StreamingContextStates.CrossAppDomain;\n        if (AnyFlagsSet((Int32)context.State, (Int32)DeserializableByHandle))\n            info.AddValue(&quot;hFileMap&quot;, m_hFileMap);\n\n        const StreamingContextStates DeserializableByName =\n            // The same computer.\n                  StreamingContextStates.CrossProcess;\n        if (AnyFlagsSet((Int32)context.State, (Int32)DeserializableByName))\n        {\n            if (m_name == null)\n                throw new SerializationException(&quot;The SharedMemory object &quot; +\n                    &quot;cannot be serialized CrossProcess because it was not constructed &quot; +\n                    &quot;with a String name.&quot;);\n            info.AddValue(&quot;name&quot;, m_name);\n        }\n    }\n\n\n    // The security attribute demands that code that calls  \n    // this method have permission to perform serialization.\n    [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]\n    private SharedMemory(SerializationInfo info, StreamingContext context)\n    {\n        // The context&#39;s State member indicates \n        // where the object was serialized from.\n\n        const StreamingContextStates InvalidSources =\n                  StreamingContextStates.CrossMachine |\n                  StreamingContextStates.File |\n                  StreamingContextStates.Other |\n                  StreamingContextStates.Persistence |\n                  StreamingContextStates.Remoting;\n        if (AnyFlagsSet((Int32)context.State, (Int32)InvalidSources))\n            throw new SerializationException(&quot;The SharedMemory object &quot; +\n                &quot;cannot be deserialized from any of the following stream contexts: &quot; +\n                InvalidSources);\n\n        const StreamingContextStates SerializedByHandle =\n                  StreamingContextStates.Clone |\n            // The same process.\n                  StreamingContextStates.CrossAppDomain;\n        if (AnyFlagsSet((Int32)context.State, (Int32)SerializedByHandle))\n        {\n            try\n            {\n                Win32.DuplicateHandle(Win32.GetCurrentProcess(),\n                    (IntPtr)info.GetValue(&quot;hFileMap&quot;, typeof(IntPtr)),\n                    Win32.GetCurrentProcess(), ref m_hFileMap, 0, false,\n                    Win32.DUPLICATE_SAME_ACCESS);\n            }\n            catch (SerializationException)\n            {\n                throw new SerializationException(&quot;A SharedMemory was not serialized &quot; +\n                    &quot;using any of the following streaming contexts: &quot; +\n                    SerializedByHandle);\n            }\n        }\n\n        const StreamingContextStates SerializedByName =\n            // The same computer.\n                  StreamingContextStates.CrossProcess;\n        if (AnyFlagsSet((Int32)context.State, (Int32)SerializedByName))\n        {\n            try\n            {\n                m_name = info.GetString(&quot;name&quot;);\n            }\n            catch (SerializationException)\n            {\n                throw new SerializationException(&quot;A SharedMemory object was not &quot; +\n                    &quot;serialized using any of the following streaming contexts: &quot; +\n                    SerializedByName);\n            }\n            m_hFileMap = Win32.OpenFileMapping(Win32.FILE_MAP_WRITE, false, m_name);\n        }\n        if (m_hFileMap != IntPtr.Zero)\n        {\n            m_address = Win32.MapViewOfFile(m_hFileMap, Win32.FILE_MAP_WRITE,\n                0, 0, IntPtr.Zero);\n        }\n        else\n        {\n            throw new SerializationException(&quot;A SharedMemory object could not &quot; +\n                &quot;be deserialized.&quot;);\n        }\n    }\n}\n\n\nclass App\n{\n    [STAThread]\n    static void Main(string[] args)\n    {\n        Serialize();\n        Console.WriteLine();\n        Deserialize();\n    }\n\n    unsafe static void Serialize()\n    {\n        // Create a hashtable of values that will eventually be serialized.\n        SharedMemory sm = new SharedMemory(1024, &quot;JeffMemory&quot;);\n        for (Int32 x = 0; x &lt; 100; x++)\n            *(sm.Address + x) = (Byte)x;\n\n        Byte[] b = new Byte[10];\n        for (Int32 x = 0; x &lt; b.Length; x++) b[x] = *(sm.Address + x);\n        Console.WriteLine(BitConverter.ToString(b));\n\n        // To serialize the SharedMemory object, \n        // you must first open a stream for writing. \n        // Use a file stream here.\n        FileStream fs = new FileStream(&quot;DataFile.dat&quot;, FileMode.Create);\n\n        // Construct a BinaryFormatter and tell it where \n        // the objects will be serialized to.\n        BinaryFormatter formatter = new BinaryFormatter(null,\n            new StreamingContext(StreamingContextStates.CrossAppDomain));\n        try\n        {\n            formatter.Serialize(fs, sm);\n        }\n        catch (SerializationException e)\n        {\n            Console.WriteLine(&quot;Failed to serialize. Reason: &quot; + e.Message);\n            throw;\n        }\n        finally\n        {\n            fs.Close();\n        }\n    }\n\n\n    unsafe static void Deserialize()\n    {\n        // Declare a SharedMemory reference.\n        SharedMemory sm = null;\n\n        // Open the file containing the data that you want to deserialize.\n        FileStream fs = new FileStream(&quot;DataFile.dat&quot;, FileMode.Open);\n        try\n        {\n            BinaryFormatter formatter = new BinaryFormatter(null,\n                new StreamingContext(StreamingContextStates.CrossAppDomain));\n\n            // Deserialize the SharedMemory object from the file and \n            // assign the reference to the local variable.\n            sm = (SharedMemory)formatter.Deserialize(fs);\n        }\n        catch (SerializationException e)\n        {\n            Console.WriteLine(&quot;Failed to deserialize. Reason: &quot; + e.Message);\n            throw;\n        }\n        finally\n        {\n            fs.Close();\n        }\n\n        // To prove that the SharedMemory object deserialized correctly, \n        // display some of its bytes to the console.\n        Byte[] b = new Byte[10];\n        for (Int32 x = 0; x &lt; b.Length; x++) b[x] = *(sm.Address + x);\n        Console.WriteLine(BitConverter.ToString(b));\n    }\n}\n</code></pre>\r\n  \r\n  \r\n      \t<h2 class=\"accented\">Fields\r\n      </h2>\r\n      <table class=\"nameValue\">\r\n      \t<tr><td id=\"System_Runtime_Serialization_StreamingContextStates_All\">\r\n      \t\t\t<span class=\"lang-csharp\">All</span>\r\n      \t</td>\r\n      \t<td><p>Specifies that the serialized data can be transmitted to or received from any of the other contexts.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Runtime_Serialization_StreamingContextStates_Clone\">\r\n      \t\t\t<span class=\"lang-csharp\">Clone</span>\r\n      \t</td>\r\n      \t<td><p>Specifies that the object graph is being cloned. Users can assume that the cloned graph will continue to exist within the same process and be safe to access handles or other references to unmanaged resources.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Runtime_Serialization_StreamingContextStates_CrossAppDomain\">\r\n      \t\t\t<span class=\"lang-csharp\">CrossAppDomain</span>\r\n      \t</td>\r\n      \t<td><p>Specifies that the source or destination context is a different AppDomain. (For a description of AppDomains, see <a href=\"http://msdn.microsoft.com/en-us/39e57d07-a740-4cd4-ae82-e119ea3856c1\" data-linktype=\"external\">Application Domains</a>).</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Runtime_Serialization_StreamingContextStates_CrossMachine\">\r\n      \t\t\t<span class=\"lang-csharp\">CrossMachine</span>\r\n      \t</td>\r\n      \t<td><p>Specifies that the source or destination context is a different computer.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Runtime_Serialization_StreamingContextStates_CrossProcess\">\r\n      \t\t\t<span class=\"lang-csharp\">CrossProcess</span>\r\n      \t</td>\r\n      \t<td><p>Specifies that the source or destination context is a different process on the same computer.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Runtime_Serialization_StreamingContextStates_File\">\r\n      \t\t\t<span class=\"lang-csharp\">File</span>\r\n      \t</td>\r\n      \t<td><p>Specifies that the source or destination context is a file. Users can assume that files will last longer than the process that created them and not serialize objects in such a way that deserialization will require accessing any data from the current process.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Runtime_Serialization_StreamingContextStates_Other\">\r\n      \t\t\t<span class=\"lang-csharp\">Other</span>\r\n      \t</td>\r\n      \t<td><p>Specifies that the serialization context is unknown.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Runtime_Serialization_StreamingContextStates_Persistence\">\r\n      \t\t\t<span class=\"lang-csharp\">Persistence</span>\r\n      \t</td>\r\n      \t<td><p>Specifies that the source or destination context is a persisted store, which could include databases, files, or other backing stores. Users can assume that persisted data will last longer than the process that created the data and not serialize objects so that deserialization will require accessing any data from the current process.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Runtime_Serialization_StreamingContextStates_Remoting\">\r\n      \t\t\t<span class=\"lang-csharp\">Remoting</span>\r\n      \t</td>\r\n      \t<td><p>Specifies that the data is remoted to a context in an unknown location. Users cannot make any assumptions whether this is on the same computer.</p>\n</td>\r\n      \t</tr>\r\n      </table>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Runtime.Serialization.StreamingContextStates.yml\">\r\n<meta name=\"APIName\" content=\"System.Runtime.Serialization.StreamingContextStates\">\r\n<meta name=\"APIName\" content=\"System.Runtime.Serialization.StreamingContextStates.All\">\r\n<meta name=\"APIName\" content=\"System.Runtime.Serialization.StreamingContextStates.Clone\">\r\n<meta name=\"APIName\" content=\"System.Runtime.Serialization.StreamingContextStates.CrossAppDomain\">\r\n<meta name=\"APIName\" content=\"System.Runtime.Serialization.StreamingContextStates.CrossMachine\">\r\n<meta name=\"APIName\" content=\"System.Runtime.Serialization.StreamingContextStates.CrossProcess\">\r\n<meta name=\"APIName\" content=\"System.Runtime.Serialization.StreamingContextStates.File\">\r\n<meta name=\"APIName\" content=\"System.Runtime.Serialization.StreamingContextStates.Other\">\r\n<meta name=\"APIName\" content=\"System.Runtime.Serialization.StreamingContextStates.Persistence\">\r\n<meta name=\"APIName\" content=\"System.Runtime.Serialization.StreamingContextStates.Remoting\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-31 05:47 AM\">\r\n<meta name=\"document_id\" content=\"adabd641-9700-5798-deaf-8cc0229aa607\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Defines a set of flags that specifies the source or destination context for the stream during serialization.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.runtime.serialization/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Runtime.Serialization.StreamingContextStates\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Runtime.Serialization.StreamingContextStates.yml","open_to_public_contributors":false,"api_name":["System.Runtime.Serialization.StreamingContextStates","System.Runtime.Serialization.StreamingContextStates.All","System.Runtime.Serialization.StreamingContextStates.Clone","System.Runtime.Serialization.StreamingContextStates.CrossAppDomain","System.Runtime.Serialization.StreamingContextStates.CrossMachine","System.Runtime.Serialization.StreamingContextStates.CrossProcess","System.Runtime.Serialization.StreamingContextStates.File","System.Runtime.Serialization.StreamingContextStates.Other","System.Runtime.Serialization.StreamingContextStates.Persistence","System.Runtime.Serialization.StreamingContextStates.Remoting"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Runtime.Serialization.StreamingContextStates","System::Runtime::Serialization::StreamingContextStates","System.Runtime.Serialization.StreamingContextStates.All","System::Runtime::Serialization::StreamingContextStates::All","System.Runtime.Serialization.StreamingContextStates.Clone","System::Runtime::Serialization::StreamingContextStates::Clone","System.Runtime.Serialization.StreamingContextStates.CrossAppDomain","System::Runtime::Serialization::StreamingContextStates::CrossAppDomain","System.Runtime.Serialization.StreamingContextStates.CrossMachine","System::Runtime::Serialization::StreamingContextStates::CrossMachine","System.Runtime.Serialization.StreamingContextStates.CrossProcess","System::Runtime::Serialization::StreamingContextStates::CrossProcess","System.Runtime.Serialization.StreamingContextStates.File","System::Runtime::Serialization::StreamingContextStates::File","System.Runtime.Serialization.StreamingContextStates.Other","System::Runtime::Serialization::StreamingContextStates::Other","System.Runtime.Serialization.StreamingContextStates.Persistence","System::Runtime::Serialization::StreamingContextStates::Persistence","System.Runtime.Serialization.StreamingContextStates.Remoting","System::Runtime::Serialization::StreamingContextStates::Remoting"],"dev_langs":["csharp"],"updated_at":"2017-03-31 05:47 AM","document_id":"adabd641-9700-5798-deaf-8cc0229aa607","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Runtime.Serialization/StreamingContextStates.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"StreamingContextStates enum | Microsoft Docs","_op_ogTitle":"StreamingContextStates enum","description":"Defines a set of flags that specifies the source or destination context for the stream during serialization.\n","toc_asset_id":"api/_splitted/System.Runtime.Serialization/toc.json","toc_rel":"_splitted/System.Runtime.Serialization/toc.json","source_url":"","ms.assetid":"System.Runtime.Serialization.StreamingContextStates","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.streamingcontextstates","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.streamingcontextstates","fileRelativePath":"api/System.Runtime.Serialization.StreamingContextStates.html"},"themesRelativePathToOutputRoot":"_themes/"}