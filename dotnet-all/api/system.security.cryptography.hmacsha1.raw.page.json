{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">HMACSHA1</span>\r\n    \t\t\t\tClass\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Computes a Hash-based Message Authentication Code (HMAC) using the <a class=\"xref\" href=\"system.security.cryptography.sha1\" data-linktype=\"relative-path\">SHA1</a> hash function.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(true)]\npublic class HMACSHA1 : System.Security.Cryptography.HMAC</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm\" data-linktype=\"relative-path\">HashAlgorithm</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.keyedhashalgorithm\" data-linktype=\"relative-path\">KeyedHashAlgorithm</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac\" data-linktype=\"relative-path\">HMAC</a></span></div><span class=\"lang-csharp\">HMACSHA1</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Attributes</dt><dd>\r\n  \t\t<div class=\"cdlHolder\">\r\n  \t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \t<h3 class=\"accented\">Inherited Members</h3>\r\n  \t<h4 class=\"accented\"></h4>\r\n  \t<div class=\"cdlHolder\">\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_CanReuseTransform\" data-linktype=\"relative-path\">CanReuseTransform</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_CanTransformMultipleBlocks\" data-linktype=\"relative-path\">CanTransformMultipleBlocks</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_Clear\" data-linktype=\"relative-path\">Clear()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_ComputeHash_System_Byte___\" data-linktype=\"relative-path\">ComputeHash(Byte[])</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_ComputeHash_System_Byte___System_Int32_System_Int32_\" data-linktype=\"relative-path\">ComputeHash(Byte[], Int32, Int32)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_ComputeHash_System_IO_Stream_\" data-linktype=\"relative-path\">ComputeHash(Stream)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_Dispose\" data-linktype=\"relative-path\">Dispose()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_Hash\" data-linktype=\"relative-path\">Hash</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_HashSize\" data-linktype=\"relative-path\">HashSize</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_HashSizeValue\" data-linktype=\"relative-path\">HashSizeValue</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_HashValue\" data-linktype=\"relative-path\">HashValue</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_InputBlockSize\" data-linktype=\"relative-path\">InputBlockSize</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_OutputBlockSize\" data-linktype=\"relative-path\">OutputBlockSize</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_State\" data-linktype=\"relative-path\">State</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_TransformBlock_System_Byte___System_Int32_System_Int32_System_Byte___System_Int32_\" data-linktype=\"relative-path\">TransformBlock(Byte[], Int32, Int32, Byte[], Int32)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_TransformFinalBlock_System_Byte___System_Int32_System_Int32_\" data-linktype=\"relative-path\">TransformFinalBlock(Byte[], Int32, Int32)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_BlockSizeValue\" data-linktype=\"relative-path\">BlockSizeValue</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_Create\" data-linktype=\"relative-path\">Create()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_Create_System_String_\" data-linktype=\"relative-path\">Create(String)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_Dispose_System_Boolean_\" data-linktype=\"relative-path\">Dispose(Boolean)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_HashCore_System_Byte___System_Int32_System_Int32_\" data-linktype=\"relative-path\">HashCore(Byte[], Int32, Int32)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_HashFinal\" data-linktype=\"relative-path\">HashFinal()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_HashName\" data-linktype=\"relative-path\">HashName</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_Initialize\" data-linktype=\"relative-path\">Initialize()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_Key\" data-linktype=\"relative-path\">Key</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.keyedhashalgorithm#System_Security_Cryptography_KeyedHashAlgorithm_KeyValue\" data-linktype=\"relative-path\">KeyValue</a></span></div>\r\n  \t</div>\r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following code example shows how to sign a file by using the HMACSHA1 object and then how to verify the file.  </p>\n<pre><code class=\"lang-cs\" name=\"HMACSHA1#1\">using System;\nusing System.IO;\nusing System.Security.Cryptography;\n\npublic class HMACSHA1example\n{\n\n    public static void Main(string[] Fileargs)\n    {\n        string dataFile;\n        string signedFile;\n        //If no file names are specified, create them.\n        if (Fileargs.Length &lt; 2)\n        {\n            dataFile = @&quot;text.txt&quot;;\n            signedFile = &quot;signedFile.enc&quot;;\n\n            if (!File.Exists(dataFile))\n            {\n                // Create a file to write to.\n                using (StreamWriter sw = File.CreateText(dataFile))\n                {\n                    sw.WriteLine(&quot;Here is a message to sign&quot;);\n                }\n            }\n\n        }\n        else\n        {\n            dataFile = Fileargs[0];\n            signedFile = Fileargs[1];\n        }\n        try\n        {\n            // Create a random key using a random number generator. This would be the\n            //  secret key shared by sender and receiver.\n            byte[] secretkey = new Byte[64];\n            //RNGCryptoServiceProvider is an implementation of a random number generator.\n            using (RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider())\n            {\n                // The array is now filled with cryptographically strong random bytes.\n                rng.GetBytes(secretkey);\n\n                // Use the secret key to sign the message file.\n                SignFile(secretkey, dataFile, signedFile);\n\n                // Verify the signed file\n                VerifyFile(secretkey, signedFile);\n            }\n        }\n        catch (IOException e)\n        {\n            Console.WriteLine(&quot;Error: File not found&quot;, e);\n        }\n\n    }  //end main\n    // Computes a keyed hash for a source file and creates a target file with the keyed hash\n    // prepended to the contents of the source file. \n    public static void SignFile(byte[] key, String sourceFile, String destFile)\n    {\n        // Initialize the keyed hash object.\n        using (HMACSHA1 hmac = new HMACSHA1(key))\n        {\n            using (FileStream inStream = new FileStream(sourceFile, FileMode.Open))\n            {\n                using (FileStream outStream = new FileStream(destFile, FileMode.Create))\n                {\n                    // Compute the hash of the input file.\n                    byte[] hashValue = hmac.ComputeHash(inStream);\n                    // Reset inStream to the beginning of the file.\n                    inStream.Position = 0;\n                    // Write the computed hash value to the output file.\n                    outStream.Write(hashValue, 0, hashValue.Length);\n                    // Copy the contents of the sourceFile to the destFile.\n                    int bytesRead;\n                    // read 1K at a time\n                    byte[] buffer = new byte[1024];\n                    do\n                    {\n                        // Read from the wrapping CryptoStream.\n                        bytesRead = inStream.Read(buffer, 0, 1024);\n                        outStream.Write(buffer, 0, bytesRead);\n                    } while (bytesRead &gt; 0);\n                }\n            }\n        }\n        return;\n    } // end SignFile\n\n\n    // Compares the key in the source file with a new key created for the data portion of the file. If the keys \n    // compare the data has not been tampered with.\n    public static bool VerifyFile(byte[] key, String sourceFile)\n    {\n        bool err = false;\n        // Initialize the keyed hash object. \n        using (HMACSHA1 hmac = new HMACSHA1(key))\n        {\n            // Create an array to hold the keyed hash value read from the file.\n            byte[] storedHash = new byte[hmac.HashSize / 8];\n            // Create a FileStream for the source file.\n            using (FileStream inStream = new FileStream(sourceFile, FileMode.Open))\n            {\n                // Read in the storedHash.\n                inStream.Read(storedHash, 0, storedHash.Length);\n                // Compute the hash of the remaining contents of the file.\n                // The stream is properly positioned at the beginning of the content, \n                // immediately after the stored hash value.\n                byte[] computedHash = hmac.ComputeHash(inStream);\n                // compare the computed hash with the stored value\n\n                for (int i = 0; i &lt; storedHash.Length; i++)\n                {\n                    if (computedHash[i] != storedHash[i])\n                    {\n                        err = true;\n                    }\n                }\n            }\n        }\n        if (err)\n        {\n            Console.WriteLine(&quot;Hash values differ! Signed file has been tampered with!&quot;);\n            return false;\n        }\n        else\n        {\n            Console.WriteLine(&quot;Hash values agree -- no tampering occurred.&quot;);\n            return true;\n        }\n\n    } //end VerifyFile\n\n} //end class\n</code></pre><pre><code class=\"lang-cpp\" name=\"HMACSHA1#1\">using namespace System;\nusing namespace System::IO;\nusing namespace System::Security::Cryptography;\n\n// Computes a keyed hash for a source file, creates a target file with the keyed hash\n// prepended to the contents of the source file, then decrypts the file and compares\n// the source and the decrypted files.\nvoid EncodeFile( array&lt;Byte&gt;^key, String^ sourceFile, String^ destFile )\n{\n   \n   // Initialize the keyed hash object.\n   HMACSHA1^ myhmacsha1 = gcnew HMACSHA1( key );\n   FileStream^ inStream = gcnew FileStream( sourceFile,FileMode::Open );\n   FileStream^ outStream = gcnew FileStream( destFile,FileMode::Create );\n   \n   // Compute the hash of the input file.\n   array&lt;Byte&gt;^hashValue = myhmacsha1-&gt;ComputeHash( inStream );\n   \n   // Reset inStream to the beginning of the file.\n   inStream-&gt;Position = 0;\n   \n   // Write the computed hash value to the output file.\n   outStream-&gt;Write( hashValue, 0, hashValue-&gt;Length );\n   \n   // Copy the contents of the sourceFile to the destFile.\n   int bytesRead;\n   \n   // read 1K at a time\n   array&lt;Byte&gt;^buffer = gcnew array&lt;Byte&gt;(1024);\n   do\n   {\n      \n      // Read from the wrapping CryptoStream.\n      bytesRead = inStream-&gt;Read( buffer, 0, 1024 );\n      outStream-&gt;Write( buffer, 0, bytesRead );\n   }\n   while ( bytesRead &gt; 0 );\n\n   myhmacsha1-&gt;Clear();\n   \n   // Close the streams\n   inStream-&gt;Close();\n   outStream-&gt;Close();\n   return;\n} // end EncodeFile\n\n\n\n// Decrypt the encoded file and compare to original file.\nbool DecodeFile( array&lt;Byte&gt;^key, String^ sourceFile )\n{\n   \n   // Initialize the keyed hash object. \n   HMACSHA1^ hmacsha1 = gcnew HMACSHA1( key );\n   \n   // Create an array to hold the keyed hash value read from the file.\n   array&lt;Byte&gt;^storedHash = gcnew array&lt;Byte&gt;(hmacsha1-&gt;HashSize / 8);\n   \n   // Create a FileStream for the source file.\n   FileStream^ inStream = gcnew FileStream( sourceFile,FileMode::Open );\n   \n   // Read in the storedHash.\n   inStream-&gt;Read( storedHash, 0, storedHash-&gt;Length );\n   \n   // Compute the hash of the remaining contents of the file.\n   // The stream is properly positioned at the beginning of the content, \n   // immediately after the stored hash value.\n   array&lt;Byte&gt;^computedHash = hmacsha1-&gt;ComputeHash( inStream );\n   \n   // compare the computed hash with the stored value\n   bool err = false;\n   for ( int i = 0; i &lt; storedHash-&gt;Length; i++ )\n   {\n      if ( computedHash[ i ] != storedHash[ i ] )\n      {\n         err = true;\n      }\n   }\n   if (err)\n        {\n            Console::WriteLine(&quot;Hash values differ! Encoded file has been tampered with!&quot;);\n            return false;\n        }\n        else\n        {\n            Console::WriteLine(&quot;Hash values agree -- no tampering occurred.&quot;);\n            return true;\n        }\n\n} //end DecodeFile\n\n\nint main()\n{\n   array&lt;String^&gt;^Fileargs = Environment::GetCommandLineArgs();\n   String^ usageText = &quot;Usage: HMACSHA1 inputfile.txt encryptedfile.hsh\\nYou must specify the two file names. Only the first file must exist.\\n&quot;;\n   \n   //If no file names are specified, write usage text.\n   if ( Fileargs-&gt;Length &lt; 3 )\n   {\n      Console::WriteLine( usageText );\n   }\n   else\n   {\n      try\n      {\n         \n         // Create a random key using a random number generator. This would be the\n         //  secret key shared by sender and receiver.\n         array&lt;Byte&gt;^secretkey = gcnew array&lt;Byte&gt;(64);\n         \n         //RNGCryptoServiceProvider is an implementation of a random number generator.\n         RNGCryptoServiceProvider^ rng = gcnew RNGCryptoServiceProvider;\n         \n         // The array is now filled with cryptographically strong random bytes.\n         rng-&gt;GetBytes( secretkey );\n         \n         // Use the secret key to encode the message file.\n         EncodeFile( secretkey, Fileargs[ 1 ], Fileargs[ 2 ] );\n         \n         // Take the encoded file and decode\n         DecodeFile( secretkey, Fileargs[ 2 ] );\n      }\n      catch ( IOException^ e ) \n      {\n         Console::WriteLine( &quot;Error: File not found&quot;, e );\n      }\n\n   }\n} //end main\n\n</code></pre><pre><code class=\"lang-vb\" name=\"HMACSHA1#1\">Imports System\nImports System.IO\nImports System.Security.Cryptography\n\nPublic Class HMACSHA1example\n\n    Public Shared Sub Main(ByVal Fileargs() As String)\n        Dim dataFile As String\n        Dim signedFile As String\n        &#39;If no file names are specified, create them.\n        If Fileargs.Length &lt; 2 Then\n            dataFile = &quot;text.txt&quot;\n            signedFile = &quot;signedFile.enc&quot;\n\n            If Not File.Exists(dataFile) Then\n                &#39; Create a file to write to.\n                Using sw As StreamWriter = File.CreateText(dataFile)\n                    sw.WriteLine(&quot;Here is a message to sign&quot;)\n                End Using\n            End If\n\n        Else\n            dataFile = Fileargs(0)\n            signedFile = Fileargs(1)\n        End If\n        Try\n            &#39; Create a random key using a random number generator. This would be the\n            &#39;  secret key shared by sender and receiver.\n            Dim secretkey() As Byte = New [Byte](63) {}\n            &#39;RNGCryptoServiceProvider is an implementation of a random number generator.\n            Using rng As New RNGCryptoServiceProvider()\n                &#39; The array is now filled with cryptographically strong random bytes.\n                rng.GetBytes(secretkey)\n\n                &#39; Use the secret key to encode the message file.\n                SignFile(secretkey, dataFile, signedFile)\n\n                &#39; Take the encoded file and decode\n                VerifyFile(secretkey, signedFile)\n            End Using\n        Catch e As IOException\n            Console.WriteLine(&quot;Error: File not found&quot;, e)\n        End Try\n\n    End Sub &#39;Main\n\n    &#39; Computes a keyed hash for a source file and creates a target file with the keyed hash\n    &#39; prepended to the contents of the source file. \n    Public Shared Sub SignFile(ByVal key() As Byte, ByVal sourceFile As String, ByVal destFile As String)\n        &#39; Initialize the keyed hash object.\n        Using myhmac As New HMACSHA1(key)\n            Using inStream As New FileStream(sourceFile, FileMode.Open)\n                Using outStream As New FileStream(destFile, FileMode.Create)\n                    &#39; Compute the hash of the input file.\n                    Dim hashValue As Byte() = myhmac.ComputeHash(inStream)\n                    &#39; Reset inStream to the beginning of the file.\n                    inStream.Position = 0\n                    &#39; Write the computed hash value to the output file.\n                    outStream.Write(hashValue, 0, hashValue.Length)\n                    &#39; Copy the contents of the sourceFile to the destFile.\n                    Dim bytesRead As Integer\n                    &#39; read 1K at a time\n                    Dim buffer(1023) As Byte\n                    Do\n                        &#39; Read from the wrapping CryptoStream.\n                        bytesRead = inStream.Read(buffer, 0, 1024)\n                        outStream.Write(buffer, 0, bytesRead)\n                    Loop While bytesRead &gt; 0\n                End Using\n            End Using\n        End Using\n        Return\n\n    End Sub &#39;SignFile\n    &#39; end SignFile\n\n    &#39; Compares the key in the source file with a new key created for the data portion of the file. If the keys \n    &#39; compare the data has not been tampered with.\n    Public Shared Function VerifyFile(ByVal key() As Byte, ByVal sourceFile As String) As Boolean\n        Dim err As Boolean = False\n        &#39; Initialize the keyed hash object. \n        Using hmac As New HMACSHA1(key)\n            &#39; Create an array to hold the keyed hash value read from the file.\n            Dim storedHash(hmac.HashSize / 8) As Byte\n            &#39; Create a FileStream for the source file.\n            Using inStream As New FileStream(sourceFile, FileMode.Open)\n                &#39; Read in the storedHash.\n                inStream.Read(storedHash, 0, storedHash.Length - 1)\n                &#39; Compute the hash of the remaining contents of the file.\n                &#39; The stream is properly positioned at the beginning of the content, \n                &#39; immediately after the stored hash value.\n                Dim computedHash As Byte() = hmac.ComputeHash(inStream)\n                &#39; compare the computed hash with the stored value\n                Dim i As Integer\n                For i = 0 To storedHash.Length - 2\n                    If computedHash(i) &lt;&gt; storedHash(i) Then\n                        err = True\n                    End If\n                Next i\n            End Using\n        End Using\n        If err Then\n            Console.WriteLine(&quot;Hash values differ! Signed file has been tampered with!&quot;)\n            Return False\n        Else\n            Console.WriteLine(&quot;Hash values agree -- no tampering occurred.&quot;)\n            Return True\n        End If\n\n    End Function &#39;VerifyFile \nEnd Class &#39;HMACSHA1example &#39;end VerifyFile\n&#39;end class\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>HMACSHA1 is a type of keyed hash algorithm that is constructed from the SHA1 hash function and used as an HMAC, or hash-based message authentication code. The HMAC process mixes a secret key with the message data, hashes the result with the hash function, mixes that hash value with the secret key again, and then applies the hash function a second time. The output hash is 160 bits in length.  </p>\n<p> An HMAC can be used to determine whether a message sent over an insecure channel has been tampered with, provided that the sender and receiver share a secret key. The sender computes the hash value for the original data and sends both the original data and hash value as a single message. The receiver recalculates the hash value on the received message and checks that the computed HMAC matches the transmitted HMAC.  </p>\n<p> Any change to the data or the hash value results in a mismatch, because knowledge of the secret key is required to change the message and reproduce the correct hash value. Therefore, if the original and computed hash values match, the message is authenticated.  </p>\n<p> The SHA-1 (Secure Hash Algorithm, also called SHS, Secure Hash Standard) is a cryptographic hash algorithm published by the United States Government. It produces a 160-bit hash value from an arbitrary length string.  </p>\n<p> HMACSHA1 accepts keys of any size, and produces a hash sequence that is 160 bits in length.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Constructors\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Security_Cryptography_HMACSHA1__ctor_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_Cryptography_HMACSHA1__ctor\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">HMACSHA1()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Initializes a new instance of the <a class=\"xref\" href=\"system.security.cryptography.hmacsha1\" data-linktype=\"relative-path\">HMACSHA1</a> class with a randomly generated key.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public HMACSHA1 ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p><a class=\"xref\" href=\"system.security.cryptography.hmacsha1\" data-linktype=\"relative-path\">HMACSHA1</a> is a type of keyed hash algorithm that is constructed from the SHA1 hash function and used as an HMAC, or hash-based message authentication code. The HMAC process mixes a secret key with the message data, hashes the result with the hash function, mixes that hash value with the secret key again, and then applies the hash function a second time. The output hash is 160 bits (20 bytes) in length.  </p>\n<p> This constructor uses a 64-byte, randomly generated key.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Security_Cryptography_HMACSHA1__ctor_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_Cryptography_HMACSHA1__ctor_System_Byte___\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">HMACSHA1(Byte[])</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Initializes a new instance of the <a class=\"xref\" href=\"system.security.cryptography.hmacsha1\" data-linktype=\"relative-path\">HMACSHA1</a> class with the specified key data.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public HMACSHA1 (byte[] key);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>key</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.byte\" data-linktype=\"relative-path\">Byte</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The secret key for <a class=\"xref\" href=\"system.security.cryptography.hmacsha1\" data-linktype=\"relative-path\">HMACSHA1</a> encryption. The key can be any length, but if it is more than 64 bytes long it is hashed (using SHA-1) to derive a 64-byte key. Therefore, the recommended size of the secret key is 64 bytes.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>key</code> parameter is <code>null</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p><a class=\"xref\" href=\"system.security.cryptography.hmacsha1\" data-linktype=\"relative-path\">HMACSHA1</a> is a type of keyed hash algorithm that is constructed from the SHA1 hash function and used as an HMAC, or hash-based message authentication code. The HMAC process mixes a secret key with the message data, hashes the result with the hash function, mixes that hash value with the secret key again, and then applies the hash function a second time. The output hash is 160 bits (20 bytes) in length.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> This constructor creates an unmanaged instance of the algorithm by using the <a class=\"xref\" href=\"system.security.cryptography.sha1cryptoserviceprovider\" data-linktype=\"relative-path\">SHA1CryptoServiceProvider</a> class.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Security_Cryptography_HMACSHA1__ctor_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_Cryptography_HMACSHA1__ctor_System_Byte___System_Boolean_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">HMACSHA1(Byte[], Boolean)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Initializes a new instance of the <a class=\"xref\" href=\"system.security.cryptography.hmacsha1\" data-linktype=\"relative-path\">HMACSHA1</a> class with the specified key data and a value that specifies whether to use the managed version of the SHA1 algorithm.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public HMACSHA1 (byte[] key, bool useManagedSha1);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>key</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.byte\" data-linktype=\"relative-path\">Byte</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The secret key for <a class=\"xref\" href=\"system.security.cryptography.hmacsha1\" data-linktype=\"relative-path\">HMACSHA1</a> encryption. The key can be any length, but if it is more than 64 bytes long, it is hashed (using SHA-1) to derive a 64-byte key. Therefore, the recommended size of the secret key is 64 bytes.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>useManagedSha1</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> to use the managed implementation of the SHA1 algorithm (the <a class=\"xref\" href=\"system.security.cryptography.sha1managed\" data-linktype=\"relative-path\">SHA1Managed</a> class); <code>false</code> to use the unmanaged implementation (the <a class=\"xref\" href=\"system.security.cryptography.sha1cryptoserviceprovider\" data-linktype=\"relative-path\">SHA1CryptoServiceProvider</a> class).</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Security.Cryptography.HMACSHA1.yml\">\r\n<meta name=\"APIName\" content=\"System.Security.Cryptography.HMACSHA1\">\r\n<meta name=\"APIName\" content=\"System.Security.Cryptography.HMACSHA1..ctor\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-31 05:47 AM\">\r\n<meta name=\"document_id\" content=\"e4174969-812d-90e3-e159-28965826368b\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Computes a Hash-based Message Authentication Code (HMAC) using the  hash function.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.security.cryptography/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Security.Cryptography.HMACSHA1\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Security.Cryptography.HMACSHA1.yml","open_to_public_contributors":false,"api_name":["System.Security.Cryptography.HMACSHA1","System.Security.Cryptography.HMACSHA1..ctor"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Security.Cryptography.HMACSHA1","System::Security::Cryptography::HMACSHA1","System.Security.Cryptography.HMACSHA1.#ctor","System::Security::Cryptography::HMACSHA1::#ctor"],"dev_langs":["csharp"],"updated_at":"2017-03-31 05:47 AM","document_id":"e4174969-812d-90e3-e159-28965826368b","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Security.Cryptography/HMACSHA1.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"HMACSHA1 class | Microsoft Docs","_op_ogTitle":"HMACSHA1 class","description":"Computes a Hash-based Message Authentication Code (HMAC) using the  hash function.\n","toc_asset_id":"api/_splitted/System.Security.Cryptography/toc.json","toc_rel":"_splitted/System.Security.Cryptography/toc.json","source_url":"","ms.assetid":"System.Security.Cryptography.HMACSHA1","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.hmacsha1","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.hmacsha1","fileRelativePath":"api/System.Security.Cryptography.HMACSHA1.html"},"themesRelativePathToOutputRoot":"_themes/"}