{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">IOrderedDictionary</span>\r\n      Interface\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Represents an indexed collection of key/value pairs.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">public interface IOrderedDictionary : System.Collections.IDictionary</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following code example demonstrates the implementation of a simple IOrderedDictionary based on the <a class=\"xref\" href=\"system.collections.arraylist\" data-linktype=\"relative-path\">ArrayList</a> class. The implemented IOrderedDictionary stores first names as the keys and last names as the values, with the added requirement that each first name is unique.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Collections.Specialized.IOrderedDictionary_Implementation#00\">\n#using &lt;System.dll&gt;\n\nusing namespace System;\nusing namespace System::Collections;\nusing namespace System::Collections::Specialized;\n\npublic ref class PeopleEnum : IDictionaryEnumerator\n{\nprivate:\n    // Enumerators are positioned before the first element\n    // until the first MoveNext() call.\n    int position;\n    ArrayList^ _people;\n\npublic:\n    PeopleEnum(ArrayList^ list)\n    {\n        this-&gt;Reset();\n        _people = list;\n    }\n\n    virtual bool MoveNext()\n    {\n        position++;\n        return (position &lt; _people-&gt;Count);\n    }\n\n    virtual void Reset()\n    {\n        position = -1;\n    }\n\n    virtual property Object^ Current\n    {\n        Object^ get()\n        {\n            try\n            {\n                return _people[position];\n            }\n            catch (IndexOutOfRangeException^)\n            {\n                throw gcnew InvalidOperationException();\n            }\n        }\n    }\n\n    virtual property DictionaryEntry Entry\n    {\n        DictionaryEntry get()\n        {\n            return (DictionaryEntry)(Current);\n        }\n    }\n\n    virtual property Object^ Key\n    {\n        Object^ get()\n        {\n            try\n            {\n                return ((DictionaryEntry^)_people[position])-&gt;Key;\n            }\n            catch (IndexOutOfRangeException^)\n            {\n                throw gcnew InvalidOperationException();\n            }\n        }\n    }\n\n    virtual property Object^ Value\n    {\n        Object^ get()\n        {\n            try\n            {\n                return ((DictionaryEntry^)_people[position])-&gt;Value;\n            }\n            catch (IndexOutOfRangeException^)\n            {\n                throw gcnew InvalidOperationException();\n            }\n        }\n    }\n};\n\npublic ref class People : IOrderedDictionary\n{\nprivate:\n    ArrayList^ _people;\n\npublic:\n    People(int numItems)\n    {\n        _people = gcnew ArrayList(numItems);\n    }\n\n    int IndexOfKey(Object^ key)\n    {\n        for (int i = 0; i &lt; _people-&gt;Count; i++)\n        {\n            if (((DictionaryEntry^)_people[i])-&gt;Key == key)\n                return i;\n        }\n\n        // key not found, return -1.\n        return -1;\n    }\n\n    virtual property Object^ default[Object^]\n    {\n        Object^ get(Object^ key)\n        {\n            return ((DictionaryEntry^)_people[IndexOfKey(key)])-&gt;Value;\n        }\n        void set(Object^ key, Object^ value)\n        {\n            _people[IndexOfKey(key)] = gcnew DictionaryEntry(key, value);\n        }\n    }\n\n    // IOrderedDictionary Members\n    virtual IDictionaryEnumerator^ GetEnumerator()\n    {\n        return gcnew PeopleEnum(_people);\n    }\n\n    virtual void Insert(int index, Object^ key, Object^ value)\n    {\n        if (IndexOfKey(key) != -1)\n        {\n            throw gcnew ArgumentException(&quot;An element with the same key already exists in the collection.&quot;);\n        }\n        _people-&gt;Insert(index, gcnew DictionaryEntry(key, value));\n    }\n\n    virtual void RemoveAt(int index)\n    {\n        _people-&gt;RemoveAt(index);\n    }\n\n    virtual property Object^ default[int]\n    {\n        Object^ get(int index)\n        {\n            return ((DictionaryEntry^)_people[index])-&gt;Value;\n        }\n        void set(int index, Object^ value)\n        {\n            Object^ key = ((DictionaryEntry^)_people[index])-&gt;Key;\n            _people[index] = gcnew DictionaryEntry(Keys, value);\n        }\n    }\n\n    // IDictionary Members\n\n    virtual void Add(Object^ key, Object^ value)\n    {\n        if (IndexOfKey(key) != -1)\n        {\n            throw gcnew ArgumentException(&quot;An element with the same key already exists in the collection.&quot;);\n        }\n        _people-&gt;Add(gcnew DictionaryEntry(key, value));\n    }\n\n    virtual void Clear()\n    {\n        _people-&gt;Clear();\n    }\n\n    virtual bool Contains(Object^ key)\n    {\n        if (IndexOfKey(key) == -1)\n        {\n            return false;\n        }\n        else\n        {\n            return true;\n        }\n    }\n\n    virtual property bool IsFixedSize\n    {\n        bool get()\n        {\n            return false;\n        }\n    }\n\n    virtual property bool IsReadOnly\n    {\n        bool get()\n        {\n            return false;\n        }\n    }\n\n    virtual property ICollection^ Keys\n    {\n        ICollection^ get()\n        {\n            ArrayList^ KeyCollection = gcnew ArrayList(_people-&gt;Count);\n            for (int i = 0; i &lt; _people-&gt;Count; i++)\n            {\n                KeyCollection-&gt;Add( ((DictionaryEntry^)_people[i])-&gt;Key );\n            }\n            return KeyCollection;\n        }\n    }\n\n    virtual void Remove(Object^ key)\n    {\n        _people-&gt;RemoveAt(IndexOfKey(key));\n    }\n\n    virtual property ICollection^ Values\n    {\n        ICollection ^get()\n        {\n            ArrayList^ ValueCollection = gcnew ArrayList(_people-&gt;Count);\n            for (int i = 0; i &lt; _people-&gt;Count; i++)\n            {\n                ValueCollection-&gt;Add( ((DictionaryEntry^)_people[i])-&gt;Value );\n            }\n            return ValueCollection;\n        }\n    }\n\n    // ICollection Members\n\n    virtual void CopyTo(Array^ array, int index)\n    {\n        _people-&gt;CopyTo(array, index);\n    }\n\n    virtual property int Count\n    {\n        int get()\n        {\n            return _people-&gt;Count;\n        }\n    }\n\n    virtual property bool IsSynchronized\n    {\n        bool get()\n        {\n            return _people-&gt;IsSynchronized;\n        }\n    }\n\n    virtual property Object^ SyncRoot\n    {\n        Object^ get()\n        {\n            return _people-&gt;SyncRoot;\n        }\n    }\n\n    // IEnumerable Members\n\n    virtual IEnumerator^ IfcGetEnumerator() = IEnumerable::GetEnumerator\n    {\n        return (IEnumerator^) gcnew PeopleEnum(_people);\n    }\n};\n\nclass App\n{\npublic:\n    static void Main()\n    {\n        People^ peopleCollection = gcnew People(3);\n        peopleCollection-&gt;Add(&quot;John&quot;, &quot;Smith&quot;);\n        peopleCollection-&gt;Add(&quot;Jim&quot;, &quot;Johnson&quot;);\n        peopleCollection-&gt;Add(&quot;Sue&quot;, &quot;Rabon&quot;);\n\n        Console::WriteLine(&quot;Displaying the entries in peopleCollection:&quot;);\n        for each (DictionaryEntry^ de in peopleCollection)\n        {\n            Console::WriteLine(&quot;{0} {1}&quot;, de-&gt;Key, de-&gt;Value);\n        }\n        Console::WriteLine();\n        Console::WriteLine(&quot;Displaying the entries in the modified peopleCollection:&quot;);\n        peopleCollection[&quot;Jim&quot;] = &quot;Jackson&quot;;\n        peopleCollection-&gt;Remove(&quot;Sue&quot;);\n        peopleCollection-&gt;Insert(0, &quot;Fred&quot;, &quot;Anderson&quot;);\n\n        for each (DictionaryEntry^ de in peopleCollection)\n        {\n            Console::WriteLine(&quot;{0} {1}&quot;, de-&gt;Key, de-&gt;Value);\n        }\n\n    }\n};\n\nint main()\n{\n    App::Main();\n}\n/* This code produces output similar to the following:\n *\n * Displaying the entries in peopleCollection:\n * John Smith\n * Jim Johnson\n * Sue Rabon\n *\n * Displaying the entries in the modified peopleCollection:\n * Fred Anderson\n * John Smith\n * Jim Jackson\n */\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Collections.Specialized.IOrderedDictionary_Implementation#00\">using System;\nusing System.Collections;\nusing System.Collections.Specialized;\n\npublic class People : IOrderedDictionary\n{\n    private ArrayList _people;\n\n    public People(int numItems)\n    {\n        _people = new ArrayList(numItems);\n    }\n\n    public int IndexOfKey(object key)\n    {\n        for (int i = 0; i &lt; _people.Count; i++)\n        {\n            if (((DictionaryEntry)_people[i]).Key == key)\n                return i;\n        }\n\n        // key not found, reutrn -1.\n        return -1;\n    }\n\n    public object this[object key]\n    {\n        get\n        {\n            return ((DictionaryEntry)_people[IndexOfKey(key)]).Value;\n        }\n        set\n        {\n            _people[IndexOfKey(key)] = new DictionaryEntry(key, value);\n        }\n    }\n\n    // IOrderedDictionary Members\n    public IDictionaryEnumerator GetEnumerator()\n    {\n        return new PeopleEnum(_people);\n    }\n\n    public void Insert(int index, object key, object value)\n    {\n        if (IndexOfKey(key) != -1)\n        {\n            throw new ArgumentException(&quot;An element with the same key already exists in the collection.&quot;);\n        }\n        _people.Insert(index, new DictionaryEntry(key, value));\n    }\n\n    public void RemoveAt(int index)\n    {\n        _people.RemoveAt(index);\n    }\n\n    public object this[int index]\n    {\n        get\n        {\n            return ((DictionaryEntry)_people[index]).Value;\n        }\n        set\n        {\n            object key = ((DictionaryEntry)_people[index]).Key;\n            _people[index] = new DictionaryEntry(Keys, value);\n        }\n    }\n    // IDictionary Members\n\n    public void Add(object key, object value)\n    {\n        if (IndexOfKey(key) != -1)\n        {\n            throw new ArgumentException(&quot;An element with the same key already exists in the collection.&quot;);\n        }\n        _people.Add(new DictionaryEntry(key, value));\n    }\n\n    public void Clear()\n    {\n        _people.Clear();\n    }\n\n    public bool Contains(object key)\n    {\n        if (IndexOfKey(key) == -1)\n        {\n            return false;\n        }\n        else\n        {\n            return true;\n        }\n    }\n\n    public bool IsFixedSize\n    {\n        get\n        {\n            return false;\n        }\n    }\n\n    public bool IsReadOnly\n    {\n        get\n        {\n            return false;\n        }\n    }\n\n    public ICollection Keys\n    {\n        get\n        {\n            ArrayList KeyCollection = new ArrayList(_people.Count);\n            for (int i = 0; i &lt; _people.Count; i++)\n            {\n                KeyCollection.Add( ((DictionaryEntry)_people[i]).Key );\n            }\n            return KeyCollection;\n        }\n    }\n\n    public void Remove(object key)\n    {\n        _people.RemoveAt(IndexOfKey(key));\n    }\n\n    public ICollection Values\n    {\n        get\n        {\n            ArrayList ValueCollection = new ArrayList(_people.Count);\n            for (int i = 0; i &lt; _people.Count; i++)\n            {\n                ValueCollection.Add( ((DictionaryEntry)_people[i]).Value );\n            }\n            return ValueCollection;\n        }\n    }\n\n\n    // ICollection Members\n\n    public void CopyTo(Array array, int index)\n    {\n        _people.CopyTo(array, index);\n    }\n\n    public int Count\n    {\n        get\n        {\n            return _people.Count;\n        }\n    }\n\n    public bool IsSynchronized\n    {\n        get\n        {\n            return _people.IsSynchronized;\n        }\n    }\n\n    public object SyncRoot\n    {\n        get\n        {\n            return _people.SyncRoot;\n        }\n    }\n\n    // IEnumerable Members\n\n    IEnumerator IEnumerable.GetEnumerator()\n    {\n        return new PeopleEnum(_people);\n    }\n}\n\npublic class PeopleEnum : IDictionaryEnumerator\n{\n    public ArrayList _people;\n    \n    // Enumerators are positioned before the first element\n    // until the first MoveNext() call.\n    int position = -1;\n\n    public PeopleEnum(ArrayList list)\n    {\n        _people = list;\n    }\n\n    public bool MoveNext()\n    {\n        position++;\n        return (position &lt; _people.Count);\n    }\n\n    public void Reset()\n    {\n        position = -1;\n    }\n\n    public object Current\n    {\n        get\n        {\n            try\n            {\n                return _people[position];\n            }\n            catch (IndexOutOfRangeException)\n            {\n                throw new InvalidOperationException();\n            }\n        }\n    }\n\n    public DictionaryEntry Entry\n    {\n        get\n        {\n            return (DictionaryEntry)Current;\n        }\n    }\n\n    public object Key\n    {\n        get\n        {\n            try\n            {\n                return ((DictionaryEntry)_people[position]).Key;\n            }\n            catch (IndexOutOfRangeException)\n            {\n                throw new InvalidOperationException();\n            }\n        }\n    }\n\n    public object Value\n    {\n        get\n        {\n            try\n            {\n                return ((DictionaryEntry)_people[position]).Value;\n            }\n            catch (IndexOutOfRangeException)\n            {\n                throw new InvalidOperationException();\n            }\n        }\n    }\n}\n\nclass App\n{\n    static void Main()\n    {\n        People peopleCollection = new People(3);\n        peopleCollection.Add(&quot;John&quot;, &quot;Smith&quot;);\n        peopleCollection.Add(&quot;Jim&quot;, &quot;Johnson&quot;);\n        peopleCollection.Add(&quot;Sue&quot;, &quot;Rabon&quot;);\n\n        Console.WriteLine(&quot;Displaying the entries in peopleCollection:&quot;);\n        foreach (DictionaryEntry de in peopleCollection)\n        {\n            Console.WriteLine(&quot;{0} {1}&quot;, de.Key, de.Value);\n        }\n\n        Console.WriteLine();\n        Console.WriteLine(&quot;Displaying the entries in the modified peopleCollection:&quot;);\n        peopleCollection[&quot;Jim&quot;] = &quot;Jackson&quot;;\n        peopleCollection.Remove(&quot;Sue&quot;);\n        peopleCollection.Insert(0, &quot;Fred&quot;, &quot;Anderson&quot;);\n\n        foreach (DictionaryEntry de in peopleCollection)\n        {\n            Console.WriteLine(&quot;{0} {1}&quot;, de.Key, de.Value);\n        }\n\n    }\n}\n/* This code produces output similar to the following:\n * \n * Displaying the entries in peopleCollection:\n * John Smith\n * Jim Johnson\n * Sue Rabon\n * \n * Displaying the entries in the modified peopleCollection:\n * Fred Anderson\n * John Smith\n * Jim Jackson\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Collections.Specialized.IOrderedDictionary_Implementation#00\">Imports System\nImports System.Collections\nImports System.Collections.Specialized\n\nPublic Class People\n    Implements IOrderedDictionary\n    Private _people As ArrayList\n\n    Public Sub New(ByVal numItems As Integer)\n        _people = New ArrayList(numItems)\n    End Sub\n\n    Public Function IndexOfKey(ByVal key As Object) As Integer\n        Dim i As Integer\n        For i = 0 To _people.Count - 1\n            If CType(_people(i), DictionaryEntry).Key = key Then\n                Return i\n            End If\n        Next i\n\n        &#39; key not found, return -1.\n        Return -1\n    End Function\n\n    &#39; IOrderedDictionary Members\n    Public Function GetEnumerator() As IDictionaryEnumerator _\n        Implements IOrderedDictionary.GetEnumerator\n\n        Return New PeopleEnum(_people)\n    End Function\n\n    Public Sub Insert(ByVal index As Integer, ByVal key As Object, _\n        ByVal value As Object) Implements IOrderedDictionary.Insert\n\n        If Not IndexOfKey(key) = -1 Then\n            Throw New ArgumentException(&quot;An element with the same key already exists in the collection.&quot;)\n        End If\n        _people.Insert(index, New DictionaryEntry(key, value))\n    End Sub\n\n    Public Sub RemoveAt(ByVal index As Integer) _\n        Implements IOrderedDictionary.RemoveAt\n\n        _people.RemoveAt(index)\n    End Sub\n\n    Public Property Item(ByVal index As Integer) As Object _\n        Implements IOrderedDictionary.Item\n\n        Get\n            Return CType(_people(index), DictionaryEntry).Value\n        End Get\n        Set(ByVal value As Object)\n            Dim key As Object = CType(_people(index), DictionaryEntry).Key\n            _people(index) = New DictionaryEntry(key, value)\n        End Set\n    End Property\n\n    &#39; IDictionary Members\n    Public Function IDictionaryGetEnumerator() As IDictionaryEnumerator _\n    Implements IDictionary.GetEnumerator\n\n        Return New PeopleEnum(_people)\n    End Function\n\n    Public Property Item(ByVal key As Object) As Object _\n        Implements IDictionary.Item\n\n        Get\n            Return CType(_people(IndexOfKey(key)), DictionaryEntry).Value\n        End Get\n        Set(ByVal value)\n            _people(IndexOfKey(key)) = New DictionaryEntry(key, value)\n        End Set\n    End Property\n\n\n    Public Sub Add(ByVal key As Object, ByVal value As Object) _\n        Implements IDictionary.Add\n\n        If Not IndexOfKey(key) = -1 Then\n            Throw New ArgumentException(&quot;An element with the same key already exists in the collection.&quot;)\n        End If\n\n        _people.Add(New DictionaryEntry(key, value))\n    End Sub\n\n    Public Sub Clear() Implements IDictionary.Clear\n        _people.Clear()\n    End Sub\n\n    Public Function Contains(ByVal key As Object) As Boolean _\n        Implements IDictionary.Contains\n\n        If IndexOfKey(key) = -1 Then\n            Return False\n        Else\n            Return True\n        End If\n    End Function\n\n    Public ReadOnly Property IsFixedSize() As Boolean _\n        Implements IDictionary.IsFixedSize\n\n        Get\n            Return False\n        End Get\n    End Property\n\n    Public ReadOnly Property IsReadOnly() As Boolean _\n        Implements IDictionary.IsReadOnly\n        Get\n            Return False\n        End Get\n    End Property\n\n    Public ReadOnly Property Keys() As ICollection _\n        Implements IDictionary.Keys\n        Get\n            Dim KeyCollection As ArrayList = New ArrayList(_people.Count)\n            Dim i As Integer\n            For i = 0 To _people.Count - 1\n                KeyCollection.Add( CType(_people(i), DictionaryEntry).Key )\n            Next i\n            Return KeyCollection\n        End Get\n    End Property\n\n    Public Sub Remove(ByVal key As Object) _\n        Implements IDictionary.Remove\n\n        _people.RemoveAt(IndexOfKey(key))\n    End Sub\n\n    Public ReadOnly Property Values() As ICollection _\n        Implements IDictionary.Values\n        Get\n            Dim ValueCollection As ArrayList = New ArrayList(_people.Count)\n            Dim i As Integer\n            For i = 0 To _people.Count - 1\n                ValueCollection.Add( CType(_people(i), DictionaryEntry).Value )\n            Next i\n            Return ValueCollection\n        End Get\n    End Property\n\n    &#39; ICollection Members\n    Public Sub CopyTo(ByVal array As Array, ByVal index As Integer) _\n    Implements ICollection.CopyTo\n\n        _people.CopyTo(Array, index)\n    End Sub\n\n    Public ReadOnly Property Count() As Integer _\n        Implements ICollection.Count\n\n        Get\n            Return _people.Count\n        End Get\n    End Property\n\n    Public ReadOnly Property IsSynchronized() As Boolean _\n        Implements ICollection.IsSynchronized\n\n        Get\n            Return _people.IsSynchronized\n        End Get\n    End Property\n\n    Public ReadOnly Property SyncRoot() As Object _\n        Implements ICollection.SyncRoot\n\n        Get\n            Return _people.SyncRoot\n        End Get\n    End Property\n\n    &#39; IEnumerable Members\n    Public Function IEnumerableGetEnumerator() As IEnumerator _\n        Implements IEnumerable.GetEnumerator\n\n        Return New PeopleEnum(_people)\n    End Function\nEnd Class\n\nPublic Class PeopleEnum\n    Implements IDictionaryEnumerator\n\n    Public _people As ArrayList\n\n    &#39; Enumerators are positioned before the first element\n    &#39; until the first MoveNext() call.\n    Dim position As Integer = -1\n\n    Public Sub New(ByVal list As ArrayList)\n        _people = list\n    End Sub\n\n    Public Function MoveNext() As Boolean _\n        Implements IEnumerator.MoveNext\n\n        position = position + 1\n        Return (position &lt; _people.Count)\n    End Function\n\n    Public Sub Reset() _\n        Implements IEnumerator.Reset\n\n        position = -1\n    End Sub\n\n    Public ReadOnly Property Current() As Object _\n        Implements IEnumerator.Current\n\n        Get\n            Try\n                Return _people(position)\n            Catch e As IndexOutOfRangeException\n                Throw New InvalidOperationException()\n            End Try\n        End Get\n    End Property\n\n    Public ReadOnly Property Entry() As DictionaryEntry _\n        Implements IDictionaryEnumerator.Entry\n        Get\n            Return CType(Current, DictionaryEntry)\n        End Get\n    End Property\n\n    Public ReadOnly Property Key() As Object _\n        Implements IDictionaryEnumerator.Key\n\n        Get\n            Try\n                Return CType(_people(position), DictionaryEntry).Key\n            Catch e As IndexOutOfRangeException\n                Throw New InvalidOperationException()\n            End Try\n        End Get\n    End Property\n\n    Public ReadOnly Property Value() As Object _\n        Implements IDictionaryEnumerator.Value\n\n        Get\n            Try\n                Return CType(_people(position), DictionaryEntry).Value\n            Catch e As IndexOutOfRangeException\n                Throw New InvalidOperationException()\n            End Try\n        End Get\n    End Property\nEnd Class\n\nClass App\n    Shared Sub Main()\n        Dim peopleCollection As People = New People(3)\n        peopleCollection.Add(&quot;John&quot;, &quot;Smith&quot;)\n        peopleCollection.Add(&quot;Jim&quot;, &quot;Johnson&quot;)\n        peopleCollection.Add(&quot;Sue&quot;, &quot;Rabon&quot;)\n\n        Console.WriteLine(&quot;Displaying the entries in peopleCollection:&quot;)\n        Dim de As DictionaryEntry\n        For Each de In peopleCollection\n            Console.WriteLine(&quot;{0} {1}&quot;, de.Key, de.Value)\n        Next\n\n        Console.WriteLine()\n        Console.WriteLine(&quot;Displaying the entries in the modified peopleCollection:&quot;)\n        &#39;peopleCollection(&quot;Jim&quot;) = &quot;Jackson&quot;\n        peopleCollection.Remove(&quot;Sue&quot;)\n        peopleCollection.Insert(0, &quot;Fred&quot;, &quot;Anderson&quot;)\n\n        For Each de In peopleCollection\n            Console.WriteLine(&quot;{0} {1}&quot;, de.Key, de.Value)\n        Next\n    End Sub\nEnd Class\n&#39; This code produces output similar to the following:\n&#39; \n&#39; Displaying the entries in peopleCollection:\n&#39; John Smith\n&#39; Jim Johnson\n&#39; Sue Rabon\n&#39; \n&#39; Displaying the entries in the modified peopleCollection:\n&#39; Fred Anderson\n&#39; John Smith\n&#39; Jim Jackson\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>IOrderedDictionary elements can be accessed either with the key or with the index.  </p>\n<p> Each element is a key/value pair stored in a <a class=\"xref\" href=\"system.collections.dictionaryentry\" data-linktype=\"relative-path\">DictionaryEntry</a> structure.  </p>\n<p> Each pair must have a unique key that is not <code>null</code>, but the value can be <code>null</code> and does not have to be unique. The IOrderedDictionary interface allows the contained keys and values to be enumerated, but it does not imply any particular sort order.  </p>\n<p> The <code>foreach</code> statement of the C# language (<code>For Each</code> in Visual Basic) returns an object of the type of the elements in the collection. Because each element of the <a class=\"xref\" href=\"system.collections.idictionary\" data-linktype=\"relative-path\">IDictionary</a> is a key/value pair, the element type is not the type of the key or the type of the value. Instead, the element type is <a class=\"xref\" href=\"system.collections.dictionaryentry\" data-linktype=\"relative-path\">DictionaryEntry</a>, as the following example shows.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Collections.Specialized.IOrderedDictionary_Implementation#03\">foreach (DictionaryEntry de in myOrderedDictionary)\n{\n    //...\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Collections.Specialized.IOrderedDictionary_Implementation#03\">for each (DictionaryEntry de in myOrderedDictionary)\n{\n    //...\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Collections.Specialized.IOrderedDictionary_Implementation#03\">For Each de In myOrderedDictionary\n    &#39;...\nNext\n</code></pre><p> The <code>foreach</code> statement is a wrapper around the enumerator, which allows only reading from, not writing to, the collection.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Properties\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_Specialized_IOrderedDictionary_Item_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_Specialized_IOrderedDictionary_Item_System_Int32_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Item(Int32)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets or sets the element at the specified index.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public object this[int index] { get; set; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>index</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The zero-based index of the element to get or set.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The element at the specified index.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>index</code> is less than 0.  </p>\n<p> -or-  </p>\n<p> <code>index</code> is equal to or greater than <span class=\"xref\">stem.Collections.ICollection.Count*</span>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p><a class=\"xref\" href=\"system.collections.specialized.iordereddictionary\" data-linktype=\"relative-path\">IOrderedDictionary</a> accepts <code>null</code> as a valid value and allows duplicate elements.  </p>\n<p> The C# language uses the  keyword to define the indexers instead of implementing the Item property. Visual Basic implements Item as a default property, which provides the same indexing functionality.  </p>\n<p> This property allows you to access a specific element in the collection by using the following syntax:  </p>\n<pre><code class=\"lang-cs\" name=\"System.Collections.Specialized.IOrderedDictionary_Implementation#04\">obj = myOrderedDictionary[index];\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Collections.Specialized.IOrderedDictionary_Implementation#04\">obj = myOrderedDictionary[index];\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Collections.Specialized.IOrderedDictionary_Implementation#04\">obj = myOrderedDictionary(index)\n</code></pre>\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Methods\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_Specialized_IOrderedDictionary_GetEnumerator_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_Specialized_IOrderedDictionary_GetEnumerator\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">GetEnumerator()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Returns an enumerator that iterates through the <a class=\"xref\" href=\"system.collections.specialized.iordereddictionary\" data-linktype=\"relative-path\">IOrderedDictionary</a> collection.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Collections.IDictionaryEnumerator GetEnumerator ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.idictionaryenumerator\" data-linktype=\"relative-path\">IDictionaryEnumerator</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>An <a class=\"xref\" href=\"system.collections.idictionaryenumerator\" data-linktype=\"relative-path\">IDictionaryEnumerator</a> for the entire <a class=\"xref\" href=\"system.collections.specialized.iordereddictionary\" data-linktype=\"relative-path\">IOrderedDictionary</a> collection.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>[Visual Basic, C#]  </p>\n<p> The <code>foreach</code> statement of the C# language (<code>for each</code> in Visual Basic) hides the complexity of the enumerators.  Therefore, using <code>foreach</code> is recommended instead of directly manipulating the enumerator.  </p>\n<p> Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.  </p>\n<p> Initially, the enumerator is positioned before the first element in the collection. <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Reset_\" data-linktype=\"relative-path\">Reset</a> also brings the enumerator back to this position.  At this position, the <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Current_\" data-linktype=\"relative-path\">Current</a> property is undefined. Therefore, you must call <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> to advance the enumerator to the first element of the collection before reading the value of <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Current_\" data-linktype=\"relative-path\">Current</a>.  </p>\n<p> <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Current_\" data-linktype=\"relative-path\">Current</a> returns the same object until either <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> or <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Reset_\" data-linktype=\"relative-path\">Reset</a> is called. <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> sets <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Current_\" data-linktype=\"relative-path\">Current</a> to the next element.  </p>\n<p> If <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> passes the end of the collection, the enumerator is positioned after the last element in the collection and <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> returns <code>false</code>. When the enumerator is at this position, subsequent calls to <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> also return <code>false</code>. If the last call to <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a> returned <code>false</code>, <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Current_\" data-linktype=\"relative-path\">Current</a> is undefined. To set <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Current_\" data-linktype=\"relative-path\">Current</a> to the first element of the collection again, you can call <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_Reset_\" data-linktype=\"relative-path\">Reset</a> followed by <a class=\"xref\" href=\"system.collections.ienumerator#System_Collections_IEnumerator_MoveNext_\" data-linktype=\"relative-path\">MoveNext</a>.  </p>\n<p> An enumerator remains valid as long as the collection remains unchanged. If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.  </p>\n<p> The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.  To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.  To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_Specialized_IOrderedDictionary_Insert_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_Specialized_IOrderedDictionary_Insert_System_Int32_System_Object_System_Object_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Insert(Int32, Object, Object)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Inserts a key/value pair into the collection at the specified index.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void Insert (int index, object key, object value);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>index</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The zero-based index at which the key/value pair should be inserted.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>key</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The object to use as the key of the element to add.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The object to use as the value of the element to add.  The value can be <code>null</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>index</code> is less than 0.  </p>\n<p> -or-  </p>\n<p> <code>index</code> is greater than <span class=\"xref\">stem.Collections.ICollection.Count*</span>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>key</code> is <code>null</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>An element with the same key already exists in the <a class=\"xref\" href=\"system.collections.specialized.iordereddictionary\" data-linktype=\"relative-path\">IOrderedDictionary</a> collection.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <a class=\"xref\" href=\"system.collections.specialized.iordereddictionary\" data-linktype=\"relative-path\">IOrderedDictionary</a> collection is read-only.  </p>\n<p> -or-  </p>\n<p> The <a class=\"xref\" href=\"system.collections.specialized.iordereddictionary\" data-linktype=\"relative-path\">IOrderedDictionary</a> collection has a fixed size.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p><a class=\"xref\" href=\"system.collections.specialized.iordereddictionary\" data-linktype=\"relative-path\">IOrderedDictionary</a> accepts <code>null</code> as a valid value and allows duplicate elements.  </p>\n<p> If the <code>index</code> parameter is equal to <a class=\"xref\" href=\"system.collections.icollection#System_Collections_ICollection_Count_\" data-linktype=\"relative-path\">Count</a>, the <code>value</code> parameter is added to the end of the <a class=\"xref\" href=\"system.collections.specialized.iordereddictionary\" data-linktype=\"relative-path\">IOrderedDictionary</a> collection.  </p>\n<p> In collections of contiguous elements, such as lists, the elements that follow the insertion point move down to accommodate the new element. If the collection is indexed, the indexes of the elements that are moved are also updated. This behavior does not apply to collections where elements are conceptually grouped together, such as a hash table.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_Specialized_IOrderedDictionary_RemoveAt_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_Specialized_IOrderedDictionary_RemoveAt_System_Int32_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">RemoveAt(Int32)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Removes the element at the specified index.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void RemoveAt (int index);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>index</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The zero-based index of the element to remove.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>index</code> is less than 0.  </p>\n<p> -or-  </p>\n<p> <code>index</code> is equal to or greater than <span class=\"xref\">stem.Collections.ICollection.Count*</span>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <a class=\"xref\" href=\"system.collections.specialized.iordereddictionary\" data-linktype=\"relative-path\">IOrderedDictionary</a> collection is read-only.  </p>\n<p> -or-  </p>\n<p> The <a class=\"xref\" href=\"system.collections.specialized.iordereddictionary\" data-linktype=\"relative-path\">IOrderedDictionary</a> collection has a fixed size.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>In collections of contiguous elements, such as lists, the elements that follow the removed element move up to occupy the vacated spot. If the collection is indexed, the indexes of the elements that are moved are also updated. This behavior does not apply to collections where elements are conceptually grouped together, such as a hash table.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Collections.Specialized.IOrderedDictionary.yml\">\r\n<meta name=\"APIName\" content=\"System.Collections.Specialized.IOrderedDictionary\">\r\n<meta name=\"APIName\" content=\"System.Collections.Specialized.IOrderedDictionary.GetEnumerator\">\r\n<meta name=\"APIName\" content=\"System.Collections.Specialized.IOrderedDictionary.Insert\">\r\n<meta name=\"APIName\" content=\"System.Collections.Specialized.IOrderedDictionary.Item\">\r\n<meta name=\"APIName\" content=\"System.Collections.Specialized.IOrderedDictionary.RemoveAt\">\r\n<meta name=\"APILocation\" content=\"System.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-04-01 05:59 PM\">\r\n<meta name=\"document_id\" content=\"c0a39d0e-af5f-47ea-20cf-153763fc4b52\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Represents an indexed collection of key/value pairs.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.collections.specialized/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Collections.Specialized.IOrderedDictionary\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","uhfHeaderId":"MSDocsHeader-DotNet","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Collections.Specialized.IOrderedDictionary.yml","open_to_public_contributors":false,"api_name":["System.Collections.Specialized.IOrderedDictionary","System.Collections.Specialized.IOrderedDictionary.GetEnumerator","System.Collections.Specialized.IOrderedDictionary.Insert","System.Collections.Specialized.IOrderedDictionary.Item","System.Collections.Specialized.IOrderedDictionary.RemoveAt"],"api_location":["System.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Collections.Specialized.IOrderedDictionary","System::Collections::Specialized::IOrderedDictionary","System.Collections.Specialized.IOrderedDictionary.GetEnumerator","System::Collections::Specialized::IOrderedDictionary::GetEnumerator","System.Collections.Specialized.IOrderedDictionary.Insert","System::Collections::Specialized::IOrderedDictionary::Insert","System.Collections.Specialized.IOrderedDictionary.Item","System::Collections::Specialized::IOrderedDictionary::Item","System.Collections.Specialized.IOrderedDictionary.RemoveAt","System::Collections::Specialized::IOrderedDictionary::RemoveAt"],"dev_langs":["csharp"],"updated_at":"2017-04-01 05:59 PM","document_id":"c0a39d0e-af5f-47ea-20cf-153763fc4b52","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Collections.Specialized/IOrderedDictionary.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"IOrderedDictionary interface | Microsoft Docs","_op_ogTitle":"IOrderedDictionary interface","description":"Represents an indexed collection of key/value pairs.\n","toc_asset_id":"api/_splitted/System.Collections.Specialized/toc.json","toc_rel":"_splitted/System.Collections.Specialized/toc.json","source_url":"","ms.assetid":"System.Collections.Specialized.IOrderedDictionary","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.collections.specialized.iordereddictionary","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.collections.specialized.iordereddictionary","fileRelativePath":"api/System.Collections.Specialized.IOrderedDictionary.html"},"themesRelativePathToOutputRoot":"_themes/"}