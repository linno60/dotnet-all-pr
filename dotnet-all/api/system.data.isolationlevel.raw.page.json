{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">IsolationLevel</span>\r\n      Enum\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Specifies the transaction locking behavior for the connection.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\r\n  \t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">public enum IsolationLevel</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.valuetype\" data-linktype=\"relative-path\">ValueType</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.enum\" data-linktype=\"relative-path\">Enum</a></span></div><span class=\"lang-csharp\">IsolationLevel</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>This application demonstrates how to use IsolationLevel in <a class=\"xref\" href=\"system.data.common.dbtransaction\" data-linktype=\"relative-path\">DbTransaction</a>. The sample will demonstrate which of the following behaviors are allowed in the different isolation levels:  </p>\n<ul>\n<li><p>Dirty reads.  </p>\n</li>\n<li><p>Non-repeatable reads.  </p>\n</li>\n<li><p>Phantoms.  </p>\n</li>\n</ul>\n<p> This application will execute in the following isolation levels:  </p>\n<ul>\n<li><p>ReadUncommitted  </p>\n</li>\n<li><p>ReadCommitted  </p>\n</li>\n<li><p>RepeatableRead  </p>\n</li>\n<li><p>Serializable  </p>\n</li>\n<li><p>Snapshot  </p>\n</li>\n</ul>\n<p> The PhantomReadThreads class demonstrates if the specific transaction allows the Phantom Read behavior. If the transaction allows the behavior, the threads will operate in the following order:  </p>\n<ul>\n<li><p>In first thread, select the products(All).  </p>\n</li>\n<li><p>In the second thread, insert a new product.  </p>\n</li>\n<li><p>Commit the transaction in second thread.  </p>\n</li>\n<li><p>Select the products again.  </p>\n</li>\n<li><p>Commit the transaction in first thread.  </p>\n</li>\n</ul>\n<p> If the transaction allows the behavior, the two Select operations will get the different results.  </p>\n<p> The NonrepeatableReadThreads class demonstrates if the specific transaction allows the Nonrepeatable Read behavior. If the transaction allows the behavior, the threads will operate in the following order:  </p>\n<ul>\n<li><p>In first thread, select the product(ProductId=1).  </p>\n</li>\n<li><p>In the second thread, update the Quantity value(ProductId=1).  </p>\n</li>\n<li><p>Commit the transaction in second thread.  </p>\n</li>\n<li><p>Select the product again.  </p>\n</li>\n<li><p>Commit the transaction in first thread.  </p>\n</li>\n</ul>\n<p> If the transaction allows the behavior, the two Select operations will get the different results.  </p>\n<p> The ExchangeValuesThreads class demonstrates the difference between the Serializable and Snapshot transaction. For the the Serializable transaction, threads will operate in the following order:  </p>\n<ul>\n<li><p>In first thread, get the Price of product(ProductId=2) and store in the variable.  </p>\n</li>\n<li><p>In first thread, update the Price of product(ProductId=1) with the price of product(ProductId=2).  </p>\n</li>\n<li><p>Commit the transaction in first thread.  </p>\n</li>\n<li><p>In second thread, get the Price of product(ProductId=1) and store in the variable.  </p>\n</li>\n<li><p>In second thread, update the Price of product(ProductId=2) with the price of product(ProductId=1).  </p>\n</li>\n<li><p>Commit the transaction in second thread.  </p>\n</li>\n</ul>\n<p> Now the values of the Price(ProductId=1 and ProductId=2) are as same as the original Price of Product(ProductId=2).  </p>\n<p> For the Snapshot transaction, threads will operate in the following order:  </p>\n<ul>\n<li><p>In first thread, get the Price of product(ProductId=2) and store in the variable;  </p>\n</li>\n<li><p>In first thread, update the Price of product(ProductId=1) with the price of product(ProductId=2).  </p>\n</li>\n<li><p>In second thread, get the Price of product(ProductId=1) from the snapshot and store in the variable.  </p>\n</li>\n<li><p>In second thread, update the Price of product(ProductId=2) with the price of product(ProductId=1).  </p>\n</li>\n<li><p>Commit the transaction in second thread.  </p>\n</li>\n<li><p>Commit the transaction in first thread.  </p>\n</li>\n</ul>\n<p> Now exchange the Price of products(ProductId=1 and ProductId=2).  </p>\n<p> The DirtyReadThreads class demonstrates if the specific transaction allows the Dirty Read behavior. If the transaction allows the behavior, the threads will operate in the following order:  </p>\n<ul>\n<li><p>In first thread, begin a transaction and add the Quantity value(ProductId=1).  </p>\n</li>\n<li><p>In the second thread, read the Quantity value and add the value again.  </p>\n</li>\n<li><p>Commit the transaction in second thread.  </p>\n</li>\n<li><p>Roll back the transaction in first thread.  </p>\n</li>\n</ul>\n<p> If the transaction allows the behavior, the Quantity value will be added twice.  </p>\n<p> C# and Visual Basic projects with this code sample can be found on <a href=\"http://code.msdn.microsoft.com/site/search?query=How%20to%20use%20IsolationLevel%20Enumeration%20in%20DbTransaction&amp;f%5B0%5D.Value=How%20to%20use%20IsolationLevel%20Enumeration%20in%20DbTransaction&amp;f%5B0%5D.Type=SearchText&amp;ac=4\" data-linktype=\"external\">Developer Code Samples</a>.  </p>\n<pre><code class=\"lang-cs\" name=\"system_data_IsolationLevel#1\">using System;\nusing System.Data.SqlClient;\nusing System.Data;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace CSDataIsolationLevel {\n\n   // Use the delegate to call the different threads.\n   public delegate void AsyncAccessDatabase(String connString, IsolationLevel level);\n\n   static class DirtyReadThreads {\n      public static void DirtyReadFirstThread(String connStrig, IsolationLevel level) {\n         Console.WriteLine(&quot;Begin the DirtyReadFirstThread.....&quot;);\n\n         using (SqlConnection conn = new SqlConnection(connStrig)) {\n            String cmdText = @&quot;Use DbDataIsolationLevel; \n\n                    Update dbo.Products set Quantity=Quantity+100 where ProductId=1;\n                    WaitFor Delay &#39;00:00:06&#39;;&quot;;\n\n            conn.Open();\n\n            using (SqlTransaction tran = conn.BeginTransaction(level, &quot;DirtyReadFirst&quot;)) {\n               using (SqlCommand command = new SqlCommand(cmdText, conn)) {\n                  command.Transaction = tran;\n                  command.ExecuteNonQuery();\n               }\n\n               if (tran != null)\n                  tran.Rollback();\n            }\n         }\n\n         Console.WriteLine(&quot;Exit from the DirtyReadFirstThread.....&quot;);\n      }\n\n      public static void DirtyReadSecondThread(String connStrig, IsolationLevel level) {\n         Console.WriteLine(&quot;Begin the DirtyReadSecondThread.....&quot;);\n\n         using (SqlConnection conn = new SqlConnection(connStrig)) {\n            String cmdText = @&quot;Use DbDataIsolationLevel;\n\n                    WaitFor Delay &#39;00:00:03&#39;; \n\n                    Declare @qty int;\n                    select @qty=Quantity from dbo.Products where ProductId=1;\n\n                    Update dbo.Products set Quantity=@qty+100 where ProductId=1;&quot;;\n\n            conn.Open();\n\n            using (SqlTransaction tran = conn.BeginTransaction(level, &quot;DirtyReadSecond&quot;)) {\n               using (SqlCommand command = new SqlCommand(cmdText, conn)) {\n                  command.Transaction = tran;\n                  command.ExecuteNonQuery();\n               }\n               tran.Commit();\n            }\n         }\n\n         Console.WriteLine(&quot;Exit from the DirtyReadSecondThread.....&quot;);\n      }\n   }\n\n\n   static class NonrepeatableReadThreads {\n      public static void NonrepeatableReadFirstThread(String connStrig, IsolationLevel level) {\n         Console.WriteLine(&quot;Begin the NonrepeatableReadFirstThread.....&quot;);\n\n         using (SqlConnection conn = new SqlConnection(connStrig)) {\n            String cmdText = @&quot;Use DbDataIsolationLevel; \n\n                    Select ProductId,ProductName,Quantity,Price\n                    from dbo.Products\n                    where ProductId=1\n\n                    WaitFor Delay &#39;00:00:06&#39;;\n\n                    Select ProductId,ProductName,Quantity,Price\n                    from dbo.Products\n                    where ProductId=1&quot;;\n\n            conn.Open();\n\n            using (SqlTransaction tran = conn.BeginTransaction(level, &quot;NonrepeatableReadFirst&quot;)) {\n               using (SqlCommand command = new SqlCommand(cmdText, conn)) {\n                  command.Transaction = tran;\n\n                  using (SqlDataReader reader = command.ExecuteReader()) {\n                     Boolean isFirstReader = true;\n                     do {\n                        Console.WriteLine(&quot;It&#39;s the result of {0} read:&quot;, isFirstReader ? &quot;first&quot; : &quot;second&quot;);\n                        TransactionIsolationLevels.DisplayData(reader);\n                        isFirstReader = !isFirstReader;\n                     } while (reader.NextResult() &amp;&amp; !isFirstReader);\n                  }\n               }\n\n               tran.Commit();\n            }\n         }\n\n         Console.WriteLine(&quot;Exit from the NonrepeatableReadFirstThread.....&quot;);\n      }\n\n      public static void NonrepeatableReadSecondThread(String connStrig, IsolationLevel level) {\n         Console.WriteLine(&quot;Begin the NonrepeatableReadSecondThread.....&quot;);\n\n         using (SqlConnection conn = new SqlConnection(connStrig)) {\n            String cmdText = @&quot;Use DbDataIsolationLevel;\n\n                    WaitFor Delay &#39;00:00:03&#39;; \n\n                    Update dbo.Products set Quantity=Quantity+100 where ProductId=1;&quot;;\n\n            conn.Open();\n\n            using (SqlTransaction tran = conn.BeginTransaction(level, &quot;NonrepeatableReadSecond&quot;)) {\n               using (SqlCommand command = new SqlCommand(cmdText, conn)) {\n                  command.Transaction = tran;\n                  command.ExecuteNonQuery();\n               }\n               tran.Commit();\n            }\n         }\n\n         Console.WriteLine(&quot;Exit from the NonrepeatableReadSecondThread.....&quot;);\n      }\n   }\n\n\n   static class PhantomReadThreads {\n      public static void PhantomReadFirstThread(String connStrig, IsolationLevel level) {\n         Console.WriteLine(&quot;Begin the PhantomReadFirstThread.....&quot;);\n\n         using (SqlConnection conn = new SqlConnection(connStrig)) {\n            String cmdText = @&quot;Use DbDataIsolationLevel; \n\n                    Select ProductId,ProductName,Quantity,Price\n                    from dbo.Products\n\n                    WaitFor Delay &#39;00:00:06&#39;;\n\n                    Select ProductId,ProductName,Quantity,Price\n                    from dbo.Products&quot;;\n\n            conn.Open();\n\n            using (SqlTransaction tran = conn.BeginTransaction(level, &quot;PhantomReadFirst&quot;)) {\n               using (SqlCommand command = new SqlCommand(cmdText, conn)) {\n                  command.Transaction = tran;\n\n                  using (SqlDataReader reader = command.ExecuteReader()) {\n                     Boolean isFirstReader = true;\n                     do {\n                        Console.WriteLine(&quot;It&#39;s the result of {0} read:&quot;, isFirstReader ? &quot;first&quot; : &quot;second&quot;);\n\n                        TransactionIsolationLevels.DisplayData(reader);\n\n                        isFirstReader = !isFirstReader;\n                     } while (reader.NextResult() &amp;&amp; !isFirstReader);\n                  }\n               }\n\n               tran.Commit();\n            }\n         }\n         Console.WriteLine(&quot;Exit from the PhantomReadFirstThread.....&quot;);\n      }\n\n      public static void PhantomReadSecondThread(String connStrig, IsolationLevel level) {\n         Console.WriteLine(&quot;Begin the PhantomReadSecondThread.....&quot;);\n\n         using (SqlConnection conn = new SqlConnection(connStrig)) {\n            String cmdText = @&quot;Use DbDataIsolationLevel;\n\n                    WaitFor Delay &#39;00:00:03&#39;; \n\n                    INSERT [dbo].[Products] ([ProductName], [Quantity], [Price]) \n                    VALUES (N&#39;White Bike&#39;, 843, 1349.00)&quot;;\n\n            conn.Open();\n\n            using (SqlTransaction tran = conn.BeginTransaction(level, &quot;PhantomReadSecond&quot;)) {\n               using (SqlCommand command = new SqlCommand(cmdText, conn)) {\n                  command.Transaction = tran;\n                  command.ExecuteNonQuery();\n               }\n               tran.Commit();\n            }\n         }\n\n         Console.WriteLine(&quot;Exit from the PhantomReadSecondThread.....&quot;);\n      }\n   }\n\n\n   // Demonstrates if the specific transaction allows the following behaviors:\n   // 1. Dirty reads;\n   // 2. Non-repeatable reads;\n   // 3. Phantoms.\n   static class TransactionIsolationLevels {\n      public static void DemonstrateIsolationLevel(String connString, IsolationLevel level) {\n         // Before connect the database, recreate the table.\n         OperateDatabase.CreateTable(connString);\n         DemonstrateIsolationLevel(connString, level, DirtyReadThreads.DirtyReadFirstThread, DirtyReadThreads.DirtyReadSecondThread);\n         DisplayData(connString);\n         Console.WriteLine();\n\n         OperateDatabase.CreateTable(connString);\n         DemonstrateIsolationLevel(connString, level, NonrepeatableReadThreads.NonrepeatableReadFirstThread, NonrepeatableReadThreads.NonrepeatableReadSecondThread);\n         Console.WriteLine();\n\n         OperateDatabase.CreateTable(connString);\n         DemonstrateIsolationLevel(connString, level, PhantomReadThreads.PhantomReadFirstThread, PhantomReadThreads.PhantomReadSecondThread);\n         Console.WriteLine();\n      }\n\n      // Demonstrates if the specific transaction allows the specific behaviors.\n      public static void DemonstrateIsolationLevel(String connString, IsolationLevel level,\n          AsyncAccessDatabase firstThread, AsyncAccessDatabase secondThread) {\n         Task[] tasks ={\n                            Task.Factory.StartNew(()=&gt;firstThread(connString, level)),\n                            Task.Factory.StartNew(()=&gt;secondThread(connString, level))\n                        };\n\n         Task.WaitAll(tasks);\n      }\n\n      static class ExchangeValuesThreads {\n         public static void ExchangeValuesFirstThread(String connStrig, IsolationLevel level) {\n            Console.WriteLine(&quot;Begin the ExchangeValuesFirstThread.....&quot;);\n\n            using (SqlConnection conn = new SqlConnection(connStrig)) {\n               String cmdText = @&quot;Use DbDataIsolationLevel;\n\n                    Declare @price money;\n                    select @price=Price from dbo.Products where ProductId=2;\n\n                    Update dbo.Products set Price=@price where ProductId=1;\n\n                    WaitFor Delay &#39;00:00:06&#39;; &quot;;\n\n               conn.Open();\n               using (SqlTransaction tran = conn.BeginTransaction(level, &quot;ExchangeValuesFirst&quot;)) {\n\n                  using (SqlCommand command = new SqlCommand(cmdText, conn)) {\n                     command.Transaction = tran;\n                     command.ExecuteNonQuery();\n                  }\n\n                  tran.Commit();\n               }\n            }\n\n            Console.WriteLine(&quot;Exit from the ExchangeValuesFirstThread.....&quot;);\n         }\n\n         public static void ExchangeValuesSecondThread(String connStrig, IsolationLevel level) {\n            Console.WriteLine(&quot;Begin the ExchangeValuesSecondThread.....&quot;);\n\n            using (SqlConnection conn = new SqlConnection(connStrig)) {\n               String cmdText = @&quot;Use DbDataIsolationLevel;\n\n                    WaitFor Delay &#39;00:00:03&#39;; \n\n                    Declare @price money;\n                    select @price=Price from dbo.Products where ProductId=1;\n\n                    Update dbo.Products set Price=@price where ProductId=2;&quot;;\n\n               conn.Open();\n\n               using (SqlTransaction tran = conn.BeginTransaction(level, &quot;ExchangeValuesSecond&quot;)) {\n                  using (SqlCommand command = new SqlCommand(cmdText, conn)) {\n                     command.Transaction = tran;\n                     command.ExecuteNonQuery();\n                  }\n                  tran.Commit();\n               }\n            }\n\n            Console.WriteLine(&quot;Exit from the ExchangeValuesSecondThread.....&quot;);\n         }\n      }\n\n      // Demonstrates the difference between the Serializable and Snapshot transaction\n      public static void DemonstrateBetweenSnapshotAndSerializable(String connString) {\n         OperateDatabase.CreateTable(connString);\n\n         Console.WriteLine(&quot;Exchange Vaules in the Snapshot transaction:&quot;);\n         DemonstrateIsolationLevel(connString, IsolationLevel.Snapshot,\n             ExchangeValuesThreads.ExchangeValuesFirstThread,\n             ExchangeValuesThreads.ExchangeValuesSecondThread);\n         DisplayData(connString);\n         Console.WriteLine();\n\n         Console.WriteLine(&quot;Cannot Exchange Vaules in the Serializable transaction:&quot;);\n         OperateDatabase.CreateTable(connString);\n         DemonstrateIsolationLevel(connString, IsolationLevel.Serializable,\n             ExchangeValuesThreads.ExchangeValuesFirstThread,\n             ExchangeValuesThreads.ExchangeValuesSecondThread);\n         DisplayData(connString);\n      }\n\n      public static void DisplayData(String connString) {\n         using (SqlConnection conn = new SqlConnection(connString)) {\n            String cmdText = @&quot;Use DbDataIsolationLevel; \n\n                    Select ProductId,ProductName,Quantity,Price\n                    from dbo.Products&quot;;\n\n            conn.Open();\n\n            using (SqlCommand command = new SqlCommand(cmdText, conn)) {\n               using (SqlDataReader reader = command.ExecuteReader()) {\n                  DisplayData(reader);\n               }\n            }\n         }\n      }\n\n      public static void DisplayData(SqlDataReader reader) {\n         Boolean isFirst = true;\n\n         while (reader.Read()) {\n            if (isFirst) {\n               isFirst = false;\n\n               for (int i = 0; i &lt; reader.FieldCount; i++)\n                  Console.Write(&quot;{0,-12}   &quot;, reader.GetName(i));\n               Console.WriteLine();\n            }\n\n            for (int i = 0; i &lt; reader.FieldCount; i++)\n               Console.Write(&quot;{0,-12}   &quot;, reader[i]);\n            Console.WriteLine();\n         }\n      }\n   }\n\n   // This class includes database operations. If there&#39;s no database &#39;DbDataIsolationLevel&#39;, create the database.\n   static class OperateDatabase {\n      public static Boolean CreateDatabase(String connString) {\n         using (SqlConnection conn = new SqlConnection(connString)) {\n            String cmdText = @&quot;Use Master;\n\n                                     if Db_Id(&#39;DbDataIsolationLevel&#39;) is null\n                                      create Database [DbDataIsolationLevel];&quot;;\n\n            using (SqlCommand command = new SqlCommand(cmdText, conn)) {\n               conn.Open();\n               command.ExecuteNonQuery();\n            }\n\n            Console.WriteLine(&quot;Create the Database &#39;DbDataIsolationLevel&#39;&quot;);\n         }\n\n         return true;\n      }\n\n\n      // If there&#39;s no table [dbo].[Products] in DbDataIsolationLevel, create the table; or recreate it.\n      public static Boolean CreateTable(String connString) {\n         using (SqlConnection conn = new SqlConnection(connString)) {\n            String cmdText = @&quot;Use DbDataIsolationLevel\n\n                                    if Object_ID(&#39;[dbo].[Products]&#39;) is not null\n                                    drop table [dbo].[Products]\n\n                                    Create Table [dbo].[Products]\n                                    (\n                                    [ProductId] int IDENTITY(1,1) primary key,\n                                    [ProductName] NVarchar(100) not null,\n                                    [Quantity] int null,\n                                    [Price] money null\n                                    )&quot;;\n\n            using (SqlCommand command = new SqlCommand(cmdText, conn)) {\n               conn.Open();\n               command.ExecuteNonQuery();\n            }\n         }\n\n         return InsertRows(connString);\n      }\n\n      // Insert some rows into [dbo].[Products] table.\n      public static Boolean InsertRows(String connString) {\n         using (SqlConnection conn = new SqlConnection(connString)) {\n            String cmdText = @&quot;Use DbDataIsolationLevel\n\n                    INSERT [dbo].[Products] ([ProductName], [Quantity], [Price]) VALUES (N&#39;Blue Bike&#39;, 365,1075.00)\n                    INSERT [dbo].[Products] ([ProductName], [Quantity], [Price]) VALUES (N&#39;Red Bike&#39;, 159, 1299.00)\n                    INSERT [dbo].[Products] ([ProductName], [Quantity], [Price]) VALUES (N&#39;Black Bike&#39;, 638, 1159.00)&quot;;\n\n            using (SqlCommand command = new SqlCommand(cmdText, conn)) {\n               conn.Open();\n               command.ExecuteNonQuery();\n            }\n         }\n         return true;\n      }\n\n      // Turn on or off &#39;ALLOW_SNAPSHOT_ISOLATION&#39;\n      public static Boolean SetSnapshot(String connString, Boolean isOpen) {\n         using (SqlConnection conn = new SqlConnection(connString)) {\n            String cmdText = null;\n\n            if (isOpen)\n               cmdText = @&quot;ALTER DATABASE DbDataIsolationLevel SET ALLOW_SNAPSHOT_ISOLATION ON&quot;;\n            else\n               cmdText = @&quot;ALTER DATABASE DbDataIsolationLevel SET ALLOW_SNAPSHOT_ISOLATION OFF&quot;;\n\n            using (SqlCommand command = new SqlCommand(cmdText, conn)) {\n               conn.Open();\n               command.ExecuteNonQuery();\n            }\n         }\n\n         return true;\n      }\n   }\n   class Program {\n      static void Main(string[] args) {\n         String connString = &quot;Data Source=(local);Initial Catalog=master;Integrated Security=True;Asynchronous Processing=true;&quot;;\n\n         OperateDatabase.CreateDatabase(connString);\n         Console.WriteLine();\n\n         Console.WriteLine(&quot;Demonstrate the ReadUncommitted transaction: &quot;);\n         TransactionIsolationLevels.DemonstrateIsolationLevel(connString,\n             System.Data.IsolationLevel.ReadUncommitted);\n         Console.WriteLine(&quot;-----------------------------------------------&quot;);\n\n         Console.WriteLine(&quot;Demonstrate the ReadCommitted transaction: &quot;);\n         TransactionIsolationLevels.DemonstrateIsolationLevel(connString,\n             System.Data.IsolationLevel.ReadCommitted);\n         Console.WriteLine(&quot;-----------------------------------------------&quot;);\n\n         Console.WriteLine(&quot;Demonstrate the RepeatableRead transaction: &quot;);\n         TransactionIsolationLevels.DemonstrateIsolationLevel(connString,\n             System.Data.IsolationLevel.RepeatableRead);\n         Console.WriteLine(&quot;-----------------------------------------------&quot;);\n\n         Console.WriteLine(&quot;Demonstrate the Serializable transaction: &quot;);\n         TransactionIsolationLevels.DemonstrateIsolationLevel(connString,\n             System.Data.IsolationLevel.Serializable);\n         Console.WriteLine(&quot;-----------------------------------------------&quot;);\n\n         Console.WriteLine(&quot;Demonstrate the Snapshot transaction: &quot;);\n         OperateDatabase.SetSnapshot(connString, true);\n         TransactionIsolationLevels.DemonstrateIsolationLevel(connString,\n             System.Data.IsolationLevel.Snapshot);\n         Console.WriteLine(&quot;-----------------------------------------------&quot;);\n\n         Console.WriteLine(&quot;Demonstrate the difference between the Snapshot and Serializable transactions:&quot;);\n         TransactionIsolationLevels.DemonstrateBetweenSnapshotAndSerializable(connString);\n         OperateDatabase.SetSnapshot(connString, false);\n         Console.WriteLine();\n      }\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"system_data_IsolationLevel#1\">Imports System.Data.SqlClient\nImports System.Data\nImports System.Threading\nImports System.Threading.Tasks\n\nNamespace CSDataIsolationLevel\n\n   &#39; Use the delegate to call the different threads.\n   Public Delegate Sub AsyncAccessDatabase(connString As [String], level As IsolationLevel)\n\n   NotInheritable Class DirtyReadThreads\n      Private Sub New()\n      End Sub\n      Public Shared Sub DirtyReadFirstThread(connStrig As [String], level As IsolationLevel)\n         Console.WriteLine(&quot;Begin the DirtyReadFirstThread.....&quot;)\n\n         Using conn As New SqlConnection(connStrig)\n            Dim cmdText As [String] = &quot;Use DbDataIsolationLevel; &quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                &quot;Update dbo.Products set Quantity=Quantity+100 where ProductId=1;&quot; &amp; vbCr &amp; vbLf &amp;\n                &quot;WaitFor Delay &#39;00:00:06&#39;;&quot;\n\n            conn.Open()\n\n            Using tran As SqlTransaction = conn.BeginTransaction(level, &quot;DirtyReadFirst&quot;)\n               Using command As New SqlCommand(cmdText, conn)\n                  command.Transaction = tran\n                  command.ExecuteNonQuery()\n               End Using\n\n               If tran IsNot Nothing Then\n                  tran.Rollback()\n               End If\n            End Using\n         End Using\n\n         Console.WriteLine(&quot;Exit from the DirtyReadFirstThread.....&quot;)\n      End Sub\n\n      Public Shared Sub DirtyReadSecondThread(connStrig As [String], level As IsolationLevel)\n         Console.WriteLine(&quot;Begin the DirtyReadSecondThread.....&quot;)\n\n         Using conn As New SqlConnection(connStrig)\n            Dim cmdText As [String] = &quot;Use DbDataIsolationLevel;&quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                &quot;WaitFor Delay &#39;00:00:03&#39;; &quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                &quot;Declare @qty int;&quot; &amp; vbCr &amp; vbLf &amp;\n                &quot;select @qty=Quantity from dbo.Products where ProductId=1;&quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                &quot;Update dbo.Products set Quantity=@qty+100 where ProductId=1;&quot;\n\n            conn.Open()\n\n            Using tran As SqlTransaction = conn.BeginTransaction(level, &quot;DirtyReadSecond&quot;)\n               Using command As New SqlCommand(cmdText, conn)\n                  command.Transaction = tran\n                  command.ExecuteNonQuery()\n               End Using\n               tran.Commit()\n            End Using\n         End Using\n\n         Console.WriteLine(&quot;Exit from the DirtyReadSecondThread.....&quot;)\n      End Sub\n   End Class\n\n\n   NotInheritable Class NonrepeatableReadThreads\n      Private Sub New()\n      End Sub\n      Public Shared Sub NonrepeatableReadFirstThread(connStrig As [String], level As IsolationLevel)\n         Console.WriteLine(&quot;Begin the NonrepeatableReadFirstThread.....&quot;)\n\n         Using conn As New SqlConnection(connStrig)\n            Dim cmdText As [String] = &quot;Use DbDataIsolationLevel; &quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                &quot;Select ProductId,ProductName,Quantity,Price&quot; &amp; vbCr &amp; vbLf &amp;\n                &quot;from dbo.Products&quot; &amp; vbCr &amp; vbLf &amp;\n                &quot;where ProductId=1&quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                &quot;WaitFor Delay &#39;00:00:06&#39;;&quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                &quot;Select ProductId,ProductName,Quantity,Price&quot; &amp; vbCr &amp; vbLf &amp;\n                &quot;from dbo.Products&quot; &amp; vbCr &amp; vbLf &amp;\n                &quot;where ProductId=1&quot;\n\n            conn.Open()\n\n            Using tran As SqlTransaction = conn.BeginTransaction(level, &quot;NonrepeatableReadFirst&quot;)\n               Using command As New SqlCommand(cmdText, conn)\n                  command.Transaction = tran\n\n                  Using reader As SqlDataReader = command.ExecuteReader()\n                     Dim isFirstReader As [Boolean] = True\n                     Do\n                        Console.WriteLine(&quot;It&#39;s the result of {0} read:&quot;, If(isFirstReader, &quot;first&quot;, &quot;second&quot;))\n                        TransactionIsolationLevels.DisplayData(reader)\n                        isFirstReader = Not isFirstReader\n                     Loop While reader.NextResult() AndAlso Not isFirstReader\n                  End Using\n               End Using\n\n               tran.Commit()\n            End Using\n         End Using\n\n         Console.WriteLine(&quot;Exit from the NonrepeatableReadFirstThread.....&quot;)\n      End Sub\n\n      Public Shared Sub NonrepeatableReadSecondThread(connStrig As [String], level As IsolationLevel)\n         Console.WriteLine(&quot;Begin the NonrepeatableReadSecondThread.....&quot;)\n\n         Using conn As New SqlConnection(connStrig)\n            Dim cmdText As [String] = &quot;Use DbDataIsolationLevel;&quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                &quot;WaitFor Delay &#39;00:00:03&#39;; &quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                &quot;Update dbo.Products set Quantity=Quantity+100 where ProductId=1;&quot;\n\n            conn.Open()\n\n            Using tran As SqlTransaction = conn.BeginTransaction(level, &quot;NonrepeatableReadSecond&quot;)\n               Using command As New SqlCommand(cmdText, conn)\n                  command.Transaction = tran\n                  command.ExecuteNonQuery()\n               End Using\n               tran.Commit()\n            End Using\n         End Using\n\n         Console.WriteLine(&quot;Exit from the NonrepeatableReadSecondThread.....&quot;)\n      End Sub\n   End Class\n\n\n   NotInheritable Class PhantomReadThreads\n      Private Sub New()\n      End Sub\n      Public Shared Sub PhantomReadFirstThread(connStrig As [String], level As IsolationLevel)\n         Console.WriteLine(&quot;Begin the PhantomReadFirstThread.....&quot;)\n\n         Using conn As New SqlConnection(connStrig)\n            Dim cmdText As [String] = &quot;Use DbDataIsolationLevel; &quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                &quot;Select ProductId,ProductName,Quantity,Price&quot; &amp; vbCr &amp; vbLf &amp;\n                &quot;from dbo.Products&quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                &quot;WaitFor Delay &#39;00:00:06&#39;;&quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                &quot;Select ProductId,ProductName,Quantity,Price&quot; &amp; vbCr &amp; vbLf &amp;\n                &quot;from dbo.Products&quot;\n\n            conn.Open()\n\n            Using tran As SqlTransaction = conn.BeginTransaction(level, &quot;PhantomReadFirst&quot;)\n               Using command As New SqlCommand(cmdText, conn)\n                  command.Transaction = tran\n\n                  Using reader As SqlDataReader = command.ExecuteReader()\n                     Dim isFirstReader As [Boolean] = True\n                     Do\n                        Console.WriteLine(&quot;It&#39;s the result of {0} read:&quot;, If(isFirstReader, &quot;first&quot;, &quot;second&quot;))\n\n                        TransactionIsolationLevels.DisplayData(reader)\n\n                        isFirstReader = Not isFirstReader\n                     Loop While reader.NextResult() AndAlso Not isFirstReader\n                  End Using\n               End Using\n\n               tran.Commit()\n            End Using\n         End Using\n         Console.WriteLine(&quot;Exit from the PhantomReadFirstThread.....&quot;)\n      End Sub\n\n      Public Shared Sub PhantomReadSecondThread(connStrig As [String], level As IsolationLevel)\n         Console.WriteLine(&quot;Begin the PhantomReadSecondThread.....&quot;)\n\n         Using conn As New SqlConnection(connStrig)\n            Dim cmdText As [String] = &quot;Use DbDataIsolationLevel;&quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                &quot;WaitFor Delay &#39;00:00:03&#39;; &quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                &quot;INSERT [dbo].[Products] ([ProductName], [Quantity], [Price]) &quot; &amp; vbCr &amp; vbLf &amp;\n                &quot;VALUES (N&#39;White Bike&#39;, 843, 1349.00)&quot;\n\n            conn.Open()\n\n            Using tran As SqlTransaction = conn.BeginTransaction(level, &quot;PhantomReadSecond&quot;)\n               Using command As New SqlCommand(cmdText, conn)\n                  command.Transaction = tran\n                  command.ExecuteNonQuery()\n               End Using\n               tran.Commit()\n            End Using\n         End Using\n\n         Console.WriteLine(&quot;Exit from the PhantomReadSecondThread.....&quot;)\n      End Sub\n   End Class\n\n\n   &#39; Demonstrates if the specific transaction allows the following behaviors:\n   &#39; 1. Dirty reads;\n   &#39; 2. Non-repeatable reads;\n   &#39; 3. Phantoms.\n   NotInheritable Class TransactionIsolationLevels\n      Private Sub New()\n      End Sub\n      Public Shared Sub DemonstrateIsolationLevel(connString As [String], level As IsolationLevel)\n         &#39; Before connect the database, recreate the table.\n         OperateDatabase.CreateTable(connString)\n         DemonstrateIsolationLevel(connString, level, AddressOf DirtyReadThreads.DirtyReadFirstThread, AddressOf DirtyReadThreads.DirtyReadSecondThread)\n         DisplayData(connString)\n         Console.WriteLine()\n\n         OperateDatabase.CreateTable(connString)\n         DemonstrateIsolationLevel(connString, level, AddressOf NonrepeatableReadThreads.NonrepeatableReadFirstThread, AddressOf NonrepeatableReadThreads.NonrepeatableReadSecondThread)\n         Console.WriteLine()\n\n         OperateDatabase.CreateTable(connString)\n         DemonstrateIsolationLevel(connString, level, AddressOf PhantomReadThreads.PhantomReadFirstThread, AddressOf PhantomReadThreads.PhantomReadSecondThread)\n         Console.WriteLine()\n      End Sub\n\n      &#39; Demonstrates if the specific transaction allows the specific behaviors.\n      Public Shared Sub DemonstrateIsolationLevel(connString As [String], level As IsolationLevel, firstThread As AsyncAccessDatabase, secondThread As AsyncAccessDatabase)\n         &#39; Dim tasks As Task() = {Task.Factory.StartNew(Function() firstThread(connString, level)), Task.Factory.StartNew(Function() secondThread(connString, level))}\n\n         Dim tasks() As Task = {\n                         Task.Factory.StartNew(Sub() firstThread(connString, level)),\n                         Task.Factory.StartNew(Sub() secondThread(connString, level))\n                                        }\n\n         Task.WaitAll(tasks)\n      End Sub\n\n      Private NotInheritable Class ExchangeValuesThreads\n         Private Sub New()\n         End Sub\n         Public Shared Sub ExchangeValuesFirstThread(connStrig As [String], level As IsolationLevel)\n            Console.WriteLine(&quot;Begin the ExchangeValuesFirstThread.....&quot;)\n\n            Using conn As New SqlConnection(connStrig)\n               Dim cmdText As [String] = &quot;Use DbDataIsolationLevel;&quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                   &quot;Declare @price money;&quot; &amp; vbCr &amp; vbLf &amp;\n                   &quot;select @price=Price from dbo.Products where ProductId=2;&quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                   &quot;Update dbo.Products set Price=@price where ProductId=1;&quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                   &quot;WaitFor Delay &#39;00:00:06&#39;; &quot;\n\n               conn.Open()\n               Using tran As SqlTransaction = conn.BeginTransaction(level, &quot;ExchangeValuesFirst&quot;)\n\n                  Using command As New SqlCommand(cmdText, conn)\n                     command.Transaction = tran\n                     command.ExecuteNonQuery()\n                  End Using\n\n                  tran.Commit()\n               End Using\n            End Using\n\n            Console.WriteLine(&quot;Exit from the ExchangeValuesFirstThread.....&quot;)\n         End Sub\n\n         Public Shared Sub ExchangeValuesSecondThread(connStrig As [String], level As IsolationLevel)\n            Console.WriteLine(&quot;Begin the ExchangeValuesSecondThread.....&quot;)\n\n            Using conn As New SqlConnection(connStrig)\n               Dim cmdText As [String] = &quot;Use DbDataIsolationLevel;&quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                   &quot;WaitFor Delay &#39;00:00:03&#39;; &quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                   &quot;Declare @price money;&quot; &amp; vbCr &amp; vbLf &amp;\n                   &quot;select @price=Price from dbo.Products where ProductId=1;&quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                   &quot;Update dbo.Products set Price=@price where ProductId=2;&quot;\n\n               conn.Open()\n\n               Using tran As SqlTransaction = conn.BeginTransaction(level, &quot;ExchangeValuesSecond&quot;)\n                  Using command As New SqlCommand(cmdText, conn)\n                     command.Transaction = tran\n                     command.ExecuteNonQuery()\n                  End Using\n                  tran.Commit()\n               End Using\n            End Using\n\n            Console.WriteLine(&quot;Exit from the ExchangeValuesSecondThread.....&quot;)\n         End Sub\n      End Class\n\n      &#39; Demonstrates the difference between the Serializable and Snapshot transaction\n      Public Shared Sub DemonstrateBetweenSnapshotAndSerializable(connString As [String])\n         OperateDatabase.CreateTable(connString)\n\n         Console.WriteLine(&quot;Exchange Vaules in the Snapshot transaction:&quot;)\n         DemonstrateIsolationLevel(connString, IsolationLevel.Snapshot, AddressOf ExchangeValuesThreads.ExchangeValuesFirstThread, AddressOf ExchangeValuesThreads.ExchangeValuesSecondThread)\n         DisplayData(connString)\n         Console.WriteLine()\n\n         Console.WriteLine(&quot;Cannot Exchange Vaules in the Serializable transaction:&quot;)\n         OperateDatabase.CreateTable(connString)\n         DemonstrateIsolationLevel(connString, IsolationLevel.Serializable, AddressOf ExchangeValuesThreads.ExchangeValuesFirstThread, AddressOf ExchangeValuesThreads.ExchangeValuesSecondThread)\n         DisplayData(connString)\n      End Sub\n\n      Public Shared Sub DisplayData(connString As [String])\n         Using conn As New SqlConnection(connString)\n            Dim cmdText As [String] = &quot;Use DbDataIsolationLevel; &quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                &quot;Select ProductId,ProductName,Quantity,Price&quot; &amp; vbCr &amp; vbLf &amp;\n                &quot;from dbo.Products&quot;\n\n            conn.Open()\n\n            Using command As New SqlCommand(cmdText, conn)\n               Using reader As SqlDataReader = command.ExecuteReader()\n                  DisplayData(reader)\n               End Using\n            End Using\n         End Using\n      End Sub\n\n      Public Shared Sub DisplayData(reader As SqlDataReader)\n         Dim isFirst As [Boolean] = True\n\n         While reader.Read()\n            If isFirst Then\n               isFirst = False\n\n               For i As Integer = 0 To reader.FieldCount - 1\n                  Console.Write(&quot;{0,-12}   &quot;, reader.GetName(i))\n               Next\n               Console.WriteLine()\n            End If\n\n            For i As Integer = 0 To reader.FieldCount - 1\n               Console.Write(&quot;{0,-12}   &quot;, reader(i))\n            Next\n            Console.WriteLine()\n         End While\n      End Sub\n   End Class\n\n   &#39; This class includes database operations. If there&#39;s no database &#39;DbDataIsolationLevel&#39;, create the database.\n   NotInheritable Class OperateDatabase\n      Private Sub New()\n      End Sub\n      Public Shared Function CreateDatabase(connString As [String]) As [Boolean]\n         Using conn As New SqlConnection(connString)\n            Dim cmdText As [String] = &quot;Use Master;&quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                &quot;if Db_Id(&#39;DbDataIsolationLevel&#39;) is null&quot; &amp; vbCr &amp; vbLf &amp;\n                &quot;create Database [DbDataIsolationLevel];&quot;\n\n            Using command As New SqlCommand(cmdText, conn)\n               conn.Open()\n               command.ExecuteNonQuery()\n            End Using\n\n            Console.WriteLine(&quot;Create the Database &#39;DbDataIsolationLevel&#39;&quot;)\n         End Using\n\n         Return True\n      End Function\n\n\n      &#39; If there&#39;s no table [dbo].[Products] in DbDataIsolationLevel, create the table; or recreate it.\n      Public Shared Function CreateTable(connString As [String]) As [Boolean]\n         Using conn As New SqlConnection(connString)\n            Dim cmdText As [String] = &quot;Use DbDataIsolationLevel&quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                &quot;if Object_ID(&#39;[dbo].[Products]&#39;) is not null&quot; &amp; vbCr &amp; vbLf &amp;\n                &quot;drop table [dbo].[Products]&quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                &quot;Create Table [dbo].[Products]&quot; &amp; vbCr &amp; vbLf &amp;\n                &quot;(&quot; &amp; vbCr &amp; vbLf &amp;\n                &quot;[ProductId] int IDENTITY(1,1) primary key,&quot; &amp; vbCr &amp; vbLf &amp;\n                &quot;[ProductName] NVarchar(100) not null,&quot; &amp; vbCr &amp; vbLf &amp;\n                &quot;[Quantity] int null,&quot; &amp; vbCr &amp; vbLf &amp;\n                &quot;[Price] money null&quot; &amp; vbCr &amp; vbLf &amp; &quot;                                    )&quot;\n\n            Using command As New SqlCommand(cmdText, conn)\n               conn.Open()\n               command.ExecuteNonQuery()\n            End Using\n         End Using\n\n         Return InsertRows(connString)\n      End Function\n\n      &#39; Insert some rows into [dbo].[Products] table.\n      Public Shared Function InsertRows(connString As [String]) As [Boolean]\n         Using conn As New SqlConnection(connString)\n            Dim cmdText As [String] = &quot;Use DbDataIsolationLevel&quot; &amp; vbCr &amp; vbLf &amp; vbCr &amp; vbLf &amp;\n                &quot;INSERT [dbo].[Products] ([ProductName], [Quantity], [Price]) VALUES (N&#39;Blue Bike&#39;, 365,1075.00)&quot; &amp; vbCr &amp; vbLf &amp;\n                &quot;INSERT [dbo].[Products] ([ProductName], [Quantity], [Price]) VALUES (N&#39;Red Bike&#39;, 159, 1299.00)&quot; &amp; vbCr &amp; vbLf &amp;\n                &quot;INSERT [dbo].[Products] ([ProductName], [Quantity], [Price]) VALUES (N&#39;Black Bike&#39;, 638, 1159.00)&quot;\n\n            Using command As New SqlCommand(cmdText, conn)\n               conn.Open()\n               command.ExecuteNonQuery()\n            End Using\n         End Using\n         Return True\n      End Function\n\n      &#39; Turn on or off &#39;ALLOW_SNAPSHOT_ISOLATION&#39;\n      Public Shared Function SetSnapshot(connString As [String], isOpen As [Boolean]) As [Boolean]\n         Using conn As New SqlConnection(connString)\n            Dim cmdText As [String] = Nothing\n\n            If isOpen Then\n               cmdText = &quot;ALTER DATABASE DbDataIsolationLevel SET ALLOW_SNAPSHOT_ISOLATION ON&quot;\n            Else\n               cmdText = &quot;ALTER DATABASE DbDataIsolationLevel SET ALLOW_SNAPSHOT_ISOLATION OFF&quot;\n            End If\n\n            Using command As New SqlCommand(cmdText, conn)\n               conn.Open()\n               command.ExecuteNonQuery()\n            End Using\n         End Using\n\n         Return True\n      End Function\n   End Class\n   Class Program\n      Public Shared Sub Main(args As String())\n         Dim connString As [String] = &quot;Data Source=(local);Initial Catalog=master;Integrated Security=True;Asynchronous Processing=true;&quot;\n\n         OperateDatabase.CreateDatabase(connString)\n         Console.WriteLine()\n\n         Console.WriteLine(&quot;Demonstrate the ReadUncommitted transaction: &quot;)\n         TransactionIsolationLevels.DemonstrateIsolationLevel(connString, System.Data.IsolationLevel.ReadUncommitted)\n         Console.WriteLine(&quot;-----------------------------------------------&quot;)\n\n         Console.WriteLine(&quot;Demonstrate the ReadCommitted transaction: &quot;)\n         TransactionIsolationLevels.DemonstrateIsolationLevel(connString, System.Data.IsolationLevel.ReadCommitted)\n         Console.WriteLine(&quot;-----------------------------------------------&quot;)\n\n         Console.WriteLine(&quot;Demonstrate the RepeatableRead transaction: &quot;)\n         TransactionIsolationLevels.DemonstrateIsolationLevel(connString, System.Data.IsolationLevel.RepeatableRead)\n         Console.WriteLine(&quot;-----------------------------------------------&quot;)\n\n         Console.WriteLine(&quot;Demonstrate the Serializable transaction: &quot;)\n         TransactionIsolationLevels.DemonstrateIsolationLevel(connString, System.Data.IsolationLevel.Serializable)\n         Console.WriteLine(&quot;-----------------------------------------------&quot;)\n\n         Console.WriteLine(&quot;Demonstrate the Snapshot transaction: &quot;)\n         OperateDatabase.SetSnapshot(connString, True)\n         TransactionIsolationLevels.DemonstrateIsolationLevel(connString, System.Data.IsolationLevel.Snapshot)\n         Console.WriteLine(&quot;-----------------------------------------------&quot;)\n\n         Console.WriteLine(&quot;Demonstrate the difference between the Snapshot and Serializable transactions:&quot;)\n         TransactionIsolationLevels.DemonstrateBetweenSnapshotAndSerializable(connString)\n         OperateDatabase.SetSnapshot(connString, False)\n         Console.WriteLine()\n      End Sub\n   End Class\nEnd Namespace\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>The IsolationLevel values are used by a .NET Framework data provider when performing a transaction.  </p>\n<p> The IsolationLevel remains in effect until explicitly changed, but it can be changed at any time. The new value is used at execution time, not parse time. If changed during a transaction, the expected behavior of the server is to apply the new locking level to all statements remaining.</p>\n\r\n  \r\n      \t<h2 class=\"accented\">Fields\r\n      </h2>\r\n      <table class=\"nameValue\">\r\n      \t<tr><td id=\"System_Data_IsolationLevel_Chaos\">\r\n      \t\t\t<span class=\"lang-csharp\">Chaos</span>\r\n      \t</td>\r\n      \t<td><p>The pending changes from more highly isolated transactions cannot be overwritten.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Data_IsolationLevel_ReadCommitted\">\r\n      \t\t\t<span class=\"lang-csharp\">ReadCommitted</span>\r\n      \t</td>\r\n      \t<td><p>Shared locks are held while the data is being read to avoid dirty reads, but the data can be changed before the end of the transaction, resulting in non-repeatable reads or phantom data.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Data_IsolationLevel_ReadUncommitted\">\r\n      \t\t\t<span class=\"lang-csharp\">ReadUncommitted</span>\r\n      \t</td>\r\n      \t<td><p>A dirty read is possible, meaning that no shared locks are issued and no exclusive locks are honored.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Data_IsolationLevel_RepeatableRead\">\r\n      \t\t\t<span class=\"lang-csharp\">RepeatableRead</span>\r\n      \t</td>\r\n      \t<td><p>Locks are placed on all data that is used in a query, preventing other users from updating the data. Prevents non-repeatable reads but phantom rows are still possible.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Data_IsolationLevel_Serializable\">\r\n      \t\t\t<span class=\"lang-csharp\">Serializable</span>\r\n      \t</td>\r\n      \t<td><p>A range lock is placed on the <a class=\"xref\" href=\"system.data.dataset\" data-linktype=\"relative-path\">DataSet</a>, preventing other users from updating or inserting rows into the dataset until the transaction is complete.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Data_IsolationLevel_Snapshot\">\r\n      \t\t\t<span class=\"lang-csharp\">Snapshot</span>\r\n      \t</td>\r\n      \t<td><p>Reduces blocking by storing a version of data that one application can read while another is modifying the same data. Indicates that from one transaction you cannot see changes made in other transactions, even if you requery.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Data_IsolationLevel_Unspecified\">\r\n      \t\t\t<span class=\"lang-csharp\">Unspecified</span>\r\n      \t</td>\r\n      \t<td><p>A different isolation level than the one specified is being used, but the level cannot be determined.</p>\n</td>\r\n      \t</tr>\r\n      </table>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Data.IsolationLevel.yml\">\r\n<meta name=\"APIName\" content=\"System.Data.IsolationLevel\">\r\n<meta name=\"APIName\" content=\"System.Data.IsolationLevel.Chaos\">\r\n<meta name=\"APIName\" content=\"System.Data.IsolationLevel.ReadCommitted\">\r\n<meta name=\"APIName\" content=\"System.Data.IsolationLevel.ReadUncommitted\">\r\n<meta name=\"APIName\" content=\"System.Data.IsolationLevel.RepeatableRead\">\r\n<meta name=\"APIName\" content=\"System.Data.IsolationLevel.Serializable\">\r\n<meta name=\"APIName\" content=\"System.Data.IsolationLevel.Snapshot\">\r\n<meta name=\"APIName\" content=\"System.Data.IsolationLevel.Unspecified\">\r\n<meta name=\"APILocation\" content=\"System.Data.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-31 05:47 AM\">\r\n<meta name=\"document_id\" content=\"809bfd43-a0d5-5127-055a-d886ed55e6bb\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Specifies the transaction locking behavior for the connection.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.data/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Data.IsolationLevel\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Data.IsolationLevel.yml","open_to_public_contributors":false,"api_name":["System.Data.IsolationLevel","System.Data.IsolationLevel.Chaos","System.Data.IsolationLevel.ReadCommitted","System.Data.IsolationLevel.ReadUncommitted","System.Data.IsolationLevel.RepeatableRead","System.Data.IsolationLevel.Serializable","System.Data.IsolationLevel.Snapshot","System.Data.IsolationLevel.Unspecified"],"api_location":["System.Data.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Data.IsolationLevel","System::Data::IsolationLevel","System.Data.IsolationLevel.Chaos","System::Data::IsolationLevel::Chaos","System.Data.IsolationLevel.ReadCommitted","System::Data::IsolationLevel::ReadCommitted","System.Data.IsolationLevel.ReadUncommitted","System::Data::IsolationLevel::ReadUncommitted","System.Data.IsolationLevel.RepeatableRead","System::Data::IsolationLevel::RepeatableRead","System.Data.IsolationLevel.Serializable","System::Data::IsolationLevel::Serializable","System.Data.IsolationLevel.Snapshot","System::Data::IsolationLevel::Snapshot","System.Data.IsolationLevel.Unspecified","System::Data::IsolationLevel::Unspecified"],"dev_langs":["csharp"],"updated_at":"2017-03-31 05:47 AM","document_id":"809bfd43-a0d5-5127-055a-d886ed55e6bb","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Data/IsolationLevel.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"IsolationLevel enum | Microsoft Docs","_op_ogTitle":"IsolationLevel enum","description":"Specifies the transaction locking behavior for the connection.\n","toc_asset_id":"api/_splitted/System.Data/toc.json","toc_rel":"_splitted/System.Data/toc.json","source_url":"","ms.assetid":"System.Data.IsolationLevel","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.data.isolationlevel","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.data.isolationlevel","fileRelativePath":"api/System.Data.IsolationLevel.html"},"themesRelativePathToOutputRoot":"_themes/"}