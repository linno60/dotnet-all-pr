{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">EventResetMode</span>\r\n      Enum\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Indicates whether an <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> is reset automatically or manually after receiving a signal.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\r\n  \t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(false)]\npublic enum EventResetMode</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.valuetype\" data-linktype=\"relative-path\">ValueType</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.enum\" data-linktype=\"relative-path\">System.Enum</a></span></div><span class=\"lang-csharp\">EventResetMode</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following code example uses the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_\" data-linktype=\"relative-path\">SignalAndWait(WaitHandle,WaitHandle)</a> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.  </p>\n<p> The example starts five threads and allows them to block on an <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> created with the AutoReset flag, then releases one thread each time the user presses the ENTER key. The example then queues another five threads and releases them all using an <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> created with the ManualReset flag.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Threading.WaitHandle.SignalAndWait#1\">using namespace System;\nusing namespace System::Threading;\n\npublic ref class Example\n{\nprivate:\n   // The EventWaitHandle used to demonstrate the difference\n   // between AutoReset and ManualReset synchronization events.\n   //\n   static EventWaitHandle^ ewh;\n\n   // A counter to make sure all threads are started and\n   // blocked before any are released. A Long is used to show\n   // the use of the 64-bit Interlocked methods.\n   //\n   static __int64 threadCount = 0;\n\n   // An AutoReset event that allows the main thread to block\n   // until an exiting thread has decremented the count.\n   //\n   static EventWaitHandle^ clearCount =\n      gcnew EventWaitHandle( false,EventResetMode::AutoReset );\n\npublic:\n   [MTAThread]\n   static void main()\n   {\n      // Create an AutoReset EventWaitHandle.\n      //\n      ewh = gcnew EventWaitHandle( false,EventResetMode::AutoReset );\n      \n      // Create and start five numbered threads. Use the\n      // ParameterizedThreadStart delegate, so the thread\n      // number can be passed as an argument to the Start\n      // method.\n      for ( int i = 0; i &lt;= 4; i++ )\n      {\n         Thread^ t = gcnew Thread(\n            gcnew ParameterizedThreadStart( ThreadProc ) );\n         t-&gt;Start( i );\n      }\n      \n      // Wait until all the threads have started and blocked.\n      // When multiple threads use a 64-bit value on a 32-bit\n      // system, you must access the value through the\n      // Interlocked class to guarantee thread safety.\n      //\n      while ( Interlocked::Read( threadCount ) &lt; 5 )\n      {\n         Thread::Sleep( 500 );\n      }\n\n      // Release one thread each time the user presses ENTER,\n      // until all threads have been released.\n      //\n      while ( Interlocked::Read( threadCount ) &gt; 0 )\n      {\n         Console::WriteLine( L&quot;Press ENTER to release a waiting thread.&quot; );\n         Console::ReadLine();\n         \n         // SignalAndWait signals the EventWaitHandle, which\n         // releases exactly one thread before resetting,\n         // because it was created with AutoReset mode.\n         // SignalAndWait then blocks on clearCount, to\n         // allow the signaled thread to decrement the count\n         // before looping again.\n         //\n         WaitHandle::SignalAndWait( ewh, clearCount );\n      }\n      Console::WriteLine();\n      \n      // Create a ManualReset EventWaitHandle.\n      //\n      ewh = gcnew EventWaitHandle( false,EventResetMode::ManualReset );\n      \n      // Create and start five more numbered threads.\n      //\n      for ( int i = 0; i &lt;= 4; i++ )\n      {\n         Thread^ t = gcnew Thread(\n            gcnew ParameterizedThreadStart( ThreadProc ) );\n         t-&gt;Start( i );\n      }\n      \n      // Wait until all the threads have started and blocked.\n      //\n      while ( Interlocked::Read( threadCount ) &lt; 5 )\n      {\n         Thread::Sleep( 500 );\n      }\n\n      // Because the EventWaitHandle was created with\n      // ManualReset mode, signaling it releases all the\n      // waiting threads.\n      //\n      Console::WriteLine( L&quot;Press ENTER to release the waiting threads.&quot; );\n      Console::ReadLine();\n      ewh-&gt;Set();\n\n   }\n\n   static void ThreadProc( Object^ data )\n   {\n      int index = static_cast&lt;Int32&gt;(data);\n\n      Console::WriteLine( L&quot;Thread {0} blocks.&quot;, data );\n      // Increment the count of blocked threads.\n      Interlocked::Increment( threadCount );\n      \n      // Wait on the EventWaitHandle.\n      ewh-&gt;WaitOne();\n\n      Console::WriteLine( L&quot;Thread {0} exits.&quot;, data );\n      // Decrement the count of blocked threads.\n      Interlocked::Decrement( threadCount );\n      \n      // After signaling ewh, the main thread blocks on\n      // clearCount until the signaled thread has\n      // decremented the count. Signal it now.\n      //\n      clearCount-&gt;Set();\n   }\n};\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.WaitHandle.SignalAndWait#1\">Imports System\nImports System.Threading\n\nPublic Class Example\n\n    &#39; The EventWaitHandle used to demonstrate the difference\n    &#39; between AutoReset and ManualReset synchronization events.\n    &#39;\n    Private Shared ewh As EventWaitHandle\n\n    &#39; A counter to make sure all threads are started and\n    &#39; blocked before any are released. A Long is used to show\n    &#39; the use of the 64-bit Interlocked methods.\n    &#39;\n    Private Shared threadCount As Long = 0\n\n    &#39; An AutoReset event that allows the main thread to block\n    &#39; until an exiting thread has decremented the count.\n    &#39;\n    Private Shared clearCount As New EventWaitHandle(False, _\n        EventResetMode.AutoReset)\n\n    &lt;MTAThread&gt; _\n    Public Shared Sub Main()\n\n        &#39; Create an AutoReset EventWaitHandle.\n        &#39;\n        ewh = New EventWaitHandle(False, EventResetMode.AutoReset)\n\n        &#39; Create and start five numbered threads. Use the\n        &#39; ParameterizedThreadStart delegate, so the thread\n        &#39; number can be passed as an argument to the Start \n        &#39; method.\n        For i As Integer = 0 To 4\n            Dim t As New Thread(AddressOf ThreadProc)\n            t.Start(i)\n        Next i\n\n        &#39; Wait until all the threads have started and blocked.\n        &#39; When multiple threads use a 64-bit value on a 32-bit\n        &#39; system, you must access the value through the\n        &#39; Interlocked class to guarantee thread safety.\n        &#39;\n        While Interlocked.Read(threadCount) &lt; 5\n            Thread.Sleep(500)\n        End While\n\n        &#39; Release one thread each time the user presses ENTER,\n        &#39; until all threads have been released.\n        &#39;\n        While Interlocked.Read(threadCount) &gt; 0\n            Console.WriteLine(&quot;Press ENTER to release a waiting thread.&quot;)\n            Console.ReadLine()\n\n            &#39; SignalAndWait signals the EventWaitHandle, which\n            &#39; releases exactly one thread before resetting, \n            &#39; because it was created with AutoReset mode. \n            &#39; SignalAndWait then blocks on clearCount, to \n            &#39; allow the signaled thread to decrement the count\n            &#39; before looping again.\n            &#39;\n            WaitHandle.SignalAndWait(ewh, clearCount)\n        End While\n        Console.WriteLine()\n\n        &#39; Create a ManualReset EventWaitHandle.\n        &#39;\n        ewh = New EventWaitHandle(False, EventResetMode.ManualReset)\n\n        &#39; Create and start five more numbered threads.\n        &#39;\n        For i As Integer = 0 To 4\n            Dim t As New Thread(AddressOf ThreadProc)\n            t.Start(i)\n        Next i\n\n        &#39; Wait until all the threads have started and blocked.\n        &#39;\n        While Interlocked.Read(threadCount) &lt; 5\n            Thread.Sleep(500)\n        End While\n\n        &#39; Because the EventWaitHandle was created with\n        &#39; ManualReset mode, signaling it releases all the\n        &#39; waiting threads.\n        &#39;\n        Console.WriteLine(&quot;Press ENTER to release the waiting threads.&quot;)\n        Console.ReadLine()\n        ewh.Set()\n        \n    End Sub\n\n    Public Shared Sub ThreadProc(ByVal data As Object)\n        Dim index As Integer = CInt(data)\n\n        Console.WriteLine(&quot;Thread {0} blocks.&quot;, data)\n        &#39; Increment the count of blocked threads.\n        Interlocked.Increment(threadCount)\n\n        &#39; Wait on the EventWaitHandle.\n        ewh.WaitOne()\n\n        Console.WriteLine(&quot;Thread {0} exits.&quot;, data)\n        &#39; Decrement the count of blocked threads.\n        Interlocked.Decrement(threadCount)\n\n        &#39; After signaling ewh, the main thread blocks on\n        &#39; clearCount until the signaled thread has \n        &#39; decremented the count. Signal it now.\n        &#39;\n        clearCount.Set()\n    End Sub\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.WaitHandle.SignalAndWait#1\">using System;\nusing System.Threading;\n\npublic class Example\n{\n    // The EventWaitHandle used to demonstrate the difference\n    // between AutoReset and ManualReset synchronization events.\n    //\n    private static EventWaitHandle ewh;\n\n    // A counter to make sure all threads are started and\n    // blocked before any are released. A Long is used to show\n    // the use of the 64-bit Interlocked methods.\n    //\n    private static long threadCount = 0;\n\n    // An AutoReset event that allows the main thread to block\n    // until an exiting thread has decremented the count.\n    //\n    private static EventWaitHandle clearCount = \n        new EventWaitHandle(false, EventResetMode.AutoReset);\n\n    [MTAThread]\n    public static void Main()\n    {\n        // Create an AutoReset EventWaitHandle.\n        //\n        ewh = new EventWaitHandle(false, EventResetMode.AutoReset);\n\n        // Create and start five numbered threads. Use the\n        // ParameterizedThreadStart delegate, so the thread\n        // number can be passed as an argument to the Start \n        // method.\n        for (int i = 0; i &lt;= 4; i++)\n        {\n            Thread t = new Thread(\n                new ParameterizedThreadStart(ThreadProc)\n            );\n            t.Start(i);\n        }\n\n        // Wait until all the threads have started and blocked.\n        // When multiple threads use a 64-bit value on a 32-bit\n        // system, you must access the value through the\n        // Interlocked class to guarantee thread safety.\n        //\n        while (Interlocked.Read(ref threadCount) &lt; 5)\n        {\n            Thread.Sleep(500);\n        }\n\n        // Release one thread each time the user presses ENTER,\n        // until all threads have been released.\n        //\n        while (Interlocked.Read(ref threadCount) &gt; 0)\n        {\n            Console.WriteLine(&quot;Press ENTER to release a waiting thread.&quot;);\n            Console.ReadLine();\n\n            // SignalAndWait signals the EventWaitHandle, which\n            // releases exactly one thread before resetting, \n            // because it was created with AutoReset mode. \n            // SignalAndWait then blocks on clearCount, to \n            // allow the signaled thread to decrement the count\n            // before looping again.\n            //\n            WaitHandle.SignalAndWait(ewh, clearCount);\n        }\n        Console.WriteLine();\n\n        // Create a ManualReset EventWaitHandle.\n        //\n        ewh = new EventWaitHandle(false, EventResetMode.ManualReset);\n\n        // Create and start five more numbered threads.\n        //\n        for(int i=0; i&lt;=4; i++)\n        {\n            Thread t = new Thread(\n                new ParameterizedThreadStart(ThreadProc)\n            );\n            t.Start(i);\n        }\n\n        // Wait until all the threads have started and blocked.\n        //\n        while (Interlocked.Read(ref threadCount) &lt; 5)\n        {\n            Thread.Sleep(500);\n        }\n\n        // Because the EventWaitHandle was created with\n        // ManualReset mode, signaling it releases all the\n        // waiting threads.\n        //\n        Console.WriteLine(&quot;Press ENTER to release the waiting threads.&quot;);\n        Console.ReadLine();\n        ewh.Set();\n        \n    }\n\n    public static void ThreadProc(object data)\n    {\n        int index = (int) data;\n\n        Console.WriteLine(&quot;Thread {0} blocks.&quot;, data);\n        // Increment the count of blocked threads.\n        Interlocked.Increment(ref threadCount);\n\n        // Wait on the EventWaitHandle.\n        ewh.WaitOne();\n\n        Console.WriteLine(&quot;Thread {0} exits.&quot;, data);\n        // Decrement the count of blocked threads.\n        Interlocked.Decrement(ref threadCount);\n\n        // After signaling ewh, the main thread blocks on\n        // clearCount until the signaled thread has \n        // decremented the count. Signal it now.\n        //\n        clearCount.Set();\n    }\n}\n</code></pre>\r\n  \r\n  \r\n      \t<h2 class=\"accented\">Fields\r\n      </h2>\r\n      <table class=\"nameValue\">\r\n      \t<tr><td id=\"System_Threading_EventResetMode_AutoReset\">\r\n      \t\t\t<span class=\"lang-csharp\">AutoReset</span>\r\n      \t</td>\r\n      \t<td><p>When signaled, the <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> resets automatically after releasing a single thread. If no threads are waiting, the <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> remains signaled until a thread blocks, and resets after releasing the thread.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Threading_EventResetMode_ManualReset\">\r\n      \t\t\t<span class=\"lang-csharp\">ManualReset</span>\r\n      \t</td>\r\n      \t<td><p>When signaled, the <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> releases all waiting threads and remains signaled until it is manually reset.</p>\n</td>\r\n      \t</tr>\r\n      </table>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Threading.EventResetMode.yml\">\r\n<meta name=\"APIName\" content=\"System.Threading.EventResetMode\">\r\n<meta name=\"APIName\" content=\"System.Threading.EventResetMode.AutoReset\">\r\n<meta name=\"APIName\" content=\"System.Threading.EventResetMode.ManualReset\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-24 01:41 AM\">\r\n<meta name=\"document_id\" content=\"e0d3d5db-9a0e-0362-0f9c-d099c75cac90\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Indicates whether an  is reset automatically or manually after receiving a signal.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.threading/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Threading.EventResetMode\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Threading.EventResetMode.yml","open_to_public_contributors":false,"api_name":["System.Threading.EventResetMode","System.Threading.EventResetMode.AutoReset","System.Threading.EventResetMode.ManualReset"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Threading.EventResetMode","System::Threading::EventResetMode","System.Threading.EventResetMode.AutoReset","System::Threading::EventResetMode::AutoReset","System.Threading.EventResetMode.ManualReset","System::Threading::EventResetMode::ManualReset"],"dev_langs":["csharp"],"updated_at":"2017-03-24 01:41 AM","document_id":"e0d3d5db-9a0e-0362-0f9c-d099c75cac90","content_git_url":"https://github.com/dotnet/docs/blob/master/xml/System.Threading/EventResetMode.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"EventResetMode enum | Microsoft Docs","_op_ogTitle":"EventResetMode enum","description":"Indicates whether an  is reset automatically or manually after receiving a signal.\n","toc_asset_id":"api/_splitted/System.Threading/toc.json","toc_rel":"_splitted/System.Threading/toc.json","source_url":"","ms.assetid":"System.Threading.EventResetMode","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.threading.eventresetmode","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.threading.eventresetmode","fileRelativePath":"api/System.Threading.EventResetMode.html"},"themesRelativePathToOutputRoot":"_themes/"}