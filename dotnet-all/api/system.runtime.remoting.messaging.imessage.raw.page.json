{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">IMessage</span>\r\n      Interface\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Contains communication data sent between cooperating message sinks.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(true)]\npublic interface IMessage</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Attributes</dt><dd>\r\n  \t\t<div class=\"cdlHolder\">\r\n  \t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<pre><code class=\"lang-vb\" name=\"ChannelServices_SyncDispatchMessage#1\">&#39; Create a custom &#39;RealProxy&#39;.\nPublic Class MyProxy\n   Inherits RealProxy\n   Private myURIString As String\n   Private myMarshalByRefObject As MarshalByRefObject\n\n   &lt;PermissionSet(SecurityAction.LinkDemand)&gt; _\n   Public Sub New(ByVal myType As Type)\n      MyBase.New(myType)\n      &#39; RealProxy uses the Type to generate a transparent proxy.\n      myMarshalByRefObject = CType(Activator.CreateInstance(myType), MarshalByRefObject)\n      &#39; Get &#39;ObjRef&#39;, for transmission serialization between application domains.\n      Dim myObjRef As ObjRef = RemotingServices.Marshal(myMarshalByRefObject)\n      &#39; Get the &#39;URI&#39; property of &#39;ObjRef&#39; and store it.\n      myURIString = myObjRef.URI\n      Console.WriteLine(&quot;URI :{0}&quot;, myObjRef.URI)\n   End Sub &#39;New\n\n&lt;SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags:=SecurityPermissionFlag.Infrastructure)&gt; _\n   Public Overrides Function Invoke(ByVal myIMessage As IMessage) As IMessage\n      Console.WriteLine(&quot;MyProxy.Invoke Start&quot;)\n      Console.WriteLine(&quot;&quot;)\n\n      If TypeOf myIMessage Is IMethodCallMessage Then\n         Console.WriteLine(&quot;IMethodCallMessage&quot;)\n      End If\n      If TypeOf myIMessage Is IMethodReturnMessage Then\n         Console.WriteLine(&quot;IMethodReturnMessage&quot;)\n      End If\n      Dim msgType As Type\n      msgType = CObj(myIMessage).GetType\n      Console.WriteLine(&quot;Message Type: {0}&quot;, msgType.ToString())\n      Console.WriteLine(&quot;Message Properties&quot;)\n      Dim myIDictionary As IDictionary = myIMessage.Properties\n      &#39; Set the &#39;__Uri&#39; property of &#39;IMessage&#39; to &#39;URI&#39; property of &#39;ObjRef&#39;.\n      myIDictionary(&quot;__Uri&quot;) = myURIString\n      Dim myIDictionaryEnumerator As IDictionaryEnumerator = CType(myIDictionary.GetEnumerator(), _\n                                                                    IDictionaryEnumerator)\n\n      While myIDictionaryEnumerator.MoveNext()\n         Dim myKey As Object = myIDictionaryEnumerator.Key\n         Dim myKeyName As String = myKey.ToString()\n         Dim myValue As Object = myIDictionaryEnumerator.Value\n\n         Console.WriteLine(ControlChars.Tab + &quot;{0} : {1}&quot;, myKeyName, myIDictionaryEnumerator.Value)\n         If myKeyName = &quot;__Args&quot; Then\n            Dim myObjectArray As Object() = CType(myValue, Object())\n            Dim aIndex As Integer\n            For aIndex = 0 To myObjectArray.Length - 1\n               Console.WriteLine(ControlChars.Tab + ControlChars.Tab + &quot;arg: {0} myValue: {1}&quot;, _\n                                                              aIndex, myObjectArray(aIndex))\n             Next aIndex\n         End If\n\n         If myKeyName = &quot;__MethodSignature&quot; And Not Nothing Is myValue Then\n            Dim myObjectArray As Object() = CType(myValue, Object())\n            Dim aIndex As Integer\n            For aIndex = 0 To myObjectArray.Length - 1\n               Console.WriteLine(ControlChars.Tab + ControlChars.Tab + &quot;arg: {0} myValue: {1}&quot;, _\n                                                           aIndex, myObjectArray(aIndex))\n            Next aIndex\n         End If\n      End While\n\n        Dim myReturnMessage As IMessage\n\n        myIDictionary(&quot;__Uri&quot;) = myURIString\n        Console.WriteLine(&quot;__Uri {0}&quot;, myIDictionary(&quot;__Uri&quot;))\n\n        Console.WriteLine(&quot;ChannelServices.SyncDispatchMessage&quot;)\n        myReturnMessage = ChannelServices.SyncDispatchMessage(CObj(myIMessage))\n\n        &#39; Push return value and OUT parameters back onto stack.\n        Dim myMethodReturnMessage As IMethodReturnMessage = CType(myReturnMessage, IMethodReturnMessage)\n        Console.WriteLine(&quot;IMethodReturnMessage.ReturnValue: {0}&quot;, myMethodReturnMessage.ReturnValue)\n\n        Console.WriteLine(&quot;MyProxy.Invoke - Finish&quot;)\n\n        Return myReturnMessage\n    End Function &#39;Invoke\nEnd Class &#39;MyProxy\n</code></pre><pre><code class=\"lang-cs\" name=\"ChannelServices_SyncDispatchMessage#1\">// Create a custom &#39;RealProxy&#39;.\npublic class MyProxy : RealProxy\n{\n   String myURIString;\n   MarshalByRefObject myMarshalByRefObject;   \n\n   [PermissionSet(SecurityAction.LinkDemand)]\n   public MyProxy(Type myType) : base(myType)\n   {\n      // RealProxy uses the Type to generate a transparent proxy.\n      myMarshalByRefObject = (MarshalByRefObject)Activator.CreateInstance((myType));\n      // Get &#39;ObjRef&#39;, for transmission serialization between application domains.\n      ObjRef myObjRef = RemotingServices.Marshal(myMarshalByRefObject);\n      // Get the &#39;URI&#39; property of &#39;ObjRef&#39; and store it.\n      myURIString = myObjRef.URI;\n      Console.WriteLine(&quot;URI :{0}&quot;, myObjRef.URI);\n   }\n\n   [SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags=SecurityPermissionFlag.Infrastructure)]\n   public override IMessage Invoke(IMessage myIMessage)\n   {\n      Console.WriteLine(&quot;MyProxy.Invoke Start&quot;);\n      Console.WriteLine(&quot;&quot;);\n\n      if (myIMessage is IMethodCallMessage)\n         Console.WriteLine(&quot;IMethodCallMessage&quot;);\n\n      if (myIMessage is IMethodReturnMessage)\n         Console.WriteLine(&quot;IMethodReturnMessage&quot;);\n\n      Type msgType = myIMessage.GetType();\n      Console.WriteLine(&quot;Message Type: {0}&quot;, msgType.ToString());\n      Console.WriteLine(&quot;Message Properties&quot;);\n      IDictionary myIDictionary = myIMessage.Properties;\n      // Set the &#39;__Uri&#39; property of &#39;IMessage&#39; to &#39;URI&#39; property of &#39;ObjRef&#39;.\n      myIDictionary[&quot;__Uri&quot;] = myURIString;\n      IDictionaryEnumerator myIDictionaryEnumerator = \n         (IDictionaryEnumerator) myIDictionary.GetEnumerator();\n\n      while (myIDictionaryEnumerator.MoveNext())\n      {\n         Object myKey = myIDictionaryEnumerator.Key;\n         String myKeyName = myKey.ToString();\n         Object myValue = myIDictionaryEnumerator.Value;\n\n         Console.WriteLine(&quot;\\t{0} : {1}&quot;, myKeyName, \n            myIDictionaryEnumerator.Value);\n         if (myKeyName == &quot;__Args&quot;)\n         {\n            Object[] myObjectArray = (Object[])myValue;\n            for (int aIndex = 0; aIndex &lt; myObjectArray.Length; aIndex++)\n               Console.WriteLine(&quot;\\t\\targ: {0} myValue: {1}&quot;, aIndex, \n                  myObjectArray[aIndex]);\n         }\n\n         if ((myKeyName == &quot;__MethodSignature&quot;) &amp;&amp; (null != myValue))\n         {\n            Object[] myObjectArray = (Object[])myValue;\n            for (int aIndex = 0; aIndex &lt; myObjectArray.Length; aIndex++)\n               Console.WriteLine(&quot;\\t\\targ: {0} myValue: {1}&quot;, aIndex, \n                  myObjectArray[aIndex]);\n         }\n      }\n      \n      IMessage myReturnMessage;\n\n      myIDictionary[&quot;__Uri&quot;] = myURIString;\n      Console.WriteLine(&quot;__Uri {0}&quot;, myIDictionary[&quot;__Uri&quot;]);\n\n      Console.WriteLine(&quot;ChannelServices.SyncDispatchMessage&quot;);\n      myReturnMessage = ChannelServices.SyncDispatchMessage(myIMessage);\n\n      // Push return value and OUT parameters back onto stack.\n\n      IMethodReturnMessage myMethodReturnMessage = (IMethodReturnMessage)\n         myReturnMessage;\n      Console.WriteLine(&quot;IMethodReturnMessage.ReturnValue: {0}&quot;, \n         myMethodReturnMessage.ReturnValue);\n\n      Console.WriteLine(&quot;MyProxy.Invoke - Finish&quot;);\n\n      return myReturnMessage;\n   }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"ChannelServices_SyncDispatchMessage#1\">// Create a custom &#39;RealProxy&#39;.\npublic ref class MyProxy: public RealProxy\n{\nprivate:\n   String^ myURIString;\n   MarshalByRefObject^ myMarshalByRefObject;\n\npublic:\n   MyProxy( Type^ myType )\n      : RealProxy( myType )\n   {\n      \n      // RealProxy uses the Type to generate a transparent proxy.\n      myMarshalByRefObject = dynamic_cast&lt;MarshalByRefObject^&gt;(Activator::CreateInstance(myType));\n      \n      // Get &#39;ObjRef&#39;, for transmission serialization between application domains.\n      ObjRef^ myObjRef = RemotingServices::Marshal( myMarshalByRefObject );\n      \n      // Get the &#39;URI&#39; property of &#39;ObjRef&#39; and store it.\n      myURIString = myObjRef-&gt;URI;\n      Console::WriteLine( &quot;URI :{0}&quot;, myObjRef-&gt;URI );\n   }\n\n   virtual IMessage^ Invoke ( IMessage^ myIMessage ) override \n\t{\n      Console::WriteLine( &quot;MyProxy.Invoke Start&quot; );\n      Console::WriteLine( &quot;&quot; );\n      if ( dynamic_cast&lt;IMethodCallMessage^&gt;(myIMessage) )\n            Console::WriteLine( &quot;IMethodCallMessage&quot; );\n\n      if ( dynamic_cast&lt;IMethodReturnMessage^&gt;(myIMessage) )\n            Console::WriteLine( &quot;IMethodReturnMessage&quot; );\n\n      Type^ msgType = myIMessage-&gt;GetType();\n      Console::WriteLine( &quot;Message Type: {0}&quot;, msgType );\n      Console::WriteLine( &quot;Message Properties&quot; );\n      IDictionary^ myIDictionary = myIMessage-&gt;Properties;\n      \n      // Set the &#39;__Uri&#39; property of &#39;IMessage&#39; to &#39;URI&#39; property of &#39;ObjRef&#39;.\n      myIDictionary-&gt;default[ &quot;__Uri&quot; ] = myURIString;\n      IDictionaryEnumerator^ myIDictionaryEnumerator = dynamic_cast&lt;IDictionaryEnumerator^&gt;(myIDictionary-&gt;GetEnumerator());\n      while ( myIDictionaryEnumerator-&gt;MoveNext() )\n      {\n         Object^ myKey = myIDictionaryEnumerator-&gt;Key;\n         String^ myKeyName = myKey-&gt;ToString();\n         Object^ myValue = myIDictionaryEnumerator-&gt;Value;\n         Console::WriteLine( &quot;\\t{0} : {1}&quot;, myKeyName, myIDictionaryEnumerator-&gt;Value );\n         if ( myKeyName-&gt;Equals( &quot;__Args&quot; ) )\n         {\n            array&lt;Object^&gt;^myObjectArray = (array&lt;Object^&gt;^)myValue;\n            for ( int aIndex = 0; aIndex &lt; myObjectArray-&gt;Length; aIndex++ )\n               Console::WriteLine( &quot;\\t\\targ: {0} myValue: {1}&quot;, aIndex, myObjectArray[ aIndex ] );\n         }\n\n         if ( (myKeyName-&gt;Equals( &quot;__MethodSignature&quot; )) &amp;&amp; (nullptr != myValue) )\n         {\n            array&lt;Object^&gt;^myObjectArray = (array&lt;Object^&gt;^)myValue;\n            for ( int aIndex = 0; aIndex &lt; myObjectArray-&gt;Length; aIndex++ )\n               Console::WriteLine( &quot;\\t\\targ: {0} myValue: {1}&quot;, aIndex, myObjectArray[ aIndex ] );\n         }\n      }\n\n      IMessage^ myReturnMessage;\n      myIDictionary-&gt;default[ &quot;__Uri&quot; ] = myURIString;\n      Console::WriteLine( &quot;__Uri {0}&quot;, myIDictionary-&gt;default[ &quot;__Uri&quot; ] );\n      Console::WriteLine( &quot;ChannelServices.SyncDispatchMessage&quot; );\n      myReturnMessage = ChannelServices::SyncDispatchMessage( myIMessage );\n      \n      // Push return value and OUT parameters back onto stack.\n      IMethodReturnMessage^ myMethodReturnMessage = dynamic_cast&lt;IMethodReturnMessage^&gt;(myReturnMessage);\n      Console::WriteLine( &quot;IMethodReturnMessage.ReturnValue: {0}&quot;, myMethodReturnMessage-&gt;ReturnValue );\n      Console::WriteLine( &quot;MyProxy.Invoke - Finish&quot; );\n      return myReturnMessage;\n   }\n};\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>Message sinks that use IMessage can be placed in the client sink chains or in the server sink chains. A message object is passed from message sink to message sink through the chain, and carries a set of named properties such as action identifiers, envoy information, and parameters.  </p>\n<p> An object that implements the IMessage interface meets the minimum qualifications to be considered a message object. The exact object received by a message sink does not have to be passed on to the next sink, but this is often the case.  </p>\n<p> Although the objects in the property bag do not have to be serializable, the message sink implementer needs to consider this, since the properties that flow out of the application domain must be serializable.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Properties\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Runtime_Remoting_Messaging_IMessage_Properties_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_Remoting_Messaging_IMessage_Properties\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Properties</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets an <a class=\"xref\" href=\"system.collections.idictionary\" data-linktype=\"relative-path\">IDictionary</a> that represents a collection of the message&#39;s properties.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Collections.IDictionary Properties { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.idictionary\" data-linktype=\"relative-path\">IDictionary</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A dictionary that represents a collection of the message&#39;s properties.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><span class=\"xref\">get: System.Security.SecurityCritical</span></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.securityexception\" data-linktype=\"relative-path\">SecurityException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The immediate caller makes the call through a reference to the interface and does not have infrastructure permission.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Runtime.Remoting.Messaging.IMessage.yml\">\r\n<meta name=\"APIName\" content=\"System.Runtime.Remoting.Messaging.IMessage\">\r\n<meta name=\"APIName\" content=\"System.Runtime.Remoting.Messaging.IMessage.Properties\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-31 05:47 AM\">\r\n<meta name=\"document_id\" content=\"8825c502-4b3c-7c7e-a05e-01126b7a3448\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Contains communication data sent between cooperating message sinks.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.runtime.remoting.messaging/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Runtime.Remoting.Messaging.IMessage\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Runtime.Remoting.Messaging.IMessage.yml","open_to_public_contributors":false,"api_name":["System.Runtime.Remoting.Messaging.IMessage","System.Runtime.Remoting.Messaging.IMessage.Properties"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Runtime.Remoting.Messaging.IMessage","System::Runtime::Remoting::Messaging::IMessage","System.Runtime.Remoting.Messaging.IMessage.Properties","System::Runtime::Remoting::Messaging::IMessage::Properties"],"dev_langs":["csharp"],"updated_at":"2017-03-31 05:47 AM","document_id":"8825c502-4b3c-7c7e-a05e-01126b7a3448","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Runtime.Remoting.Messaging/IMessage.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"IMessage interface | Microsoft Docs","_op_ogTitle":"IMessage interface","description":"Contains communication data sent between cooperating message sinks.\n","toc_asset_id":"api/_splitted/System.Runtime.Remoting.Messaging/toc.json","toc_rel":"_splitted/System.Runtime.Remoting.Messaging/toc.json","source_url":"","ms.assetid":"System.Runtime.Remoting.Messaging.IMessage","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.runtime.remoting.messaging.imessage","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.runtime.remoting.messaging.imessage","fileRelativePath":"api/System.Runtime.Remoting.Messaging.IMessage.html"},"themesRelativePathToOutputRoot":"_themes/"}