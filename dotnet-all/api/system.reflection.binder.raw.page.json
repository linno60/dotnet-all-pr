{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">Binder</span>\r\n    \t\t\t\tClass\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Selects a member from a list of candidates, and performs type conversion from actual argument type to formal argument type.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)]\n[System.Runtime.InteropServices.ComVisible(true)]\npublic abstract class Binder</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><span class=\"lang-csharp\">Binder</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Attributes</dt><dd>\r\n  \t\t<div class=\"cdlHolder\">\r\n  \t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.classinterfaceattribute\" title=\"System.Runtime.InteropServices.ClassInterfaceAttribute\" data-linktype=\"relative-path\">ClassInterfaceAttribute</a></span>\r\n  \t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \t<h3 class=\"accented\">Inherited Members</h3>\r\n  \t<h4 class=\"accented\"></h4>\r\n  \t<div class=\"cdlHolder\">\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a></span></div>\r\n  \t</div>\r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following example implements and demonstrates all members of the <code>Binder</code> class. The private method <code>CanConvertFrom</code> finds compatible types for a given type.  </p>\n<pre><code class=\"lang-cpp\" name=\"Binder_1#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Globalization;\nusing namespace System::Runtime::InteropServices;\npublic ref class MyBinder: public Binder\n{\npublic:\n   MyBinder()\n      : Binder()\n   {}\n\nprivate:\n   ref class BinderState\n   {\n   public:\n      array&lt;Object^&gt;^args;\n   };\n\npublic:\n   virtual FieldInfo^ BindToField( BindingFlags bindingAttr, array&lt;FieldInfo^&gt;^match, Object^ value, CultureInfo^ culture ) override\n   {\n      if ( match == nullptr )\n            throw gcnew ArgumentNullException( &quot;match&quot; );\n\n      // Get a field for which the value parameter can be converted to the specified field type.\n      for ( int i = 0; i &lt; match-&gt;Length; i++ )\n         if ( ChangeType( value, match[ i ]-&gt;FieldType, culture ) != nullptr )\n                  return match[ i ];\n\n      return nullptr;\n   }\n\n   virtual MethodBase^ BindToMethod( BindingFlags bindingAttr, array&lt;MethodBase^&gt;^match, array&lt;Object^&gt;^%args, array&lt;ParameterModifier&gt;^ modifiers, CultureInfo^ culture, array&lt;String^&gt;^names, [Out]Object^% state ) override\n   {\n      // Store the arguments to the method in a state Object*.\n      BinderState^ myBinderState = gcnew BinderState;\n      array&lt;Object^&gt;^arguments = gcnew array&lt;Object^&gt;(args-&gt;Length);\n      args-&gt;CopyTo( arguments, 0 );\n      myBinderState-&gt;args = arguments;\n      state = myBinderState;\n      if ( match == nullptr )\n            throw gcnew ArgumentNullException;\n\n      // Find a method that has the same parameters as those of the args parameter.\n      for ( int i = 0; i &lt; match-&gt;Length; i++ )\n      {\n         // Count the number of parameters that match.\n         int count = 0;\n         array&lt;ParameterInfo^&gt;^parameters = match[ i ]-&gt;GetParameters();\n\n         // Go on to the next method if the number of parameters do not match.\n         if ( args-&gt;Length != parameters-&gt;Length )\n                  continue;\n\n         // Match each of the parameters that the user expects the method to have.\n         for ( int j = 0; j &lt; args-&gt;Length; j++ )\n         {\n            // If the names parameter is not 0, then reorder args.\n            if ( names != nullptr )\n            {\n               if ( names-&gt;Length != args-&gt;Length )\n                              throw gcnew ArgumentException( &quot;names and args must have the same number of elements.&quot; );\n\n               for ( int k = 0; k &lt; names-&gt;Length; k++ )\n                  if ( String::Compare( parameters[ j ]-&gt;Name, names[ k ] ) == 0 )\n                                    args[ j ] = myBinderState-&gt;args[ k ];\n            }\n\n            // Determine whether the types specified by the user can be converted to the parameter type.\n            if ( ChangeType( args[ j ], parameters[ j ]-&gt;ParameterType, culture ) != nullptr )\n                        count += 1;\n            else\n                        break;\n         }\n         if ( count == args-&gt;Length )\n                  return match[ i ];\n      }\n      return nullptr;\n   }\n\n   virtual Object^ ChangeType( Object^ value, Type^ myChangeType, CultureInfo^ culture ) override\n   {\n      // Determine whether the value parameter can be converted to a value of type myType.\n      if ( CanConvertFrom( value-&gt;GetType(), myChangeType ) )\n         // Return the converted Object*.\n         return Convert::ChangeType( value, myChangeType ); \n      else\n         return nullptr;\n   }\n\n   virtual void ReorderArgumentArray( array&lt;Object^&gt;^%args, Object^ state ) override\n   {\n      // Return the args that had been reordered by BindToMethod.\n      (safe_cast&lt;BinderState^&gt;(state))-&gt;args-&gt;CopyTo( args, 0 );\n   }\n\n   virtual MethodBase^ SelectMethod( BindingFlags bindingAttr, array&lt;MethodBase^&gt;^match, array&lt;Type^&gt;^types, array&lt;ParameterModifier&gt;^ modifiers ) override\n   {\n      if ( match == nullptr )\n            throw gcnew ArgumentNullException( &quot;match&quot; );\n\n      for ( int i = 0; i &lt; match-&gt;Length; i++ )\n      {\n         // Count the number of parameters that match.\n         int count = 0;\n         array&lt;ParameterInfo^&gt;^parameters = match[ i ]-&gt;GetParameters();\n\n         // Go on to the next method if the number of parameters do not match.\n         if ( types-&gt;Length != parameters-&gt;Length )\n                  continue;\n\n         // Match each of the parameters that the user expects the method to have.\n         for ( int j = 0; j &lt; types-&gt;Length; j++ )\n         {\n            // Determine whether the types specified by the user can be converted to parameter type.\n            if ( CanConvertFrom( types[ j ], parameters[ j ]-&gt;ParameterType ) )\n                        count += 1;\n            else\n                        break;\n         }\n         // Determine whether the method has been found.\n         if ( count == types-&gt;Length )\n                  return match[ i ];\n      }\n      return nullptr;\n   }\n\n   virtual PropertyInfo^ SelectProperty( BindingFlags bindingAttr, array&lt;PropertyInfo^&gt;^match, Type^ returnType, array&lt;Type^&gt;^indexes, array&lt;ParameterModifier&gt;^ modifiers ) override\n   {\n      if ( match == nullptr )\n            throw gcnew ArgumentNullException( &quot;match&quot; );\n\n      for ( int i = 0; i &lt; match-&gt;Length; i++ )\n      {\n         // Count the number of indexes that match.\n         int count = 0;\n         array&lt;ParameterInfo^&gt;^parameters = match[ i ]-&gt;GetIndexParameters();\n\n         // Go on to the next property if the number of indexes do not match.\n         if ( indexes-&gt;Length != parameters-&gt;Length )\n                  continue;\n\n         // Match each of the indexes that the user expects the property to have.\n         for ( int j = 0; j &lt; indexes-&gt;Length; j++ )\n            // Determine whether the types specified by the user can be converted to index type.\n            if ( CanConvertFrom( indexes[ j ], parameters[ j ]-&gt;ParameterType ) )\n                        count += 1;\n            else\n                        break;\n\n         // Determine whether the property has been found.\n         if ( count == indexes-&gt;Length )\n         {\n            // Determine whether the return type can be converted to the properties type.\n            if ( CanConvertFrom( returnType, match[ i ]-&gt;PropertyType ) )\n                  return match[ i ];\n            else\n                  continue;\n         }\n      }\n      return nullptr;\n   }\n\nprivate:\n\n   // Determines whether type1 can be converted to type2. Check only for primitive types.\n   bool CanConvertFrom( Type^ type1, Type^ type2 )\n   {\n      if ( type1-&gt;IsPrimitive &amp;&amp; type2-&gt;IsPrimitive )\n      {\n         TypeCode typeCode1 = Type::GetTypeCode( type1 );\n         TypeCode typeCode2 = Type::GetTypeCode( type2 );\n\n         // If both type1 and type2 have the same type, return true.\n         if ( typeCode1 == typeCode2 )\n                  return true;\n\n         // Possible conversions from Char follow.\n         if ( typeCode1 == TypeCode::Char )\n         {\n            switch ( typeCode2 )\n            {\n               case TypeCode::UInt16:\n                  return true;\n\n               case TypeCode::UInt32:\n                  return true;\n\n               case TypeCode::Int32:\n                  return true;\n\n               case TypeCode::UInt64:\n                  return true;\n\n               case TypeCode::Int64:\n                  return true;\n\n               case TypeCode::Single:\n                  return true;\n\n               case TypeCode::Double:\n                  return true;\n\n               default:\n                  return false;\n            }\n         }\n\n         // Possible conversions from Byte follow.\n         if ( typeCode1 == TypeCode::Byte )\n         {\n            switch ( typeCode2 )\n            {\n               case TypeCode::Char:\n                  return true;\n\n               case TypeCode::UInt16:\n                  return true;\n\n               case TypeCode::Int16:\n                  return true;\n\n               case TypeCode::UInt32:\n                  return true;\n\n               case TypeCode::Int32:\n                  return true;\n\n               case TypeCode::UInt64:\n                  return true;\n\n               case TypeCode::Int64:\n                  return true;\n\n               case TypeCode::Single:\n                  return true;\n\n               case TypeCode::Double:\n                  return true;\n\n               default:\n                  return false;\n            }\n         }\n\n         // Possible conversions from SByte follow.\n         if ( typeCode1 == TypeCode::SByte )\n         {\n            switch ( typeCode2 )\n            {\n               case TypeCode::Int16:\n                  return true;\n\n               case TypeCode::Int32:\n                  return true;\n\n               case TypeCode::Int64:\n                  return true;\n\n               case TypeCode::Single:\n                  return true;\n\n               case TypeCode::Double:\n                  return true;\n\n               default:\n                  return false;\n            }\n         }\n\n         // Possible conversions from UInt16 follow.\n         if ( typeCode1 == TypeCode::UInt16 )\n         {\n            switch ( typeCode2 )\n            {\n               case TypeCode::UInt32:\n                  return true;\n\n               case TypeCode::Int32:\n                  return true;\n\n               case TypeCode::UInt64:\n                  return true;\n\n               case TypeCode::Int64:\n                  return true;\n\n               case TypeCode::Single:\n                  return true;\n\n               case TypeCode::Double:\n                  return true;\n\n               default:\n                  return false;\n            }\n         }\n\n         // Possible conversions from Int16 follow.\n         if ( typeCode1 == TypeCode::Int16 )\n         {\n            switch ( typeCode2 )\n            {\n               case TypeCode::Int32:\n                  return true;\n\n               case TypeCode::Int64:\n                  return true;\n\n               case TypeCode::Single:\n                  return true;\n\n               case TypeCode::Double:\n                  return true;\n\n               default:\n                  return false;\n            }\n         }\n\n         // Possible conversions from UInt32 follow.\n         if ( typeCode1 == TypeCode::UInt32 )\n         {\n            switch ( typeCode2 )\n            {\n               case TypeCode::UInt64:\n                  return true;\n\n               case TypeCode::Int64:\n                  return true;\n\n               case TypeCode::Single:\n                  return true;\n\n               case TypeCode::Double:\n                  return true;\n\n               default:\n                  return false;\n            }\n         }\n\n         // Possible conversions from Int32 follow.\n         if ( typeCode1 == TypeCode::Int32 )\n         {\n            switch ( typeCode2 )\n            {\n               case TypeCode::Int64:\n                  return true;\n\n               case TypeCode::Single:\n                  return true;\n\n               case TypeCode::Double:\n                  return true;\n\n               default:\n                  return false;\n            }\n         }\n\n         // Possible conversions from UInt64 follow.\n         if ( typeCode1 == TypeCode::UInt64 )\n         {\n            switch ( typeCode2 )\n            {\n               case TypeCode::Single:\n                  return true;\n\n               case TypeCode::Double:\n                  return true;\n\n               default:\n                  return false;\n            }\n         }\n\n         // Possible conversions from Int64 follow.\n         if ( typeCode1 == TypeCode::Int64 )\n         {\n            switch ( typeCode2 )\n            {\n               case TypeCode::Single:\n                  return true;\n\n               case TypeCode::Double:\n                  return true;\n\n               default:\n                  return false;\n            }\n         }\n\n         // Possible conversions from Single follow.\n         if ( typeCode1 == TypeCode::Single )\n         {\n            switch ( typeCode2 )\n            {\n               case TypeCode::Double:\n                  return true;\n\n               default:\n                  return false;\n            }\n         }\n      }\n\n      return false;\n   }\n\n};\n\npublic ref class MyClass1\n{\npublic:\n   short myFieldB;\n   int myFieldA;\n   void MyMethod( long i, char k )\n   {\n      Console::WriteLine( &quot;\\nThis is MyMethod(long i, char k)&quot; );\n   }\n\n   void MyMethod( long i, long j )\n   {\n      Console::WriteLine( &quot;\\nThis is MyMethod(long i, long j)&quot; );\n   }\n};\n\nint main()\n{\n   // Get the type of MyClass1.\n   Type^ myType = MyClass1::typeid;\n\n   // Get the instance of MyClass1.\n   MyClass1^ myInstance = gcnew MyClass1;\n   Console::WriteLine( &quot;\\nDisplaying the results of using the MyBinder binder.\\n&quot; );\n\n   // Get the method information for MyMethod.\n   array&lt;Type^&gt;^types = {short::typeid,short::typeid};\n   MethodInfo^ myMethod = myType-&gt;GetMethod( &quot;MyMethod&quot;, static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Instance), gcnew MyBinder, types, nullptr );\n   Console::WriteLine( myMethod );\n\n   // Invoke MyMethod.\n   array&lt;Object^&gt;^obj = {32,32};\n   myMethod-&gt;Invoke( myInstance, BindingFlags::InvokeMethod, gcnew MyBinder, obj, CultureInfo::CurrentCulture );\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Binder_1#1\">Imports System\nImports System.Reflection\nImports System.Globalization\nImports Microsoft.VisualBasic\n\nPublic Class MyBinder\n    Inherits Binder\n    Public Sub New()\n        MyBase.new()\n    End Sub &#39;New\n    Private Class BinderState\n        Public args() As Object\n    End Class &#39;BinderState\n\n    Public Overrides Function BindToField(ByVal bindingAttr As BindingFlags, ByVal match() As FieldInfo, ByVal value As Object, ByVal culture As CultureInfo) As FieldInfo\n        If match Is Nothing Then\n            Throw New ArgumentNullException(&quot;match&quot;)\n        End If\n        &#39; Get a field for which the value parameter can be converted to the specified field type.\n        Dim i As Integer\n        For i = 0 To match.Length - 1\n            If Not (ChangeType(value, match(i).FieldType, culture) Is Nothing) Then\n                Return match(i)\n            End If\n        Next i\n        Return Nothing\n    End Function &#39;BindToField\n\n    Public Overrides Function BindToMethod(ByVal bindingAttr As BindingFlags, ByVal match() As MethodBase, ByRef args() As Object, ByVal modifiers() As ParameterModifier, ByVal culture As CultureInfo, ByVal names() As String, ByRef state As Object) As MethodBase\n        &#39; Store the arguments to the method in a state object.\n        Dim myBinderState As New BinderState()\n        Dim arguments() As Object = New [Object](args.Length) {}\n        args.CopyTo(arguments, 0)\n        myBinderState.args = arguments\n        state = myBinderState\n\n        If match Is Nothing Then\n            Throw New ArgumentNullException()\n        End If\n        &#39; Find a method that has the same parameters as those of args.\n        Dim i As Integer\n        For i = 0 To match.Length - 1\n            &#39; Count the number of parameters that match.\n            Dim count As Integer = 0\n            Dim parameters As ParameterInfo() = match(i).GetParameters()\n            &#39; Go on to the next method if the number of parameters do not match.\n            If args.Length &lt;&gt; parameters.Length Then\n                GoTo ContinueFori\n            End If\n            &#39; Match each of the parameters that the user expects the method to have.\n            Dim j As Integer\n            For j = 0 To args.Length - 1\n                &#39; If names is not null, then reorder args.\n                If Not (names Is Nothing) Then\n                    If names.Length &lt;&gt; args.Length Then\n                        Throw New ArgumentException(&quot;names and args must have the same number of elements.&quot;)\n                    End If\n                    Dim k As Integer\n                    For k = 0 To names.Length - 1\n                        If String.Compare(parameters(j).Name, names(k).ToString()) = 0 Then\n                            args(j) = myBinderState.args(k)\n                        End If\n                    Next k\n                End If &#39; Determine whether the types specified by the user can be converted to parameter type.\n                If Not (ChangeType(args(j), parameters(j).ParameterType, culture) Is Nothing) Then\n                    count += 1\n                Else\n                    Exit For\n                End If\n            Next j\n            &#39; Determine whether the method has been found.\n            If count = args.Length Then\n                Return match(i)\n            End If\nContinueFori:\n        Next i\n        Return Nothing\n    End Function &#39;BindToMethod\n\n    Public Overrides Function ChangeType(ByVal value As Object, ByVal myChangeType As Type, ByVal culture As CultureInfo) As Object\n        &#39; Determine whether the value parameter can be converted to a value of type myType.\n        If CanConvertFrom(value.GetType(), myChangeType) Then\n            &#39; Return the converted object.\n            Return Convert.ChangeType(value, myChangeType)\n            &#39; Return null.\n        Else\n            Return Nothing\n        End If\n    End Function &#39;ChangeType\n\n    Public Overrides Sub ReorderArgumentArray(ByRef args() As Object, ByVal state As Object)\n        &#39;Redimension the array to hold the state values.\n        ReDim args(CType(state, BinderState).args.Length)\n        &#39; Return the args that had been reordered by BindToMethod.\n        CType(state, BinderState).args.CopyTo(args, 0)\n    End Sub &#39;ReorderArgumentArray\n\n    Public Overrides Function SelectMethod(ByVal bindingAttr As BindingFlags, ByVal match() As MethodBase, ByVal types() As Type, ByVal modifiers() As ParameterModifier) As MethodBase\n        If match Is Nothing Then\n            Throw New ArgumentNullException(&quot;match&quot;)\n        End If\n        Dim i As Integer\n        For i = 0 To match.Length - 1\n            &#39; Count the number of parameters that match.\n            Dim count As Integer = 0\n            Dim parameters As ParameterInfo() = match(i).GetParameters()\n            &#39; Go on to the next method if the number of parameters do not match.\n            If types.Length &lt;&gt; parameters.Length Then\n                GoTo ContinueFori\n            End If\n            &#39; Match each of the parameters that the user expects the method to have.\n            Dim j As Integer\n            For j = 0 To types.Length - 1\n                &#39; Determine whether the types specified by the user can be converted to parameter type.\n                If CanConvertFrom(types(j), parameters(j).ParameterType) Then\n                    count += 1\n                Else\n                    Exit For\n                End If\n            Next j &#39; Determine whether the method has been found.\n            If count = types.Length Then\n                Return match(i)\n            End If\nContinueFori:\n        Next i\n        Return Nothing\n    End Function &#39;SelectMethod\n    Public Overrides Function SelectProperty(ByVal bindingAttr As BindingFlags, ByVal match() As PropertyInfo, ByVal returnType As Type, ByVal indexes() As Type, ByVal modifiers() As ParameterModifier) As PropertyInfo\n        If match Is Nothing Then\n            Throw New ArgumentNullException(&quot;match&quot;)\n        End If\n        Dim i As Integer\n        For i = 0 To match.Length - 1\n            &#39; Count the number of indexes that match.\n            Dim count As Integer = 0\n            Dim parameters As ParameterInfo() = match(i).GetIndexParameters()\n\n            &#39; Go on to the next property if the number of indexes do not match.\n            If indexes.Length &lt;&gt; parameters.Length Then\n                GoTo ContinueFori\n            End If\n            &#39; Match each of the indexes that the user expects the property to have.\n            Dim j As Integer\n            For j = 0 To indexes.Length - 1\n                &#39; Determine whether the types specified by the user can be converted to index type.\n                If CanConvertFrom(indexes(j), parameters(j).ParameterType) Then\n                    count += 1\n                Else\n                    Exit For\n                End If\n            Next j &#39; Determine whether the property has been found.\n            If count = indexes.Length Then\n                &#39; Determine whether the return type can be converted to the properties type.\n                If CanConvertFrom(returnType, match(i).PropertyType) Then\n                    Return match(i)\n                Else\n                    GoTo ContinueFori\n                End If\n            End If\nContinueFori:\n        Next i\n        Return Nothing\n    End Function &#39;SelectProperty\n\n    &#39; Determine whether type1 can be converted to type2. Check only for primitive types.\n    Private Function CanConvertFrom(ByVal type1 As Type, ByVal type2 As Type) As Boolean\n        If type1.IsPrimitive And type2.IsPrimitive Then\n            Dim typeCode1 As TypeCode = Type.GetTypeCode(type1)\n            Dim typeCode2 As TypeCode = Type.GetTypeCode(type2)\n            &#39; If both type1 and type2 have same type, return true.\n            If typeCode1 = typeCode2 Then\n                Return True\n            End If &#39; Possible conversions from Char follow.\n            If typeCode1 = TypeCode.Char Then\n                Select Case typeCode2\n                    Case TypeCode.UInt16\n                        Return True\n                    Case TypeCode.UInt32\n                        Return True\n                    Case TypeCode.Int32\n                        Return True\n                    Case TypeCode.UInt64\n                        Return True\n                    Case TypeCode.Int64\n                        Return True\n                    Case TypeCode.Single\n                        Return True\n                    Case TypeCode.Double\n                        Return True\n                    Case Else\n                        Return False\n                End Select\n            End If &#39; Possible conversions from Byte follow.\n            If typeCode1 = TypeCode.Byte Then\n                Select Case typeCode2\n                    Case TypeCode.Char\n                        Return True\n                    Case TypeCode.UInt16\n                        Return True\n                    Case TypeCode.Int16\n                        Return True\n                    Case TypeCode.UInt32\n                        Return True\n                    Case TypeCode.Int32\n                        Return True\n                    Case TypeCode.UInt64\n                        Return True\n                    Case TypeCode.Int64\n                        Return True\n                    Case TypeCode.Single\n                        Return True\n                    Case TypeCode.Double\n                        Return True\n                    Case Else\n                        Return False\n                End Select\n            End If &#39; Possible conversions from SByte follow.\n            If typeCode1 = TypeCode.SByte Then\n                Select Case typeCode2\n                    Case TypeCode.Int16\n                        Return True\n                    Case TypeCode.Int32\n                        Return True\n                    Case TypeCode.Int64\n                        Return True\n                    Case TypeCode.Single\n                        Return True\n                    Case TypeCode.Double\n                        Return True\n                    Case Else\n                        Return False\n                End Select\n            End If &#39; Possible conversions from UInt16 follow.\n            If typeCode1 = TypeCode.UInt16 Then\n                Select Case typeCode2\n                    Case TypeCode.UInt32\n                        Return True\n                    Case TypeCode.Int32\n                        Return True\n                    Case TypeCode.UInt64\n                        Return True\n                    Case TypeCode.Int64\n                        Return True\n                    Case TypeCode.Single\n                        Return True\n                    Case TypeCode.Double\n                        Return True\n                    Case Else\n                        Return False\n                End Select\n            End If &#39; Possible conversions from Int16 follow.\n            If typeCode1 = TypeCode.Int16 Then\n                Select Case typeCode2\n                    Case TypeCode.Int32\n                        Return True\n                    Case TypeCode.Int64\n                        Return True\n                    Case TypeCode.Single\n                        Return True\n                    Case TypeCode.Double\n                        Return True\n                    Case Else\n                        Return False\n                End Select\n            End If &#39; Possible conversions from UInt32 follow.\n            If typeCode1 = TypeCode.UInt32 Then\n                Select Case typeCode2\n                    Case TypeCode.UInt64\n                        Return True\n                    Case TypeCode.Int64\n                        Return True\n                    Case TypeCode.Single\n                        Return True\n                    Case TypeCode.Double\n                        Return True\n                    Case Else\n                        Return False\n                End Select\n            End If &#39; Possible conversions from Int32 follow.\n            If typeCode1 = TypeCode.Int32 Then\n                Select Case typeCode2\n                    Case TypeCode.Int64\n                        Return True\n                    Case TypeCode.Single\n                        Return True\n                    Case TypeCode.Double\n                        Return True\n                    Case Else\n                        Return False\n                End Select\n            End If &#39; Possible conversions from UInt64 follow.\n            If typeCode1 = TypeCode.UInt64 Then\n                Select Case typeCode2\n                    Case TypeCode.Single\n                        Return True\n                    Case TypeCode.Double\n                        Return True\n                    Case Else\n                        Return False\n                End Select\n            End If &#39; Possible conversions from Int64 follow.\n            If typeCode1 = TypeCode.Int64 Then\n                Select Case typeCode2\n                    Case TypeCode.Single\n                        Return True\n                    Case TypeCode.Double\n                        Return True\n                    Case Else\n                        Return False\n                End Select\n            End If &#39; Possible conversions from Single follow.\n            If typeCode1 = TypeCode.Single Then\n                Select Case typeCode2\n                    Case TypeCode.Double\n                        Return True\n                    Case Else\n                        Return False\n                End Select\n            End If\n        End If\n        Return False\n    End Function &#39;CanConvertFrom\nEnd Class &#39;MyBinder\n\n\nPublic Class MyClass1\n    Public myFieldB As Short\n    Public myFieldA As Integer\n\n    Public Overloads Sub MyMethod(ByVal i As Long, ByVal k As Char)\n        Console.WriteLine(ControlChars.NewLine &amp; &quot;This is MyMethod(long i, char k).&quot;)\n    End Sub &#39;MyMethod\n\n    Public Overloads Sub MyMethod(ByVal i As Long, ByVal j As Long)\n        Console.WriteLine(ControlChars.NewLine &amp; &quot;This is MyMethod(long i, long j).&quot;)\n    End Sub &#39;MyMethod\nEnd Class &#39;MyClass1\n\n\nPublic Class Binder_Example\n    Public Shared Sub Main()\n        &#39; Get the type of MyClass1.\n        Dim myType As Type = GetType(MyClass1)\n        &#39; Get the instance of MyClass1.\n        Dim myInstance As New MyClass1()\n        Console.WriteLine(ControlChars.Cr &amp; &quot;Displaying the results of using the MyBinder binder.&quot;)\n        Console.WriteLine()\n        &#39; Get the method information for MyMethod.\n        Dim myMethod As MethodInfo = myType.GetMethod(&quot;MyMethod&quot;, BindingFlags.Public Or BindingFlags.Instance, New MyBinder(), New Type() {GetType(Short), GetType(Short)}, Nothing)\n        Console.WriteLine(MyMethod)\n        &#39; Invoke MyMethod.\n        myMethod.Invoke(myInstance, BindingFlags.InvokeMethod, New MyBinder(), New [Object]() {CInt(32), CInt(32)}, CultureInfo.CurrentCulture)\n    End Sub &#39;Main\nEnd Class &#39;Binder_Example\n</code></pre><pre><code class=\"lang-cs\" name=\"Binder_1#1\">using System;\nusing System.Reflection;\nusing System.Globalization;\n\npublic class MyBinder : Binder \n{\n    public MyBinder() : base()\n    {\n    }\n    private class BinderState\n    {\n        public object[] args;\n    }\n    public override FieldInfo BindToField(\n        BindingFlags bindingAttr,\n        FieldInfo[] match,\n        object value,\n        CultureInfo culture\n        )\n    {\n        if(match == null)\n            throw new ArgumentNullException(&quot;match&quot;);\n        // Get a field for which the value parameter can be converted to the specified field type.\n        for(int i = 0; i &lt; match.Length; i++)\n            if(ChangeType(value, match[i].FieldType, culture) != null)\n                return match[i];\n        return null;\n    }\n    public override MethodBase BindToMethod(\n        BindingFlags bindingAttr,\n        MethodBase[] match,\n        ref object[] args,\n        ParameterModifier[] modifiers,\n        CultureInfo culture,\n        string[] names,\n        out object state\n        )\n    {\n        // Store the arguments to the method in a state object.\n        BinderState myBinderState = new BinderState();\n        object[] arguments = new Object[args.Length];\n        args.CopyTo(arguments, 0);\n        myBinderState.args = arguments;\n        state = myBinderState;\n        if(match == null)\n            throw new ArgumentNullException();\n        // Find a method that has the same parameters as those of the args parameter.\n        for(int i = 0; i &lt; match.Length; i++)\n        {\n            // Count the number of parameters that match.\n            int count = 0;\n            ParameterInfo[] parameters = match[i].GetParameters();\n            // Go on to the next method if the number of parameters do not match.\n            if(args.Length != parameters.Length)\n                continue;\n            // Match each of the parameters that the user expects the method to have.\n            for(int j = 0; j &lt; args.Length; j++)\n            {\n                // If the names parameter is not null, then reorder args.\n                if(names != null)\n                {\n                    if(names.Length != args.Length)\n                        throw new ArgumentException(&quot;names and args must have the same number of elements.&quot;);\n                    for(int k = 0; k &lt; names.Length; k++)\n                        if(String.Compare(parameters[j].Name, names[k].ToString()) == 0)\n                            args[j] = myBinderState.args[k];\n                }\n                // Determine whether the types specified by the user can be converted to the parameter type.\n                if(ChangeType(args[j], parameters[j].ParameterType, culture) != null)\n                    count += 1;\n                else\n                    break;\n            }\n            // Determine whether the method has been found.\n            if(count == args.Length)\n                return match[i];\n        }\n        return null;\n    }\n    public override object ChangeType(\n        object value,\n        Type myChangeType,\n        CultureInfo culture\n        )\n    {\n        // Determine whether the value parameter can be converted to a value of type myType.\n        if(CanConvertFrom(value.GetType(), myChangeType))\n            // Return the converted object.\n            return Convert.ChangeType(value, myChangeType);\n        else\n            // Return null.\n            return null;\n    }\n    public override void ReorderArgumentArray(\n        ref object[] args,\n        object state\n        )\n    {\n        // Return the args that had been reordered by BindToMethod.\n        ((BinderState)state).args.CopyTo(args, 0);\n    }\n    public override MethodBase SelectMethod(\n        BindingFlags bindingAttr,\n        MethodBase[] match,\n        Type[] types,\n        ParameterModifier[] modifiers\n        )\n    {\n        if(match == null)\n            throw new ArgumentNullException(&quot;match&quot;);\n        for(int i = 0; i &lt; match.Length; i++)\n        {\n            // Count the number of parameters that match.\n            int count = 0; \n            ParameterInfo[] parameters = match[i].GetParameters();\n            // Go on to the next method if the number of parameters do not match.\n            if(types.Length != parameters.Length)\n                continue;\n            // Match each of the parameters that the user expects the method to have.\n            for(int j = 0; j &lt; types.Length; j++)\n                // Determine whether the types specified by the user can be converted to parameter type.\n                if(CanConvertFrom(types[j], parameters[j].ParameterType))\n                    count += 1;\n                else\n                    break;\n            // Determine whether the method has been found.\n            if(count == types.Length)\n                return match[i];\n        }\n        return null;\n    }\n    public override PropertyInfo SelectProperty(\n        BindingFlags bindingAttr,\n        PropertyInfo[] match,\n        Type returnType,\n        Type[] indexes,\n        ParameterModifier[] modifiers\n        )\n    {\n        if(match == null)\n            throw new ArgumentNullException(&quot;match&quot;);\n        for(int i = 0; i &lt; match.Length; i++)\n        {\n            // Count the number of indexes that match.\n            int count = 0;\n            ParameterInfo[] parameters = match[i].GetIndexParameters();\n            // Go on to the next property if the number of indexes do not match.\n            if(indexes.Length != parameters.Length)\n                continue;\n            // Match each of the indexes that the user expects the property to have.\n            for(int j = 0; j &lt; indexes.Length; j++)\n                // Determine whether the types specified by the user can be converted to index type.\n                if(CanConvertFrom(indexes[j], parameters[j].ParameterType))\n                    count += 1;\n                else\n                    break;\n            // Determine whether the property has been found.\n            if(count == indexes.Length)\n                // Determine whether the return type can be converted to the properties type.\n                if(CanConvertFrom(returnType, match[i].PropertyType))\n                    return match[i];\n                else\n                    continue;\n        }\n        return null;\n    }\n    // Determines whether type1 can be converted to type2. Check only for primitive types.\n    private bool CanConvertFrom(Type type1, Type type2)\n    {\n        if(type1.IsPrimitive &amp;&amp; type2.IsPrimitive)\n        {\n            TypeCode typeCode1 = Type.GetTypeCode(type1);\n            TypeCode typeCode2 = Type.GetTypeCode(type2);\n            // If both type1 and type2 have the same type, return true.\n            if(typeCode1 == typeCode2)\n                return true;\n            // Possible conversions from Char follow.\n            if(typeCode1 == TypeCode.Char)\n                switch(typeCode2)\n                {\n                    case TypeCode.UInt16 : return true;\n                    case TypeCode.UInt32 : return true;\n                    case TypeCode.Int32  : return true;\n                    case TypeCode.UInt64 : return true;\n                    case TypeCode.Int64  : return true;\n                    case TypeCode.Single : return true;\n                    case TypeCode.Double : return true;\n                    default              : return false;\n                }\n            // Possible conversions from Byte follow.\n            if(typeCode1 == TypeCode.Byte)\n                switch(typeCode2)\n                {\n                    case TypeCode.Char   : return true;\n                    case TypeCode.UInt16 : return true;\n                    case TypeCode.Int16  : return true;\n                    case TypeCode.UInt32 : return true;\n                    case TypeCode.Int32  : return true;\n                    case TypeCode.UInt64 : return true;\n                    case TypeCode.Int64  : return true;\n                    case TypeCode.Single : return true;\n                    case TypeCode.Double : return true;\n                    default              : return false;\n                }\n            // Possible conversions from SByte follow.\n            if(typeCode1 == TypeCode.SByte)\n                switch(typeCode2)\n                {\n                    case TypeCode.Int16  : return true;\n                    case TypeCode.Int32  : return true;\n                    case TypeCode.Int64  : return true;\n                    case TypeCode.Single : return true;\n                    case TypeCode.Double : return true;\n                    default              : return false;\n                }\n            // Possible conversions from UInt16 follow.\n            if(typeCode1 == TypeCode.UInt16)\n                switch(typeCode2)\n                {\n                    case TypeCode.UInt32 : return true;\n                    case TypeCode.Int32  : return true;\n                    case TypeCode.UInt64 : return true;\n                    case TypeCode.Int64  : return true;\n                    case TypeCode.Single : return true;\n                    case TypeCode.Double : return true;\n                    default              : return false;\n                }\n            // Possible conversions from Int16 follow.\n            if(typeCode1 == TypeCode.Int16)\n                switch(typeCode2)\n                {\n                    case TypeCode.Int32  : return true;\n                    case TypeCode.Int64  : return true;\n                    case TypeCode.Single : return true;\n                    case TypeCode.Double : return true;\n                    default              : return false;\n                }\n            // Possible conversions from UInt32 follow.\n            if(typeCode1 == TypeCode.UInt32)\n                switch(typeCode2)\n                {\n                    case TypeCode.UInt64 : return true;\n                    case TypeCode.Int64  : return true;\n                    case TypeCode.Single : return true;\n                    case TypeCode.Double : return true;\n                    default              : return false;\n                }\n            // Possible conversions from Int32 follow.\n            if(typeCode1 == TypeCode.Int32)\n                switch(typeCode2)\n                {\n                    case TypeCode.Int64  : return true;\n                    case TypeCode.Single : return true;\n                    case TypeCode.Double : return true;\n                    default              : return false;\n                }\n            // Possible conversions from UInt64 follow.\n            if(typeCode1 == TypeCode.UInt64)\n                switch(typeCode2)\n                {\n                    case TypeCode.Single : return true;\n                    case TypeCode.Double : return true;\n                    default              : return false;\n                }\n            // Possible conversions from Int64 follow.\n            if(typeCode1 == TypeCode.Int64)\n                switch(typeCode2)\n                {\n                    case TypeCode.Single : return true;\n                    case TypeCode.Double : return true;\n                    default              : return false;\n                }\n            // Possible conversions from Single follow.\n            if(typeCode1 == TypeCode.Single)\n                switch(typeCode2)\n                {\n                    case TypeCode.Double : return true;\n                    default              : return false;\n                }\n        }\n        return false;\n    }\n}\npublic class MyClass1\n{\n    public short myFieldB;\n    public int myFieldA; \n    public void MyMethod(long i, char k)\n    {\n        Console.WriteLine(&quot;\\nThis is MyMethod(long i, char k)&quot;);\n    }\n    public void MyMethod(long i, long j)\n    {\n        Console.WriteLine(&quot;\\nThis is MyMethod(long i, long j)&quot;);\n    }\n}\npublic class Binder_Example\n{\n    public static void Main()\n    {\n        // Get the type of MyClass1.\n        Type myType = typeof(MyClass1);\n        // Get the instance of MyClass1.\n        MyClass1 myInstance = new MyClass1();\n        Console.WriteLine(&quot;\\nDisplaying the results of using the MyBinder binder.\\n&quot;);\n        // Get the method information for MyMethod.\n        MethodInfo myMethod = myType.GetMethod(&quot;MyMethod&quot;, BindingFlags.Public | BindingFlags.Instance,\n            new MyBinder(), new Type[] {typeof(short), typeof(short)}, null);\n        Console.WriteLine(myMethod);\n        // Invoke MyMethod.\n        myMethod.Invoke(myInstance, BindingFlags.InvokeMethod, new MyBinder(), new Object[] {(int)32, (int)32}, CultureInfo.CurrentCulture);\n    }\n}\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>Implementations of the Binder class are used by methods such as <a class=\"xref\" href=\"system.type#System_Type_InvokeMember_\" data-linktype=\"relative-path\">InvokeMember</a>, which selects from a set of possible members to execute, based on a set of parameter types and argument values; <a class=\"xref\" href=\"system.type#System_Type_GetMethod_\" data-linktype=\"relative-path\">GetMethod</a>, which selects a method based on parameter types; and so on.  </p>\n<p> A default implementation of the Binder class is provided by the <a class=\"xref\" href=\"system.type#System_Type_DefaultBinder_\" data-linktype=\"relative-path\">DefaultBinder</a> property.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Constructors\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Reflection_Binder__ctor_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Reflection_Binder__ctor\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Binder()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Initializes a new instance of the <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a> class.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">protected Binder ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.classinterfaceattribute\" title=\"System.Runtime.InteropServices.ClassInterfaceAttribute\" data-linktype=\"relative-path\">ClassInterfaceAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This constructor is called by the constructors of derived classes, to initialize state in this type.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Methods\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Reflection_Binder_BindToField_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Reflection_Binder_BindToField_System_Reflection_BindingFlags_System_Reflection_FieldInfo___System_Object_System_Globalization_CultureInfo_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">BindToField(BindingFlags, FieldInfo[], Object, CultureInfo)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Selects a field from the given set of fields, based on the specified criteria.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public abstract System.Reflection.FieldInfo BindToField (System.Reflection.BindingFlags bindingAttr, System.Reflection.FieldInfo[] match, object value, System.Globalization.CultureInfo culture);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>bindingAttr</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A bitwise combination of <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> values.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>match</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.fieldinfo\" data-linktype=\"relative-path\">FieldInfo</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The set of fields that are candidates for matching. For example, when a <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a> object is used by <span class=\"xref\">stem.Type.InvokeMember*</span>, this parameter specifies the set of fields that reflection has determined to be possible matches, typically because they have the correct member name. The default implementation provided by <span class=\"xref\">stem.Type.DefaultBinder*</span> changes the order of this array.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The field value used to locate a matching field.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>culture</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An instance of <a class=\"xref\" href=\"system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a> that is used to control the coercion of data types, in binder implementations that coerce types. If <code>culture</code> is <code>null</code>, the <a class=\"xref\" href=\"system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a> for the current thread is used.  </p>\n<p> Note   For example, if a binder implementation allows coercion of string values to numeric types, this parameter is necessary to convert a <code>String</code> that represents 1000 to a <code>Double</code> value, because 1000 is represented differently by different cultures. The default binder does not do such string coercions.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.fieldinfo\" data-linktype=\"relative-path\">FieldInfo</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>The matching field.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.classinterfaceattribute\" title=\"System.Runtime.InteropServices.ClassInterfaceAttribute\" data-linktype=\"relative-path\">ClassInterfaceAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>For the default binder, <code>bindingAttr</code> includes <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a>, and <code>match</code> contains multiple fields that are equally good matches for <code>value</code>. For example, <code>value</code> contains a <code>MyClass</code> object that implements the <code>IMyClass</code> interface, and <code>match</code> contains a field of type <code>MyClass</code> and a field of type <code>IMyClass</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.missingfieldexception\" data-linktype=\"relative-path\">MissingFieldException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>For the default binder, <code>bindingAttr</code> includes <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a>, and <code>match</code> contains no fields that can accept <code>value</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>For the default binder, <code>bindingAttr</code> includes <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a>, and <code>match</code> is <code>null</code> or an empty array.  </p>\n<p> -or-  </p>\n<p> <code>bindingAttr</code> includes <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a>, and <code>value</code> is <code>null</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>If <code>bindingAttr</code> does not include <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a>, the default binder implementation provided by <a class=\"xref\" href=\"system.type#System_Type_DefaultBinder_\" data-linktype=\"relative-path\">DefaultBinder</a> simply returns the first element of <code>match</code>. No selection is done.  </p>\n<p> This method controls the binding provided by <a class=\"xref\" href=\"system.type#System_Type_InvokeMember_\" data-linktype=\"relative-path\">InvokeMember</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Reflection_Binder_BindToMethod_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Reflection_Binder_BindToMethod_System_Reflection_BindingFlags_System_Reflection_MethodBase___System_Object____System_Reflection_ParameterModifier___System_Globalization_CultureInfo_System_String___System_Object__\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">BindToMethod(BindingFlags, MethodBase[], Object[], ParameterModifier[], CultureInfo, String[], Object)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Selects a method to invoke from the given set of methods, based on the supplied arguments.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public abstract System.Reflection.MethodBase BindToMethod (System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, ref object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] names, out object state);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>bindingAttr</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A bitwise combination of <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> values.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>match</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The set of methods that are candidates for matching. For example, when a <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a> object is used by <span class=\"xref\">stem.Type.InvokeMember*</span>, this parameter specifies the set of methods that reflection has determined to be possible matches, typically because they have the correct member name. The default implementation provided by <span class=\"xref\">stem.Type.DefaultBinder*</span> changes the order of this array.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>args</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The arguments that are passed in. The binder can change the order of the arguments in this array; for example, the default binder changes the order of arguments if the <code>names</code> parameter is used to specify an order other than positional order. If a binder implementation coerces argument types, the types and values of the arguments can be changed as well.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>modifiers</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An array of parameter modifiers that enable binding to work with parameter signatures in which the types have been modified. The default binder implementation does not use this parameter.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>culture</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An instance of <a class=\"xref\" href=\"system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a> that is used to control the coercion of data types, in binder implementations that coerce types. If <code>culture</code> is <code>null</code>, the <a class=\"xref\" href=\"system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a> for the current thread is used.  </p>\n<p> Note   For example, if a binder implementation allows coercion of string values to numeric types, this parameter is necessary to convert a <code>String</code> that represents 1000 to a <code>Double</code> value, because 1000 is represented differently by different cultures. The default binder does not do such string coercions.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>names</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The parameter names, if parameter names are to be considered when matching, or <code>null</code> if arguments are to be treated as purely positional. For example, parameter names must be used if arguments are not supplied in positional order.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>state</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>After the method returns, <code>state</code> contains a binder-provided object that keeps track of argument reordering. The binder creates this object, and the binder is the sole consumer of this object. If <code>state</code> is not <code>null</code> when <code>BindToMethod</code> returns, you must pass <code>state</code> to the <span class=\"xref\">stem.Reflection.Binder.ReorderArgumentArray*</span> method if you want to restore <code>args</code> to its original order, for example, so that you can retrieve the values of <code>ref</code> parameters (<code>ByRef</code> parameters in Visual Basic).</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>The matching method.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.classinterfaceattribute\" title=\"System.Runtime.InteropServices.ClassInterfaceAttribute\" data-linktype=\"relative-path\">ClassInterfaceAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>For the default binder, <code>match</code> contains multiple methods that are equally good matches for <code>args</code>. For example, <code>args</code> contains a <code>MyClass</code> object that implements the <code>IMyClass</code> interface, and <code>match</code> contains a method that takes <code>MyClass</code> and a method that takes <code>IMyClass</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.missingmethodexception\" data-linktype=\"relative-path\">MissingMethodException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>For the default binder, <code>match</code> contains no methods that can accept the arguments supplied in <code>args</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>For the default binder, <code>match</code> is <code>null</code> or an empty array.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The default binder takes into account both parameters that have values and <code>params</code> arrays (<code>ParamArray</code> arrays in Visual Basic). Thus, it is possible to find a match in cases where <code>args</code> and <code>match</code> do not contain the same number of elements.  </p>\n<p> The binder enables a client to map the array of arguments back to its original form if the argument array has been manipulated by BindToMethod. Use this remap capability to get back by-reference arguments when such arguments are present. When you pass arguments by name, the binder reorders the argument array. The <code>state</code> parameter keeps track of argument reordering, thus enabling the binder&#39;s <a class=\"xref\" href=\"system.reflection.binder#System_Reflection_Binder_ReorderArgumentArray_\" data-linktype=\"relative-path\">ReorderArgumentArray</a> method to reorder the argument array to its original form.  </p>\n<p> The BindToMethod method is used by the <a class=\"xref\" href=\"system.type#System_Type_InvokeMember_\" data-linktype=\"relative-path\">InvokeMember</a> method.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Reflection_Binder_ChangeType_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Reflection_Binder_ChangeType_System_Object_System_Type_System_Globalization_CultureInfo_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">ChangeType(Object, Type, CultureInfo)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Changes the type of the given <code>Object</code> to the given <code>Type</code>.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public abstract object ChangeType (object value, Type type, System.Globalization.CultureInfo culture);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The object to change into a new <code>Type</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>type</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The new <code>Type</code> that <code>value</code> will become.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>culture</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An instance of <a class=\"xref\" href=\"system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a> that is used to control the coercion of data types. If <code>culture</code> is <code>null</code>, the <a class=\"xref\" href=\"system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a> for the current thread is used.  </p>\n<p> Note   For example, this parameter is necessary to convert a <code>String</code> that represents 1000 to a <code>Double</code> value, because 1000 is represented differently by different cultures.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>An object that contains the given value as the new type.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.classinterfaceattribute\" title=\"System.Runtime.InteropServices.ClassInterfaceAttribute\" data-linktype=\"relative-path\">ClassInterfaceAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Reflection models the accessibility rules of the common type system. For example, if the caller is in the same assembly, the caller does not need special permissions for internal members. Otherwise, the caller needs <a class=\"xref\" href=\"system.security.permissions.reflectionpermission\" data-linktype=\"relative-path\">ReflectionPermission</a>. This is consistent with lookup of members that are protected, private, and so on.  </p>\n<p> The general principle is that <code>ChangeType</code> should perform only widening coercions, which never lose data. An example of a widening coercion is coercing a value that is a 32-bit signed integer to a value that is a 64-bit signed integer. This is distinguished from a narrowing coercion, which may lose data. An example of a narrowing coercion is coercing a 64-bit signed integer to a 32-bit signed integer.  </p>\n<p> The following table lists the coercions performed by the default <code>ChangeType</code>.  </p>\n<table>\n<thead>\n<tr>\n<th>Source type</th>\n<th>Target type</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Any type</td>\n<td>Its base type.</td>\n</tr>\n<tr>\n<td>Any type</td>\n<td>The interface it implements.</td>\n</tr>\n<tr>\n<td>Char</td>\n<td>UInt16, UInt32, Int32, UInt64, Int64, Single, Double</td>\n</tr>\n<tr>\n<td>Byte</td>\n<td>Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</td>\n</tr>\n<tr>\n<td>SByte</td>\n<td>Int16, Int32, Int64, Single, Double</td>\n</tr>\n<tr>\n<td>UInt16</td>\n<td>UInt32, Int32, UInt64, Int64, Single, Double</td>\n</tr>\n<tr>\n<td>Int16</td>\n<td>Int32, Int64, Single, Double</td>\n</tr>\n<tr>\n<td>UInt32</td>\n<td>UInt64, Int64, Single, Double</td>\n</tr>\n<tr>\n<td>Int32</td>\n<td>Int64, Single, Double</td>\n</tr>\n<tr>\n<td>UInt64</td>\n<td>Single, Double</td>\n</tr>\n<tr>\n<td>Int64</td>\n<td>Single, Double</td>\n</tr>\n<tr>\n<td>Single</td>\n<td>Double</td>\n</tr>\n<tr>\n<td>Non-reference</td>\n<td>By-reference.</td>\n</tr>\n</tbody>\n</table>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Reflection_Binder_ReorderArgumentArray_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Reflection_Binder_ReorderArgumentArray_System_Object____System_Object_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">ReorderArgumentArray(Object[], Object)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Upon returning from <span class=\"xref\">stem.Reflection.Binder.BindToMethod*</span>, restores the <code>args</code> argument to what it was when it came from <code>BindToMethod</code>.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public abstract void ReorderArgumentArray (ref object[] args, object state);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>args</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The actual arguments that are passed in. Both the types and values of the arguments can be changed.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>state</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A binder-provided object that keeps track of argument reordering.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.classinterfaceattribute\" title=\"System.Runtime.InteropServices.ClassInterfaceAttribute\" data-linktype=\"relative-path\">ClassInterfaceAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The common language runtime calls this method if <code>state</code> is not <code>null</code> after a return from <code>BindToMethod</code>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Reflection_Binder_SelectMethod_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Reflection_Binder_SelectMethod_System_Reflection_BindingFlags_System_Reflection_MethodBase___System_Type___System_Reflection_ParameterModifier___\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">SelectMethod(BindingFlags, MethodBase[], Type[], ParameterModifier[])</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Selects a method from the given set of methods, based on the argument type.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public abstract System.Reflection.MethodBase SelectMethod (System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, Type[] types, System.Reflection.ParameterModifier[] modifiers);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>bindingAttr</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A bitwise combination of <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> values.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>match</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The set of methods that are candidates for matching. For example, when a <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a> object is used by <span class=\"xref\">stem.Type.InvokeMember*</span>, this parameter specifies the set of methods that reflection has determined to be possible matches, typically because they have the correct member name. The default implementation provided by <span class=\"xref\">stem.Type.DefaultBinder*</span> changes the order of this array.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>types</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The parameter types used to locate a matching method.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>modifiers</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An array of parameter modifiers that enable binding to work with parameter signatures in which the types have been modified.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>The matching method, if found; otherwise, <code>null</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.classinterfaceattribute\" title=\"System.Runtime.InteropServices.ClassInterfaceAttribute\" data-linktype=\"relative-path\">ClassInterfaceAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>For the default binder, <code>match</code> contains multiple methods that are equally good matches for the parameter types described by <code>types</code>. For example, the array in <code>types</code> contains a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object for <code>MyClass</code> and the array in <code>match</code> contains a method that takes a base class of <code>MyClass</code> and a method that takes an interface that <code>MyClass</code> implements.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>For the default binder, <code>match</code> is <code>null</code> or an empty array.  </p>\n<p> -or-  </p>\n<p> An element of <code>types</code> derives from <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, but is not of type <code>RuntimeType</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This method should return <code>null</code> if no method matches the criteria. This method controls the selection provided by the <code>GetConstructor</code> and <code>GetMethod</code> methods on <code>Type</code>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Reflection_Binder_SelectProperty_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Reflection_Binder_SelectProperty_System_Reflection_BindingFlags_System_Reflection_PropertyInfo___System_Type_System_Type___System_Reflection_ParameterModifier___\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">SelectProperty(BindingFlags, PropertyInfo[], Type, Type[], ParameterModifier[])</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Selects a property from the given set of properties, based on the specified criteria.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public abstract System.Reflection.PropertyInfo SelectProperty (System.Reflection.BindingFlags bindingAttr, System.Reflection.PropertyInfo[] match, Type returnType, Type[] indexes, System.Reflection.ParameterModifier[] modifiers);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>bindingAttr</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A bitwise combination of <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> values.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>match</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The set of properties that are candidates for matching. For example, when a <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a> object is used by <span class=\"xref\">stem.Type.InvokeMember*</span>, this parameter specifies the set of properties that reflection has determined to be possible matches, typically because they have the correct member name. The default implementation provided by <span class=\"xref\">stem.Type.DefaultBinder*</span> changes the order of this array.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>returnType</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The return value the matching property must have.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>indexes</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The index types of the property being searched for. Used for index properties such as the indexer for a class.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>modifiers</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An array of parameter modifiers that enable binding to work with parameter signatures in which the types have been modified.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>The matching property.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.classinterfaceattribute\" title=\"System.Runtime.InteropServices.ClassInterfaceAttribute\" data-linktype=\"relative-path\">ClassInterfaceAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>For the default binder, <code>match</code> contains multiple properties that are equally good matches for <code>returnType</code> and <code>indexes</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>For the default binder, <code>match</code> is <code>null</code> or an empty array.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This method controls the selection provided by the <code>GetProperty</code> method on <code>Type</code>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Reflection.Binder.yml\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Binder\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Binder..ctor\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Binder.BindToField\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Binder.BindToMethod\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Binder.ChangeType\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Binder.ReorderArgumentArray\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Binder.SelectMethod\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Binder.SelectProperty\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-31 05:47 AM\">\r\n<meta name=\"document_id\" content=\"4d9dea16-6965-9b12-0a05-066c0b835a60\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Selects a member from a list of candidates, and performs type conversion from actual argument type to formal argument type.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.reflection/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Reflection.Binder\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Reflection.Binder.yml","open_to_public_contributors":false,"api_name":["System.Reflection.Binder","System.Reflection.Binder..ctor","System.Reflection.Binder.BindToField","System.Reflection.Binder.BindToMethod","System.Reflection.Binder.ChangeType","System.Reflection.Binder.ReorderArgumentArray","System.Reflection.Binder.SelectMethod","System.Reflection.Binder.SelectProperty"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Reflection.Binder","System::Reflection::Binder","System.Reflection.Binder.#ctor","System::Reflection::Binder::#ctor","System.Reflection.Binder.BindToField","System::Reflection::Binder::BindToField","System.Reflection.Binder.BindToMethod","System::Reflection::Binder::BindToMethod","System.Reflection.Binder.ChangeType","System::Reflection::Binder::ChangeType","System.Reflection.Binder.ReorderArgumentArray","System::Reflection::Binder::ReorderArgumentArray","System.Reflection.Binder.SelectMethod","System::Reflection::Binder::SelectMethod","System.Reflection.Binder.SelectProperty","System::Reflection::Binder::SelectProperty"],"dev_langs":["csharp"],"updated_at":"2017-03-31 05:47 AM","document_id":"4d9dea16-6965-9b12-0a05-066c0b835a60","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Reflection/Binder.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"Binder class | Microsoft Docs","_op_ogTitle":"Binder class","description":"Selects a member from a list of candidates, and performs type conversion from actual argument type to formal argument type.\n","toc_asset_id":"api/_splitted/System.Reflection/toc.json","toc_rel":"_splitted/System.Reflection/toc.json","source_url":"","ms.assetid":"System.Reflection.Binder","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.reflection.binder","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.reflection.binder","fileRelativePath":"api/System.Reflection.Binder.html"},"themesRelativePathToOutputRoot":"_themes/"}