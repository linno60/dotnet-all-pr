{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">HMACMD5</span>\r\n    \t\t\t\tClass\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Computes a Hash-based Message Authentication Code (HMAC) by using the <a class=\"xref\" href=\"system.security.cryptography.md5\" data-linktype=\"relative-path\">MD5</a> hash function.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(true)]\npublic class HMACMD5 : System.Security.Cryptography.HMAC</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm\" data-linktype=\"relative-path\">HashAlgorithm</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.keyedhashalgorithm\" data-linktype=\"relative-path\">KeyedHashAlgorithm</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac\" data-linktype=\"relative-path\">HMAC</a></span></div><span class=\"lang-csharp\">HMACMD5</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Attributes</dt><dd>\r\n  \t\t<div class=\"cdlHolder\">\r\n  \t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \t<h3 class=\"accented\">Inherited Members</h3>\r\n  \t<h4 class=\"accented\"></h4>\r\n  \t<div class=\"cdlHolder\">\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_CanReuseTransform\" data-linktype=\"relative-path\">CanReuseTransform</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_CanTransformMultipleBlocks\" data-linktype=\"relative-path\">CanTransformMultipleBlocks</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_Clear\" data-linktype=\"relative-path\">Clear()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_ComputeHash_System_Byte___\" data-linktype=\"relative-path\">ComputeHash(Byte[])</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_ComputeHash_System_Byte___System_Int32_System_Int32_\" data-linktype=\"relative-path\">ComputeHash(Byte[], Int32, Int32)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_ComputeHash_System_IO_Stream_\" data-linktype=\"relative-path\">ComputeHash(Stream)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_Dispose\" data-linktype=\"relative-path\">Dispose()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_Hash\" data-linktype=\"relative-path\">Hash</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_HashSize\" data-linktype=\"relative-path\">HashSize</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_HashSizeValue\" data-linktype=\"relative-path\">HashSizeValue</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_HashValue\" data-linktype=\"relative-path\">HashValue</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_InputBlockSize\" data-linktype=\"relative-path\">InputBlockSize</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_OutputBlockSize\" data-linktype=\"relative-path\">OutputBlockSize</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_State\" data-linktype=\"relative-path\">State</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_TransformBlock_System_Byte___System_Int32_System_Int32_System_Byte___System_Int32_\" data-linktype=\"relative-path\">TransformBlock(Byte[], Int32, Int32, Byte[], Int32)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_TransformFinalBlock_System_Byte___System_Int32_System_Int32_\" data-linktype=\"relative-path\">TransformFinalBlock(Byte[], Int32, Int32)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_BlockSizeValue\" data-linktype=\"relative-path\">BlockSizeValue</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_Create\" data-linktype=\"relative-path\">Create()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_Create_System_String_\" data-linktype=\"relative-path\">Create(String)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_Dispose_System_Boolean_\" data-linktype=\"relative-path\">Dispose(Boolean)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_HashCore_System_Byte___System_Int32_System_Int32_\" data-linktype=\"relative-path\">HashCore(Byte[], Int32, Int32)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_HashFinal\" data-linktype=\"relative-path\">HashFinal()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_HashName\" data-linktype=\"relative-path\">HashName</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_Initialize\" data-linktype=\"relative-path\">Initialize()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_Key\" data-linktype=\"relative-path\">Key</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.keyedhashalgorithm#System_Security_Cryptography_KeyedHashAlgorithm_KeyValue\" data-linktype=\"relative-path\">KeyValue</a></span></div>\r\n  \t</div>\r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following example shows how to sign a file by using the HMACMD5 object and then how to verify the file.  </p>\n<pre><code class=\"lang-cs\" name=\"HMACMD5#1\">using System;\nusing System.IO;\nusing System.Security.Cryptography;\n\npublic class HMACMD5example\n{\n\n    public static void Main(string[] Fileargs)\n    {\n        string dataFile;\n        string signedFile;\n        //If no file names are specified, create them.\n        if (Fileargs.Length &lt; 2)\n        {\n            dataFile = @&quot;text.txt&quot;;\n            signedFile = &quot;signedFile.enc&quot;;\n\n            if (!File.Exists(dataFile))\n            {\n                // Create a file to write to.\n                using (StreamWriter sw = File.CreateText(dataFile))\n                {\n                    sw.WriteLine(&quot;Here is a message to sign&quot;);\n                }\n            }\n\n        }\n        else\n        {\n            dataFile = Fileargs[0];\n            signedFile = Fileargs[1];\n        }\n        try\n        {\n            // Create a random key using a random number generator. This would be the\n            //  secret key shared by sender and receiver.\n            byte[] secretkey = new Byte[64];\n            //RNGCryptoServiceProvider is an implementation of a random number generator.\n            using (RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider())\n            {\n                // The array is now filled with cryptographically strong random bytes.\n                rng.GetBytes(secretkey);\n\n                // Use the secret key to sign the message file.\n                SignFile(secretkey, dataFile, signedFile);\n\n                // Verify the signed file\n                VerifyFile(secretkey, signedFile);\n            }\n        }\n        catch (IOException e)\n        {\n            Console.WriteLine(&quot;Error: File not found&quot;, e);\n        }\n\n    }  //end main\n    // Computes a keyed hash for a source file and creates a target file with the keyed hash\n    // prepended to the contents of the source file. \n    public static void SignFile(byte[] key, String sourceFile, String destFile)\n    {\n        // Initialize the keyed hash object.\n        using (HMACMD5 hmac = new HMACMD5(key))\n        {\n            using (FileStream inStream = new FileStream(sourceFile, FileMode.Open))\n            {\n                using (FileStream outStream = new FileStream(destFile, FileMode.Create))\n                {\n                    // Compute the hash of the input file.\n                    byte[] hashValue = hmac.ComputeHash(inStream);\n                    // Reset inStream to the beginning of the file.\n                    inStream.Position = 0;\n                    // Write the computed hash value to the output file.\n                    outStream.Write(hashValue, 0, hashValue.Length);\n                    // Copy the contents of the sourceFile to the destFile.\n                    int bytesRead;\n                    // read 1K at a time\n                    byte[] buffer = new byte[1024];\n                    do\n                    {\n                        // Read from the wrapping CryptoStream.\n                        bytesRead = inStream.Read(buffer, 0, 1024);\n                        outStream.Write(buffer, 0, bytesRead);\n                    } while (bytesRead &gt; 0);\n                }\n            }\n        }\n        return;\n    } // end SignFile\n\n\n    // Compares the key in the source file with a new key created for the data portion of the file. If the keys \n    // compare the data has not been tampered with.\n    public static bool VerifyFile(byte[] key, String sourceFile)\n    {\n        bool err = false;\n        // Initialize the keyed hash object. \n        using (HMACMD5 hmac = new HMACMD5(key))\n        {\n            // Create an array to hold the keyed hash value read from the file.\n            byte[] storedHash = new byte[hmac.HashSize / 8];\n            // Create a FileStream for the source file.\n            using (FileStream inStream = new FileStream(sourceFile, FileMode.Open))\n            {\n                // Read in the storedHash.\n                inStream.Read(storedHash, 0, storedHash.Length);\n                // Compute the hash of the remaining contents of the file.\n                // The stream is properly positioned at the beginning of the content, \n                // immediately after the stored hash value.\n                byte[] computedHash = hmac.ComputeHash(inStream);\n                // compare the computed hash with the stored value\n\n                for (int i = 0; i &lt; storedHash.Length; i++)\n                {\n                    if (computedHash[i] != storedHash[i])\n                    {\n                        err = true;\n                    }\n                }\n            }\n        }\n        if (err)\n        {\n            Console.WriteLine(&quot;Hash values differ! Signed file has been tampered with!&quot;);\n            return false;\n        }\n        else\n        {\n            Console.WriteLine(&quot;Hash values agree -- no tampering occurred.&quot;);\n            return true;\n        }\n\n    } //end VerifyFile\n\n} //end class\n</code></pre><pre><code class=\"lang-cpp\" name=\"HMACMD5#1\">using namespace System;\nusing namespace System::IO;\nusing namespace System::Security::Cryptography;\n\n// Computes a keyed hash for a source file, creates a target file with the keyed hash\n// prepended to the contents of the source file, then decrypts the file and compares\n// the source and the decrypted files.\nvoid EncodeFile( array&lt;Byte&gt;^key, String^ sourceFile, String^ destFile )\n{\n   \n   // Initialize the keyed hash object.\n   HMACMD5^ myhmacMD5 = gcnew HMACMD5( key );\n   FileStream^ inStream = gcnew FileStream( sourceFile,FileMode::Open );\n   FileStream^ outStream = gcnew FileStream( destFile,FileMode::Create );\n   \n   // Compute the hash of the input file.\n   array&lt;Byte&gt;^hashValue = myhmacMD5-&gt;ComputeHash( inStream );\n   \n   // Reset inStream to the beginning of the file.\n   inStream-&gt;Position = 0;\n   \n   // Write the computed hash value to the output file.\n   outStream-&gt;Write( hashValue, 0, hashValue-&gt;Length );\n   \n   // Copy the contents of the sourceFile to the destFile.\n   int bytesRead;\n   \n   // read 1K at a time\n   array&lt;Byte&gt;^buffer = gcnew array&lt;Byte&gt;(1024);\n   do\n   {\n      \n      // Read from the wrapping CryptoStream.\n      bytesRead = inStream-&gt;Read( buffer, 0, 1024 );\n      outStream-&gt;Write( buffer, 0, bytesRead );\n   }\n   while ( bytesRead &gt; 0 );\n\n   myhmacMD5-&gt;Clear();\n   \n   // Close the streams\n   inStream-&gt;Close();\n   outStream-&gt;Close();\n   return;\n} // end EncodeFile\n\n\n\n// Decrypt the encoded file and compare to original file.\nbool DecodeFile( array&lt;Byte&gt;^key, String^ sourceFile )\n{\n   \n   // Initialize the keyed hash object. \n   HMACMD5^ hmacMD5 = gcnew HMACMD5( key );\n   \n   // Create an array to hold the keyed hash value read from the file.\n   array&lt;Byte&gt;^storedHash = gcnew array&lt;Byte&gt;(hmacMD5-&gt;HashSize / 8);\n   \n   // Create a FileStream for the source file.\n   FileStream^ inStream = gcnew FileStream( sourceFile,FileMode::Open );\n   \n   // Read in the storedHash.\n   inStream-&gt;Read( storedHash, 0, storedHash-&gt;Length );\n   \n   // Compute the hash of the remaining contents of the file.\n   // The stream is properly positioned at the beginning of the content, \n   // immediately after the stored hash value.\n   array&lt;Byte&gt;^computedHash = hmacMD5-&gt;ComputeHash( inStream );\n   \n   // compare the computed hash with the stored value\n   bool err = false;\n   for ( int i = 0; i &lt; storedHash-&gt;Length; i++ )\n   {\n      if ( computedHash[ i ] != storedHash[ i ] )\n      {\n         err = true;\n      }\n   }\n   if (err)\n        {\n            Console::WriteLine(&quot;Hash values differ! Encoded file has been tampered with!&quot;);\n            return false;\n        }\n        else\n        {\n            Console::WriteLine(&quot;Hash values agree -- no tampering occurred.&quot;);\n            return true;\n        }\n\n} //end DecodeFile\n\n\nint main()\n{\n   String^ usageText = &quot;Usage: HMACMD5 inputfile.txt encryptedfile.hsh\\nYou must specify the two file names. Only the first file must exist.\\n&quot;;\n   array&lt;String^&gt;^Fileargs = Environment::GetCommandLineArgs();\n   \n   //If no file names are specified, write usage text.\n   if ( Fileargs-&gt;Length &lt; 3 )\n   {\n      Console::WriteLine( usageText );\n   }\n   else\n   {\n      try\n      {\n         \n         // Create a random key using a random number generator. This would be the\n         //  secret key shared by sender and receiver.\n         array&lt;Byte&gt;^secretkey = gcnew array&lt;Byte&gt;(64);\n         \n         //RNGCryptoServiceProvider is an implementation of a random number generator.\n         RNGCryptoServiceProvider^ rng = gcnew RNGCryptoServiceProvider;\n         \n         // The array is now filled with cryptographically strong random bytes.\n         rng-&gt;GetBytes( secretkey );\n         \n         // Use the secret key to encode the message file.\n         EncodeFile( secretkey, Fileargs[ 1 ], Fileargs[ 2 ] );\n         \n         // Take the encoded file and decode\n         DecodeFile( secretkey, Fileargs[ 2 ] );\n      }\n      catch ( IOException^ e ) \n      {\n         Console::WriteLine( &quot;Error: File not found&quot;, e );\n      }\n\n   }\n} //end main\n\n</code></pre><pre><code class=\"lang-vb\" name=\"HMACMD5#1\">Imports System\nImports System.IO\nImports System.Security.Cryptography\n\nPublic Class HMACMD5example\n\n    Public Shared Sub Main(ByVal Fileargs() As String)\n        Dim dataFile As String\n        Dim signedFile As String\n        &#39;If no file names are specified, create them.\n        If Fileargs.Length &lt; 2 Then\n            dataFile = &quot;text.txt&quot;\n            signedFile = &quot;signedFile.enc&quot;\n\n            If Not File.Exists(dataFile) Then\n                &#39; Create a file to write to.\n                Using sw As StreamWriter = File.CreateText(dataFile)\n                    sw.WriteLine(&quot;Here is a message to sign&quot;)\n                End Using\n            End If\n\n        Else\n            dataFile = Fileargs(0)\n            signedFile = Fileargs(1)\n        End If\n        Try\n            &#39; Create a random key using a random number generator. This would be the\n            &#39;  secret key shared by sender and receiver.\n            Dim secretkey() As Byte = New [Byte](63) {}\n            &#39;RNGCryptoServiceProvider is an implementation of a random number generator.\n            Using rng As New RNGCryptoServiceProvider()\n                &#39; The array is now filled with cryptographically strong random bytes.\n                rng.GetBytes(secretkey)\n\n                &#39; Use the secret key to encode the message file.\n                SignFile(secretkey, dataFile, signedFile)\n\n                &#39; Take the encoded file and decode\n                VerifyFile(secretkey, signedFile)\n            End Using\n        Catch e As IOException\n            Console.WriteLine(&quot;Error: File not found&quot;, e)\n        End Try\n\n    End Sub &#39;Main\n\n    &#39; Computes a keyed hash for a source file and creates a target file with the keyed hash\n    &#39; prepended to the contents of the source file. \n    Public Shared Sub SignFile(ByVal key() As Byte, ByVal sourceFile As String, ByVal destFile As String)\n        &#39; Initialize the keyed hash object.\n        Using myhmac As New HMACMD5(key)\n            Using inStream As New FileStream(sourceFile, FileMode.Open)\n                Using outStream As New FileStream(destFile, FileMode.Create)\n                    &#39; Compute the hash of the input file.\n                    Dim hashValue As Byte() = myhmac.ComputeHash(inStream)\n                    &#39; Reset inStream to the beginning of the file.\n                    inStream.Position = 0\n                    &#39; Write the computed hash value to the output file.\n                    outStream.Write(hashValue, 0, hashValue.Length)\n                    &#39; Copy the contents of the sourceFile to the destFile.\n                    Dim bytesRead As Integer\n                    &#39; read 1K at a time\n                    Dim buffer(1023) As Byte\n                    Do\n                        &#39; Read from the wrapping CryptoStream.\n                        bytesRead = inStream.Read(buffer, 0, 1024)\n                        outStream.Write(buffer, 0, bytesRead)\n                    Loop While bytesRead &gt; 0\n                End Using\n            End Using\n        End Using\n        Return\n\n    End Sub &#39;SignFile\n    &#39; end SignFile\n\n    &#39; Compares the key in the source file with a new key created for the data portion of the file. If the keys \n    &#39; compare the data has not been tampered with.\n    Public Shared Function VerifyFile(ByVal key() As Byte, ByVal sourceFile As String) As Boolean\n        Dim err As Boolean = False\n        &#39; Initialize the keyed hash object. \n        Using hmac As New HMACMD5(key)\n            &#39; Create an array to hold the keyed hash value read from the file.\n            Dim storedHash(hmac.HashSize / 8) As Byte\n            &#39; Create a FileStream for the source file.\n            Using inStream As New FileStream(sourceFile, FileMode.Open)\n                &#39; Read in the storedHash.\n                inStream.Read(storedHash, 0, storedHash.Length - 1)\n                &#39; Compute the hash of the remaining contents of the file.\n                &#39; The stream is properly positioned at the beginning of the content, \n                &#39; immediately after the stored hash value.\n                Dim computedHash As Byte() = hmac.ComputeHash(inStream)\n                &#39; compare the computed hash with the stored value\n                Dim i As Integer\n                For i = 0 To storedHash.Length - 2\n                    If computedHash(i) &lt;&gt; storedHash(i) Then\n                        err = True\n                    End If\n                Next i\n            End Using\n        End Using\n        If err Then\n            Console.WriteLine(&quot;Hash values differ! Signed file has been tampered with!&quot;)\n            Return False\n        Else\n            Console.WriteLine(&quot;Hash values agree -- no tampering occurred.&quot;)\n            Return True\n        End If\n\n    End Function &#39;VerifyFile \nEnd Class &#39;HMACMD5example &#39;end VerifyFile\n&#39;end class\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>HMACMD5 is a type of keyed hash algorithm that is constructed from the Message Digest Algorithm 5 (MD5) hash function and used as a Hash-based Message Authentication Code (HMAC). The HMAC process mixes a secret key with the message data, hashes the result with the hash function, mixes that hash value with the secret key again, and then applies the hash function a second time. The output hash is 128 bits in length.  </p>\n<p> An HMAC can be used to determine whether a message sent over an insecure channel has been tampered with, provided that the sender and receiver share a secret key. The sender computes the hash value for the original data and sends both the original data and hash value as a single message. The receiver recalculates the hash value on the received message and checks that the computed HMAC matches the transmitted HMAC.  </p>\n<p> Any change to the data or the hash value results in a mismatch, because knowledge of the secret key is required to change the message and reproduce the correct hash value. Therefore, if the original and computed hash values match, the message is authenticated.  </p>\n<p> MD5 is a cryptographic hash algorithm developed at RSA Laboratories. HMACMD5 accepts keys of any size, and produces a hash sequence that is 128 bits in length.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Constructors\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Security_Cryptography_HMACMD5__ctor_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_Cryptography_HMACMD5__ctor\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">HMACMD5()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Initializes a new instance of the <a class=\"xref\" href=\"system.security.cryptography.hmacmd5\" data-linktype=\"relative-path\">HMACMD5</a> class by using a randomly generated key.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public HMACMD5 ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p><a class=\"xref\" href=\"system.security.cryptography.hmacmd5\" data-linktype=\"relative-path\">HMACMD5</a> is a type of keyed hash algorithm that is constructed from the MD5 hash function and used as a Hash-based Message Authentication Code (HMAC). The HMAC process mixes a secret key with the message data, hashes the result with the hash function, mixes that hash value with the secret key again, and then applies the hash function a second time. The output hash is 128 bits in length.  </p>\n<p> This constructor uses a 64-byte, randomly generated key.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Security_Cryptography_HMACMD5__ctor_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_Cryptography_HMACMD5__ctor_System_Byte___\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">HMACMD5(Byte[])</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Initializes a new instance of the <a class=\"xref\" href=\"system.security.cryptography.hmacmd5\" data-linktype=\"relative-path\">HMACMD5</a> class by using the specified key.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public HMACMD5 (byte[] key);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>key</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.byte\" data-linktype=\"relative-path\">Byte</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The secret key for <a class=\"xref\" href=\"system.security.cryptography.hmacmd5\" data-linktype=\"relative-path\">HMACMD5</a> encryption. The key can be any length, but if it is more than 64 bytes long it will be hashed (using SHA-1) to derive a 64-byte key. Therefore, the recommended size of the secret key is 64 bytes.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>key</code> parameter is <code>null</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p><a class=\"xref\" href=\"system.security.cryptography.hmacmd5\" data-linktype=\"relative-path\">HMACMD5</a> is a type of keyed hash algorithm that is constructed from the MD5 hash function and used as a Hash-based Message Authentication Code (HMAC). The HMAC process mixes a secret key with the message data, hashes the result with the hash function, mixes that hash value with the secret key again, and then applies the hash function a second time. The output hash is 128 bits in length.  </p>\n<p> This constructor uses a key you provide to create the <a class=\"xref\" href=\"system.security.cryptography.hmacmd5\" data-linktype=\"relative-path\">HMACMD5</a> object.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Security.Cryptography.HMACMD5.yml\">\r\n<meta name=\"APIName\" content=\"System.Security.Cryptography.HMACMD5\">\r\n<meta name=\"APIName\" content=\"System.Security.Cryptography.HMACMD5..ctor\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-04-01 05:59 PM\">\r\n<meta name=\"document_id\" content=\"7b4fbde3-1d1b-9047-9a57-521f78cbe082\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Computes a Hash-based Message Authentication Code (HMAC) by using the  hash function.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.security.cryptography/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Security.Cryptography.HMACMD5\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","uhfHeaderId":"MSDocsHeader-DotNet","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Security.Cryptography.HMACMD5.yml","open_to_public_contributors":false,"api_name":["System.Security.Cryptography.HMACMD5","System.Security.Cryptography.HMACMD5..ctor"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Security.Cryptography.HMACMD5","System::Security::Cryptography::HMACMD5","System.Security.Cryptography.HMACMD5.#ctor","System::Security::Cryptography::HMACMD5::#ctor"],"dev_langs":["csharp"],"updated_at":"2017-04-01 05:59 PM","document_id":"7b4fbde3-1d1b-9047-9a57-521f78cbe082","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Security.Cryptography/HMACMD5.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"HMACMD5 class | Microsoft Docs","_op_ogTitle":"HMACMD5 class","description":"Computes a Hash-based Message Authentication Code (HMAC) by using the  hash function.\n","toc_asset_id":"api/_splitted/System.Security.Cryptography/toc.json","toc_rel":"_splitted/System.Security.Cryptography/toc.json","source_url":"","ms.assetid":"System.Security.Cryptography.HMACMD5","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.hmacmd5","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.hmacmd5","fileRelativePath":"api/System.Security.Cryptography.HMACMD5.html"},"themesRelativePathToOutputRoot":"_themes/"}