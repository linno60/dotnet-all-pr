{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">WindowsImpersonationContext</span>\r\n    \t\t\t\tClass\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Represents the Windows user prior to an impersonation operation.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[ECMA2Yaml.Models.ECMAAttribute]\npublic class WindowsImpersonationContext : IDisposable</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><span class=\"lang-csharp\">WindowsImpersonationContext</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Attributes</dt><dd>\r\n  \t\t<div class=\"cdlHolder\">\r\n  \t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \t<h3 class=\"accented\">Inherited Members</h3>\r\n  \t<h4 class=\"accented\"></h4>\r\n  \t<div class=\"cdlHolder\">\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a></span></div>\r\n  \t</div>\r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following example demonstrates how to impersonate a user and then revert to the original identity.  </p>\n<pre><code class=\"lang-cpp\" name=\"WindowsIdentity Impersonation#1\">// This sample demonstrates the use of the WindowsIdentity class to impersonate a user.\n// IMPORTANT NOTES: \n// This sample requests the user to enter a password on the console screen.\n// Because the console window does not support methods allowing the password to be masked,\n// it will be visible to anyone viewing the screen.\n// On Windows Vista and later this sample must be run as an administrator. \n\n#using &lt;System.dll&gt;\n\nusing namespace System;\nusing namespace System::Runtime::InteropServices;\nusing namespace System::Security::Principal;\nusing namespace System::Security::Permissions;\n\n\n[DllImport(&quot;advapi32.dll&quot;,SetLastError=true)]\nbool LogonUser( String^ lpszUsername, String^ lpszDomain, String^ lpszPassword, int dwLogonType, int dwLogonProvider, IntPtr * phToken );\n\n[DllImport(&quot;kernel32.dll&quot;,CharSet=CharSet::Auto)]\nbool CloseHandle( IntPtr handle );\n\n// Test harness.\n// If you incorporate this code into a DLL, be sure to demand FullTrust.\n\n[PermissionSetAttribute(SecurityAction::Demand,Name=&quot;FullTrust&quot;)]\nint main()\n{\n   IntPtr tokenHandle = IntPtr(0);\n\n   try\n   {\n      String^ userName;\n      String^ domainName;\n      \n      // Get the user token for the specified user, domain, and password using the \n      // unmanaged LogonUser method.  \n      // The local machine name can be used for the domain name to impersonate a user on this machine.\n      Console::Write( &quot;Enter the name of the domain on which to log on: &quot; );\n      domainName = Console::ReadLine();\n      Console::Write( &quot;Enter the login of a user on {0} that you wish to impersonate: &quot;, domainName );\n      userName = Console::ReadLine();\n      Console::Write( &quot;Enter the password for {0}: &quot;, userName );\n      const int LOGON32_PROVIDER_DEFAULT = 0;\n      \n      //This parameter causes LogonUser to create a primary token.\n      const int LOGON32_LOGON_INTERACTIVE = 2;\n      const int SecurityImpersonation = 2;\n      tokenHandle = IntPtr::Zero;\n      \n      // Call LogonUser to obtain a handle to an access token.\n      bool returnValue = LogonUser( userName, domainName, Console::ReadLine(), LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT,  &amp;tokenHandle );\n      Console::WriteLine( &quot;LogonUser called.&quot; );\n      if ( false == returnValue )\n      {\n         int ret = Marshal::GetLastWin32Error();\n         Console::WriteLine( &quot;LogonUser failed with error code : {0}&quot;, ret );\n         throw gcnew System::ComponentModel::Win32Exception( ret );\n      }\n      Console::WriteLine( &quot;Did LogonUser Succeed? {0}&quot;, (returnValue ? (String^)&quot;Yes&quot; : &quot;No&quot;) );\n      Console::WriteLine( &quot;Value of Windows NT token: {0}&quot;, tokenHandle );\n      \n      // Check the identity.\n      Console::WriteLine( &quot;Before impersonation: {0}&quot;, WindowsIdentity::GetCurrent()-&gt;Name );\n      \n      // The token that is passed to the following constructor must \n      // be a primary token in order to use it for impersonation.\n      WindowsIdentity^ newId = gcnew WindowsIdentity( tokenHandle );\n      WindowsImpersonationContext^ impersonatedUser = newId-&gt;Impersonate();\n      \n      // Check the identity.\n      Console::WriteLine( &quot;After impersonation: {0}&quot;, WindowsIdentity::GetCurrent()-&gt;Name );\n      \n      // Stop impersonating the user.\n      impersonatedUser-&gt;Undo();\n      \n      // Check the identity.\n      Console::WriteLine( &quot;After Undo: {0}&quot;, WindowsIdentity::GetCurrent()-&gt;Name );\n      \n      // Free the tokens.\n      if ( tokenHandle != IntPtr::Zero )\n            CloseHandle( tokenHandle );\n   }\n   catch ( Exception^ ex ) \n   {\n      Console::WriteLine( &quot;Exception occurred. {0}&quot;, ex-&gt;Message );\n   }\n\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"WindowsIdentity Impersonation#1\">// This sample demonstrates the use of the WindowsIdentity class to impersonate a user.\n// IMPORTANT NOTES:\n// This sample requests the user to enter a password on the console screen.\n// Because the console window does not support methods allowing the password to be masked,\n// it will be visible to anyone viewing the screen.\n// On Windows Vista and later this sample must be run as an administrator. \n\n\nusing System;\nusing System.Runtime.InteropServices;\nusing System.Security.Principal;\nusing System.Security.Permissions;\nusing Microsoft.Win32.SafeHandles;\nusing System.Runtime.ConstrainedExecution;\nusing System.Security;\n\n\npublic class ImpersonationDemo\n{\n    [DllImport(&quot;advapi32.dll&quot;, SetLastError = true, CharSet = CharSet.Unicode)]\n    public static extern bool LogonUser(String lpszUsername, String lpszDomain, String lpszPassword,\n        int dwLogonType, int dwLogonProvider, out SafeTokenHandle phToken);\n\n    [DllImport(&quot;kernel32.dll&quot;, CharSet = CharSet.Auto)]\n    public extern static bool CloseHandle(IntPtr handle);\n\n    // Test harness.\n    // If you incorporate this code into a DLL, be sure to demand FullTrust.\n    [PermissionSetAttribute(SecurityAction.Demand, Name = &quot;FullTrust&quot;)]\n    public static void Main(string[] args)\n    {\n        SafeTokenHandle safeTokenHandle;\n        try\n        {\n            string userName, domainName;\n            // Get the user token for the specified user, domain, and password using the\n            // unmanaged LogonUser method.\n            // The local machine name can be used for the domain name to impersonate a user on this machine.\n            Console.Write(&quot;Enter the name of the domain on which to log on: &quot;);\n            domainName = Console.ReadLine();\n\n            Console.Write(&quot;Enter the login of a user on {0} that you wish to impersonate: &quot;, domainName);\n            userName = Console.ReadLine();\n\n            Console.Write(&quot;Enter the password for {0}: &quot;, userName);\n\n            const int LOGON32_PROVIDER_DEFAULT = 0;\n            //This parameter causes LogonUser to create a primary token.\n            const int LOGON32_LOGON_INTERACTIVE = 2;\n\n            // Call LogonUser to obtain a handle to an access token.\n            bool returnValue = LogonUser(userName, domainName, Console.ReadLine(),\n                LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT,\n                out safeTokenHandle);\n\n            Console.WriteLine(&quot;LogonUser called.&quot;);\n\n            if (false == returnValue)\n            {\n                int ret = Marshal.GetLastWin32Error();\n                Console.WriteLine(&quot;LogonUser failed with error code : {0}&quot;, ret);\n                throw new System.ComponentModel.Win32Exception(ret);\n            }\n            using (safeTokenHandle)\n            {\n                Console.WriteLine(&quot;Did LogonUser Succeed? &quot; + (returnValue ? &quot;Yes&quot; : &quot;No&quot;));\n                Console.WriteLine(&quot;Value of Windows NT token: &quot; + safeTokenHandle);\n\n                // Check the identity.\n                Console.WriteLine(&quot;Before impersonation: &quot;\n                    + WindowsIdentity.GetCurrent().Name);\n                // Use the token handle returned by LogonUser.\n                using (WindowsIdentity newId = new WindowsIdentity(safeTokenHandle.DangerousGetHandle()))\n                {\n                    using (WindowsImpersonationContext impersonatedUser = newId.Impersonate())\n                    {\n\n                        // Check the identity.\n                        Console.WriteLine(&quot;After impersonation: &quot;\n                            + WindowsIdentity.GetCurrent().Name);\n                    }\n                }\n                // Releasing the context object stops the impersonation\n                // Check the identity.\n                Console.WriteLine(&quot;After closing the context: &quot; + WindowsIdentity.GetCurrent().Name);\n            }\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine(&quot;Exception occurred. &quot; + ex.Message);\n        }\n\n    }\n}\npublic sealed class SafeTokenHandle : SafeHandleZeroOrMinusOneIsInvalid\n{\n    private SafeTokenHandle()\n        : base(true)\n    {\n    }\n\n    [DllImport(&quot;kernel32.dll&quot;)]\n    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]\n    [SuppressUnmanagedCodeSecurity]\n    [return: MarshalAs(UnmanagedType.Bool)]\n    private static extern bool CloseHandle(IntPtr handle);\n\n    protected override bool ReleaseHandle()\n    {\n        return CloseHandle(handle);\n    }\n}\n\n\n</code></pre><pre><code class=\"lang-vb\" name=\"WindowsIdentity Impersonation#1\">&#39; This sample demonstrates the use of the WindowsIdentity class to impersonate a user.\n&#39; IMPORTANT NOTES: \n&#39; This sample requests the user to enter a password on the console screen.\n&#39; Because the console window does not support methods allowing the password to be masked,\n&#39; it will be visible to anyone viewing the screen.\n&#39; On Windows Vista and later this sample must be run as an administrator. \n\nImports System\nImports System.Runtime.InteropServices\nImports System.Security.Principal\nImports System.Security.Permissions\nImports Microsoft.VisualBasic\nImports Microsoft.Win32.SafeHandles\nImports System.Runtime.ConstrainedExecution\nImports System.Security\n\nModule Module1\n\n    Public Class ImpersonationDemo\n\n        &#39;Private Declare Auto Function LogonUser Lib &quot;advapi32.dll&quot; (ByVal lpszUsername As [String], _\n        &#39;    ByVal lpszDomain As [String], ByVal lpszPassword As [String], _\n        &#39;    ByVal dwLogonType As Integer, ByVal dwLogonProvider As Integer, _\n        &#39;    ByRef phToken As IntPtr) As Boolean\n\n        Private Declare Auto Function LogonUser Lib &quot;advapi32.dll&quot; (ByVal lpszUsername As [String], _\n            ByVal lpszDomain As [String], ByVal lpszPassword As [String], _\n            ByVal dwLogonType As Integer, ByVal dwLogonProvider As Integer, _\n            &lt;Out()&gt; ByRef phToken As SafeTokenHandle) As Boolean\n\n        Public Declare Auto Function CloseHandle Lib &quot;kernel32.dll&quot; (ByVal handle As IntPtr) As Boolean\n\n        &#39; Test harness.\n        &#39; If you incorporate this code into a DLL, be sure to demand FullTrust.\n        &lt;PermissionSetAttribute(SecurityAction.Demand, Name:=&quot;FullTrust&quot;)&gt; _\n        Public Overloads Shared Sub Main(ByVal args() As String)\n            Dim safeTokenHandle As SafeTokenHandle = Nothing\n            Dim tokenHandle As New IntPtr(0)\n            Try\n\n\n                Dim userName, domainName As String\n\n                &#39; Get the user token for the specified user, domain, and password using the \n                &#39; unmanaged LogonUser method.  \n                &#39; The local machine name can be used for the domain name to impersonate a user on this machine.\n                Console.Write(&quot;Enter the name of a domain on which to log on: &quot;)\n                domainName = Console.ReadLine()\n\n                Console.Write(&quot;Enter the login of a user on {0} that you wish to impersonate: &quot;, domainName)\n                userName = Console.ReadLine()\n\n                Console.Write(&quot;Enter the password for {0}: &quot;, userName)\n\n                Const LOGON32_PROVIDER_DEFAULT As Integer = 0\n                &#39;This parameter causes LogonUser to create a primary token.\n                Const LOGON32_LOGON_INTERACTIVE As Integer = 2\n\n                &#39; Call LogonUser to obtain a handle to an access token.\n                Dim returnValue As Boolean = LogonUser(userName, domainName, Console.ReadLine(), LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT, safeTokenHandle)\n\n                Console.WriteLine(&quot;LogonUser called.&quot;)\n\n                If False = returnValue Then\n                    Dim ret As Integer = Marshal.GetLastWin32Error()\n                    Console.WriteLine(&quot;LogonUser failed with error code : {0}&quot;, ret)\n                    Throw New System.ComponentModel.Win32Exception(ret)\n\n                    Return\n                End If\n                Using safeTokenHandle\n                    Dim success As String\n                    If returnValue Then success = &quot;Yes&quot; Else success = &quot;No&quot;\n                    Console.WriteLine((&quot;Did LogonUser succeed? &quot; + success))\n                    Console.WriteLine((&quot;Value of Windows NT token: &quot; + safeTokenHandle.DangerousGetHandle().ToString()))\n\n                    &#39; Check the identity.\n                    Console.WriteLine((&quot;Before impersonation: &quot; + WindowsIdentity.GetCurrent().Name))\n\n                    &#39; Use the token handle returned by LogonUser.\n                    Using newId As New WindowsIdentity(safeTokenHandle.DangerousGetHandle())\n                        Using impersonatedUser As WindowsImpersonationContext = newId.Impersonate()\n\n                            &#39; Check the identity.\n                            Console.WriteLine((&quot;After impersonation: &quot; + WindowsIdentity.GetCurrent().Name))\n\n                            &#39; Free the tokens.\n                        End Using\n                    End Using\n                End Using\n            Catch ex As Exception\n                Console.WriteLine((&quot;Exception occurred. &quot; + ex.Message))\n            End Try\n        End Sub &#39;Main \n    End Class &#39;Class1\nEnd Module\n\nPublic NotInheritable Class SafeTokenHandle\n    Inherits SafeHandleZeroOrMinusOneIsInvalid\n\n    Private Sub New()\n        MyBase.New(True)\n\n    End Sub &#39;New\n\n    Private Declare Auto Function LogonUser Lib &quot;advapi32.dll&quot; (ByVal lpszUsername As [String], _\n            ByVal lpszDomain As [String], ByVal lpszPassword As [String], _\n            ByVal dwLogonType As Integer, ByVal dwLogonProvider As Integer, _\n            ByRef phToken As IntPtr) As Boolean\n    &lt;DllImport(&quot;kernel32.dll&quot;), ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success), SuppressUnmanagedCodeSecurity()&gt; _\n    Private Shared Function CloseHandle(ByVal handle As IntPtr) As &lt;MarshalAs(UnmanagedType.Bool)&gt; Boolean\n\n    End Function\n    Protected Overrides Function ReleaseHandle() As Boolean\n        Return CloseHandle(handle)\n\n    End Function &#39;ReleaseHandle\nEnd Class &#39;SafeTokenHandle\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>This class reverts a user&#39;s identity after the user impersonates another user.  </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> This type implements the <a class=\"xref\" href=\"system.idisposable\" data-linktype=\"relative-path\">IDisposable</a> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a> method in a <code>try</code>/<code>catch</code> block. To dispose of it indirectly, use a language construct such as <code>using</code> (in C#) or <code>Using</code> (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <a class=\"xref\" href=\"system.idisposable\" data-linktype=\"relative-path\">IDisposable</a> interface topic.</p>\n</div>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Methods\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Security_Principal_WindowsImpersonationContext_Dispose_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_Principal_WindowsImpersonationContext_Dispose\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Dispose()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Releases all resources used by the <a class=\"xref\" href=\"system.security.principal.windowsimpersonationcontext\" data-linktype=\"relative-path\">WindowsImpersonationContext</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void Dispose ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Call Dispose when you are finished using the <a class=\"xref\" href=\"system.security.principal.windowsimpersonationcontext\" data-linktype=\"relative-path\">WindowsImpersonationContext</a>. The Dispose method leaves the <a class=\"xref\" href=\"system.security.principal.windowsimpersonationcontext\" data-linktype=\"relative-path\">WindowsImpersonationContext</a> in an unusable state. After calling Dispose, you must release all references to the <a class=\"xref\" href=\"system.security.principal.windowsimpersonationcontext\" data-linktype=\"relative-path\">WindowsImpersonationContext</a> so the garbage collector can reclaim the memory that the <a class=\"xref\" href=\"system.security.principal.windowsimpersonationcontext\" data-linktype=\"relative-path\">WindowsImpersonationContext</a> was occupying. For more information, see <a href=\"../topic/cleaning%20up%20unmanaged%20resources\" data-linktype=\"relative-path\">Cleaning Up Unmanaged Resources</a> and <a href=\"../topic/implementing%20a%20dispose%20method\" data-linktype=\"relative-path\">Implementing a Dispose Method</a>.  </p>\n<p> <strong>Note:</strong> Always call Dispose before you release your last reference to the <a class=\"xref\" href=\"system.security.principal.windowsimpersonationcontext\" data-linktype=\"relative-path\">WindowsImpersonationContext</a>. Otherwise, the resources it is using will not be freed until the garbage collector calls the <a class=\"xref\" href=\"system.security.principal.windowsimpersonationcontext\" data-linktype=\"relative-path\">WindowsImpersonationContext</a> object&#39;s <strong>Finalize</strong> method.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Security_Principal_WindowsImpersonationContext_Dispose_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_Principal_WindowsImpersonationContext_Dispose_System_Boolean_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Dispose(Boolean)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Releases the unmanaged resources used by the <a class=\"xref\" href=\"system.security.principal.windowsimpersonationcontext\" data-linktype=\"relative-path\">WindowsImpersonationContext</a> and optionally releases the managed resources.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">protected virtual void Dispose (bool disposing);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>disposing</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> to release both managed and unmanaged resources; <code>false</code> to release only unmanaged resources.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitysafecriticalattribute\" title=\"System.Security.SecuritySafeCriticalAttribute\" data-linktype=\"relative-path\">SecuritySafeCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This method is called by the public <code>Dispose()</code>method and the <a class=\"xref\" href=\"system.object#System_Object_Finalize_\" data-linktype=\"relative-path\">Finalize</a> method. <code>Dispose()</code> invokes the protected <code>Dispose(Boolean)</code> method with the <code>disposing</code> parameter set to <code>true</code>. <a class=\"xref\" href=\"system.object#System_Object_Finalize_\" data-linktype=\"relative-path\">Finalize</a> invokes <code>Dispose</code> with <code>disposing</code> set to <code>false</code>.  </p>\n<p> When the <code>disposing</code> parameter is true, this method releases all resources held by any managed objects that this <a class=\"xref\" href=\"system.security.principal.windowsimpersonationcontext\" data-linktype=\"relative-path\">WindowsImpersonationContext</a> references. This method invokes the <code>Dispose()</code> method of each referenced object.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Security_Principal_WindowsImpersonationContext_Undo_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_Principal_WindowsImpersonationContext_Undo\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Undo()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Reverts the user context to the Windows user represented by this object.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void Undo ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitysafecriticalattribute\" title=\"System.Security.SecuritySafeCriticalAttribute\" data-linktype=\"relative-path\">SecuritySafeCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.securityexception\" data-linktype=\"relative-path\">SecurityException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>An attempt is made to use this method for any purpose other than to revert identity to self.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc1.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Security.Principal.WindowsImpersonationContext.yml\">\r\n<meta name=\"APIName\" content=\"System.Security.Principal.WindowsImpersonationContext\">\r\n<meta name=\"APIName\" content=\"System.Security.Principal.WindowsImpersonationContext.Dispose\">\r\n<meta name=\"APIName\" content=\"System.Security.Principal.WindowsImpersonationContext.Undo\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-31 02:21 PM\">\r\n<meta name=\"document_id\" content=\"8bc6dee5-1650-41ee-00ed-95a4c9b0380d\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Represents the Windows user prior to an impersonation operation.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.security.principal/toc1.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Security.Principal.WindowsImpersonationContext\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Security.Principal.WindowsImpersonationContext.yml","open_to_public_contributors":false,"api_name":["System.Security.Principal.WindowsImpersonationContext","System.Security.Principal.WindowsImpersonationContext.Dispose","System.Security.Principal.WindowsImpersonationContext.Undo"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Security.Principal.WindowsImpersonationContext","System::Security::Principal::WindowsImpersonationContext","System.Security.Principal.WindowsImpersonationContext.Dispose","System::Security::Principal::WindowsImpersonationContext::Dispose","System.Security.Principal.WindowsImpersonationContext.Undo","System::Security::Principal::WindowsImpersonationContext::Undo"],"dev_langs":["csharp"],"updated_at":"2017-03-31 02:21 PM","document_id":"8bc6dee5-1650-41ee-00ed-95a4c9b0380d","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Security.Principal/WindowsImpersonationContext.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"WindowsImpersonationContext class | Microsoft Docs","_op_ogTitle":"WindowsImpersonationContext class","description":"Represents the Windows user prior to an impersonation operation.\n","toc_asset_id":"api/_splitted/System.Security.Principal/toc.json","toc_rel":"_splitted/System.Security.Principal/toc.json","source_url":"","ms.assetid":"System.Security.Principal.WindowsImpersonationContext","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.security.principal.windowsimpersonationcontext","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.security.principal.windowsimpersonationcontext","fileRelativePath":"api/System.Security.Principal.WindowsImpersonationContext.html"},"themesRelativePathToOutputRoot":"_themes/"}