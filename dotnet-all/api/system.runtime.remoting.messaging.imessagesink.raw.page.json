{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">IMessageSink</span>\r\n      Interface\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Defines the interface for a message sink.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(true)]\npublic interface IMessageSink</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following code example shows the implementation of the IMessageSink interface. Note that the sample assumes type definitions and assembly references that must be provided for the sample to compile.  </p>\n<pre><code class=\"lang-cs\" name=\"IMessageSink_Client#3\">using System;\nusing System.Collections;\nusing System.Threading;\nusing System.Runtime.Remoting;\nusing System.Runtime.Remoting.Channels;\nusing System.Runtime.Remoting.Channels.Http;\nusing System.Runtime.Remoting.Proxies;\nusing System.Runtime.Remoting.Messaging;\nusing System.Security.Permissions;\nusing Share;\t\n\nnamespace MyNameSpace\n{\n   \n   public class MyProxy : RealProxy\n   {\n      string myUrl;\n      string myObjectURI;\n      IMessageSink myMessageSink;\n\n      [PermissionSet(SecurityAction.LinkDemand)]\n      public MyProxy(Type myType, string myUrl1)\n         : base(myType)\n      {\n         \n         myUrl = myUrl1;\n\n         IChannel[] myRegisteredChannels = ChannelServices.RegisteredChannels;\n         foreach (IChannel channel in myRegisteredChannels )\n         {\n            if (channel is IChannelSender)\n            {\n               IChannelSender myChannelSender = (IChannelSender)channel;\n\n               myMessageSink = myChannelSender.CreateMessageSink(myUrl, null, out myObjectURI);\n               if (myMessageSink != null)\n                  break;\n            }\n         }\n\n         if (myMessageSink == null)\n         {\n            throw new Exception(&quot;A supported channel could not be found for myUrl1:&quot;+ myUrl);\n         }\n      }\n\n      [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]\n      public override IMessage Invoke(IMessage myMesg)\n      {\n         Console.WriteLine(&quot;MyProxy.Invoke Start&quot;);\n\n         if (myMesg is IMethodCallMessage)\n            Console.WriteLine(&quot;IMethodCallMessage&quot;);\n\n         if (myMesg is IMethodReturnMessage)\n            Console.WriteLine(&quot;IMethodReturnMessage&quot;);\n\n         Console.WriteLine(&quot;Message Properties&quot;);\n         IDictionary myDictionary = myMesg.Properties;\n         IDictionaryEnumerator myEnum = (IDictionaryEnumerator) myDictionary.GetEnumerator();\n\n         while (myEnum.MoveNext())\n         {\n            object myKey = myEnum.Key;\n            string myKeyName = myKey.ToString();\n            object myValue = myEnum.Value;\n\n            Console.WriteLine(&quot;{0} : {1}&quot;, myKeyName, myEnum.Value);\n            if (myKeyName == &quot;__Args&quot;)\n            {\n               object[] myArgs = (object[])myValue;\n               for (int myInt = 0; myInt &lt; myArgs.Length; myInt++)\n                  Console.WriteLine(&quot;arg: {0} myValue: {1}&quot;, myInt, myArgs[myInt]);\n            }\n\n            if ((myKeyName == &quot;__MethodSignature&quot;) &amp;&amp; (null != myValue))\n            {\n               object[] myArgs = (object[])myValue;\n               for (int myInt = 0; myInt &lt; myArgs.Length; myInt++)\n                  Console.WriteLine(&quot;arg: {0} myValue: {1}&quot;, myInt, myArgs[myInt]);\n            }\n         }\n\n         Console.WriteLine(&quot;myUrl1 {0} object URI{1}&quot;,myUrl,myObjectURI);\n\n         myDictionary[&quot;__Uri&quot;] = myUrl;\n         Console.WriteLine(&quot;URI {0}&quot;, myDictionary[&quot;__URI&quot;]);\n         IMessage myRetMsg = myMessageSink.SyncProcessMessage(myMesg);\n\n         if (myRetMsg is IMethodReturnMessage)\n         {\n            IMethodReturnMessage myMethodReturnMessage = (IMethodReturnMessage)myRetMsg;\n         }\n\n         Console.WriteLine(&quot;MyProxy.Invoke - Finish&quot;);\n         return myRetMsg;\n      }\n   }\n\n   //\n   // Main class that drives the whole sample\n   //\n   public class ProxySample\n   {\n      [PermissionSet(SecurityAction.LinkDemand)]\n      public static void Main()\n      {\n         ChannelServices.RegisterChannel(new HttpChannel());\n\n         Console.WriteLine(&quot;Remoting Sample:&quot;);\n\n         Console.WriteLine(&quot;Generate a new MyProxy using the Type&quot;);\n         Type myType = typeof(MyHelloService);\n         string myUrl1 = &quot;http://localhost/myServiceAccess.soap&quot;;\n         MyProxy myProxy = new MyProxy(myType, myUrl1);\n\n         Console.WriteLine(&quot;Obtain the transparent proxy from myProxy&quot;);\n         MyHelloService myService = (MyHelloService)myProxy.GetTransparentProxy();\n\n         Console.WriteLine(&quot;Calling the Proxy&quot;);\n         string myReturnString = myService.myFunction(&quot;bill&quot;);\n\n         Console.WriteLine(&quot;Checking result : {0}&quot;, myReturnString);\n\n         if (myReturnString == &quot;Hi there bill, you are using .NET Remoting&quot;)\n         {\n            Console.WriteLine(&quot;myService.HelloMethod PASSED : returned {0}&quot;, myReturnString);\n         }\n         else\n         {\n            Console.WriteLine(&quot;myService.HelloMethod FAILED : returned {0}&quot;, myReturnString);\n         }\n      }\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"IMessageSink_Client#3\">\nImports System\nImports System.Collections\nImports System.Threading\nImports System.Runtime.Remoting\nImports System.Runtime.Remoting.Channels\nImports System.Runtime.Remoting.Channels.Http\nImports System.Runtime.Remoting.Proxies\nImports System.Runtime.Remoting.Messaging\nImports System.Security.Permissions\nImports Share\n\n\nNamespace MyNameSpace\n\n   Public Class MyProxy\n      Inherits RealProxy\n      Private myUrl As String\n      Private myObjectURI As String\n      Private myMessageSink As IMessageSink\n\n      &lt;PermissionSet(SecurityAction.LinkDemand)&gt; _\n      Public Sub New(myType As Type, myUrl1 As String)\n         MyBase.New(myType)\n\n         myUrl = myUrl1\n\n         Dim myRegisteredChannels As IChannel() = ChannelServices.RegisteredChannels\n\n         Dim channel As IChannel\n         For Each channel In  myRegisteredChannels\n            If TypeOf channel Is IChannelSender Then\n               Dim myChannelSender As IChannelSender = CType(channel, IChannelSender)\n\n               myMessageSink = myChannelSender.CreateMessageSink(myUrl, Nothing, myObjectURI)\n               If Not (myMessageSink Is Nothing) Then\n                  Exit For\n               End If\n            End If\n         Next channel\n         If myMessageSink Is Nothing Then\n            Throw New Exception(&quot;A supported channel could not be found for myUrl1:&quot; + myUrl)\n         End If\n      End Sub &#39;New\n\n      &lt;SecurityPermission(SecurityAction.LinkDemand, Flags := SecurityPermissionFlag.Infrastructure)&gt; _\n      Public Overrides Function Invoke(ByVal myMesg As IMessage) As IMessage\n         Console.WriteLine(&quot;MyProxy.Invoke Start&quot;)\n\n         If TypeOf myMesg Is IMethodCallMessage Then\n            Console.WriteLine(&quot;IMethodCallMessage&quot;)\n         End If\n         If TypeOf myMesg Is IMethodReturnMessage Then\n            Console.WriteLine(&quot;IMethodReturnMessage&quot;)\n         End If\n\n         Console.WriteLine(&quot;Message Properties&quot;)\n         Dim myDictionary As IDictionary = myMesg.Properties\n         Dim myEnum As IDictionaryEnumerator = CType(myDictionary.GetEnumerator(), IDictionaryEnumerator)\n\n         While myEnum.MoveNext()\n            Dim myKey As Object = myEnum.Key\n            Dim myKeyName As String = myKey.ToString()\n            Dim myValue As Object = myEnum.Value\n\n            Console.WriteLine( &quot;{0} : {1}&quot;, myKeyName, myEnum.Value)\n            If myKeyName = &quot;__Args&quot; Then\n               Dim myArgs As Object() = CType(myValue, Object())\n               Dim myInt As Integer\n               For myInt = 0 To myArgs.Length - 1\n                  Console.WriteLine(  &quot;arg: {0} myValue: {1}&quot;, myInt, myArgs(myInt))\n               Next myInt\n            End If\n            If myKeyName = &quot;__MethodSignature&quot; And Not (myValue Is Nothing) Then\n               Dim myArgs As Object() = CType(myValue, Object())\n               Dim myInt As Integer\n               For myInt = 0 To myArgs.Length - 1\n                  Console.WriteLine(&quot;arg: {0} myValue: {1}&quot;, myInt, myArgs(myInt))\n               Next myInt\n            End If\n         End While\n\n         Console.WriteLine(&quot;myUrl1 {0} object URI{1}&quot;, myUrl, myObjectURI)\n\n         myDictionary(&quot;__Uri&quot;) = myUrl\n         Console.WriteLine(&quot;URI {0}&quot;, myDictionary(&quot;__URI&quot;))\n\n         Dim myRetMsg As IMessage = myMessageSink.SyncProcessMessage(myMesg)\n\n         If TypeOf (myRetMsg) Is IMethodReturnMessage Then\n            Dim myMethodReturnMessage As IMethodReturnMessage = CType(myRetMsg, IMethodReturnMessage)\n         End If\n\n         Console.WriteLine(&quot;MyProxy.Invoke - Finish&quot;)\n         Return myRetMsg\n      End Function &#39;Invoke\n   End Class &#39;MyProxy\n\n   &#39;\n   &#39; Main class that drives the whole sample\n   &#39;\n   Public Class ProxySample\n      &lt;PermissionSet(SecurityAction.LinkDemand)&gt; _\n      Public Shared Sub Main()\n         ChannelServices.RegisterChannel(New HttpChannel())\n\n         Console.WriteLine(&quot;Remoting Sample:&quot;)\n\n         Console.WriteLine(&quot;Generate a new MyProxy using the Type&quot;)\n         Dim myType As Type = GetType(MyHelloService)\n         Dim myUrl1 As String = &quot;http://localhost/myServiceAccess.soap&quot;\n         Dim myProxy As New MyProxy(myType, myUrl1)\n\n         Console.WriteLine(&quot;Obtain the transparent proxy from myProxy&quot;)\n         Dim myService As MyHelloService = CType(myProxy.GetTransparentProxy(), MyHelloService)\n\n         Console.WriteLine(&quot;Calling the Proxy&quot;)\n         Dim myReturnString As String = myService.myFunction(&quot;bill&quot;)\n\n         Console.WriteLine(&quot;Checking result : {0}&quot;, myReturnString)\n\n         If myReturnString = &quot;Hi there bill, you are using .NET Remoting&quot; Then\n            Console.WriteLine(&quot;myService.HelloMethod PASSED : returned {0}&quot;, myReturnString)\n         Else\n            Console.WriteLine(&quot;myService.HelloMethod FAILED : returned {0}&quot;, myReturnString)\n         End If\n      End Sub &#39;Main\n   End Class &#39;ProxySample\nEnd Namespace &#39;MyNameSpace\n</code></pre><pre><code class=\"lang-cpp\" name=\"IMessageSink_Client#3\">#using &lt;System.Runtime.Remoting.dll&gt;\n#using &lt;System.dll&gt;\n#using &lt;IMessageSink_Share.dll&gt;\n\nusing namespace System;\nusing namespace System::Collections;\nusing namespace System::Threading;\nusing namespace System::Runtime::Remoting;\nusing namespace System::Runtime::Remoting::Channels;\nusing namespace System::Runtime::Remoting::Channels::Http;\nusing namespace System::Runtime::Remoting::Proxies;\nusing namespace System::Runtime::Remoting::Messaging;\nusing namespace System::Security::Permissions;\nusing namespace Share;\n\npublic ref class MyProxy: public RealProxy\n{\nprivate:\n   String^ myUrl;\n   String^ myObjectURI;\n   IMessageSink^ myMessageSink;\n\npublic:\n\t[System::Security::Permissions::PermissionSetAttribute(System::Security::Permissions::SecurityAction::LinkDemand)]\n\n   MyProxy( Type^ myType, String^ myUrl1 )\n      : RealProxy( myType )\n   {\n      myUrl = myUrl1;\n      array&lt;IChannel^&gt;^myRegisteredChannels = ChannelServices::RegisteredChannels;\n      IEnumerator^ myEnum = myRegisteredChannels-&gt;GetEnumerator();\n      while ( myEnum-&gt;MoveNext() )\n      {\n         IChannel^ channel = safe_cast&lt;IChannel^&gt;(myEnum-&gt;Current);\n         if ( dynamic_cast&lt;IChannelSender^&gt;(channel) )\n         {\n            IChannelSender^ myChannelSender = dynamic_cast&lt;IChannelSender^&gt;(channel);\n            myMessageSink = myChannelSender-&gt;CreateMessageSink( myUrl, nullptr, myObjectURI );\n            if ( myMessageSink != nullptr )\n                        break;\n         }\n      }\n\n      if ( myMessageSink == nullptr )\n      {\n         throw gcnew Exception( String::Format( &quot;A supported channel could not be found for myUrl1:{0}&quot;, myUrl ) );\n      }\n   }\n\n   virtual IMessage^ Invoke( IMessage^ myMesg ) override\n   {\n      Console::WriteLine( &quot;MyProxy.Invoke Start&quot; );\n      if ( dynamic_cast&lt;IMethodCallMessage^&gt;(myMesg) )\n            Console::WriteLine( &quot;IMethodCallMessage&quot; );\n\n      if ( dynamic_cast&lt;IMethodReturnMessage^&gt;(myMesg) )\n            Console::WriteLine( &quot;IMethodReturnMessage&quot; );\n\n      \n      Console::WriteLine( &quot;Message Properties&quot; );\n      IDictionary^ myDictionary = myMesg-&gt;Properties;\n      IDictionaryEnumerator^ myEnum = dynamic_cast&lt;IDictionaryEnumerator^&gt;(myDictionary-&gt;GetEnumerator());\n      while ( myEnum-&gt;MoveNext() )\n      {\n         Object^ myKey = myEnum-&gt;Key;\n         String^ myKeyName = myKey-&gt;ToString();\n         Object^ myValue = myEnum-&gt;Value;\n         Console::WriteLine( &quot;{0} : {1}&quot;, myKeyName, myEnum-&gt;Value );\n         if ( myKeyName-&gt;Equals( &quot;__Args&quot; ) )\n         {\n            array&lt;Object^&gt;^myArgs = (array&lt;Object^&gt;^)myValue;\n            for ( int myInt = 0; myInt &lt; myArgs-&gt;Length; myInt++ )\n               Console::WriteLine( &quot;arg: {0} myValue: {1}&quot;, myInt, myArgs[ myInt ] );\n         }\n\n         if ( (myKeyName-&gt;Equals( &quot;__MethodSignature&quot; )) &amp;&amp; (nullptr != myValue) )\n         {\n            array&lt;Object^&gt;^myArgs = (array&lt;Object^&gt;^)myValue;\n            for ( int myInt = 0; myInt &lt; myArgs-&gt;Length; myInt++ )\n               Console::WriteLine( &quot;arg: {0} myValue: {1}&quot;, myInt, myArgs[ myInt ] );\n         }\n      }\n\n      Console::WriteLine( &quot;myUrl1 {0} object URI{1}&quot;, myUrl, myObjectURI );\n      myDictionary-&gt;default[ &quot;__Uri&quot; ] = myUrl;\n      Console::WriteLine( &quot;URI {0}&quot;, myDictionary-&gt;default[ &quot;__URI&quot; ] );\n      \n      IMessage^ myRetMsg = myMessageSink-&gt;SyncProcessMessage( myMesg );\n      if ( dynamic_cast&lt;IMethodReturnMessage^&gt;(myRetMsg) )\n      {\n         IMethodReturnMessage^ myMethodReturnMessage = dynamic_cast&lt;IMethodReturnMessage^&gt;(myRetMsg);\n      }\n\n      \n      Console::WriteLine( &quot;MyProxy.Invoke - Finish&quot; );\n      return myRetMsg;\n   }\n\n};\n\n\n//\n// Main function that drives the whole sample\n//\nint main()\n{\n   ChannelServices::RegisterChannel( gcnew HttpChannel, false );\n   Console::WriteLine( &quot;Remoting Sample:&quot; );\n   Console::WriteLine( &quot;Generate a new MyProxy using the Type&quot; );\n   Type^ myType = MyHelloService::typeid;\n   String^ myUrl1 = &quot;http://localhost/myServiceAccess.soap&quot;;\n   MyProxy^ myProxy = gcnew MyProxy( myType,myUrl1 );\n   Console::WriteLine( &quot;Obtain the transparent proxy from myProxy&quot; );\n   MyHelloService^ myService = dynamic_cast&lt;MyHelloService^&gt;(myProxy-&gt;GetTransparentProxy());\n   Console::WriteLine( &quot;Calling the Proxy&quot; );\n   String^ myReturnString = myService-&gt;myFunction( &quot;bill&quot; );\n   Console::WriteLine( &quot;Checking result : {0}&quot;, myReturnString );\n   if ( myReturnString-&gt;Equals( &quot;Hi there bill, you are using .NET Remoting&quot; ) )\n   {\n      Console::WriteLine( &quot;myService.HelloMethod PASSED : returned {0}&quot;, myReturnString );\n   }\n   else\n   {\n      Console::WriteLine( &quot;myService.HelloMethod FAILED : returned {0}&quot;, myReturnString );\n   }\n}\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>When a method call is made on the proxy, the remoting infrastructure provides the necessary support for passing the arguments to the actual object across the remoting boundaries, calling the actual object method with the arguments, and returning the results back to the client of the proxy object.  </p>\n<p> A remote method call is a message that goes from the client end to the server end and possibly back again. As it crosses remoting boundaries on the way, the remote method call passes through a chain of <code>IMessageSink</code> objects. Each sink in the chain receives the message object, performs a specific operation, and delegates to the next sink in the chain. The proxy object contains a reference to the first <code>IMessageSink</code> it needs to use to start off the chain.  </p>\n<p> For asynchronous calls, at the time of delegation, each sink provides a reply sink (another <code>IMessageSink</code>) that will be called by the next sink when the reply is on its way back.  </p>\n<p> Different types of sinks perform different operations, depending on the type of message object received. For example, one sink could cause a lock to be taken, another could enforce call security, another could perform flow call control and reliability services, and yet another could transport the call to a different <a class=\"xref\" href=\"system.appdomain\" data-linktype=\"relative-path\">AppDomain</a>, process, or computer. Two or more message sinks in the chain can interact with each other in regard to each specific action.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Properties\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_Remoting_Messaging_IMessageSink_NextSink\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">NextSink</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets the next message sink in the sink chain.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Runtime.Remoting.Messaging.IMessageSink NextSink { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtime.remoting.messaging.imessagesink\" data-linktype=\"relative-path\">IMessageSink</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The next message sink in the sink chain.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.securityexception\" data-linktype=\"relative-path\">SecurityException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The immediate caller makes the call through a reference to the interface and does not have infrastructure permission.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Methods\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_Remoting_Messaging_IMessageSink_AsyncProcessMessage_System_Runtime_Remoting_Messaging_IMessage_System_Runtime_Remoting_Messaging_IMessageSink_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">AsyncProcessMessage(IMessage, IMessageSink)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Asynchronously processes the given message.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage (System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>msg</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtime.remoting.messaging.imessage\" data-linktype=\"relative-path\">IMessage</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The message to process.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>replySink</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtime.remoting.messaging.imessagesink\" data-linktype=\"relative-path\">IMessageSink</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The reply sink for the reply message.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtime.remoting.messaging.imessagectrl\" data-linktype=\"relative-path\">IMessageCtrl</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>Returns an <a class=\"xref\" href=\"system.runtime.remoting.messaging.imessagectrl\" data-linktype=\"relative-path\">IMessageCtrl</a> interface that provides a way to control asynchronous messages after they have been dispatched.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.securityexception\" data-linktype=\"relative-path\">SecurityException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The immediate caller makes the call through a reference to the interface and does not have infrastructure permission.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This method is invoked on the message sink by the remoting infrastructure or by a previous sink for asynchronous messages.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_Remoting_Messaging_IMessageSink_SyncProcessMessage_System_Runtime_Remoting_Messaging_IMessage_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">SyncProcessMessage(IMessage)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Synchronously processes the given message.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage (System.Runtime.Remoting.Messaging.IMessage msg);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>msg</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtime.remoting.messaging.imessage\" data-linktype=\"relative-path\">IMessage</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The message to process.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtime.remoting.messaging.imessage\" data-linktype=\"relative-path\">IMessage</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>A reply message in response to the request.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.securityexception\" data-linktype=\"relative-path\">SecurityException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The immediate caller makes the call through a reference to the interface and does not have infrastructure permission.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The SyncProcessMessage method is invoked on the message sink by the remoting infrastructure or by a previous sink for synchronous messages.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Runtime.Remoting.Messaging.IMessageSink.yml\">\r\n<meta name=\"APIName\" content=\"System.Runtime.Remoting.Messaging.IMessageSink\">\r\n<meta name=\"APIName\" content=\"System.Runtime.Remoting.Messaging.IMessageSink.AsyncProcessMessage\">\r\n<meta name=\"APIName\" content=\"System.Runtime.Remoting.Messaging.IMessageSink.NextSink\">\r\n<meta name=\"APIName\" content=\"System.Runtime.Remoting.Messaging.IMessageSink.SyncProcessMessage\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-28 03:03 AM\">\r\n<meta name=\"document_id\" content=\"0b417fd3-6f69-181e-3098-1096922e90bf\">\r\n<meta name=\"internalonly\" content=\"false\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Defines the interface for a message sink.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.runtime.remoting.messaging/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Runtime.Remoting.Messaging.IMessageSink\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Runtime.Remoting.Messaging.IMessageSink.yml","open_to_public_contributors":false,"api_name":["System.Runtime.Remoting.Messaging.IMessageSink","System.Runtime.Remoting.Messaging.IMessageSink.AsyncProcessMessage","System.Runtime.Remoting.Messaging.IMessageSink.NextSink","System.Runtime.Remoting.Messaging.IMessageSink.SyncProcessMessage"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Runtime.Remoting.Messaging.IMessageSink","System::Runtime::Remoting::Messaging::IMessageSink","System.Runtime.Remoting.Messaging.IMessageSink.AsyncProcessMessage","System::Runtime::Remoting::Messaging::IMessageSink::AsyncProcessMessage","System.Runtime.Remoting.Messaging.IMessageSink.NextSink","System::Runtime::Remoting::Messaging::IMessageSink::NextSink","System.Runtime.Remoting.Messaging.IMessageSink.SyncProcessMessage","System::Runtime::Remoting::Messaging::IMessageSink::SyncProcessMessage"],"dev_langs":["csharp"],"updated_at":"2017-03-28 03:03 AM","document_id":"0b417fd3-6f69-181e-3098-1096922e90bf","content_git_url":"https://github.com/dotnet/docs/blob/master/xml/System.Runtime.Remoting.Messaging/IMessageSink.xml","internalonly":false,"layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"IMessageSink interface | Microsoft Docs","_op_ogTitle":"IMessageSink interface","description":"Defines the interface for a message sink.\n","toc_asset_id":"api/_splitted/System.Runtime.Remoting.Messaging/toc.json","toc_rel":"_splitted/System.Runtime.Remoting.Messaging/toc.json","source_url":"","ms.assetid":"System.Runtime.Remoting.Messaging.IMessageSink","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.runtime.remoting.messaging.imessagesink","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.runtime.remoting.messaging.imessagesink","fileRelativePath":"api/System.Runtime.Remoting.Messaging.IMessageSink.html"},"themesRelativePathToOutputRoot":"_themes/"}