{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">StreamingContext</span>\r\n      Struct\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Describes the source and destination of a given serialized stream, and provides an additional caller-defined context.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(true)]\npublic struct StreamingContext</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.valuetype\" data-linktype=\"relative-path\">System.ValueType</a></span></div><span class=\"lang-csharp\">StreamingContext</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following code example demonstrates the StreamingContext structure.  </p>\n<pre><code class=\"lang-vb\" name=\"StreamingContext Example#1\">Imports System\nImports System.IO\nImports System.Collections\nImports System.Runtime.Serialization.Formatters.Binary\nImports System.Runtime.Serialization\nImports System.Runtime.InteropServices\nImports System.Security.Permissions\n\n&lt;Assembly: SecurityPermission( _\nSecurityAction.RequestMinimum, Execution:=True)&gt; \n&#39; This class includes several Win32 interop definitions.\nFriend Class Win32\n    Public Shared ReadOnly InvalidHandleValue As New IntPtr(-1)\n    Public Const FILE_MAP_WRITE As Int32 = 2\n    Public Const PAGE_READWRITE As Int32 = &amp;H4\n\n    &lt;DllImport(&quot;Kernel32&quot;, CharSet:=CharSet.Unicode)&gt; _\n    Public Shared Function CreateFileMapping(ByVal hFile As IntPtr, _\n                                             ByVal pAttributes As IntPtr, _\n                                             ByVal flProtect As Int32, _\n                                             ByVal dwMaximumSizeHigh As Int32, _\n                                             ByVal dwMaximumSizeLow As Int32, _\n                                             ByVal pName As String) As IntPtr\n    End Function\n\n    &lt;DllImport(&quot;Kernel32&quot;, CharSet:=CharSet.Unicode)&gt; _\n    Public Shared Function OpenFileMapping(ByVal dwDesiredAccess As Int32, _\n                                           ByVal bInheritHandle As Boolean, _\n                                           ByVal name As String) As IntPtr\n    End Function\n\n    &lt;DllImport(&quot;Kernel32&quot;, CharSet:=CharSet.Unicode)&gt; _\n    Public Shared Function CloseHandle(ByVal handle As IntPtr) As Boolean\n    End Function\n\n    &lt;DllImport(&quot;Kernel32&quot;, CharSet:=CharSet.Unicode)&gt; _\n    Public Shared Function MapViewOfFile(ByVal hFileMappingObject As IntPtr, _\n                                         ByVal dwDesiredAccess As Int32, _\n                                         ByVal dwFileOffsetHigh As Int32, _\n                                         ByVal dwFileOffsetLow As Int32, _\n                                         ByVal dwNumberOfBytesToMap As IntPtr) _\n                                         As IntPtr\n    End Function\n\n    &lt;DllImport(&quot;Kernel32&quot;, CharSet:=CharSet.Unicode)&gt; _\n    Public Shared Function UnmapViewOfFile(ByVal address As IntPtr) As Boolean\n    End Function\n\n    &lt;DllImport(&quot;Kernel32&quot;, CharSet:=CharSet.Unicode)&gt; _\n    Public Shared Function DuplicateHandle(ByVal hSourceProcessHandle As IntPtr, _\n                                           ByVal hSourceHandle As IntPtr, _\n                                           ByVal hTargetProcessHandle As IntPtr, _\n                                           ByRef lpTargetHandle As IntPtr, _\n                                           ByVal dwDesiredAccess As Int32, _\n                                           ByVal bInheritHandle As Boolean, _\n                                           ByVal dwOptions As Int32) As Boolean\n    End Function\n\n    Public Const DUPLICATE_CLOSE_SOURCE As Int32 = &amp;H1\n    Public Const DUPLICATE_SAME_ACCESS As Int32 = &amp;H2\n\n    &lt;DllImport(&quot;Kernel32&quot;, CharSet:=CharSet.Unicode)&gt; Public Shared Function GetCurrentProcess() As IntPtr\n    End Function\nEnd Class\n\n\n&#39; This class wraps memory that can be simultaneously \n&#39; shared by multiple AppDomains and Processes.\n&lt;Serializable()&gt; Public NotInheritable Class SharedMemory\n    Implements ISerializable\n    Implements IDisposable\n\n    &#39; The handle and string that identify \n    &#39; the Windows file-mapping object.\n    Private m_hFileMap As IntPtr = IntPtr.Zero\n    Private m_name As String\n\n    &#39; The address of the memory-mapped file-mapping object.\n    Private m_address As IntPtr\n    &lt;SecurityPermissionAttribute(SecurityAction.LinkDemand, _\n    Flags:=SecurityPermissionFlag.UnmanagedCode)&gt; _\n    Public Function GetByte(ByVal offset As Int32) As Byte\n        Dim b(0) As Byte\n        Marshal.Copy(New IntPtr(m_address.ToInt64() + offset), b, 0, 1)\n        Return b(0)\n    End Function\n\n    &lt;SecurityPermissionAttribute(SecurityAction.LinkDemand, _\n    Flags:=SecurityPermissionFlag.UnmanagedCode)&gt; _\n    Public Sub SetByte(ByVal offset As Int32, ByVal value As Byte)\n        Dim b(0) As Byte\n        b(0) = value\n        Marshal.Copy(b, 0, New IntPtr(m_address.ToInt64() + offset), 1)\n    End Sub\n\n\n    &#39; The constructors.\n    Public Sub New(ByVal size As Int32)\n        Me.New(size, Nothing)\n    End Sub\n\n    Public Sub New(ByVal size As Int32, ByVal name As String)\n        m_hFileMap = Win32.CreateFileMapping(Win32.InvalidHandleValue, _\n           IntPtr.Zero, Win32.PAGE_READWRITE, 0, size, name)\n        If (m_hFileMap.Equals(IntPtr.Zero)) Then _\n           Throw New Exception(&quot;Could not create memory-mapped file.&quot;)\n        m_name = name\n        m_address = Win32.MapViewOfFile(m_hFileMap, _\n           Win32.FILE_MAP_WRITE, 0, 0, IntPtr.Zero)\n    End Sub\n\n\n    &#39; The cleanup methods.\n    Public Sub Dispose() Implements IDisposable.Dispose\n        GC.SuppressFinalize(Me)\n        Dispose(True)\n    End Sub\n\n    Private Sub Dispose(ByVal disposing As Boolean)\n        Win32.UnmapViewOfFile(m_address)\n        Win32.CloseHandle(m_hFileMap)\n        m_address = IntPtr.Zero\n        m_hFileMap = IntPtr.Zero\n    End Sub\n\n    Protected Overrides Sub Finalize()\n        Dispose(False)\n    End Sub\n\n\n    &#39; Private helper methods.\n    Private Shared Function AllFlagsSet(ByVal flags As Int32, _\n                                        ByVal flagsToTest As Int32) As Boolean\n        Return (flags And flagsToTest) = flagsToTest\n    End Function\n\n    Private Shared Function AnyFlagsSet(ByVal flags As Int32, _\n                                        ByVal flagsToTest As Int32) As Boolean\n        Return (flags And flagsToTest) &lt;&gt; 0\n    End Function\n\n\n    &#39; The security attribute demands that code that calls  \n    &#39; this method have permission to perform serialization.\n    &lt;SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter:=True)&gt; _\n    Sub GetObjectData(ByVal info As SerializationInfo, _\n                      ByVal context As StreamingContext) _\n                      Implements ISerializable.GetObjectData\n        &#39; The context&#39;s State member indicates where the object will be deserialized.\n\n        &#39; A SharedMemory object cannot be serialized \n        &#39; to any of the following destinations.\n        Const InvalidDestinations As StreamingContextStates = _\n           StreamingContextStates.CrossMachine Or _\n           StreamingContextStates.File Or _\n           StreamingContextStates.Other Or _\n           StreamingContextStates.Persistence Or _\n           StreamingContextStates.Remoting\n        If AnyFlagsSet(CType(context.State, Int32), _\n                       CType(InvalidDestinations, Int32)) Then\n            Throw New SerializationException(&quot;The SharedMemory object &quot; &amp; _\n               &quot;cannot be serialized to any of the following streaming contexts: &quot; _\n               &amp; InvalidDestinations)\n        End If\n\n        Const DeserializableByHandle As StreamingContextStates = _\n                 StreamingContextStates.Clone Or _\n                 StreamingContextStates.CrossAppDomain\n\n        If AnyFlagsSet(CType(context.State, Int32), _\n              CType(DeserializableByHandle, Int32)) Then\n            info.AddValue(&quot;hFileMap&quot;, m_hFileMap)\n        End If\n\n        Const DeserializableByName As StreamingContextStates = _\n                 StreamingContextStates.CrossProcess   &#39; The same computer.\n        If AnyFlagsSet(CType(context.State, Int32), CType(DeserializableByName, _\n                       Int32)) Then\n            If m_name = Nothing Then\n                Throw New SerializationException(&quot;The SharedMemory object &quot; &amp; _\n                   &quot;cannot be serialized CrossProcess because it was not constructed &quot; &amp; _\n                   &quot;with a String name.&quot;)\n            End If\n            info.AddValue(&quot;name&quot;, m_name)\n        End If\n    End Sub\n\n    Private Sub New(ByVal info As SerializationInfo, ByVal context As StreamingContext)\n        &#39; The context&#39;s State member indicates where the object was serialized from.\n\n        Const InvalidSources As StreamingContextStates = _\n                 StreamingContextStates.CrossMachine Or _\n                 StreamingContextStates.File Or _\n                 StreamingContextStates.Other Or _\n                 StreamingContextStates.Persistence Or _\n                 StreamingContextStates.Remoting\n\n        If AnyFlagsSet(CType(context.State, Int32), CType(InvalidSources, Int32)) Then\n            Throw New SerializationException(&quot;The SharedMemory object &quot; &amp; _\n               &quot;cannot be deserialized from any of the following stream contexts: &quot; &amp; _\n               InvalidSources)\n        End If\n\n        Const SerializedByHandle As StreamingContextStates = _\n                 StreamingContextStates.Clone Or _\n                 StreamingContextStates.CrossAppDomain &#39; The same process.\n        If AnyFlagsSet(CType(context.State, Int32), _\n              CType(SerializedByHandle, Int32)) Then\n            Try\n                Win32.DuplicateHandle(Win32.GetCurrentProcess(), _\n                   CType(info.GetValue(&quot;hFileMap&quot;, GetType(IntPtr)), IntPtr), _\n                      Win32.GetCurrentProcess(), m_hFileMap, 0, False, _\n                      Win32.DUPLICATE_SAME_ACCESS)\n            Catch e As SerializationException\n                Throw New SerializationException(&quot;A SharedMemory was not &quot; &amp; _\n                   &quot;serialized using any of the following streaming contexts: &quot; &amp; _\n                   SerializedByHandle)\n            End Try\n        End If\n\n        Const SerializedByName As StreamingContextStates = _\n                 StreamingContextStates.CrossProcess   &#39; The same computer.\n        If AnyFlagsSet(CType(context.State, Int32), _\n                       CType(SerializedByName, Int32)) Then\n            Try\n                m_name = info.GetString(&quot;name&quot;)\n            Catch e As SerializationException\n                Throw New SerializationException(&quot;A SharedMemory object &quot; &amp; _\n                   &quot;was not serialized using any of the following streaming contexts: &quot; &amp; _\n                   SerializedByName)\n            End Try\n            m_hFileMap = Win32.OpenFileMapping(Win32.FILE_MAP_WRITE, False, m_name)\n        End If\n        If Not m_hFileMap.Equals(IntPtr.Zero) Then\n            m_address = Win32.MapViewOfFile(m_hFileMap, _\n               Win32.FILE_MAP_WRITE, 0, 0, IntPtr.Zero)\n        Else\n            Throw New SerializationException(&quot;A SharedMemory object &quot; &amp; _\n               &quot;could not be deserialized.&quot;)\n        End If\n    End Sub\nEnd Class\n\nClass App\n    &lt;STAThread()&gt; Shared Sub Main()\n        Serialize()\n        Console.WriteLine()\n        Deserialize()\n    End Sub\n\n    Shared Sub Serialize()\n        &#39; Create a hashtable of values that will eventually be serialized.\n        Dim sm As New SharedMemory(1024, &quot;MyMemory&quot;)\n        Dim x As Int32\n        For x = 0 To 99\n            sm.SetByte(x, x)\n        Next\n\n        Dim b(9) As Byte\n        For x = 0 To b.Length - 1\n            b(x) = sm.GetByte(x)\n        Next\n        Console.WriteLine(BitConverter.ToString(b))\n\n        &#39; To serialize the hashtable (and its key/value pairs), you must first \n        &#39; open a stream for writing. Use a file stream here.\n        Dim fs As New FileStream(&quot;DataFile.dat&quot;, FileMode.Create)\n\n        &#39; Construct a BinaryFormatter telling it where \n        &#39; the objects will be serialized to.\n        Dim formatter As New BinaryFormatter(Nothing, _\n           New StreamingContext(StreamingContextStates.CrossAppDomain))\n        Try\n            formatter.Serialize(fs, sm)\n        Catch e As SerializationException\n            Console.WriteLine(&quot;Failed to serialize. Reason: &quot; + e.Message)\n            Throw\n        Finally\n            fs.Close()\n        End Try\n    End Sub\n\n    Shared Sub Deserialize()\n        &#39; Declare the hashtable reference.\n        Dim sm As SharedMemory = Nothing\n\n        &#39; Open the file containing the data that you want to deserialize.\n        Dim fs As New FileStream(&quot;DataFile.dat&quot;, FileMode.Open)\n        Try\n            Dim Formatter As New BinaryFormatter(Nothing, _\n               New StreamingContext(StreamingContextStates.CrossAppDomain))\n\n            &#39; Deserialize the SharedMemory object from the file and \n            &#39; assign the reference to the local variable.\n            sm = DirectCast(Formatter.Deserialize(fs), SharedMemory)\n        Catch e As SerializationException\n            Console.WriteLine(&quot;Failed to deserialize. Reason: &quot; &amp; e.Message)\n        Finally\n            fs.Close()\n        End Try\n\n        &#39; To prove that the SharedMemory object deserialized correctly, \n        &#39; display some of its bytes to the console.\n        Dim b(9) As Byte\n        Dim x As Int32\n        For x = 0 To b.Length - 1\n            b(x) = sm.GetByte(x)\n        Next\n        Console.WriteLine(BitConverter.ToString(b))\n    End Sub\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"StreamingContext Example#1\">// Note: You must compile this file using the C# /unsafe switch.\nusing System;\nusing System.IO;\nusing System.Collections;\nusing System.Runtime.Serialization.Formatters.Binary;\nusing System.Runtime.Serialization;\nusing System.Runtime.InteropServices;\nusing System.Security.Permissions;\n\n[assembly: SecurityPermission(\nSecurityAction.RequestMinimum, Execution = true)]\n// This class includes several Win32 interop definitions.\ninternal class Win32\n{\n    public static readonly IntPtr InvalidHandleValue = new IntPtr(-1);\n    public const UInt32 FILE_MAP_WRITE = 2;\n    public const UInt32 PAGE_READWRITE = 0x04;\n\n    [DllImport(&quot;Kernel32&quot;,CharSet=CharSet.Unicode)]\n    public static extern IntPtr CreateFileMapping(IntPtr hFile,\n        IntPtr pAttributes, UInt32 flProtect,\n        UInt32 dwMaximumSizeHigh, UInt32 dwMaximumSizeLow, String pName);\n\n    [DllImport(&quot;Kernel32&quot;,CharSet=CharSet.Unicode)]\n    public static extern IntPtr OpenFileMapping(UInt32 dwDesiredAccess,\n        Boolean bInheritHandle, String name);\n\n    [DllImport(&quot;Kernel32&quot;,CharSet=CharSet.Unicode)]\n    public static extern Boolean CloseHandle(IntPtr handle);\n\n    [DllImport(&quot;Kernel32&quot;,CharSet=CharSet.Unicode)]\n    public static extern IntPtr MapViewOfFile(IntPtr hFileMappingObject,\n        UInt32 dwDesiredAccess,\n        UInt32 dwFileOffsetHigh, UInt32 dwFileOffsetLow,\n        IntPtr dwNumberOfBytesToMap);\n\n    [DllImport(&quot;Kernel32&quot;,CharSet=CharSet.Unicode)]\n    public static extern Boolean UnmapViewOfFile(IntPtr address);\n\n    [DllImport(&quot;Kernel32&quot;,CharSet=CharSet.Unicode)]\n    public static extern Boolean DuplicateHandle(IntPtr hSourceProcessHandle,\n        IntPtr hSourceHandle,\n        IntPtr hTargetProcessHandle, ref IntPtr lpTargetHandle,\n        UInt32 dwDesiredAccess, Boolean bInheritHandle, UInt32 dwOptions);\n    public const UInt32 DUPLICATE_CLOSE_SOURCE = 0x00000001;\n    public const UInt32 DUPLICATE_SAME_ACCESS = 0x00000002;\n\n    [DllImport(&quot;Kernel32&quot;,CharSet=CharSet.Unicode)]\n    public static extern IntPtr GetCurrentProcess();\n}\n\n\n// This class wraps memory that can be simultaneously \n// shared by multiple AppDomains and Processes.\n[Serializable]\npublic sealed class SharedMemory : ISerializable, IDisposable\n{\n    // The handle and string that identify \n    // the Windows file-mapping object.\n    private IntPtr m_hFileMap = IntPtr.Zero;\n    private String m_name;\n\n    // The address of the memory-mapped file-mapping object.\n    private IntPtr m_address;\n\n    public unsafe Byte* Address\n    {\n        get { return (Byte*)m_address; }\n    }\n\n    // The constructors.\n    public SharedMemory(Int32 size) : this(size, null) { }\n\n    public SharedMemory(Int32 size, String name)\n    {\n        m_hFileMap = Win32.CreateFileMapping(Win32.InvalidHandleValue,\n            IntPtr.Zero, Win32.PAGE_READWRITE,\n            0, unchecked((UInt32)size), name);\n        if (m_hFileMap == IntPtr.Zero)\n            throw new Exception(&quot;Could not create memory-mapped file.&quot;);\n        m_name = name;\n        m_address = Win32.MapViewOfFile(m_hFileMap, Win32.FILE_MAP_WRITE,\n            0, 0, IntPtr.Zero);\n    }\n\n    // The cleanup methods.\n    public void Dispose()\n    {\n        GC.SuppressFinalize(this);\n        Dispose(true);\n    }\n\n    private void Dispose(Boolean disposing)\n    {\n        Win32.UnmapViewOfFile(m_address);\n        Win32.CloseHandle(m_hFileMap);\n        m_address = IntPtr.Zero;\n        m_hFileMap = IntPtr.Zero;\n    }\n\n    ~SharedMemory()\n    {\n        Dispose(false);\n    }\n\n    // Private helper methods.\n    private static Boolean AllFlagsSet(Int32 flags, Int32 flagsToTest)\n    {\n        return (flags &amp; flagsToTest) == flagsToTest;\n    }\n\n    private static Boolean AnyFlagsSet(Int32 flags, Int32 flagsToTest)\n    {\n        return (flags &amp; flagsToTest) != 0;\n    }\n\n\n    // The security attribute demands that code that calls  \n    // this method have permission to perform serialization.\n    [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]\n    void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)\n    {\n        // The context&#39;s State member indicates\n        // where the object will be deserialized.\n\n        // A SharedMemory object cannot be serialized \n        // to any of the following destinations.\n        const StreamingContextStates InvalidDestinations =\n                  StreamingContextStates.CrossMachine |\n                  StreamingContextStates.File |\n                  StreamingContextStates.Other |\n                  StreamingContextStates.Persistence |\n                  StreamingContextStates.Remoting;\n        if (AnyFlagsSet((Int32)context.State, (Int32)InvalidDestinations))\n            throw new SerializationException(&quot;The SharedMemory object &quot; +\n                &quot;cannot be serialized to any of the following streaming contexts: &quot; +\n                InvalidDestinations);\n\n        const StreamingContextStates DeserializableByHandle =\n                  StreamingContextStates.Clone |\n            // The same process.\n                  StreamingContextStates.CrossAppDomain;\n        if (AnyFlagsSet((Int32)context.State, (Int32)DeserializableByHandle))\n            info.AddValue(&quot;hFileMap&quot;, m_hFileMap);\n\n        const StreamingContextStates DeserializableByName =\n            // The same computer.\n                  StreamingContextStates.CrossProcess;\n        if (AnyFlagsSet((Int32)context.State, (Int32)DeserializableByName))\n        {\n            if (m_name == null)\n                throw new SerializationException(&quot;The SharedMemory object &quot; +\n                    &quot;cannot be serialized CrossProcess because it was not constructed &quot; +\n                    &quot;with a String name.&quot;);\n            info.AddValue(&quot;name&quot;, m_name);\n        }\n    }\n\n\n    // The security attribute demands that code that calls  \n    // this method have permission to perform serialization.\n    [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]\n    private SharedMemory(SerializationInfo info, StreamingContext context)\n    {\n        // The context&#39;s State member indicates \n        // where the object was serialized from.\n\n        const StreamingContextStates InvalidSources =\n                  StreamingContextStates.CrossMachine |\n                  StreamingContextStates.File |\n                  StreamingContextStates.Other |\n                  StreamingContextStates.Persistence |\n                  StreamingContextStates.Remoting;\n        if (AnyFlagsSet((Int32)context.State, (Int32)InvalidSources))\n            throw new SerializationException(&quot;The SharedMemory object &quot; +\n                &quot;cannot be deserialized from any of the following stream contexts: &quot; +\n                InvalidSources);\n\n        const StreamingContextStates SerializedByHandle =\n                  StreamingContextStates.Clone |\n            // The same process.\n                  StreamingContextStates.CrossAppDomain;\n        if (AnyFlagsSet((Int32)context.State, (Int32)SerializedByHandle))\n        {\n            try\n            {\n                Win32.DuplicateHandle(Win32.GetCurrentProcess(),\n                    (IntPtr)info.GetValue(&quot;hFileMap&quot;, typeof(IntPtr)),\n                    Win32.GetCurrentProcess(), ref m_hFileMap, 0, false,\n                    Win32.DUPLICATE_SAME_ACCESS);\n            }\n            catch (SerializationException)\n            {\n                throw new SerializationException(&quot;A SharedMemory was not serialized &quot; +\n                    &quot;using any of the following streaming contexts: &quot; +\n                    SerializedByHandle);\n            }\n        }\n\n        const StreamingContextStates SerializedByName =\n            // The same computer.\n                  StreamingContextStates.CrossProcess;\n        if (AnyFlagsSet((Int32)context.State, (Int32)SerializedByName))\n        {\n            try\n            {\n                m_name = info.GetString(&quot;name&quot;);\n            }\n            catch (SerializationException)\n            {\n                throw new SerializationException(&quot;A SharedMemory object was not &quot; +\n                    &quot;serialized using any of the following streaming contexts: &quot; +\n                    SerializedByName);\n            }\n            m_hFileMap = Win32.OpenFileMapping(Win32.FILE_MAP_WRITE, false, m_name);\n        }\n        if (m_hFileMap != IntPtr.Zero)\n        {\n            m_address = Win32.MapViewOfFile(m_hFileMap, Win32.FILE_MAP_WRITE,\n                0, 0, IntPtr.Zero);\n        }\n        else\n        {\n            throw new SerializationException(&quot;A SharedMemory object could not &quot; +\n                &quot;be deserialized.&quot;);\n        }\n    }\n}\n\n\nclass App\n{\n    [STAThread]\n    static void Main(string[] args)\n    {\n        Serialize();\n        Console.WriteLine();\n        Deserialize();\n    }\n\n    unsafe static void Serialize()\n    {\n        // Create a hashtable of values that will eventually be serialized.\n        SharedMemory sm = new SharedMemory(1024, &quot;JeffMemory&quot;);\n        for (Int32 x = 0; x &lt; 100; x++)\n            *(sm.Address + x) = (Byte)x;\n\n        Byte[] b = new Byte[10];\n        for (Int32 x = 0; x &lt; b.Length; x++) b[x] = *(sm.Address + x);\n        Console.WriteLine(BitConverter.ToString(b));\n\n        // To serialize the SharedMemory object, \n        // you must first open a stream for writing. \n        // Use a file stream here.\n        FileStream fs = new FileStream(&quot;DataFile.dat&quot;, FileMode.Create);\n\n        // Construct a BinaryFormatter and tell it where \n        // the objects will be serialized to.\n        BinaryFormatter formatter = new BinaryFormatter(null,\n            new StreamingContext(StreamingContextStates.CrossAppDomain));\n        try\n        {\n            formatter.Serialize(fs, sm);\n        }\n        catch (SerializationException e)\n        {\n            Console.WriteLine(&quot;Failed to serialize. Reason: &quot; + e.Message);\n            throw;\n        }\n        finally\n        {\n            fs.Close();\n        }\n    }\n\n\n    unsafe static void Deserialize()\n    {\n        // Declare a SharedMemory reference.\n        SharedMemory sm = null;\n\n        // Open the file containing the data that you want to deserialize.\n        FileStream fs = new FileStream(&quot;DataFile.dat&quot;, FileMode.Open);\n        try\n        {\n            BinaryFormatter formatter = new BinaryFormatter(null,\n                new StreamingContext(StreamingContextStates.CrossAppDomain));\n\n            // Deserialize the SharedMemory object from the file and \n            // assign the reference to the local variable.\n            sm = (SharedMemory)formatter.Deserialize(fs);\n        }\n        catch (SerializationException e)\n        {\n            Console.WriteLine(&quot;Failed to deserialize. Reason: &quot; + e.Message);\n            throw;\n        }\n        finally\n        {\n            fs.Close();\n        }\n\n        // To prove that the SharedMemory object deserialized correctly, \n        // display some of its bytes to the console.\n        Byte[] b = new Byte[10];\n        for (Int32 x = 0; x &lt; b.Length; x++) b[x] = *(sm.Address + x);\n        Console.WriteLine(BitConverter.ToString(b));\n    }\n}\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>Indicates the source or destination of the bits that the formatter uses. Classes with surrogates or that implement <a class=\"xref\" href=\"system.runtime.serialization.iserializable\" data-linktype=\"relative-path\">ISerializable</a> can serialize or ignore fields and values based on the information stored in the streaming context. For example, a window handle is still valid if the <a class=\"xref\" href=\"system.runtime.serialization.streamingcontext#System_Runtime_Serialization_StreamingContext_State_\" data-linktype=\"relative-path\">State</a> property is set to <code>System.Runtime.Serialization.StreamingContextStates.CrossProcess</code>.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Constructors\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_Serialization_StreamingContext__ctor_System_Runtime_Serialization_StreamingContextStates_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">StreamingContext(StreamingContextStates)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Initializes a new instance of the <a class=\"xref\" href=\"system.runtime.serialization.streamingcontext\" data-linktype=\"relative-path\">StreamingContext</a> class with a given context state.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public StreamingContext (System.Runtime.Serialization.StreamingContextStates state);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>state</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtime.serialization.streamingcontextstates\" data-linktype=\"relative-path\">StreamingContextStates</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A bitwise combination of the <a class=\"xref\" href=\"system.runtime.serialization.streamingcontextstates\" data-linktype=\"relative-path\">StreamingContextStates</a> values that specify the source or destination context for this <a class=\"xref\" href=\"system.runtime.serialization.streamingcontext\" data-linktype=\"relative-path\">StreamingContext</a>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_Serialization_StreamingContext__ctor_System_Runtime_Serialization_StreamingContextStates_System_Object_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">StreamingContext(StreamingContextStates,Object)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Initializes a new instance of the <a class=\"xref\" href=\"system.runtime.serialization.streamingcontext\" data-linktype=\"relative-path\">StreamingContext</a> class with a given context state, and some additional information.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public StreamingContext (System.Runtime.Serialization.StreamingContextStates state, object additional);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>state</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtime.serialization.streamingcontextstates\" data-linktype=\"relative-path\">StreamingContextStates</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A bitwise combination of the <a class=\"xref\" href=\"system.runtime.serialization.streamingcontextstates\" data-linktype=\"relative-path\">StreamingContextStates</a> values that specify the source or destination context for this <a class=\"xref\" href=\"system.runtime.serialization.streamingcontext\" data-linktype=\"relative-path\">StreamingContext</a>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>additional</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>Any additional information to be associated with the <a class=\"xref\" href=\"system.runtime.serialization.streamingcontext\" data-linktype=\"relative-path\">StreamingContext</a>. This information is available to any object that implements <a class=\"xref\" href=\"system.runtime.serialization.iserializable\" data-linktype=\"relative-path\">ISerializable</a> or any serialization surrogate. Most users do not need to set this parameter.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t  \r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Properties\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_Serialization_StreamingContext_Context\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Context</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets context specified as part of the additional context.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public object Context { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The context specified as part of the additional context.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Can be <code>null</code>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_Serialization_StreamingContext_State\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">State</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets the source or destination of the transmitted data.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Runtime.Serialization.StreamingContextStates State { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtime.serialization.streamingcontextstates\" data-linktype=\"relative-path\">StreamingContextStates</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>During serialization, the destination of the transmitted data. During deserialization, the source of the data.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>During serialization, the current property specifies the destination of the transmitted data. For example, when serializing data from cross-AppDomain remoting, the <a class=\"xref\" href=\"system.runtime.serialization.streamingcontextstates\" data-linktype=\"relative-path\">StreamingContextStates</a> is <a class=\"xref\" href=\"system.runtime.serialization.streamingcontextstates\" data-linktype=\"relative-path\">StreamingContextStates</a>. During deserialization, the state indicates the source of the deserialized stream.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t  \r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Methods\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_Serialization_StreamingContext_Equals_System_Object_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Equals(Object)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Determines whether two <a class=\"xref\" href=\"system.runtime.serialization.streamingcontext\" data-linktype=\"relative-path\">StreamingContext</a> instances contain the same values.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public override bool Equals (object obj);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>obj</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An object to compare with the current instance.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if the specified object is an instance of <a class=\"xref\" href=\"system.runtime.serialization.streamingcontext\" data-linktype=\"relative-path\">StreamingContext</a> and equals the value of the current instance; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Two code groups are equivalent if they have the same <a class=\"xref\" href=\"system.runtime.serialization.streamingcontext#System_Runtime_Serialization_StreamingContext_Context_\" data-linktype=\"relative-path\">Context</a> and <a class=\"xref\" href=\"system.runtime.serialization.streamingcontext#System_Runtime_Serialization_StreamingContext_State_\" data-linktype=\"relative-path\">State</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Runtime_Serialization_StreamingContext_GetHashCode\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">GetHashCode()</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Returns a hash code of this object.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public override int GetHashCode ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The <a class=\"xref\" href=\"system.runtime.serialization.streamingcontextstates\" data-linktype=\"relative-path\">StreamingContextStates</a> value that contains the source or destination of the serialization for this <a class=\"xref\" href=\"system.runtime.serialization.streamingcontext\" data-linktype=\"relative-path\">StreamingContext</a>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t  \r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Runtime.Serialization.StreamingContext.yml\">\r\n<meta name=\"APIName\" content=\"System.Runtime.Serialization.StreamingContext\">\r\n<meta name=\"APIName\" content=\"System.Runtime.Serialization.StreamingContext..ctor\">\r\n<meta name=\"APIName\" content=\"System.Runtime.Serialization.StreamingContext.Context\">\r\n<meta name=\"APIName\" content=\"System.Runtime.Serialization.StreamingContext.Equals\">\r\n<meta name=\"APIName\" content=\"System.Runtime.Serialization.StreamingContext.GetHashCode\">\r\n<meta name=\"APIName\" content=\"System.Runtime.Serialization.StreamingContext.State\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-24 01:41 AM\">\r\n<meta name=\"document_id\" content=\"e34f2c1d-0c62-ca96-e66c-e604169d5e19\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Describes the source and destination of a given serialized stream, and provides an additional caller-defined context.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.runtime.serialization/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Runtime.Serialization.StreamingContext\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Runtime.Serialization.StreamingContext.yml","open_to_public_contributors":false,"api_name":["System.Runtime.Serialization.StreamingContext","System.Runtime.Serialization.StreamingContext..ctor","System.Runtime.Serialization.StreamingContext.Context","System.Runtime.Serialization.StreamingContext.Equals","System.Runtime.Serialization.StreamingContext.GetHashCode","System.Runtime.Serialization.StreamingContext.State"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Runtime.Serialization.StreamingContext","System::Runtime::Serialization::StreamingContext","System.Runtime.Serialization.StreamingContext.#ctor","System::Runtime::Serialization::StreamingContext::#ctor","System.Runtime.Serialization.StreamingContext.Context","System::Runtime::Serialization::StreamingContext::Context","System.Runtime.Serialization.StreamingContext.Equals","System::Runtime::Serialization::StreamingContext::Equals","System.Runtime.Serialization.StreamingContext.GetHashCode","System::Runtime::Serialization::StreamingContext::GetHashCode","System.Runtime.Serialization.StreamingContext.State","System::Runtime::Serialization::StreamingContext::State"],"dev_langs":["csharp"],"updated_at":"2017-03-24 01:41 AM","document_id":"e34f2c1d-0c62-ca96-e66c-e604169d5e19","content_git_url":"https://github.com/dotnet/docs/blob/master/xml/System.Runtime.Serialization/StreamingContext.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"StreamingContext struct | Microsoft Docs","_op_ogTitle":"StreamingContext struct","description":"Describes the source and destination of a given serialized stream, and provides an additional caller-defined context.\n","toc_asset_id":"api/_splitted/System.Runtime.Serialization/toc.json","toc_rel":"_splitted/System.Runtime.Serialization/toc.json","source_url":"","ms.assetid":"System.Runtime.Serialization.StreamingContext","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.streamingcontext","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.streamingcontext","fileRelativePath":"api/System.Runtime.Serialization.StreamingContext.html"},"themesRelativePathToOutputRoot":"_themes/"}