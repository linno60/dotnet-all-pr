{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">RegistryValueKind</span>\r\n      Enum\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Specifies the data types to use when storing values in the registry, or identifies the data type of a value in the registry.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\r\n  \t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(true)]\npublic enum RegistryValueKind</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.valuetype\" data-linktype=\"relative-path\">ValueType</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.enum\" data-linktype=\"relative-path\">System.Enum</a></span></div><span class=\"lang-csharp\">RegistryValueKind</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following code example creates a registry key and sets several values for that key, using RegistryValueKind to specify the registry data types. The example then uses <a class=\"xref\" href=\"microsoft.win32.registrykey#Microsoft_Win32_RegistryKey_GetValueKind_\" data-linktype=\"relative-path\">GetValueKind</a> to check the registry data types, in order to retrieve the values and display them.  </p>\n<pre><code class=\"lang-cpp\" name=\"Microsoft.Win32.RegistryValueKind#1\">using namespace System;\nusing namespace Microsoft::Win32;\nint main()\n{\n   \n   // Delete and recreate the test key.\n   Registry::CurrentUser-&gt;DeleteSubKey( &quot;RegistryValueKindExample&quot;, false );\n   RegistryKey ^ rk = Registry::CurrentUser-&gt;CreateSubKey( &quot;RegistryValueKindExample&quot; );\n   \n   // Create name/value pairs.\n   // This overload supports QWord (long) values. \n   rk-&gt;SetValue( &quot;QuadWordValue&quot;, 42, RegistryValueKind::QWord );\n   \n   // The following SetValue calls have the same effect as using the\n   // SetValue overload that does not specify RegistryValueKind.\n   //\n   rk-&gt;SetValue( &quot;DWordValue&quot;, 42, RegistryValueKind::DWord );\n   rk-&gt;SetValue( &quot;MultipleStringValue&quot;, gcnew array&lt;String^&gt;{\n      &quot;One&quot;,&quot;Two&quot;,&quot;Three&quot;\n   }, RegistryValueKind::MultiString );\n   rk-&gt;SetValue( &quot;BinaryValue&quot;, gcnew array&lt;Byte&gt;{\n      10,43,44,45,14,255\n   }, RegistryValueKind::Binary );\n   rk-&gt;SetValue( &quot;StringValue&quot;, &quot;The path is %PATH%&quot;, RegistryValueKind::String );\n   \n   // This overload supports setting expandable string values. Compare\n   // the output from this value with the previous string value.\n   rk-&gt;SetValue( &quot;ExpandedStringValue&quot;, &quot;The path is %PATH%&quot;, RegistryValueKind::ExpandString );\n   \n   // Display all the name/value pairs stored in the test key, with the\n   // registry data type in parentheses.\n   //\n   array&lt;String^&gt;^valueNames = rk-&gt;GetValueNames();\n   System::Collections::IEnumerator^ myEnum = valueNames-&gt;GetEnumerator();\n   while ( myEnum-&gt;MoveNext() )\n   {\n      String^ s = safe_cast&lt;String^&gt;(myEnum-&gt;Current);\n      RegistryValueKind rvk = rk-&gt;GetValueKind( s );\n      switch ( rvk )\n      {\n         case RegistryValueKind::MultiString:\n         {\n            array&lt;String^&gt;^values = (array&lt;String^&gt;^)rk-&gt;GetValue( s );\n            Console::Write( &quot;\\r\\n {0} ({1}) =&quot;, s, rvk );\n            for ( int i = 0; i &lt; values-&gt;Length; i++ )\n            {\n               if (i != 0) Console::Write(&quot;,&quot;);\n               Console::Write( &quot; \\&quot;{0}\\&quot;&quot;, values[ i ] );\n\n            }\n            Console::WriteLine();\n            break;\n         }\n         case RegistryValueKind::Binary:\n         {\n            array&lt;Byte&gt;^bytes = (array&lt;Byte&gt;^)rk-&gt;GetValue( s );\n            Console::Write( &quot;\\r\\n {0} ({1}) =&quot;, s, rvk );\n            for ( int i = 0; i &lt; bytes-&gt;Length; i++ )\n            {\n               \n               // Display each byte as two hexadecimal digits.\n               Console::Write( &quot; {0:X2}&quot;, bytes[ i ] );\n\n            }\n            Console::WriteLine();\n            break;\n         }\n         default:\n            Console::WriteLine( &quot;\\r\\n {0} ({1}) = {2}&quot;, s, rvk, rk-&gt;GetValue( s ) );\n            break;\n      }\n   }\n}\n/*\n\nThis code example produces the following output:\n QuadWordValue (QWord) = 42\n\n DWordValue (DWord) = 42\n\n MultipleStringValue (MultiString) =, &quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;\n\n BinaryValue (Binary) = 0A 2B 2C 2D 0E FF\n\n StringValue (String) = The path is %PATH%\n\n ExpandedStringValue (ExpandString) = The path is C:\\Program Files\\Microsoft.NET\\SDK\\v2.0\\Bin;\n [***The remainder of this output is omitted.***]\n\n*/\n</code></pre><pre><code class=\"lang-cs\" name=\"Microsoft.Win32.RegistryValueKind#1\">using System;\nusing Microsoft.Win32;\n\npublic class Example\n{\n    public static void Main()\n    {\n        // Delete and recreate the test key.\n        Registry.CurrentUser.DeleteSubKey(&quot;RegistryValueKindExample&quot;, false);\n        RegistryKey rk = Registry.CurrentUser.CreateSubKey(&quot;RegistryValueKindExample&quot;);\n\n        // Create name/value pairs.\n\n        // This overload supports QWord (long) values. \n        rk.SetValue(&quot;QuadWordValue&quot;, 42, RegistryValueKind.QWord);\n\n        // The following SetValue calls have the same effect as using the\n        // SetValue overload that does not specify RegistryValueKind.\n        //\n        rk.SetValue(&quot;DWordValue&quot;, 42, RegistryValueKind.DWord);\n        rk.SetValue(&quot;MultipleStringValue&quot;, new string[] {&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;}, RegistryValueKind.MultiString);\n        rk.SetValue(&quot;BinaryValue&quot;, new byte[] {10, 43, 44, 45, 14, 255}, RegistryValueKind.Binary);\n        rk.SetValue(&quot;StringValue&quot;, &quot;The path is %PATH%&quot;, RegistryValueKind.String);\n\n        // This overload supports setting expandable string values. Compare\n        // the output from this value with the previous string value.\n        rk.SetValue(&quot;ExpandedStringValue&quot;, &quot;The path is %PATH%&quot;, RegistryValueKind.ExpandString);\n\n\n        // Display all name/value pairs stored in the test key, with each\n        // registry data type in parentheses.\n        //\n        string[] valueNames = rk.GetValueNames();\n        foreach (string s in valueNames)\n        {\n            RegistryValueKind rvk = rk.GetValueKind(s);\n            switch (rvk)\n            {\n                case RegistryValueKind.MultiString :\n                    string[] values = (string[]) rk.GetValue(s);\n                    Console.Write(&quot;\\r\\n {0} ({1}) =&quot;, s, rvk);\n                    for (int i = 0; i &lt; values.Length; i++)\n                    {\n                        if (i != 0) Console.Write(&quot;,&quot;);\n                        Console.Write(&quot; \\&quot;{0}\\&quot;&quot;, values[i]);\n                    }\n                    Console.WriteLine();\n                    break;\n                \n                case RegistryValueKind.Binary :\n                    byte[] bytes = (byte[]) rk.GetValue(s);\n                    Console.Write(&quot;\\r\\n {0} ({1}) =&quot;, s, rvk);\n                    for (int i = 0; i &lt; bytes.Length; i++)\n                    {\n                        // Display each byte as two hexadecimal digits.\n                        Console.Write(&quot; {0:X2}&quot;, bytes[i]);\n                    }\n                    Console.WriteLine();\n                    break;\n                \n                default :\n                    Console.WriteLine(&quot;\\r\\n {0} ({1}) = {2}&quot;, s, rvk, rk.GetValue(s));\n                    break;\n            }\n        }\n    }\n}\n/*\n\nThis code example produces the following output:\n QuadWordValue (QWord) = 42\n\n DWordValue (DWord) = 42\n\n MultipleStringValue (MultiString) =, &quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;\n\n BinaryValue (Binary) = 0A 2B 2C 2D 0E FF\n\n StringValue (String) = The path is %PATH%\n\n ExpandedStringValue (ExpandString) = The path is C:\\Program Files\\Microsoft.NET\\SDK\\v2.0\\Bin;\n [***The remainder of this output is omitted.***]\n\n*/\n</code></pre><pre><code class=\"lang-vb\" name=\"Microsoft.Win32.RegistryValueKind#1\">Imports System\nImports Microsoft.Win32\nImports Microsoft.VisualBasic\n\nPublic Class Example\n    Public Shared Sub Main()\n        &#39; Delete and recreate the test key.\n        Registry.CurrentUser.DeleteSubKey(&quot;RegistryValueKindExample&quot;, False)\n        Dim rk As RegistryKey = Registry.CurrentUser.CreateSubKey(&quot;RegistryValueKindExample&quot;)\n        \n        &#39; Create name/value pairs.\n        &#39; This overload supports QWord (long) values. \n        rk.SetValue(&quot;QuadWordValue&quot;, 42, RegistryValueKind.QWord)\n        \n        &#39; The following SetValue calls have the same effect as using the\n        &#39; SetValue overload that does not specify RegistryValueKind.\n        &#39;\n        rk.SetValue(&quot;DWordValue&quot;, 42, RegistryValueKind.DWord)\n        rk.SetValue(&quot;MultipleStringValue&quot;, New String() {&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;}, RegistryValueKind.MultiString)\n        rk.SetValue(&quot;BinaryValue&quot;, New Byte() {10, 43, 44, 45, 14, 255}, RegistryValueKind.Binary)\n        rk.SetValue(&quot;StringValue&quot;, &quot;The path is %PATH%&quot;, RegistryValueKind.String) \n        \n        &#39; This overload supports setting expandable string values. Compare\n        &#39; the output from this value with the previous string value.\n        rk.SetValue(&quot;ExpandedStringValue&quot;, &quot;The path is %PATH%&quot;, RegistryValueKind.ExpandString)\n        \n        \n        &#39; Display all name/value pairs stored in the test key, with each\n        &#39; registry data type in parentheses.\n        &#39;\n        Dim valueNames As String() = rk.GetValueNames()\n        Dim s As String\n        For Each s In  valueNames\n            Dim rvk As RegistryValueKind = rk.GetValueKind(s)\n            Select Case rvk\n                Case RegistryValueKind.MultiString\n                    Dim values As String() = CType(rk.GetValue(s), String())\n                    Console.Write(vbCrLf &amp; &quot; {0} ({1}) =&quot;, s, rvk)\n                    For i As Integer = 0 To values.Length - 1\n                        If i &lt;&gt; 0 Then Console.Write(&quot;,&quot;)\n                        Console.Write(&quot; &quot;&quot;{0}&quot;&quot;&quot;, values(i))\n                    Next i\n                    Console.WriteLine()\n                \n                Case RegistryValueKind.Binary\n                    Dim bytes As Byte() = CType(rk.GetValue(s), Byte())\n                    Console.Write(vbCrLf &amp; &quot; {0} ({1}) =&quot;, s, rvk)\n                    For i As Integer = 0 To bytes.Length - 1\n                        &#39; Display each byte as two hexadecimal digits.\n                        Console.Write(&quot; {0:X2}&quot;, bytes(i))\n                    Next i\n                    Console.WriteLine()\n                \n                Case Else\n                    Console.WriteLine(vbCrLf &amp; &quot; {0} ({1}) = {2}&quot;, s, rvk, rk.GetValue(s))\n            End Select\n        Next s\n    End Sub &#39;Main\nEnd Class &#39;Example\n\n&#39;\n&#39;This code example produces the following output (some output is omitted):\n&#39;\n&#39; QuadWordValue (QWord) = 42\n&#39;\n&#39; DWordValue (DWord) = 42\n&#39;\n&#39; MultipleStringValue (MultiString) = &quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;\n&#39;\n&#39; BinaryValue (Binary) = 0A 2B 2C 2D 0E FF\n&#39;\n&#39; StringValue (String) = The path is %PATH%\n&#39;\n&#39; ExpandedStringValue (ExpandString) = The path is C:\\Program Files\\Microsoft.NET\\SDK\\v2.0\\Bin;\n&#39; [***The remainder of this output is omitted.***]\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>The RegistryValueKind enumeration defines the set of supported registry data types and the value that is used for unsupported types (Unknown). Starting in the .NET Framework 4, you can specify not to use a data type with the None value.  </p>\n<p> Use the <a class=\"xref\" href=\"microsoft.win32.registrykey#Microsoft_Win32_RegistryKey_GetValueKind_\" data-linktype=\"relative-path\">GetValueKind</a> method to determine the data type of a registry key value before retrieving the value. When you set a registry key value, use the <a class=\"xref\" href=\"microsoft.win32.registrykey#Microsoft_Win32_RegistryKey_SetValue_\" data-linktype=\"relative-path\">SetValue</a> method to specify the registry data type explicitly.</p>\n\r\n  \r\n      \t<h2 class=\"accented\">Fields\r\n      </h2>\r\n      <table class=\"nameValue\">\r\n      \t<tr><td id=\"Microsoft_Win32_RegistryValueKind_Binary\">\r\n      \t\t\t<span class=\"lang-csharp\">Binary</span>\r\n      \t</td>\r\n      \t<td><p>Binary data in any form. This value is equivalent to the Win32 API registry data type REG_BINARY.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"Microsoft_Win32_RegistryValueKind_DWord\">\r\n      \t\t\t<span class=\"lang-csharp\">DWord</span>\r\n      \t</td>\r\n      \t<td><p>A 32-bit binary number. This value is equivalent to the Win32 API registry data type REG_DWORD.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"Microsoft_Win32_RegistryValueKind_ExpandString\">\r\n      \t\t\t<span class=\"lang-csharp\">ExpandString</span>\r\n      \t</td>\r\n      \t<td><p>A null-terminated string that contains unexpanded references to environment variables, such as %PATH%, that are expanded when the value is retrieved. This value is equivalent to the Win32 API registry data type REG_EXPAND_SZ.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"Microsoft_Win32_RegistryValueKind_MultiString\">\r\n      \t\t\t<span class=\"lang-csharp\">MultiString</span>\r\n      \t</td>\r\n      \t<td><p>An array of null-terminated strings, terminated by two null characters. This value is equivalent to the Win32 API registry data type REG_MULTI_SZ.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"Microsoft_Win32_RegistryValueKind_None\">\r\n      \t\t\t<span class=\"lang-csharp\">None</span>\r\n      \t</td>\r\n      \t<td><p>No data type.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"Microsoft_Win32_RegistryValueKind_QWord\">\r\n      \t\t\t<span class=\"lang-csharp\">QWord</span>\r\n      \t</td>\r\n      \t<td><p>A 64-bit binary number. This value is equivalent to the Win32 API registry data type REG_QWORD.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"Microsoft_Win32_RegistryValueKind_String\">\r\n      \t\t\t<span class=\"lang-csharp\">String</span>\r\n      \t</td>\r\n      \t<td><p>A null-terminated string. This value is equivalent to the Win32 API registry data type REG_SZ.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"Microsoft_Win32_RegistryValueKind_Unknown\">\r\n      \t\t\t<span class=\"lang-csharp\">Unknown</span>\r\n      \t</td>\r\n      \t<td><p>An unsupported registry data type. For example, the Microsoft Win32 API registry data type REG_RESOURCE_LIST is unsupported. Use this value to specify that the <span class=\"xref\">crosoft.Win32.RegistryKey.SetValue*</span> method should determine the appropriate registry data type when storing a name/value pair.</p>\n</td>\r\n      \t</tr>\r\n      </table>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/Microsoft.Win32.RegistryValueKind.yml\">\r\n<meta name=\"APIName\" content=\"Microsoft.Win32.RegistryValueKind\">\r\n<meta name=\"APIName\" content=\"Microsoft.Win32.RegistryValueKind.Binary\">\r\n<meta name=\"APIName\" content=\"Microsoft.Win32.RegistryValueKind.DWord\">\r\n<meta name=\"APIName\" content=\"Microsoft.Win32.RegistryValueKind.ExpandString\">\r\n<meta name=\"APIName\" content=\"Microsoft.Win32.RegistryValueKind.MultiString\">\r\n<meta name=\"APIName\" content=\"Microsoft.Win32.RegistryValueKind.None\">\r\n<meta name=\"APIName\" content=\"Microsoft.Win32.RegistryValueKind.QWord\">\r\n<meta name=\"APIName\" content=\"Microsoft.Win32.RegistryValueKind.String\">\r\n<meta name=\"APIName\" content=\"Microsoft.Win32.RegistryValueKind.Unknown\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-24 01:41 AM\">\r\n<meta name=\"document_id\" content=\"b7220543-882c-2950-f4e3-8ba1c14d2194\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Specifies the data types to use when storing values in the registry, or identifies the data type of a value in the registry.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/microsoft.win32/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"Microsoft.Win32.RegistryValueKind\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/Microsoft.Win32.RegistryValueKind.yml","open_to_public_contributors":false,"api_name":["Microsoft.Win32.RegistryValueKind","Microsoft.Win32.RegistryValueKind.Binary","Microsoft.Win32.RegistryValueKind.DWord","Microsoft.Win32.RegistryValueKind.ExpandString","Microsoft.Win32.RegistryValueKind.MultiString","Microsoft.Win32.RegistryValueKind.None","Microsoft.Win32.RegistryValueKind.QWord","Microsoft.Win32.RegistryValueKind.String","Microsoft.Win32.RegistryValueKind.Unknown"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["Microsoft.Win32.RegistryValueKind","Microsoft::Win32::RegistryValueKind","Microsoft.Win32.RegistryValueKind.Binary","Microsoft::Win32::RegistryValueKind::Binary","Microsoft.Win32.RegistryValueKind.DWord","Microsoft::Win32::RegistryValueKind::DWord","Microsoft.Win32.RegistryValueKind.ExpandString","Microsoft::Win32::RegistryValueKind::ExpandString","Microsoft.Win32.RegistryValueKind.MultiString","Microsoft::Win32::RegistryValueKind::MultiString","Microsoft.Win32.RegistryValueKind.None","Microsoft::Win32::RegistryValueKind::None","Microsoft.Win32.RegistryValueKind.QWord","Microsoft::Win32::RegistryValueKind::QWord","Microsoft.Win32.RegistryValueKind.String","Microsoft::Win32::RegistryValueKind::String","Microsoft.Win32.RegistryValueKind.Unknown","Microsoft::Win32::RegistryValueKind::Unknown"],"dev_langs":["csharp"],"updated_at":"2017-03-24 01:41 AM","document_id":"b7220543-882c-2950-f4e3-8ba1c14d2194","content_git_url":"https://github.com/dotnet/docs/blob/master/xml/Microsoft.Win32/RegistryValueKind.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"RegistryValueKind enum | Microsoft Docs","_op_ogTitle":"RegistryValueKind enum","description":"Specifies the data types to use when storing values in the registry, or identifies the data type of a value in the registry.\n","toc_asset_id":"api/_splitted/Microsoft.Win32/toc.json","toc_rel":"_splitted/Microsoft.Win32/toc.json","source_url":"","ms.assetid":"Microsoft.Win32.RegistryValueKind","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/microsoft.win32.registryvaluekind","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/microsoft.win32.registryvaluekind","fileRelativePath":"api/Microsoft.Win32.RegistryValueKind.html"},"themesRelativePathToOutputRoot":"_themes/"}