{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">CallingConventions</span>\r\n      Enum\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Defines the valid calling conventions for a method.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\r\n  \t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Flags]\n[System.Runtime.InteropServices.ComVisible(true)]\npublic enum CallingConventions</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.valuetype\" data-linktype=\"relative-path\">ValueType</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.enum\" data-linktype=\"relative-path\">System.Enum</a></span></div><span class=\"lang-csharp\">CallingConventions</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<pre><code class=\"lang-cpp\" name=\"Type_GetConstructor3#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Security;\npublic ref class MyClass1\n{\npublic:\n   MyClass1( int i ){}\n\n};\n\nint main()\n{\n   try\n   {\n      Type^ myType = MyClass1::typeid;\n      array&lt;Type^&gt;^types = gcnew array&lt;Type^&gt;(1);\n      types[ 0 ] = int::typeid;\n      \n      // Get the public instance constructor that takes an integer parameter.\n      ConstructorInfo^ constructorInfoObj = myType-&gt;GetConstructor( static_cast&lt;BindingFlags&gt;(BindingFlags::Instance | BindingFlags::Public), nullptr, CallingConventions::HasThis, types, nullptr );\n      if ( constructorInfoObj != nullptr )\n      {\n         Console::WriteLine( &quot;The constructor of MyClass1 that is a public instance method and takes an integer as a parameter is: &quot; );\n         Console::WriteLine( constructorInfoObj );\n      }\n      else\n      {\n         Console::WriteLine( &quot;The constructor of MyClass1 that is a public instance method and takes an integer as a parameter is not available.&quot; );\n      }\n   }\n   catch ( ArgumentNullException^ e ) \n   {\n      Console::WriteLine( &quot;ArgumentNullException: {0}&quot;, e-&gt;Message );\n   }\n   catch ( ArgumentException^ e ) \n   {\n      Console::WriteLine( &quot;ArgumentException: {0}&quot;, e-&gt;Message );\n   }\n   catch ( SecurityException^ e ) \n   {\n      Console::WriteLine( &quot;SecurityException: {0}&quot;, e-&gt;Message );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception: {0}&quot;, e-&gt;Message );\n   }\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetConstructor3#1\">using System;\nusing System.Reflection;\nusing System.Security;\n\npublic class MyClass1\n{\n    public MyClass1(int i){}\n    public static void Main()\n    {\n        try\n        {\n            Type  myType = typeof(MyClass1);\n            Type[] types = new Type[1];\n            types[0] = typeof(int);\n            // Get the public instance constructor that takes an integer parameter.\n            ConstructorInfo constructorInfoObj = myType.GetConstructor(\n                BindingFlags.Instance | BindingFlags.Public, null,\n                CallingConventions.HasThis, types, null);\n            if(constructorInfoObj != null)\n            {\n                Console.WriteLine(&quot;The constructor of MyClass1 that is a public &quot; +\n                    &quot;instance method and takes an integer as a parameter is: &quot;);\n                Console.WriteLine(constructorInfoObj.ToString());\n            }\n            else\n            {\n                Console.WriteLine(&quot;The constructor of MyClass1 that is a public instance &quot; +\n                    &quot;method and takes an integer as a parameter is not available.&quot;);\n            }\n        }\n        catch(ArgumentNullException e)\n        {\n            Console.WriteLine(&quot;ArgumentNullException: &quot; + e.Message);\n        }\n        catch(ArgumentException e)\n        {\n            Console.WriteLine(&quot;ArgumentException: &quot; + e.Message);\n        }\n        catch(SecurityException e)\n        {\n            Console.WriteLine(&quot;SecurityException: &quot; + e.Message);\n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;Exception: &quot; + e.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetConstructor3#1\">Public Class MyClass1\n    Public Sub New(ByVal i As Integer)\n    End Sub\n    Public Shared Sub Main()\n        Try\n            Dim myType As Type = GetType(MyClass1)\n            Dim types(0) As Type\n            types(0) = GetType(Integer)\n            &#39; Get the public instance constructor that takes an integer parameter.\n            Dim constructorInfoObj As ConstructorInfo = _\n                        myType.GetConstructor(BindingFlags.Instance Or _\n                        BindingFlags.Public, Nothing, _\n                        CallingConventions.HasThis, types, Nothing)\n            If Not (constructorInfoObj Is Nothing) Then\n                Console.WriteLine(&quot;The constructor of MyClass1 that &quot; + _\n                                  &quot;is a public instance method and takes an &quot; + _\n                                  &quot;integer as a parameter is: &quot;)\n                Console.WriteLine(constructorInfoObj.ToString())\n            Else\n                Console.WriteLine(&quot;The constructor MyClass1 that &quot; + _\n                                  &quot;is a public instance method and takes an &quot; + _\n                                  &quot;integer as a parameter is not available.&quot;)\n            End If\n        Catch e As ArgumentNullException\n            Console.WriteLine(&quot;ArgumentNullException: &quot; + e.Message)\n        Catch e As ArgumentException\n            Console.WriteLine(&quot;ArgumentException: &quot; + e.Message)\n        Catch e As SecurityException\n            Console.WriteLine(&quot;SecurityException: &quot; + e.Message)\n        Catch e As Exception\n            Console.WriteLine(&quot;Exception: &quot; + e.Message)\n        End Try\n    End Sub\nEnd Class\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>The native calling convention is the set of rules governing the order and layout of arguments passed to compiled methods. It also governs how to pass the return value, what registers to use for arguments, and whether the called or the calling method removes arguments from the stack.</p>\n\r\n  \r\n      \t<h2 class=\"accented\">Fields\r\n      </h2>\r\n      <table class=\"nameValue\">\r\n      \t<tr><td id=\"System_Reflection_CallingConventions_Any\">\r\n      \t\t\t<span class=\"lang-csharp\">Any</span>\r\n      \t</td>\r\n      \t<td><p>Specifies that either the <code>Standard</code> or the <code>VarArgs</code> calling convention may be used.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Reflection_CallingConventions_ExplicitThis\">\r\n      \t\t\t<span class=\"lang-csharp\">ExplicitThis</span>\r\n      \t</td>\r\n      \t<td><p>Specifies that the signature is a function-pointer signature, representing a call to an instance or virtual method (not a static method). If <code>ExplicitThis</code> is set, <code>HasThis</code> must also be set. The first argument passed to the called method is still a <code>this</code> pointer, but the type of the first argument is now unknown. Therefore, a token that describes the type (or class) of the <code>this</code> pointer is explicitly stored into its metadata signature.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Reflection_CallingConventions_HasThis\">\r\n      \t\t\t<span class=\"lang-csharp\">HasThis</span>\r\n      \t</td>\r\n      \t<td><p>Specifies an instance or virtual method (not a static method). At run-time, the called method is passed a pointer to the target object as its first argument (the <code>this</code> pointer). The signature stored in metadata does not include the type of this first argument, because the method is known and its owner class can be discovered from metadata.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Reflection_CallingConventions_Standard\">\r\n      \t\t\t<span class=\"lang-csharp\">Standard</span>\r\n      \t</td>\r\n      \t<td><p>Specifies the default calling convention as determined by the common language runtime. Use this calling convention for static methods. For instance or virtual methods use <code>HasThis</code>.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Reflection_CallingConventions_VarArgs\">\r\n      \t\t\t<span class=\"lang-csharp\">VarArgs</span>\r\n      \t</td>\r\n      \t<td><p>Specifies the calling convention for methods with variable arguments.</p>\n</td>\r\n      \t</tr>\r\n      </table>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Reflection.CallingConventions.yml\">\r\n<meta name=\"APIName\" content=\"System.Reflection.CallingConventions\">\r\n<meta name=\"APIName\" content=\"System.Reflection.CallingConventions.Any\">\r\n<meta name=\"APIName\" content=\"System.Reflection.CallingConventions.ExplicitThis\">\r\n<meta name=\"APIName\" content=\"System.Reflection.CallingConventions.HasThis\">\r\n<meta name=\"APIName\" content=\"System.Reflection.CallingConventions.Standard\">\r\n<meta name=\"APIName\" content=\"System.Reflection.CallingConventions.VarArgs\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-24 01:41 AM\">\r\n<meta name=\"document_id\" content=\"aab8c6f5-ae93-7818-9577-05a94c7f6bc8\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Defines the valid calling conventions for a method.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.reflection/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Reflection.CallingConventions\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Reflection.CallingConventions.yml","open_to_public_contributors":false,"api_name":["System.Reflection.CallingConventions","System.Reflection.CallingConventions.Any","System.Reflection.CallingConventions.ExplicitThis","System.Reflection.CallingConventions.HasThis","System.Reflection.CallingConventions.Standard","System.Reflection.CallingConventions.VarArgs"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Reflection.CallingConventions","System::Reflection::CallingConventions","System.Reflection.CallingConventions.Any","System::Reflection::CallingConventions::Any","System.Reflection.CallingConventions.ExplicitThis","System::Reflection::CallingConventions::ExplicitThis","System.Reflection.CallingConventions.HasThis","System::Reflection::CallingConventions::HasThis","System.Reflection.CallingConventions.Standard","System::Reflection::CallingConventions::Standard","System.Reflection.CallingConventions.VarArgs","System::Reflection::CallingConventions::VarArgs"],"dev_langs":["csharp"],"updated_at":"2017-03-24 01:41 AM","document_id":"aab8c6f5-ae93-7818-9577-05a94c7f6bc8","content_git_url":"https://github.com/dotnet/docs/blob/master/xml/System.Reflection/CallingConventions.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"CallingConventions enum | Microsoft Docs","_op_ogTitle":"CallingConventions enum","description":"Defines the valid calling conventions for a method.\n","toc_asset_id":"api/_splitted/System.Reflection/toc.json","toc_rel":"_splitted/System.Reflection/toc.json","source_url":"","ms.assetid":"System.Reflection.CallingConventions","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.reflection.callingconventions","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.reflection.callingconventions","fileRelativePath":"api/System.Reflection.CallingConventions.html"},"themesRelativePathToOutputRoot":"_themes/"}