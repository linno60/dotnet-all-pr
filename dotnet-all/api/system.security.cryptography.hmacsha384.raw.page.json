{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">HMACSHA384</span>\r\n    \t\t\t\tClass\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Computes a Hash-based Message Authentication Code (HMAC) using the <a class=\"xref\" href=\"system.security.cryptography.sha384\" data-linktype=\"relative-path\">SHA384</a> hash function.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[ECMA2Yaml.Models.ECMAAttribute]\npublic class HMACSHA384 : System.Security.Cryptography.HMAC</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm\" data-linktype=\"relative-path\">HashAlgorithm</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.keyedhashalgorithm\" data-linktype=\"relative-path\">KeyedHashAlgorithm</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac\" data-linktype=\"relative-path\">HMAC</a></span></div><span class=\"lang-csharp\">HMACSHA384</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Attributes</dt><dd>\r\n  \t\t<div class=\"cdlHolder\">\r\n  \t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \t<h3 class=\"accented\">Inherited Members</h3>\r\n  \t<h4 class=\"accented\"></h4>\r\n  \t<div class=\"cdlHolder\">\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_CanReuseTransform\" data-linktype=\"relative-path\">CanReuseTransform</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_CanTransformMultipleBlocks\" data-linktype=\"relative-path\">CanTransformMultipleBlocks</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_Clear\" data-linktype=\"relative-path\">Clear()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_ComputeHash_System_Byte___\" data-linktype=\"relative-path\">ComputeHash(Byte[])</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_ComputeHash_System_Byte___System_Int32_System_Int32_\" data-linktype=\"relative-path\">ComputeHash(Byte[], Int32, Int32)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_ComputeHash_System_IO_Stream_\" data-linktype=\"relative-path\">ComputeHash(Stream)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_Dispose\" data-linktype=\"relative-path\">Dispose()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_Hash\" data-linktype=\"relative-path\">Hash</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_HashSize\" data-linktype=\"relative-path\">HashSize</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_HashSizeValue\" data-linktype=\"relative-path\">HashSizeValue</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_HashValue\" data-linktype=\"relative-path\">HashValue</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_InputBlockSize\" data-linktype=\"relative-path\">InputBlockSize</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_OutputBlockSize\" data-linktype=\"relative-path\">OutputBlockSize</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_State\" data-linktype=\"relative-path\">State</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_TransformBlock_System_Byte___System_Int32_System_Int32_System_Byte___System_Int32_\" data-linktype=\"relative-path\">TransformBlock(Byte[], Int32, Int32, Byte[], Int32)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hashalgorithm#System_Security_Cryptography_HashAlgorithm_TransformFinalBlock_System_Byte___System_Int32_System_Int32_\" data-linktype=\"relative-path\">TransformFinalBlock(Byte[], Int32, Int32)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_BlockSizeValue\" data-linktype=\"relative-path\">BlockSizeValue</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_Create\" data-linktype=\"relative-path\">Create()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_Create_System_String_\" data-linktype=\"relative-path\">Create(String)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_Dispose_System_Boolean_\" data-linktype=\"relative-path\">Dispose(Boolean)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_HashCore_System_Byte___System_Int32_System_Int32_\" data-linktype=\"relative-path\">HashCore(Byte[], Int32, Int32)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_HashFinal\" data-linktype=\"relative-path\">HashFinal()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_HashName\" data-linktype=\"relative-path\">HashName</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_Initialize\" data-linktype=\"relative-path\">Initialize()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.hmac#System_Security_Cryptography_HMAC_Key\" data-linktype=\"relative-path\">Key</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.keyedhashalgorithm#System_Security_Cryptography_KeyedHashAlgorithm_KeyValue\" data-linktype=\"relative-path\">KeyValue</a></span></div>\r\n  \t</div>\r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following example shows how to sign a file by using the HMACSHA384 object, and then how to verify the file.  </p>\n<pre><code class=\"lang-cs\" name=\"HMACSHA384#1\">using System;\nusing System.IO;\nusing System.Security.Cryptography;\n\npublic class HMACSHA384example\n{\n\n    public static void Main(string[] Fileargs)\n    {\n        string dataFile;\n        string signedFile;\n        //If no file names are specified, create them.\n        if (Fileargs.Length &lt; 2)\n        {\n            dataFile = @&quot;text.txt&quot;;\n            signedFile = &quot;signedFile.enc&quot;;\n\n            if (!File.Exists(dataFile))\n            {\n                // Create a file to write to.\n                using (StreamWriter sw = File.CreateText(dataFile))\n                {\n                    sw.WriteLine(&quot;Here is a message to sign&quot;);\n                }\n            }\n\n        }\n        else\n        {\n            dataFile = Fileargs[0];\n            signedFile = Fileargs[1];\n        }\n        try\n        {\n            // Create a random key using a random number generator. This would be the\n            //  secret key shared by sender and receiver.\n            byte[] secretkey = new Byte[64];\n            //RNGCryptoServiceProvider is an implementation of a random number generator.\n            using (RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider())\n            {\n                // The array is now filled with cryptographically strong random bytes.\n                rng.GetBytes(secretkey);\n\n                // Use the secret key to sign the message file.\n                SignFile(secretkey, dataFile, signedFile);\n\n                // Verify the signed file\n                VerifyFile(secretkey, signedFile);\n            }\n        }\n        catch (IOException e)\n        {\n            Console.WriteLine(&quot;Error: File not found&quot;, e);\n        }\n\n    }  //end main\n    // Computes a keyed hash for a source file and creates a target file with the keyed hash\n    // prepended to the contents of the source file. \n    public static void SignFile(byte[] key, String sourceFile, String destFile)\n    {\n        // Initialize the keyed hash object.\n        using (HMACSHA384 hmac = new HMACSHA384(key))\n        {\n            using (FileStream inStream = new FileStream(sourceFile, FileMode.Open))\n            {\n                using (FileStream outStream = new FileStream(destFile, FileMode.Create))\n                {\n                    // Compute the hash of the input file.\n                    byte[] hashValue = hmac.ComputeHash(inStream);\n                    // Reset inStream to the beginning of the file.\n                    inStream.Position = 0;\n                    // Write the computed hash value to the output file.\n                    outStream.Write(hashValue, 0, hashValue.Length);\n                    // Copy the contents of the sourceFile to the destFile.\n                    int bytesRead;\n                    // read 1K at a time\n                    byte[] buffer = new byte[1024];\n                    do\n                    {\n                        // Read from the wrapping CryptoStream.\n                        bytesRead = inStream.Read(buffer, 0, 1024);\n                        outStream.Write(buffer, 0, bytesRead);\n                    } while (bytesRead &gt; 0);\n                }\n            }\n        }\n        return;\n    } // end SignFile\n\n\n    // Compares the key in the source file with a new key created for the data portion of the file. If the keys \n    // compare the data has not been tampered with.\n    public static bool VerifyFile(byte[] key, String sourceFile)\n    {\n        bool err = false;\n        // Initialize the keyed hash object. \n        using (HMACSHA384 hmac = new HMACSHA384(key))\n        {\n            // Create an array to hold the keyed hash value read from the file.\n            byte[] storedHash = new byte[hmac.HashSize / 8];\n            // Create a FileStream for the source file.\n            using (FileStream inStream = new FileStream(sourceFile, FileMode.Open))\n            {\n                // Read in the storedHash.\n                inStream.Read(storedHash, 0, storedHash.Length);\n                // Compute the hash of the remaining contents of the file.\n                // The stream is properly positioned at the beginning of the content, \n                // immediately after the stored hash value.\n                byte[] computedHash = hmac.ComputeHash(inStream);\n                // compare the computed hash with the stored value\n\n                for (int i = 0; i &lt; storedHash.Length; i++)\n                {\n                    if (computedHash[i] != storedHash[i])\n                    {\n                        err = true;\n                    }\n                }\n            }\n        }\n        if (err)\n        {\n            Console.WriteLine(&quot;Hash values differ! Signed file has been tampered with!&quot;);\n            return false;\n        }\n        else\n        {\n            Console.WriteLine(&quot;Hash values agree -- no tampering occurred.&quot;);\n            return true;\n        }\n\n    } //end VerifyFile\n\n} //end class\n</code></pre><pre><code class=\"lang-vb\" name=\"HMACSHA384#1\">Imports System\nImports System.IO\nImports System.Security.Cryptography\n\nPublic Class HMACSHA384example\n\n    Public Shared Sub Main(ByVal Fileargs() As String)\n        Dim dataFile As String\n        Dim signedFile As String\n        &#39;If no file names are specified, create them.\n        If Fileargs.Length &lt; 2 Then\n            dataFile = &quot;text.txt&quot;\n            signedFile = &quot;signedFile.enc&quot;\n\n            If Not File.Exists(dataFile) Then\n                &#39; Create a file to write to.\n                Using sw As StreamWriter = File.CreateText(dataFile)\n                    sw.WriteLine(&quot;Here is a message to sign&quot;)\n                End Using\n            End If\n\n        Else\n            dataFile = Fileargs(0)\n            signedFile = Fileargs(1)\n        End If\n        Try\n            &#39; Create a random key using a random number generator. This would be the\n            &#39;  secret key shared by sender and receiver.\n            Dim secretkey() As Byte = New [Byte](63) {}\n            &#39;RNGCryptoServiceProvider is an implementation of a random number generator.\n            Using rng As New RNGCryptoServiceProvider()\n                &#39; The array is now filled with cryptographically strong random bytes.\n                rng.GetBytes(secretkey)\n\n                &#39; Use the secret key to encode the message file.\n                SignFile(secretkey, dataFile, signedFile)\n\n                &#39; Take the encoded file and decode\n                VerifyFile(secretkey, signedFile)\n            End Using\n        Catch e As IOException\n            Console.WriteLine(&quot;Error: File not found&quot;, e)\n        End Try\n\n    End Sub &#39;Main\n\n    &#39; Computes a keyed hash for a source file and creates a target file with the keyed hash\n    &#39; prepended to the contents of the source file. \n    Public Shared Sub SignFile(ByVal key() As Byte, ByVal sourceFile As String, ByVal destFile As String)\n        &#39; Initialize the keyed hash object.\n        Using myhmac As New HMACSHA384(key)\n            Using inStream As New FileStream(sourceFile, FileMode.Open)\n                Using outStream As New FileStream(destFile, FileMode.Create)\n                    &#39; Compute the hash of the input file.\n                    Dim hashValue As Byte() = myhmac.ComputeHash(inStream)\n                    &#39; Reset inStream to the beginning of the file.\n                    inStream.Position = 0\n                    &#39; Write the computed hash value to the output file.\n                    outStream.Write(hashValue, 0, hashValue.Length)\n                    &#39; Copy the contents of the sourceFile to the destFile.\n                    Dim bytesRead As Integer\n                    &#39; read 1K at a time\n                    Dim buffer(1023) As Byte\n                    Do\n                        &#39; Read from the wrapping CryptoStream.\n                        bytesRead = inStream.Read(buffer, 0, 1024)\n                        outStream.Write(buffer, 0, bytesRead)\n                    Loop While bytesRead &gt; 0\n                End Using\n            End Using\n        End Using\n        Return\n\n    End Sub &#39;SignFile\n    &#39; end SignFile\n\n    &#39; Compares the key in the source file with a new key created for the data portion of the file. If the keys \n    &#39; compare the data has not been tampered with.\n    Public Shared Function VerifyFile(ByVal key() As Byte, ByVal sourceFile As String) As Boolean\n        Dim err As Boolean = False\n        &#39; Initialize the keyed hash object. \n        Using hmac As New HMACSHA384(key)\n            &#39; Create an array to hold the keyed hash value read from the file.\n            Dim storedHash(hmac.HashSize / 8) As Byte\n            &#39; Create a FileStream for the source file.\n            Using inStream As New FileStream(sourceFile, FileMode.Open)\n                &#39; Read in the storedHash.\n                inStream.Read(storedHash, 0, storedHash.Length - 1)\n                &#39; Compute the hash of the remaining contents of the file.\n                &#39; The stream is properly positioned at the beginning of the content, \n                &#39; immediately after the stored hash value.\n                Dim computedHash As Byte() = hmac.ComputeHash(inStream)\n                &#39; compare the computed hash with the stored value\n                Dim i As Integer\n                For i = 0 To storedHash.Length - 2\n                    If computedHash(i) &lt;&gt; storedHash(i) Then\n                        err = True\n                    End If\n                Next i\n            End Using\n        End Using\n        If err Then\n            Console.WriteLine(&quot;Hash values differ! Signed file has been tampered with!&quot;)\n            Return False\n        Else\n            Console.WriteLine(&quot;Hash values agree -- no tampering occurred.&quot;)\n            Return True\n        End If\n\n    End Function &#39;VerifyFile \nEnd Class &#39;HMACSHA384example &#39;end VerifyFile\n&#39;end class\n</code></pre><pre><code class=\"lang-cpp\" name=\"HMACSHA384#1\">using namespace System;\nusing namespace System::IO;\nusing namespace System::Security::Cryptography;\n\n// Computes a keyed hash for a source file, creates a target file with the keyed hash\n// prepended to the contents of the source file, then decrypts the file and compares\n// the source and the decrypted files.\nvoid EncodeFile( array&lt;Byte&gt;^key, String^ sourceFile, String^ destFile )\n{\n   \n   // Initialize the keyed hash object.\n   HMACSHA384^ myhmacsha384 = gcnew HMACSHA384( key );\n   FileStream^ inStream = gcnew FileStream( sourceFile,FileMode::Open );\n   FileStream^ outStream = gcnew FileStream( destFile,FileMode::Create );\n   \n   // Compute the hash of the input file.\n   array&lt;Byte&gt;^hashValue = myhmacsha384-&gt;ComputeHash( inStream );\n   \n   // Reset inStream to the beginning of the file.\n   inStream-&gt;Position = 0;\n   \n   // Write the computed hash value to the output file.\n   outStream-&gt;Write( hashValue, 0, hashValue-&gt;Length );\n   \n   // Copy the contents of the sourceFile to the destFile.\n   int bytesRead;\n   \n   // read 1K at a time\n   array&lt;Byte&gt;^buffer = gcnew array&lt;Byte&gt;(1024);\n   do\n   {\n      \n      // Read from the wrapping CryptoStream.\n      bytesRead = inStream-&gt;Read( buffer, 0, 1024 );\n      outStream-&gt;Write( buffer, 0, bytesRead );\n   }\n   while ( bytesRead &gt; 0 );\n\n   myhmacsha384-&gt;Clear();\n   \n   // Close the streams\n   inStream-&gt;Close();\n   outStream-&gt;Close();\n   return;\n} // end EncodeFile\n\n\n\n// Decrypt the encoded file and compare to original file.\nbool DecodeFile( array&lt;Byte&gt;^key, String^ sourceFile )\n{\n   \n   // Initialize the keyed hash object. \n   HMACSHA384^ hmacsha384 = gcnew HMACSHA384( key );\n   \n   // Create an array to hold the keyed hash value read from the file.\n   array&lt;Byte&gt;^storedHash = gcnew array&lt;Byte&gt;(hmacsha384-&gt;HashSize / 8);\n   \n   // Create a FileStream for the source file.\n   FileStream^ inStream = gcnew FileStream( sourceFile,FileMode::Open );\n   \n   // Read in the storedHash.\n   inStream-&gt;Read( storedHash, 0, storedHash-&gt;Length );\n   \n   // Compute the hash of the remaining contents of the file.\n   // The stream is properly positioned at the beginning of the content, \n   // immediately after the stored hash value.\n   array&lt;Byte&gt;^computedHash = hmacsha384-&gt;ComputeHash( inStream );\n   \n   // compare the computed hash with the stored value\n   bool err = false;\n   for ( int i = 0; i &lt; storedHash-&gt;Length; i++ )\n   {\n      if ( computedHash[ i ] != storedHash[ i ] )\n      {\n         err = true;\n      }\n   }\n   if (err)\n        {\n            Console::WriteLine(&quot;Hash values differ! Encoded file has been tampered with!&quot;);\n            return false;\n        }\n        else\n        {\n            Console::WriteLine(&quot;Hash values agree -- no tampering occurred.&quot;);\n            return true;\n        }\n\n} //end DecodeFile\n\n\nint main()\n{\n   array&lt;String^&gt;^Fileargs = Environment::GetCommandLineArgs();\n   String^ usageText = &quot;Usage: HMACSHA384 inputfile.txt encryptedfile.hsh\\nYou must specify the two file names. Only the first file must exist.\\n&quot;;\n   \n   //If no file names are specified, write usage text.\n   if ( Fileargs-&gt;Length &lt; 3 )\n   {\n      Console::WriteLine( usageText );\n   }\n   else\n   {\n      try\n      {\n         \n         // Create a random key using a random number generator. This would be the\n         //  secret key shared by sender and receiver.\n         array&lt;Byte&gt;^secretkey = gcnew array&lt;Byte&gt;(64);\n         \n         //RNGCryptoServiceProvider is an implementation of a random number generator.\n         RNGCryptoServiceProvider^ rng = gcnew RNGCryptoServiceProvider;\n         \n         // The array is now filled with cryptographically strong random bytes.\n         rng-&gt;GetBytes( secretkey );\n         \n         // Use the secret key to encode the message file.\n         EncodeFile( secretkey, Fileargs[ 1 ], Fileargs[ 2 ] );\n         \n         // Take the encoded file and decode\n         DecodeFile( secretkey, Fileargs[ 2 ] );\n      }\n      catch ( IOException^ e ) \n      {\n         Console::WriteLine( &quot;Error: File not found&quot;, e );\n      }\n\n   }\n} //end main\n\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>HMACSHA384 is a type of keyed hash algorithm that is constructed from the SHA-384 hash function and used as a Hash-based Message Authentication Code (HMAC). The HMAC process mixes a secret key with the message data and hashes the result. The hash value is mixed with the secret key again, and then hashed a second time. The output hash is 384 bits long.  </p>\n<p> An HMAC can be used to determine whether a message sent over a nonsecure channel has been tampered with, provided that the sender and receiver share a secret key. The sender computes the hash value for the original data and sends both the original data and the hash value as a single message. The receiver recalculates the hash value on the received message and checks that the computed HMAC matches the transmitted HMAC.  </p>\n<p> If the original and computed hash values match, the message is authenticated. If they do not match, either the data or the hash value has been changed. HMACs provide security against tampering because knowledge of the secret key is required to change the message and reproduce the correct hash value.  </p>\n<p> HMACSHA384 accepts all key sizes and produces a hash sequence that is 384 bits long.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Constructors\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Security_Cryptography_HMACSHA384__ctor_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_Cryptography_HMACSHA384__ctor\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">HMACSHA384()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Initializes a new instance of the <a class=\"xref\" href=\"system.security.cryptography.hmacsha384\" data-linktype=\"relative-path\">HMACSHA384</a> class by using a randomly generated key.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public HMACSHA384 ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This constructor uses a 64-byte, randomly generated key.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Security_Cryptography_HMACSHA384__ctor_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_Cryptography_HMACSHA384__ctor_System_Byte___\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">HMACSHA384(Byte[])</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Initializes a new instance of the <a class=\"xref\" href=\"system.security.cryptography.hmacsha384\" data-linktype=\"relative-path\">HMACSHA384</a> class by using the specified key data.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public HMACSHA384 (byte[] key);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>key</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.byte\" data-linktype=\"relative-path\">Byte</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The secret key for <a class=\"xref\" href=\"system.security.cryptography.hmacsha384\" data-linktype=\"relative-path\">HMACSHA384</a> encryption. The key can be any length. However, the recommended size is 128 bytes. If the key is more than 128 bytes long, it is hashed (using SHA-384) to derive a 128-byte key. If it is less than 128 bytes long, it is padded to 128 bytes.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitysafecriticalattribute\" title=\"System.Security.SecuritySafeCriticalAttribute\" data-linktype=\"relative-path\">SecuritySafeCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>key</code> parameter is <code>null</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Properties\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Security_Cryptography_HMACSHA384_ProduceLegacyHmacValues_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_Cryptography_HMACSHA384_ProduceLegacyHmacValues\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">ProduceLegacyHmacValues</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Provides a workaround for the .NET Framework 2.0 implementation of the <a class=\"xref\" href=\"system.security.cryptography.hmacsha384\" data-linktype=\"relative-path\">HMACSHA384</a> algorithm, which is inconsistent with the .NET Framework 2.0 Service Pack 1 implementation of the algorithm.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public bool ProduceLegacyHmacValues { get; set; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> to enable .NET Framework 2.0 Service Pack 1 applications to interact with .NET Framework 2.0 applications; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The purpose of the ProduceLegacyHmacValues Boolean property is to enable .NET Framework 2.0 Service Pack 1 applications to interact with .NET Framework 2.0 applications. When you set this property to <code>true</code>, the <a class=\"xref\" href=\"system.security.cryptography.hmacsha384\" data-linktype=\"relative-path\">HMACSHA384</a> object produces values that match the values produced by the .NET Framework 2.0. You should set this property only once after you create your HMAC object. You will need to reset your key afterwards, as shown in the following example.  </p>\n<pre><code>public static void Test()  \n    {  \n    HMACSHA384 hmac = new HMACSHA384();  \n    hmac.ProduceLegacyHmacValues = true;  \n    hmac.Key = // ...Get the HMAC key.  \n    // ...  \n    // Use the HMAC algorithm.  \n    // ...  \n    }  \n</code></pre>\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Security.Cryptography.HMACSHA384.yml\">\r\n<meta name=\"APIName\" content=\"System.Security.Cryptography.HMACSHA384\">\r\n<meta name=\"APIName\" content=\"System.Security.Cryptography.HMACSHA384..ctor\">\r\n<meta name=\"APIName\" content=\"System.Security.Cryptography.HMACSHA384.ProduceLegacyHmacValues\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-31 02:21 PM\">\r\n<meta name=\"document_id\" content=\"6a5396b0-8501-286f-a615-2e9ae12f8336\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Computes a Hash-based Message Authentication Code (HMAC) using the  hash function.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.security.cryptography/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Security.Cryptography.HMACSHA384\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Security.Cryptography.HMACSHA384.yml","open_to_public_contributors":false,"api_name":["System.Security.Cryptography.HMACSHA384","System.Security.Cryptography.HMACSHA384..ctor","System.Security.Cryptography.HMACSHA384.ProduceLegacyHmacValues"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Security.Cryptography.HMACSHA384","System::Security::Cryptography::HMACSHA384","System.Security.Cryptography.HMACSHA384.#ctor","System::Security::Cryptography::HMACSHA384::#ctor","System.Security.Cryptography.HMACSHA384.ProduceLegacyHmacValues","System::Security::Cryptography::HMACSHA384::ProduceLegacyHmacValues"],"dev_langs":["csharp"],"updated_at":"2017-03-31 02:21 PM","document_id":"6a5396b0-8501-286f-a615-2e9ae12f8336","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Security.Cryptography/HMACSHA384.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"HMACSHA384 class | Microsoft Docs","_op_ogTitle":"HMACSHA384 class","description":"Computes a Hash-based Message Authentication Code (HMAC) using the  hash function.\n","toc_asset_id":"api/_splitted/System.Security.Cryptography/toc.json","toc_rel":"_splitted/System.Security.Cryptography/toc.json","source_url":"","ms.assetid":"System.Security.Cryptography.HMACSHA384","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.hmacsha384","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.hmacsha384","fileRelativePath":"api/System.Security.Cryptography.HMACSHA384.html"},"themesRelativePathToOutputRoot":"_themes/"}