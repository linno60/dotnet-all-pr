{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">ManualResetEvent</span>\r\n    \t\t\t\tClass\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Notifies one or more waiting threads that an event has occurred. This class cannot be inherited.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(true)]\npublic sealed class ManualResetEvent : System.Threading.EventWaitHandle</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.marshalbyrefobject\" data-linktype=\"relative-path\">MarshalByRefObject</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a></span></div><span class=\"lang-csharp\">ManualResetEvent</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \r\n  \t<h3 class=\"accented\">Inherited Members</h3>\r\n  \t<h4 class=\"accented\"></h4>\r\n  \t<div class=\"cdlHolder\">\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_CreateObjRef_System_Type_\" data-linktype=\"relative-path\">CreateObjRef(Type)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_GetLifetimeService\" data-linktype=\"relative-path\">GetLifetimeService()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_InitializeLifetimeService\" data-linktype=\"relative-path\">InitializeLifetimeService()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_MemberwiseClone_System_Boolean_\" data-linktype=\"relative-path\">MemberwiseClone(Boolean)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_GetAccessControl\" data-linktype=\"relative-path\">GetAccessControl()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_OpenExisting_System_String_System_Security_AccessControl_EventWaitHandleRights_\" data-linktype=\"relative-path\">OpenExisting(String, EventWaitHandleRights)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Reset\" data-linktype=\"relative-path\">Reset()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Set\" data-linktype=\"relative-path\">Set()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_SetAccessControl_System_Security_AccessControl_EventWaitHandleSecurity_\" data-linktype=\"relative-path\">SetAccessControl(EventWaitHandleSecurity)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_TryOpenExisting_System_String_System_Security_AccessControl_EventWaitHandleRights_System_Threading_EventWaitHandle__\" data-linktype=\"relative-path\">TryOpenExisting(String, EventWaitHandleRights, EventWaitHandle)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_TryOpenExisting_System_String_System_Threading_EventWaitHandle__\" data-linktype=\"relative-path\">TryOpenExisting(String, EventWaitHandle)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Close\" data-linktype=\"relative-path\">Close()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Dispose\" data-linktype=\"relative-path\">Dispose()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Dispose_System_Boolean_\" data-linktype=\"relative-path\">Dispose(Boolean)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Handle\" data-linktype=\"relative-path\">Handle</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_InvalidHandle\" data-linktype=\"relative-path\">InvalidHandle</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SafeWaitHandle\" data-linktype=\"relative-path\">SafeWaitHandle</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_\" data-linktype=\"relative-path\">SignalAndWait(WaitHandle, WaitHandle)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_System_Int32_System_Boolean_\" data-linktype=\"relative-path\">SignalAndWait(WaitHandle, WaitHandle, Int32, Boolean)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_System_TimeSpan_System_Boolean_\" data-linktype=\"relative-path\">SignalAndWait(WaitHandle, WaitHandle, TimeSpan, Boolean)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___\" data-linktype=\"relative-path\">WaitAll(WaitHandle[])</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_Int32_\" data-linktype=\"relative-path\">WaitAll(WaitHandle[], Int32)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_Int32_System_Boolean_\" data-linktype=\"relative-path\">WaitAll(WaitHandle[], Int32, Boolean)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_TimeSpan_\" data-linktype=\"relative-path\">WaitAll(WaitHandle[], TimeSpan)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_TimeSpan_System_Boolean_\" data-linktype=\"relative-path\">WaitAll(WaitHandle[], TimeSpan, Boolean)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___\" data-linktype=\"relative-path\">WaitAny(WaitHandle[])</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_Int32_\" data-linktype=\"relative-path\">WaitAny(WaitHandle[], Int32)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_Int32_System_Boolean_\" data-linktype=\"relative-path\">WaitAny(WaitHandle[], Int32, Boolean)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_TimeSpan_\" data-linktype=\"relative-path\">WaitAny(WaitHandle[], TimeSpan)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_TimeSpan_System_Boolean_\" data-linktype=\"relative-path\">WaitAny(WaitHandle[], TimeSpan, Boolean)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne\" data-linktype=\"relative-path\">WaitOne()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_System_Int32_\" data-linktype=\"relative-path\">WaitOne(Int32)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_System_Int32_System_Boolean_\" data-linktype=\"relative-path\">WaitOne(Int32, Boolean)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_System_TimeSpan_\" data-linktype=\"relative-path\">WaitOne(TimeSpan)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_System_TimeSpan_System_Boolean_\" data-linktype=\"relative-path\">WaitOne(TimeSpan, Boolean)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitTimeout\" data-linktype=\"relative-path\">WaitTimeout</a></span></div>\r\n  \t</div>\r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following example demonstrates how ManualResetEvent works. The example starts with a ManualResetEvent in the unsignaled state (that is, <code>false</code> is passed to the constructor). The example creates three threads, each of which blocks on the ManualResetEvent by calling its <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> method. When the user presses the <strong>Enter</strong> key, the example calls the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Set_\" data-linktype=\"relative-path\">Set</a> method, which releases all three threads. Contrast this with the behavior of the <a class=\"xref\" href=\"system.threading.autoresetevent\" data-linktype=\"relative-path\">AutoResetEvent</a> class, which releases threads one at a time, resetting automatically after each release.  </p>\n<p> Pressing the <strong>Enter</strong> key again demonstrates that the ManualResetEvent remains in the signaled state until its <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Reset_\" data-linktype=\"relative-path\">Reset</a> method is called: The example starts two more threads. These threads do not block when they call the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> method, but instead run to completion.  </p>\n<p> Pressing the <strong>Enter</strong> key again causes the example to call the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Reset_\" data-linktype=\"relative-path\">Reset</a> method and to start one more thread, which blocks when it calls <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a>. Pressing the <strong>Enter</strong> key one final time calls <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Set_\" data-linktype=\"relative-path\">Set</a> to release the last thread, and the program ends.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Threading.ManualResetEvent#1\">using namespace System;\nusing namespace System::Threading;\n\nref class Example\n{\nprivate:\n    // mre is used to block and release threads manually. It is\n    // created in the unsignaled state.\n    static ManualResetEvent^ mre = gcnew ManualResetEvent(false);\n\n    static void ThreadProc()\n    {\n        String^ name = Thread::CurrentThread-&gt;Name;\n\n        Console::WriteLine(name + &quot; starts and calls mre-&gt;WaitOne()&quot;);\n\n        mre-&gt;WaitOne();\n\n        Console::WriteLine(name + &quot; ends.&quot;);\n    }\n\npublic:\n    static void Demo()\n    {\n        Console::WriteLine(&quot;\\nStart 3 named threads that block on a ManualResetEvent:\\n&quot;);\n\n        for(int i = 0; i &lt;=2 ; i++)\n        {\n            Thread^ t = gcnew Thread(gcnew ThreadStart(ThreadProc));\n            t-&gt;Name = &quot;Thread_&quot; + i;\n            t-&gt;Start();\n        }\n\n        Thread::Sleep(500);\n        Console::WriteLine(&quot;\\nWhen all three threads have started, press Enter to call Set()&quot; +\n                           &quot;\\nto release all the threads.\\n&quot;);\n        Console::ReadLine();\n\n        mre-&gt;Set();\n\n        Thread::Sleep(500);\n        Console::WriteLine(&quot;\\nWhen a ManualResetEvent is signaled, threads that call WaitOne()&quot; +\n                           &quot;\\ndo not block. Press Enter to show this.\\n&quot;);\n        Console::ReadLine();\n\n        for(int i = 3; i &lt;= 4; i++)\n        {\n            Thread^ t = gcnew Thread(gcnew ThreadStart(ThreadProc));\n            t-&gt;Name = &quot;Thread_&quot; + i;\n            t-&gt;Start();\n        }\n\n        Thread::Sleep(500);\n        Console::WriteLine(&quot;\\nPress Enter to call Reset(), so that threads once again block&quot; +\n                           &quot;\\nwhen they call WaitOne().\\n&quot;);\n        Console::ReadLine();\n\n        mre-&gt;Reset();\n\n        // Start a thread that waits on the ManualResetEvent.\n        Thread^ t5 = gcnew Thread(gcnew ThreadStart(ThreadProc));\n        t5-&gt;Name = &quot;Thread_5&quot;;\n        t5-&gt;Start();\n\n        Thread::Sleep(500);\n        Console::WriteLine(&quot;\\nPress Enter to call Set() and conclude the demo.&quot;);\n        Console::ReadLine();\n\n        mre-&gt;Set();\n\n        // If you run this example in Visual Studio, uncomment the following line:\n        //Console::ReadLine();\n    }\n};\n\nint main()\n{\n   Example::Demo();\n}\n\n/* This example produces output similar to the following:\n\nStart 3 named threads that block on a ManualResetEvent:\n\nThread_0 starts and calls mre-&gt;WaitOne()\nThread_1 starts and calls mre-&gt;WaitOne()\nThread_2 starts and calls mre-&gt;WaitOne()\n\nWhen all three threads have started, press Enter to call Set()\nto release all the threads.\n\n\nThread_2 ends.\nThread_1 ends.\nThread_0 ends.\n\nWhen a ManualResetEvent is signaled, threads that call WaitOne()\ndo not block. Press Enter to show this.\n\n\nThread_3 starts and calls mre-&gt;WaitOne()\nThread_3 ends.\nThread_4 starts and calls mre-&gt;WaitOne()\nThread_4 ends.\n\nPress Enter to call Reset(), so that threads once again block\nwhen they call WaitOne().\n\n\nThread_5 starts and calls mre-&gt;WaitOne()\n\nPress Enter to call Set() and conclude the demo.\n\nThread_5 ends.\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.ManualResetEvent#1\">Imports System.Threading\n\nPublic Class Example\n\n    &#39; mre is used to block and release threads manually. It is\n    &#39; created in the unsignaled state.\n    Private Shared mre As New ManualResetEvent(False)\n\n    &lt;MTAThreadAttribute&gt; _\n    Shared Sub Main()\n\n        Console.WriteLine(vbLf &amp; _\n            &quot;Start 3 named threads that block on a ManualResetEvent:&quot; &amp; vbLf)\n\n        For i As Integer = 0 To 2\n            Dim t As New Thread(AddressOf ThreadProc)\n            t.Name = &quot;Thread_&quot; &amp; i\n            t.Start()\n        Next i\n\n        Thread.Sleep(500)\n        Console.WriteLine(vbLf &amp; _\n            &quot;When all three threads have started, press Enter to call Set()&quot; &amp; vbLf &amp; _\n            &quot;to release all the threads.&quot; &amp; vbLf)\n        Console.ReadLine()\n\n        mre.Set()\n\n        Thread.Sleep(500)\n        Console.WriteLine(vbLf &amp; _\n            &quot;When a ManualResetEvent is signaled, threads that call WaitOne()&quot; &amp; vbLf &amp; _\n            &quot;do not block. Press Enter to show this.&quot; &amp; vbLf)\n        Console.ReadLine()\n\n        For i As Integer = 3 To 4\n            Dim t As New Thread(AddressOf ThreadProc)\n            t.Name = &quot;Thread_&quot; &amp; i\n            t.Start()\n        Next i\n\n        Thread.Sleep(500)\n        Console.WriteLine(vbLf &amp; _\n            &quot;Press Enter to call Reset(), so that threads once again block&quot; &amp; vbLf &amp; _\n            &quot;when they call WaitOne().&quot; &amp; vbLf)\n        Console.ReadLine()\n\n        mre.Reset()\n\n        &#39; Start a thread that waits on the ManualResetEvent.\n        Dim t5 As New Thread(AddressOf ThreadProc)\n        t5.Name = &quot;Thread_5&quot;\n        t5.Start()\n\n        Thread.Sleep(500)\n        Console.WriteLine(vbLf &amp; &quot;Press Enter to call Set() and conclude the demo.&quot;)\n        Console.ReadLine()\n\n        mre.Set()\n\n        &#39; If you run this example in Visual Studio, uncomment the following line:\n        &#39;Console.ReadLine()\n\n    End Sub\n\n\n    Private Shared Sub ThreadProc()\n\n        Dim name As String = Thread.CurrentThread.Name\n\n        Console.WriteLine(name &amp; &quot; starts and calls mre.WaitOne()&quot;)\n\n        mre.WaitOne()\n\n        Console.WriteLine(name &amp; &quot; ends.&quot;)\n\n    End Sub\n\nEnd Class\n\n&#39; This example produces output similar to the following:\n&#39;\n&#39;Start 3 named threads that block on a ManualResetEvent:\n&#39;\n&#39;Thread_0 starts and calls mre.WaitOne()\n&#39;Thread_1 starts and calls mre.WaitOne()\n&#39;Thread_2 starts and calls mre.WaitOne()\n&#39;\n&#39;When all three threads have started, press Enter to call Set()\n&#39;to release all the threads.\n&#39;\n&#39;\n&#39;Thread_2 ends.\n&#39;Thread_0 ends.\n&#39;Thread_1 ends.\n&#39;\n&#39;When a ManualResetEvent is signaled, threads that call WaitOne()\n&#39;do not block. Press Enter to show this.\n&#39;\n&#39;\n&#39;Thread_3 starts and calls mre.WaitOne()\n&#39;Thread_3 ends.\n&#39;Thread_4 starts and calls mre.WaitOne()\n&#39;Thread_4 ends.\n&#39;\n&#39;Press Enter to call Reset(), so that threads once again block\n&#39;when they call WaitOne().\n&#39;\n&#39;\n&#39;Thread_5 starts and calls mre.WaitOne()\n&#39;\n&#39;Press Enter to call Set() and conclude the demo.\n&#39;\n&#39;Thread_5 ends.\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.ManualResetEvent#1\">using System;\nusing System.Threading;\n\npublic class Example\n{\n    // mre is used to block and release threads manually. It is\n    // created in the unsignaled state.\n    private static ManualResetEvent mre = new ManualResetEvent(false);\n\n    static void Main()\n    {\n        Console.WriteLine(&quot;\\nStart 3 named threads that block on a ManualResetEvent:\\n&quot;);\n\n        for(int i = 0; i &lt;= 2; i++)\n        {\n            Thread t = new Thread(ThreadProc);\n            t.Name = &quot;Thread_&quot; + i;\n            t.Start();\n        }\n\n        Thread.Sleep(500);\n        Console.WriteLine(&quot;\\nWhen all three threads have started, press Enter to call Set()&quot; +\n                          &quot;\\nto release all the threads.\\n&quot;);\n        Console.ReadLine();\n\n        mre.Set();\n\n        Thread.Sleep(500);\n        Console.WriteLine(&quot;\\nWhen a ManualResetEvent is signaled, threads that call WaitOne()&quot; +\n                          &quot;\\ndo not block. Press Enter to show this.\\n&quot;);\n        Console.ReadLine();\n\n        for(int i = 3; i &lt;= 4; i++)\n        {\n            Thread t = new Thread(ThreadProc);\n            t.Name = &quot;Thread_&quot; + i;\n            t.Start();\n        }\n\n        Thread.Sleep(500);\n        Console.WriteLine(&quot;\\nPress Enter to call Reset(), so that threads once again block&quot; +\n                          &quot;\\nwhen they call WaitOne().\\n&quot;);\n        Console.ReadLine();\n\n        mre.Reset();\n\n        // Start a thread that waits on the ManualResetEvent.\n        Thread t5 = new Thread(ThreadProc);\n        t5.Name = &quot;Thread_5&quot;;\n        t5.Start();\n\n        Thread.Sleep(500);\n        Console.WriteLine(&quot;\\nPress Enter to call Set() and conclude the demo.&quot;);\n        Console.ReadLine();\n\n        mre.Set();\n\n        // If you run this example in Visual Studio, uncomment the following line:\n        //Console.ReadLine();\n    }\n\n\n    private static void ThreadProc()\n    {\n        string name = Thread.CurrentThread.Name;\n\n        Console.WriteLine(name + &quot; starts and calls mre.WaitOne()&quot;);\n\n        mre.WaitOne();\n\n        Console.WriteLine(name + &quot; ends.&quot;);\n    }\n}\n\n/* This example produces output similar to the following:\n\nStart 3 named threads that block on a ManualResetEvent:\n\nThread_0 starts and calls mre.WaitOne()\nThread_1 starts and calls mre.WaitOne()\nThread_2 starts and calls mre.WaitOne()\n\nWhen all three threads have started, press Enter to call Set()\nto release all the threads.\n\n\nThread_2 ends.\nThread_0 ends.\nThread_1 ends.\n\nWhen a ManualResetEvent is signaled, threads that call WaitOne()\ndo not block. Press Enter to show this.\n\n\nThread_3 starts and calls mre.WaitOne()\nThread_3 ends.\nThread_4 starts and calls mre.WaitOne()\nThread_4 ends.\n\nPress Enter to call Reset(), so that threads once again block\nwhen they call WaitOne().\n\n\nThread_5 starts and calls mre.WaitOne()\n\nPress Enter to call Set() and conclude the demo.\n\nThread_5 ends.\n */\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>In the .NET Framework version 2.0, ManualResetEvent derives from the new <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> class. A ManualResetEvent is functionally equivalent to an <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> created with <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">System.Threading.EventResetMode</a>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Unlike the ManualResetEvent class, the <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> class provides access to named system synchronization events.  </p>\n</div>\n<p> ManualResetEvent allows threads to communicate with each other by signaling. Typically, this communication concerns a task which one thread must complete before other threads can proceed.  </p>\n<p> When a thread begins an activity that must complete before other threads proceed, it calls <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Reset_\" data-linktype=\"relative-path\">Reset</a> to put <code>ManualResetEvent</code> in the non-signaled state. This thread can be thought of as controlling the <code>ManualResetEvent</code>. Threads that call <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> on the <code>ManualResetEvent</code> will block, awaiting the signal. When the controlling thread completes the activity, it calls <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Set_\" data-linktype=\"relative-path\">Set</a> to signal that the waiting threads can proceed. All waiting threads are released.  </p>\n<p> Once it has been signaled, <code>ManualResetEvent</code> remains signaled until it is manually reset. That is, calls to <code>WaitOne</code> return immediately.  </p>\n<p> You can control the initial state of a <code>ManualResetEvent</code> by passing a Boolean value to the constructor, <code>true</code> if the initial state is signaled and <code>false</code> otherwise.  </p>\n<p> <code>ManualResetEvent</code> can also be used with the <code>static</code><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> and <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> methods.  </p>\n<p> For more information about thread synchronization mechanisms, see <a href=\"../topic/manualresetevent%20and%20manualreseteventslim\" data-linktype=\"relative-path\">ManualResetEvent and ManualResetEventSlim</a> in the conceptual documentation.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Constructors\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_ManualResetEvent__ctor_System_Boolean_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">ManualResetEvent(Boolean)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.manualresetevent\" data-linktype=\"relative-path\">ManualResetEvent</a> class with a Boolean value indicating whether to set the initial state to signaled.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public ManualResetEvent (bool initialState);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>initialState</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> to set the initial state signaled; <code>false</code> to set the initial state to nonsignaled.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>If the initial state of a <a class=\"xref\" href=\"system.threading.manualresetevent\" data-linktype=\"relative-path\">ManualResetEvent</a> is signaled (that is, if it is created by passing <code>true</code> for <code>initialState</code>), threads that wait on the <a class=\"xref\" href=\"system.threading.manualresetevent\" data-linktype=\"relative-path\">ManualResetEvent</a> do not block. If the initial state is nonsignaled, threads block until the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Set_\" data-linktype=\"relative-path\">Set</a> method is called.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Threading.ManualResetEvent.yml\">\r\n<meta name=\"APIName\" content=\"System.Threading.ManualResetEvent\">\r\n<meta name=\"APIName\" content=\"System.Threading.ManualResetEvent..ctor\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-28 03:03 AM\">\r\n<meta name=\"document_id\" content=\"1f98bd07-c32b-62f5-f4db-1dcdc3b32ead\">\r\n<meta name=\"internalonly\" content=\"false\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Notifies one or more waiting threads that an event has occurred. This class cannot be inherited.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.threading/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Threading.ManualResetEvent\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Threading.ManualResetEvent.yml","open_to_public_contributors":false,"api_name":["System.Threading.ManualResetEvent","System.Threading.ManualResetEvent..ctor"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Threading.ManualResetEvent","System::Threading::ManualResetEvent","System.Threading.ManualResetEvent.#ctor","System::Threading::ManualResetEvent::#ctor"],"dev_langs":["csharp"],"updated_at":"2017-03-28 03:03 AM","document_id":"1f98bd07-c32b-62f5-f4db-1dcdc3b32ead","content_git_url":"https://github.com/dotnet/docs/blob/master/xml/System.Threading/ManualResetEvent.xml","internalonly":false,"layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"ManualResetEvent class | Microsoft Docs","_op_ogTitle":"ManualResetEvent class","description":"Notifies one or more waiting threads that an event has occurred. This class cannot be inherited.\n","toc_asset_id":"api/_splitted/System.Threading/toc.json","toc_rel":"_splitted/System.Threading/toc.json","source_url":"","ms.assetid":"System.Threading.ManualResetEvent","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.threading.manualresetevent","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.threading.manualresetevent","fileRelativePath":"api/System.Threading.ManualResetEvent.html"},"themesRelativePathToOutputRoot":"_themes/"}