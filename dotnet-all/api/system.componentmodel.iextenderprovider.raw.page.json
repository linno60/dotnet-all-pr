{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">IExtenderProvider</span>\r\n      Interface\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Defines the interface for extending properties to other components in a container.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">public interface IExtenderProvider</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following code example demonstrates how to implement the IExtenderProvider interface. This example is part of a larger example discussed in <a href=\"../Topic/How%20to:%20Implement%20a%20HelpLabel%20Extender%20Provider.md\" data-linktype=\"relative-path\">How to: Implement a HelpLabel Extender Provider</a>.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Windows.Forms.HelpLabel#1\">Option Strict On\nOption Explicit On \nImports System\nImports System.Collections\nImports System.ComponentModel\nImports System.ComponentModel.Design\nImports System.Drawing\nImports System.Windows.Forms\nImports System.Windows.Forms.Design\n\nNamespace Microsoft.Samples.WinForms.Vb.HelpLabel\n    &#39;\n    &#39; &lt;doc&gt;\n    &#39; &lt;desc&gt;\n    &#39; Help Label offers an extender property called\n    &#39; HelpText.  It monitors the active control\n    &#39; and displays the help text for the active control.\n    &#39; &lt;/desc&gt;\n    &#39; &lt;/doc&gt;\n    &#39;\n\n    &lt;ProvideProperty(&quot;HelpText&quot;, GetType(Control)), Designer(GetType(HelpLabel.HelpLabelDesigner))&gt; _\n    Public Class HelpLabel\n        Inherits Control\n        Implements System.ComponentModel.IExtenderProvider\n        &#39; &lt;summary&gt;\n        &#39;    Required designer variable.\n        &#39; &lt;/summary&gt;\n        Private components As System.ComponentModel.Container\n        Private helpTexts As Hashtable\n        Private activeControl As System.Windows.Forms.Control\n\n        &#39;\n        &#39; &lt;doc&gt;\n        &#39; &lt;desc&gt;\n        &#39;      Creates a new help label object.\n        &#39; &lt;/desc&gt;\n        &#39; &lt;/doc&gt;\n        &#39;\n        Public Sub New()\n            &#39;\n            &#39; Required for Windows Form designer support.\n            &#39;\n            InitializeComponent()\n            helpTexts = New Hashtable\n        End Sub\n\n        &#39; &lt;summary&gt;\n        &#39;    Clean up any resources being used.\n        &#39; &lt;/summary&gt;\n        Protected Overloads Overrides Sub Dispose(ByVal disposing As Boolean)\n            If disposing Then\n                If components IsNot Nothing Then\n                    components.Dispose()\n                End If\n            End If\n            MyBase.Dispose(disposing)\n        End Sub\n\n        &#39; &lt;summary&gt;\n        &#39;    Required method for designer support. Do not modify\n        &#39;    the contents of this method with the code editor.\n        &#39; &lt;/summary&gt;\n        Private Sub InitializeComponent()\n            Me.components = New System.ComponentModel.Container\n            Me.BackColor = System.Drawing.SystemColors.Info\n            Me.ForeColor = System.Drawing.SystemColors.InfoText\n            Me.TabStop = False\n        End Sub\n        &#39;\n        &#39; &lt;doc&gt;\n        &#39; &lt;desc&gt;\n        &#39;      Overrides the text property of Control.  This label ignores\n        &#39;      the text property, so we add additional attributes here so the\n        &#39;      property does not show up in the Properties window and is not\n        &#39;      persisted.\n        &#39; &lt;/desc&gt;\n        &#39; &lt;/doc&gt;\n        &#39;\n        &lt;Browsable(False), _\n        EditorBrowsable(EditorBrowsableState.Never), _\n        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)&gt; _\n        Public Overrides Property [Text]() As String\n            Get\n                Return MyBase.Text\n            End Get\n            Set(ByVal Value As String)\n                MyBase.Text = Value\n            End Set\n        End Property\n\n\n        &#39;\n        &#39; &lt;doc&gt;\n        &#39; &lt;desc&gt;\n        &#39;      This implements the IExtenderProvider.CanExtend method.  The\n        &#39;      help label provides an extender property, and the design-time\n        &#39;      framework will call this method once for each component to determine\n        &#39;      if we are interested in providing our extended properties for the\n        &#39;      component.  We return true here if the object is a control and is\n        &#39;      not a HelpLabel (because it would not be meaningful to add this property to\n        &#39;      ourselves).\n        &#39; &lt;/desc&gt;\n        &#39; &lt;/doc&gt;\n        &#39;\n        Function CanExtend(ByVal target As Object) As Boolean Implements IExtenderProvider.CanExtend\n            If TypeOf target Is Control And Not TypeOf target Is HelpLabel Then\n\n                Return True\n            End If\n            Return False\n        End Function\n\n        &#39;\n        &#39; &lt;doc&gt;\n        &#39; &lt;desc&gt;\n        &#39;      This is the extended property for the HelpText property.  Extended\n        &#39;      properties are actual methods because they take an additional parameter\n        &#39;      that is the object or control to provide the property for.\n        &#39; &lt;/desc&gt;\n        &#39; &lt;/doc&gt;\n        &#39;\n        &lt;DefaultValue(&quot;&quot;)&gt; _\n        Public Function GetHelpText(ByVal ctrl As Control) As String\n            Dim myText As String = CStr(helpTexts(ctrl))\n            If myText Is Nothing Then\n                myText = String.Empty\n            End If\n            Return myText\n        End Function\n\n        &#39;\n        &#39; &lt;doc&gt;\n        &#39; &lt;desc&gt;\n        &#39;      This is the extended property for the HelpText property.\n        &#39; &lt;/desc&gt;\n        &#39; &lt;/doc&gt;\n        &#39;\n        Public Sub SetHelpText(ByVal ctrl As Control, ByVal value As String)\n            If value Is Nothing Then\n                value = String.Empty\n            End If\n\n            If value.Length = 0 Then\n                helpTexts.Remove(ctrl)\n\n                RemoveHandler ctrl.Enter, AddressOf OnControlEnter\n                RemoveHandler ctrl.Leave, AddressOf OnControlLeave\n            Else\n                helpTexts(ctrl) = value\n                AddHandler ctrl.Enter, AddressOf OnControlEnter\n                AddHandler ctrl.Leave, AddressOf OnControlLeave\n            End If\n\n            If ctrl Is activeControl Then\n                Invalidate()\n            End If\n        End Sub\n\n        &#39;\n        &#39; &lt;doc&gt;\n        &#39; &lt;desc&gt;\n        &#39;      This is an event handler that responds to the OnControlEnter\n        &#39;      event.  We attach this to each control we are providing help\n        &#39;      text for.\n        &#39; &lt;/desc&gt;\n        &#39; &lt;/doc&gt;\n        &#39;\n        Private Sub OnControlEnter(ByVal sender As Object, ByVal e As EventArgs)\n            activeControl = CType(sender, Control)\n            Invalidate()\n        End Sub\n\n        &#39;\n        &#39; &lt;doc&gt;\n        &#39; &lt;desc&gt;\n        &#39;      This is an event handler that responds to the OnControlLeave\n        &#39;      event.  We attach this to each control we are providing help\n        &#39;      text for.\n        &#39; &lt;/desc&gt;\n        &#39; &lt;/doc&gt;\n        &#39;\n        Private Sub OnControlLeave(ByVal sender As Object, ByVal e As EventArgs)\n            If sender Is activeControl Then\n                activeControl = Nothing\n                Invalidate()\n            End If\n        End Sub\n\n        &#39;\n        &#39; &lt;doc&gt;\n        &#39; &lt;desc&gt;\n        &#39;      Overrides Control.OnPaint.  Here we draw our\n        &#39;      label.\n        &#39; &lt;/desc&gt;\n        &#39; &lt;/doc&gt;\n        &#39;\n        Protected Overrides Sub OnPaint(ByVal pe As PaintEventArgs)\n            &#39; Let the base draw.  This will cover our back\n            &#39; color and set any image that the user has\n            &#39; provided.\n            &#39;\n            MyBase.OnPaint(pe)\n\n            &#39; Draw a rectangle around the control.\n            &#39;\n            Dim rect As Rectangle = ClientRectangle\n\n            Dim borderPen As New Pen(ForeColor)\n            pe.Graphics.DrawRectangle(borderPen, rect)\n            borderPen.Dispose()\n\n            &#39; Finally, draw the text over the top of the\n            &#39; rectangle.\n            &#39;\n            If (activeControl IsNot Nothing) Then\n                Dim myText As String = CStr(helpTexts(activeControl))\n                If (myText IsNot Nothing) And myText.Length &gt; 0 Then\n                    rect.Inflate(-2, -2)\n                    Dim brush As New SolidBrush(ForeColor)\n                    pe.Graphics.DrawString(myText, Font, brush, RectangleF.op_Implicit(rect))\n                    brush.Dispose()\n                End If\n            End If\n        End Sub\n\n\n        &#39; &lt;doc&gt;\n        &#39; &lt;desc&gt;\n        &#39;     Returns true if backColor should be persisted in code gen.  We\n        &#39;      override this because we change the default back color.\n        &#39; &lt;/desc&gt;\n        &#39; &lt;retvalue&gt;\n        &#39;     true if the backColor should be persisted.\n        &#39; &lt;/retvalue&gt;\n        &#39; &lt;/doc&gt;\n        &#39;\n        Public Function ShouldSerializeBackColor() As Boolean\n            Return Not BackColor.Equals(SystemColors.Info)\n        End Function\n\n\n        &#39; &lt;doc&gt;\n        &#39; &lt;desc&gt;\n        &#39;     Returns true if foreColor should be persisted in code gen.  We\n        &#39;      override this because we change the default foreground color.\n        &#39; &lt;/desc&gt;\n        &#39; &lt;retvalue&gt;\n        &#39;     true if foreColor should be persisted.\n        &#39; &lt;/retvalue&gt;\n        &#39; &lt;/doc&gt;\n        &#39;\n        Public Function ShouldSerializeForeColor() As Boolean\n            Return Not ForeColor.Equals(SystemColors.InfoText)\n        End Function\n\n        &#39;\n        &#39; &lt;doc&gt;\n        &#39; &lt;desc&gt;\n        &#39;      This is a designer for the HelpLabel.  This designer provides\n        &#39;      design time feedback for the label.  The help label responds\n        &#39;      to changes in the active control, but these events do not\n        &#39;      occur at design time.  In order to provide some usable feedback\n        &#39;      that the control is working the right way, this designer listens\n        &#39;      to selection change events and uses those events to trigger active\n        &#39;      control changes.\n        &#39; &lt;/desc&gt;\n        &#39; &lt;/doc&gt;\n        &#39;\n        &lt;System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.Demand, Name:=&quot;FullTrust&quot;)&gt; _\n        Public Class HelpLabelDesigner\n            Inherits System.Windows.Forms.Design.ControlDesigner\n\n            Private _trackSelection As Boolean = True\n\n            &#39; &lt;summary&gt;\n            &#39; This property is added to the control&#39;s set of properties in the method\n            &#39; PreFilterProperties below.  Note that on designers, properties that are\n            &#39; explictly declared by TypeDescriptor.CreateProperty can be declared as\n            &#39; private on the designer.  This helps to keep the designer&#39;s public\n            &#39; object model clean.\n            &#39; &lt;/summary&gt;\n            &lt;DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)&gt; _\n            Private Property TrackSelection() As Boolean\n                Get\n                    Return _trackSelection\n                End Get\n                Set(ByVal Value As Boolean)\n                    _trackSelection = Value\n                    If _trackSelection Then\n                        Dim ss As ISelectionService = CType(GetService(GetType(ISelectionService)), ISelectionService)\n                        If (ss IsNot Nothing) Then\n                            UpdateHelpLabelSelection(ss)\n                        End If\n                    Else\n                        Dim helpLabel As HelpLabel = CType(Control, HelpLabel)\n                        If (helpLabel.activeControl IsNot Nothing) Then\n                            helpLabel.activeControl = Nothing\n                            helpLabel.Invalidate()\n                        End If\n                    End If\n                End Set\n            End Property\n\n            Public Overrides ReadOnly Property Verbs() As DesignerVerbCollection\n                Get\n                    Dim myVerbs() As DesignerVerb = {New DesignerVerb(&quot;Sample Verb&quot;, AddressOf OnSampleVerb)}\n                    Return New DesignerVerbCollection(myVerbs)\n                End Get\n            End Property\n\n            &#39;\n            &#39; &lt;doc&gt;\n            &#39; &lt;desc&gt;\n            &#39;      Overrides Dispose.  Here we remove our handler for the selection changed\n            &#39;      event.  With designers, it is critical that they clean up any events they\n            &#39;      have attached.  Otherwise, during the course of an editing session many\n            &#39;      designers might get created and never destroyed.\n            &#39; &lt;/desc&gt;\n            &#39; &lt;/doc&gt;\n            &#39;\n            Protected Overloads Overrides Sub Dispose(ByVal disposing As Boolean)\n                If disposing Then\n                    Dim ss As ISelectionService = CType(GetService(GetType(ISelectionService)), ISelectionService)\n                    If (ss IsNot Nothing) Then\n                        RemoveHandler ss.SelectionChanged, AddressOf OnSelectionChanged\n                    End If\n                End If\n                MyBase.Dispose(disposing)\n            End Sub\n\n            &#39;\n            &#39; &lt;doc&gt;\n            &#39; &lt;desc&gt;\n            &#39;       Overrides initialize.  Here we add an event handler to the selection service.\n            &#39;      Notice that we are very careful not to assume that the selection service is\n            &#39;      available.  It is entirely optional that a service is available and you should\n            &#39;      always degrade gracefully if a service cannot be found.\n            &#39; &lt;/desc&gt;\n            &#39; &lt;/doc&gt;\n            &#39;\n            Public Overrides Sub Initialize(ByVal component As IComponent)\n                MyBase.Initialize(component)\n\n                Dim ss As ISelectionService = CType(GetService(GetType(ISelectionService)), ISelectionService)\n                If (ss IsNot Nothing) Then\n                    AddHandler ss.SelectionChanged, AddressOf OnSelectionChanged\n                End If\n            End Sub\n\n            Private Sub OnSampleVerb(ByVal sender As Object, ByVal e As EventArgs)\n                MessageBox.Show(&quot;You have just invoked a sample verb.  Normally, this would do something interesting.&quot;)\n            End Sub\n\n            &#39;\n            &#39; &lt;doc&gt;\n            &#39; &lt;desc&gt;\n            &#39;      The handler for the selection change event.  Here we update the active control within\n            &#39;      the help label.\n            &#39; &lt;/desc&gt;\n            &#39; &lt;/doc&gt;\n            &#39;\n            Private Sub OnSelectionChanged(ByVal sender As Object, ByVal e As EventArgs)\n                If _trackSelection Then\n                    Dim ss As ISelectionService = CType(sender, ISelectionService)\n                    UpdateHelpLabelSelection(ss)\n                End If\n            End Sub\n\n            Protected Overrides Sub PreFilterProperties(ByVal properties As IDictionary)\n                &#39; Always call base first in PreFilter* methods, and last in PostFilter*\n                &#39; methods.\n                MyBase.PreFilterProperties(properties)\n\n                &#39; We add a design-time property called TrackSelection that is used to track\n                &#39; the active selection.  If the user sets this to true (the default), then\n                &#39; we will listen to selection change events and update the control&#39;s active\n                &#39; control to point to the current primary selection.\n                properties(&quot;TrackSelection&quot;) = TypeDescriptor.CreateProperty( _\n                   Me.GetType(), _\n                   &quot;TrackSelection&quot;, _\n                   GetType(Boolean), _\n                   New Attribute() {CategoryAttribute.Design})\n            End Sub\n\n            &#39; &lt;summary&gt;\n            &#39; This is a helper method that, given a selection service, will update the active control\n            &#39; of the help label with the currently active selection.\n            &#39; &lt;/summary&gt;\n            &#39; &lt;param name=&quot;ss&quot;&gt;&lt;/param&gt;\n            Private Sub UpdateHelpLabelSelection(ByVal ss As ISelectionService)\n                Dim c As Control = CType(ss.PrimarySelection, Control)\n                Dim helpLabel As HelpLabel = CType(Control, HelpLabel)\n                If (c IsNot Nothing) Then\n                    helpLabel.activeControl = c\n                    helpLabel.Invalidate()\n                Else\n                    If (helpLabel.activeControl IsNot Nothing) Then\n                        helpLabel.activeControl = Nothing\n                        helpLabel.Invalidate()\n                    End If\n                End If\n            End Sub\n\n            Public Sub New()\n\n            End Sub\n        End Class\n\n    End Class\nEnd Namespace\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Windows.Forms.HelpLabel#1\">namespace Microsoft.Samples.WinForms.Cs.HelpLabel \n{\n\tusing System;\n\tusing System.Collections;\n\tusing System.ComponentModel;\n\tusing System.ComponentModel.Design;\n\tusing System.Drawing;\n\tusing System.Windows.Forms;\n\tusing System.Windows.Forms.Design;\n\n\t//\n\t// &lt;doc&gt;\n\t// &lt;desc&gt;\n\t// Help Label offers an extender property called\n\t// &quot;HelpText&quot;.  It monitors the active control\n\t// and displays the help text for the active control.\n\t// &lt;/desc&gt;\n\t// &lt;/doc&gt;\n\t//\n\t[\n\tProvideProperty(&quot;HelpText&quot;,typeof(Control)),\n\tDesigner(typeof(HelpLabel.HelpLabelDesigner))\n\t]\n\tpublic class HelpLabel : Control, System.ComponentModel.IExtenderProvider \n\t{\n\t\t/// &lt;summary&gt;\n\t\t///    Required designer variable.\n\t\t/// &lt;/summary&gt;\n\t\tprivate System.ComponentModel.Container components;\n\t\tprivate Hashtable helpTexts;\n\t\tprivate System.Windows.Forms.Control activeControl;\n\n\t\t//\n\t\t// &lt;doc&gt;\n\t\t// &lt;desc&gt;\n\t\t//      Creates a new help label object.\n\t\t// &lt;/desc&gt;\n\t\t// &lt;/doc&gt;\n\t\t//\n\t\tpublic HelpLabel() \n\t\t{\n\t\t\t//\n\t\t\t// Required for Windows Form Designer support\n\t\t\t//\n\t\t\tInitializeComponent();\n\n\t\t\thelpTexts = new Hashtable();\n\t\t}\n\n\t\t/// &lt;summary&gt;\n\t\t///    Clean up any resources being used.\n\t\t/// &lt;/summary&gt;\n\t\tprotected override void Dispose(bool disposing) \n\t\t{\n\t\t\tif (disposing) \n\t\t\t{\n\t\t\t\tcomponents.Dispose();\n\t\t\t}\n\t\t\tbase.Dispose(disposing);\n\t\t}\n\n\t\t/// &lt;summary&gt;\n\t\t///    Required method for Designer support - do not modify\n\t\t///    the contents of this method with the code editor.\n\t\t/// &lt;/summary&gt;\n\t\tprivate void InitializeComponent() \n\t\t{\n\t\t\tthis.components = new System.ComponentModel.Container ();\n\t\t\tthis.BackColor = System.Drawing.SystemColors.Info;\n\t\t\tthis.ForeColor = System.Drawing.SystemColors.InfoText;\n\t\t\tthis.TabStop = false;\n\t\t}\n\n\t\t//\n\t\t// &lt;doc&gt;\n\t\t// &lt;desc&gt;\n\t\t//      Overrides the text property of Control.  This label ignores\n\t\t//      the text property, so we add additional attributes here so the\n\t\t//      property does not show up in the properties window and is not\n\t\t//      persisted.\n\t\t// &lt;/desc&gt;\n\t\t// &lt;/doc&gt;\n\t\t//\n\t\t[\n\t\tBrowsable(false),\n\t\tEditorBrowsable(EditorBrowsableState.Never),\n\t\tDesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)\n\t\t]\n\t\tpublic override string Text \n\t\t{\n\t\t\tget \n\t\t\t{\n\t\t\t\treturn base.Text;\n\t\t\t}\n\t\t\tset \n\t\t\t{\n\t\t\t\tbase.Text = value;\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// &lt;doc&gt;\n\t\t// &lt;desc&gt;\n\t\t//      This implements the IExtenderProvider.CanExtend method.  The\n\t\t//      help label provides an extender property, and the design time\n\t\t//      framework will call this method once for each component to determine\n\t\t//      if we are interested in providing our extended properties for the\n\t\t//      component.  We return true here if the object is a control and is\n\t\t//      not a HelpLabel (since it would be silly to add this property to\n\t\t//      ourselves).\n\t\t// &lt;/desc&gt;\n\t\t// &lt;/doc&gt;\n\t\t//\n\t\tbool IExtenderProvider.CanExtend(object target) \n\t\t{\n\t\t\tif (target is Control &amp;&amp;\n\t\t\t\t!(target is HelpLabel)) \n\t\t\t{\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t//\n\t\t// &lt;doc&gt;\n\t\t// &lt;desc&gt;\n\t\t//      This is the extended property for the HelpText property.  Extended\n\t\t//      properties are actual methods because they take an additional parameter\n\t\t//      that is the object or control to provide the property for.\n\t\t// &lt;/desc&gt;\n\t\t// &lt;/doc&gt;\n\t\t//\n\t\t[\n\t\tDefaultValue(&quot;&quot;),\n\t\t]\n\t\tpublic string GetHelpText(Control control) \n\t\t{\n\t\t\tstring text = (string)helpTexts[control];\n\t\t\tif (text == null) \n\t\t\t{\n\t\t\t\ttext = string.Empty;\n\t\t\t}\n\t\t\treturn text;\n\t\t}\n\n\t\t//\n\t\t// &lt;doc&gt;\n\t\t// &lt;desc&gt;\n\t\t//      This is an event handler that responds to the OnControlEnter\n\t\t//      event.  We attach this to each control we are providing help\n\t\t//      text for.\n\t\t// &lt;/desc&gt;\n\t\t// &lt;/doc&gt;\n\t\t//\n\t\tprivate void OnControlEnter(object sender, EventArgs e) \n\t\t{\n\t\t\tactiveControl = (Control)sender;\n\t\t\tInvalidate();\n\t\t}\n\n\t\t//\n\t\t// &lt;doc&gt;\n\t\t// &lt;desc&gt;\n\t\t//      This is an event handler that responds to the OnControlLeave\n\t\t//      event.  We attach this to each control we are providing help\n\t\t//      text for.\n\t\t// &lt;/desc&gt;\n\t\t// &lt;/doc&gt;\n\t\t//\n\t\tprivate void OnControlLeave(object sender, EventArgs e) \n\t\t{\n\t\t\tif (sender == activeControl) \n\t\t\t{\n\t\t\t\tactiveControl = null;\n\t\t\t\tInvalidate();\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// &lt;doc&gt;\n\t\t// &lt;desc&gt;\n\t\t//      This is the extended property for the HelpText property.\n\t\t// &lt;/desc&gt;\n\t\t// &lt;/doc&gt;\n\t\t//\n\t\tpublic void SetHelpText(Control control, string value) \n\t\t{\n\t\t\tif (value == null) \n\t\t\t{\n\t\t\t\tvalue = string.Empty;\n\t\t\t}\n\n\t\t\tif (value.Length == 0) \n\t\t\t{\n\t\t\t\thelpTexts.Remove(control);\n\n\t\t\t\tcontrol.Enter -= new EventHandler(OnControlEnter);\n\t\t\t\tcontrol.Leave -= new EventHandler(OnControlLeave);\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\thelpTexts[control] = value;\n\n\t\t\t\tcontrol.Enter += new EventHandler(OnControlEnter);\n\t\t\t\tcontrol.Leave += new EventHandler(OnControlLeave);\n\t\t\t}\n\n\t\t\tif (control == activeControl) \n\t\t\t{\n\t\t\t\tInvalidate();\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// &lt;doc&gt;\n\t\t// &lt;desc&gt;\n\t\t//      Overrides Control.OnPaint.  Here we draw our\n\t\t//      label.\n\t\t// &lt;/desc&gt;\n\t\t// &lt;/doc&gt;\n\t\t//\n\t\tprotected override void OnPaint(PaintEventArgs pe) \n\t\t{\n\n\t\t\t// Let the base draw.  This will cover our back\n\t\t\t// color and set any image that the user may have\n\t\t\t// provided.\n\t\t\t//\n\t\t\tbase.OnPaint(pe);\n\n\t\t\t// Draw a rectangle around our control.\n\t\t\t//\n\t\t\tRectangle rect = ClientRectangle;\n\n\t\t\tPen borderPen = new Pen(ForeColor);\n\t\t\tpe.Graphics.DrawRectangle(borderPen, rect);\n\t\t\tborderPen.Dispose();\n\n\t\t\t// Finally, draw the text over the top of the\n\t\t\t// rectangle.\n\t\t\t//\n\t\t\tif (activeControl != null) \n\t\t\t{\n\t\t\t\tstring text = (string)helpTexts[activeControl];\n\t\t\t\tif (text != null &amp;&amp; text.Length &gt; 0) \n\t\t\t\t{\n\t\t\t\t\trect.Inflate(-2, -2);\n\t\t\t\t\tBrush brush = new SolidBrush(ForeColor);\n\t\t\t\t\tpe.Graphics.DrawString(text, Font, brush, rect);\n\t\t\t\t\tbrush.Dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// &lt;doc&gt;\n\t\t// &lt;desc&gt;\n\t\t//     Returns true if the backColor should be persisted in code gen.  We\n\t\t//      override this because we change the default back color.\n\t\t// &lt;/desc&gt;\n\t\t// &lt;retvalue&gt;\n\t\t//     true if the backColor should be persisted.\n\t\t// &lt;/retvalue&gt;\n\t\t// &lt;/doc&gt;\n\t\t//\n\t\tpublic bool ShouldSerializeBackColor() \n\t\t{\n\t\t\treturn(!BackColor.Equals(SystemColors.Info));\n\t\t}\n\n\t\t// &lt;doc&gt;\n\t\t// &lt;desc&gt;\n\t\t//     Returns true if the foreColor should be persisted in code gen.  We\n\t\t//      override this because we change the default foreground color.\n\t\t// &lt;/desc&gt;\n\t\t// &lt;retvalue&gt;\n\t\t//     true if the foreColor should be persisted.\n\t\t// &lt;/retvalue&gt;\n\t\t// &lt;/doc&gt;\n\t\t//\n\t\tpublic bool ShouldSerializeForeColor() \n\t\t{\n\t\t\treturn(!ForeColor.Equals(SystemColors.InfoText));\n\t\t}\n\n\t\t//\n\t\t// &lt;doc&gt;\n\t\t// &lt;desc&gt;\n\t\t//      This is a designer for the HelpLabel.  This designer provides\n\t\t//      design time feedback for the label.  The help label responds\n\t\t//      to changes in the active control, but these events do not\n\t\t//      occur at design time.  In order to provide some usable feedback\n\t\t//      that the control is working the right way, this designer listens\n\t\t//      to selection change events and uses those events to trigger active\n\t\t//      control changes.\n\t\t// &lt;/desc&gt;\n\t\t// &lt;/doc&gt;\n\t\t//\n        [System.Security.Permissions.PermissionSet(System.Security.Permissions.SecurityAction.Demand, Name = &quot;FullTrust&quot;)] \n\t\tpublic class HelpLabelDesigner : System.Windows.Forms.Design.ControlDesigner \n\t\t{\n\n\t\t\tprivate bool trackSelection = true;\n\n\t\t\t/// &lt;summary&gt;\n\t\t\t/// This property is added to the control&#39;s set of properties in the method\n\t\t\t/// PreFilterProperties below.  Note that on designers, properties that are\n\t\t\t/// explictly declared by TypeDescriptor.CreateProperty can be declared as\n\t\t\t/// private on the designer.  This helps to keep the designer&#39;s publi\n\t\t\t/// object model clean.\n\t\t\t/// &lt;/summary&gt;\n            [DesignerSerializationVisibility( DesignerSerializationVisibility.Hidden )]\n\t\t\tprivate bool TrackSelection\n\t\t\t{\n\t\t\t\tget\n\t\t\t\t{\n\t\t\t\t\treturn trackSelection;\n\t\t\t\t}\n\t\t\t\tset\n\t\t\t\t{\n\t\t\t\t\ttrackSelection = value;\n\t\t\t\t\tif (trackSelection)\n\t\t\t\t\t{\n\t\t\t\t\t\tISelectionService ss = (ISelectionService)GetService(typeof(ISelectionService));\n\t\t\t\t\t\tif (ss != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tUpdateHelpLabelSelection(ss);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tHelpLabel helpLabel = (HelpLabel)Control;\n\t\t\t\t\t\tif (helpLabel.activeControl != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thelpLabel.activeControl = null;\n\t\t\t\t\t\t\thelpLabel.Invalidate();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic override DesignerVerbCollection Verbs\n\t\t\t{\n\t\t\t\tget\n\t\t\t\t{\n\t\t\t\t\tDesignerVerb[] verbs = new DesignerVerb[] {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  new DesignerVerb(&quot;Sample Verb&quot;, new EventHandler(OnSampleVerb))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  };\n\t\t\t\t\treturn new DesignerVerbCollection(verbs);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\t// &lt;doc&gt;\n\t\t\t// &lt;desc&gt;\n\t\t\t//      Overrides Dispose.  Here we remove our handler for the selection changed\n\t\t\t//      event.  With designers, it is critical that they clean up any events they\n\t\t\t//      have attached.  Otherwise, during the course of an editing session many\n\t\t\t//      designers may get created and never destroyed.\n\t\t\t// &lt;/desc&gt;\n\t\t\t// &lt;/doc&gt;\n\t\t\t//\n\t\t\tprotected override void Dispose(bool disposing) \n\t\t\t{\n\t\t\t\tif (disposing) \n\t\t\t\t{\n\t\t\t\t\tISelectionService ss = (ISelectionService)GetService(typeof(ISelectionService));\n\t\t\t\t\tif (ss != null) \n\t\t\t\t\t{\n\t\t\t\t\t\tss.SelectionChanged -= new EventHandler(OnSelectionChanged);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbase.Dispose(disposing);\n\t\t\t}\n\n\t\t\t//\n\t\t\t// &lt;doc&gt;\n\t\t\t// &lt;desc&gt;\n\t\t\t//       Overrides initialize.  Here we add an event handler to the selection service.\n\t\t\t//      Notice that we are very careful not to assume that the selection service is\n\t\t\t//      available.  It is entirely optional that a service is available and you should\n\t\t\t//      always degrade gracefully if a service could not be found.\n\t\t\t// &lt;/desc&gt;\n\t\t\t// &lt;/doc&gt;\n\t\t\t//\n\t\t\tpublic override void Initialize(IComponent component) \n\t\t\t{\n\t\t\t\tbase.Initialize(component);\n\n\t\t\t\tISelectionService ss = (ISelectionService)GetService(typeof(ISelectionService));\n\t\t\t\tif (ss != null) \n\t\t\t\t{\n\t\t\t\t\tss.SelectionChanged += new EventHandler(OnSelectionChanged);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprivate void OnSampleVerb(object sender, EventArgs e)\n\t\t\t{\n\t\t\t\tMessageBox.Show(&quot;You have just invoked a sample verb.  Normally, this would do something interesting.&quot;);\n\t\t\t}\n\n\t\t\t//\n\t\t\t// &lt;doc&gt;\n\t\t\t// &lt;desc&gt;\n\t\t\t//      Our handler for the selection change event.  Here we update the active control within\n\t\t\t//      the help label.\n\t\t\t// &lt;/desc&gt;\n\t\t\t// &lt;/doc&gt;\n\t\t\t//\n\t\t\tprivate void OnSelectionChanged(object sender, EventArgs e) \n\t\t\t{\n\t\t\t\tif (trackSelection)\n\t\t\t\t{\n\t\t\t\t\tISelectionService ss = (ISelectionService)sender;\n\t\t\t\t\tUpdateHelpLabelSelection(ss);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprotected override void PreFilterProperties(IDictionary properties)\n\t\t\t{\n\t\t\t\t// Always call base first in PreFilter* methods, and last in PostFilter*\n\t\t\t\t// methods.\n\t\t\t\tbase.PreFilterProperties(properties);\n\n\t\t\t\t// We add a design-time property called &quot;TrackSelection&quot; that is used to track\n\t\t\t\t// the active selection.  If the user sets this to true (the default), then\n\t\t\t\t// we will listen to selection change events and update the control&#39;s active\n\t\t\t\t// control to point to the current primary selection.\n\t\t\t\tproperties[&quot;TrackSelection&quot;] = TypeDescriptor.CreateProperty(\n\t\t\t\t\tthis.GetType(),        // the type this property is defined on\n\t\t\t\t\t&quot;TrackSelection&quot;,    // the name of the property\n\t\t\t\t\ttypeof(bool),        // the type of the property\n\t\t\t\t\tnew Attribute[] {CategoryAttribute.Design});    // attributes\n\t\t\t}\n\n\t\t\t/// &lt;summary&gt;\n\t\t\t/// This is a helper method that, given a selection service, will update the active control\n\t\t\t/// of our help label with the currently active selection.\n\t\t\t/// &lt;/summary&gt;\n\t\t\t/// &lt;param name=&quot;ss&quot;&gt;&lt;/param&gt;\n\t\t\tprivate void UpdateHelpLabelSelection(ISelectionService ss)\n\t\t\t{\n\t\t\t\tControl c = ss.PrimarySelection as Control;\n\t\t\t\tHelpLabel helpLabel = (HelpLabel)Control;\n\t\t\t\tif (c != null)\n\t\t\t\t{\n\t\t\t\t\thelpLabel.activeControl = c;\n\t\t\t\t\thelpLabel.Invalidate();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (helpLabel.activeControl != null)\n\t\t\t\t\t{\n\t\t\t\t\t\thelpLabel.activeControl = null;\n\t\t\t\t\t\thelpLabel.Invalidate();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>An extender provider is a component that provides properties to other components. For example, the <a class=\"xref\" href=\"system.windows.forms.tooltip\" data-linktype=\"relative-path\">ToolTip</a> control is an extender provider. When you add a <a class=\"xref\" href=\"system.windows.forms.tooltip\" data-linktype=\"relative-path\">ToolTip</a> control to a <a class=\"xref\" href=\"system.windows.forms.form\" data-linktype=\"relative-path\">Form</a>, all other controls on the form have a <a class=\"xref\" href=\"system.windows.forms.tooltip\" data-linktype=\"relative-path\">ToolTip</a> property added to their list of properties.  </p>\n<p> Any component that provides extender properties must implement IExtenderProvider. A visual designer can then call <a class=\"xref\" href=\"system.componentmodel.iextenderprovider#System_ComponentModel_IExtenderProvider_CanExtend_\" data-linktype=\"relative-path\">CanExtend</a> to determine which objects in a container should receive the extender properties.  </p>\n<p> For more information about extender providers, see <a href=\"../Topic/How%20to:%20Implement%20an%20Extender%20Provider.md\" data-linktype=\"relative-path\">How to: Implement an Extender Provider</a>.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Methods\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_ComponentModel_IExtenderProvider_CanExtend_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_ComponentModel_IExtenderProvider_CanExtend_System_Object_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">CanExtend(Object)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Specifies whether this object can provide its extender properties to the specified object.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public bool CanExtend (object extendee);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>extendee</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a> to receive the extender properties.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if this object can provide extender properties to the specified object; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>For more information on extender properties, see <a href=\"../Topic/How%20to:%20Implement%20an%20Extender%20Provider.md\" data-linktype=\"relative-path\">How to: Implement an Extender Provider</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc1.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.ComponentModel.IExtenderProvider.yml\">\r\n<meta name=\"APIName\" content=\"System.ComponentModel.IExtenderProvider\">\r\n<meta name=\"APIName\" content=\"System.ComponentModel.IExtenderProvider.CanExtend\">\r\n<meta name=\"APILocation\" content=\"System.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-31 02:21 PM\">\r\n<meta name=\"document_id\" content=\"66abfdc7-ab28-2da8-d627-4ba75705996b\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Defines the interface for extending properties to other components in a container.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.componentmodel/toc1.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.ComponentModel.IExtenderProvider\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.ComponentModel.IExtenderProvider.yml","open_to_public_contributors":false,"api_name":["System.ComponentModel.IExtenderProvider","System.ComponentModel.IExtenderProvider.CanExtend"],"api_location":["System.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.ComponentModel.IExtenderProvider","System::ComponentModel::IExtenderProvider","System.ComponentModel.IExtenderProvider.CanExtend","System::ComponentModel::IExtenderProvider::CanExtend"],"dev_langs":["csharp"],"updated_at":"2017-03-31 02:21 PM","document_id":"66abfdc7-ab28-2da8-d627-4ba75705996b","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.ComponentModel/IExtenderProvider.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"IExtenderProvider interface | Microsoft Docs","_op_ogTitle":"IExtenderProvider interface","description":"Defines the interface for extending properties to other components in a container.\n","toc_asset_id":"api/_splitted/System.ComponentModel/toc.json","toc_rel":"_splitted/System.ComponentModel/toc.json","source_url":"","ms.assetid":"System.ComponentModel.IExtenderProvider","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.iextenderprovider","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.iextenderprovider","fileRelativePath":"api/System.ComponentModel.IExtenderProvider.html"},"themesRelativePathToOutputRoot":"_themes/"}