{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">ICustomFormatter</span>\r\n      Interface\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Defines a method that supports custom formatting of the value of an object.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(true)]\npublic interface ICustomFormatter</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following example implements ICustomFormatter to allow binary, octal, and hexadecimal formatting of integral values. In this example, a single class, <code>IBinaryFormatter</code>, implements both ICustomFormatter and <a class=\"xref\" href=\"system.iformatprovider\" data-linktype=\"relative-path\">IFormatProvider</a>. Its <a class=\"xref\" href=\"system.iformatprovider#System_IFormatProvider_GetFormat_\" data-linktype=\"relative-path\">GetFormat</a> method determines whether the <code>formatType</code> parameter represents an ICustomFormatter type. If it does, <code>BinaryFormatter</code> returns an instance of itself; otherwise, it returns <code>null</code>. Its <a class=\"xref\" href=\"system.icustomformatter#System_ICustomFormatter_Format_\" data-linktype=\"relative-path\">Format</a> implementation determines whether the format parameter is one of the three supported format strings (&quot;B&quot; for binary, &quot;O&quot; for octal, and &quot;H&quot; for hexadecimal) and formats the <code>arg</code> parameter appropriately. Otherwise, if <code>arg</code> is not <code>null</code>, it calls the <code>arg</code> parameter&#39;s <a class=\"xref\" href=\"system.iformattable#System_IFormattable_ToString_\" data-linktype=\"relative-path\">ToString</a> implementation, if one exists, or its parameterless <code>ToString</code> method, if one does not. If <code>arg</code> is <code>null</code>, the method returns <a class=\"xref\" href=\"system.string#System_String_Empty\" data-linktype=\"relative-path\">System.String.Empty</a>.  </p>\n<pre><code class=\"lang-vb\" name=\"System.ICustomFormatter.Class#1\">Imports System.Globalization\nImports System.Numerics\n\nPublic Class BinaryFormatter : Implements IFormatProvider, ICustomFormatter\n   &#39; IFormatProvider.GetFormat implementation.\n   Public Function GetFormat(formatType As Type) As Object _\n                   Implements IFormatProvider.GetFormat\n      &#39; Determine whether custom formatting object is requested.\n      If formatType Is GetType(ICustomFormatter) Then\n         Return Me\n      Else\n         Return Nothing\n      End If\n   End Function   \n\n   &#39; Format number in binary (B), octal (O), or hexadecimal (H).\n   Public Function Format(fmt As String, arg As Object, _\n                          formatProvider As IFormatProvider) As String _\n                   Implements ICustomFormatter.Format\n\n     &#39; Handle format string.\n      Dim base As Integer\n      &#39; Handle null or empty format string, string with precision specifier.\n      Dim thisFmt As String = String.Empty\n      &#39; Extract first character of format string (precision specifiers\n      &#39; are not supported by BinaryFormatter).\n      If Not String.IsNullOrEmpty(fmt) Then\n         thisFmt = CStr(IIf(fmt.Length &gt; 1, fmt.Substring(0, 1), fmt))\n      End If\n         \n\n\n      &#39; Get a byte array representing the numeric value.\n      Dim bytes() As Byte\n      If TypeOf(arg) Is SByte Then\n         Dim byteString As String = CType(arg, SByte).ToString(&quot;X2&quot;)\n         bytes = New Byte(0) { Byte.Parse(byteString, System.Globalization.NumberStyles.HexNumber ) }\n      ElseIf TypeOf(arg) Is Byte Then\n         bytes = New Byte(0) { CType(arg, Byte) }\n      ElseIf TypeOf(arg) Is Int16 Then\n         bytes = BitConverter.GetBytes(CType(arg, Int16))\n      ElseIf TypeOf(arg) Is Int32 Then\n         bytes = BitConverter.GetBytes(CType(arg, Int32))\n      ElseIf TypeOf(arg) Is Int64 Then\n         bytes = BitConverter.GetBytes(CType(arg, Int64))\n      ElseIf TypeOf(arg) Is UInt16 Then\n         bytes = BitConverter.GetBytes(CType(arg, UInt16))\n      ElseIf TypeOf(arg) Is UInt32 Then\n         bytes = BitConverter.GetBytes(CType(arg, UInt64))\n      ElseIf TypeOf(arg) Is UInt64 Then\n         bytes = BitConverter.GetBytes(CType(arg, UInt64))                  \n      ElseIf TypeOf(arg) Is BigInteger Then\n         bytes = CType(arg, BigInteger).ToByteArray()\n      Else\n         Try \n            Return HandleOtherFormats(fmt, arg) \n         Catch e As FormatException \n            Throw New FormatException(String.Format(&quot;The format of &#39;{0}&#39; is invalid.&quot;, fmt), e)\n         End Try\n      End If\n\n      Select Case thisFmt.ToUpper()\n         &#39; Binary formatting.\n         Case &quot;B&quot;\n            base = 2        \n         Case &quot;O&quot;\n            base = 8\n         Case &quot;H&quot;\n            base = 16\n         &#39; Handle unsupported format strings.\n         Case Else\n            Try \n               Return HandleOtherFormats(fmt, arg) \n            Catch e As FormatException \n               Throw New FormatException(String.Format(&quot;The format of &#39;{0}&#39; is invalid.&quot;, fmt), e)\n            End Try\n      End Select\n      \n      &#39; Return a formatted string.\n      Dim numericString As String = String.Empty\n      For ctr As Integer = bytes.GetUpperBound(0) To bytes.GetLowerBound(0) Step -1\n         Dim byteString As String = Convert.ToString(bytes(ctr), base)\n         If base = 2 Then\n            byteString = New String(&quot;0&quot;c, 8 - byteString.Length) + byteString\n         ElseIf base = 8 Then\n            byteString = New String(&quot;0&quot;c, 4 - byteString.Length) + byteString\n         &#39; Base is 16.\n         Else     \n            byteString = New String(&quot;0&quot;c, 2 - byteString.Length) + byteString\n         End If\n         numericString +=  byteString + &quot; &quot;\n      Next\n      Return numericString.Trim()\n   End Function\n   \n   Private Function HandleOtherFormats(fmt As String, arg As Object) As String\n      If TypeOf arg Is IFormattable Then\n         Return DirectCast(arg, IFormattable).ToString(fmt, CultureInfo.CurrentCulture)\n      ElseIf arg IsNot Nothing Then\n         Return arg.ToString()\n      Else\n         Return String.Empty\n      End If\n   End Function\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"System.ICustomFormatter.Class#1\">using System;\nusing System.Globalization;\nusing System.Numerics;\n\npublic class BinaryFormatter : IFormatProvider, ICustomFormatter\n{\n   // IFormatProvider.GetFormat implementation.\n   public object GetFormat(Type formatType)\n   {\n      // Determine whether custom formatting object is requested.\n      if (formatType == typeof(ICustomFormatter))\n         return this;\n      else\n         return null;\n   }   \n\n   // Format number in binary (B), octal (O), or hexadecimal (H).\n   public string Format(string format, object arg, IFormatProvider formatProvider)\n   {\n      // Handle format string.\n      int baseNumber;\n      // Handle null or empty format string, string with precision specifier.\n      string thisFmt = String.Empty;\n      // Extract first character of format string (precision specifiers\n      // are not supported).\n      if (! String.IsNullOrEmpty(format))\n         thisFmt = format.Length &gt; 1 ? format.Substring(0, 1) : format;\n         \n\n      // Get a byte array representing the numeric value.\n      byte[] bytes;\n      if (arg is sbyte)\n      {\n         string byteString = ((sbyte) arg).ToString(&quot;X2&quot;);\n         bytes = new byte[1] { Byte.Parse(byteString, System.Globalization.NumberStyles.HexNumber ) };\n      }\n      else if (arg is byte) {\n         bytes = new byte[1] { (byte) arg };\n      }   \n      else if (arg is short) {\n         bytes = BitConverter.GetBytes((short) arg);\n      }   \n      else if (arg is int) {\n         bytes = BitConverter.GetBytes((int) arg);\n      }   \n      else if (arg is long) {\n         bytes = BitConverter.GetBytes((long) arg);\n      }\n      else if (arg is ushort) {\n         bytes = BitConverter.GetBytes((ushort) arg);\n      }\n      else if (arg is uint) {\n         bytes = BitConverter.GetBytes((uint) arg);\n      }\n      else if (arg is ulong) {\n         bytes = BitConverter.GetBytes((ulong) arg);                  \n      }\n      else if (arg is BigInteger) {\n         bytes = ((BigInteger) arg).ToByteArray();\n      }\n      else {\n         try {\n            return HandleOtherFormats(format, arg); \n         }\n         catch (FormatException e) {\n            throw new FormatException(String.Format(&quot;The format of &#39;{0}&#39; is invalid.&quot;, format), e);\n         }\n      }\n\n      switch (thisFmt.ToUpper())\n      {\n         // Binary formatting.\n         case &quot;B&quot;:\n            baseNumber = 2;\n            break;        \n         case &quot;O&quot;:\n            baseNumber = 8;\n            break;\n         case &quot;H&quot;:\n            baseNumber = 16;\n            break;\n         // Handle unsupported format strings.\n         default:\n         try {\n            return HandleOtherFormats(format, arg); \n         }\n         catch (FormatException e) {\n            throw new FormatException(String.Format(&quot;The format of &#39;{0}&#39; is invalid.&quot;, format), e);\n         }\n      }\n   \n      // Return a formatted string.\n      string numericString = String.Empty;\n      for (int ctr = bytes.GetUpperBound(0); ctr &gt;= bytes.GetLowerBound(0); ctr--)\n      {\n         string byteString = Convert.ToString(bytes[ctr], baseNumber);\n         if (baseNumber == 2)\n            byteString = new String(&#39;0&#39;, 8 - byteString.Length) + byteString;\n         else if (baseNumber == 8)\n            byteString = new String(&#39;0&#39;, 4 - byteString.Length) + byteString;\n         // Base is 16.\n         else     \n            byteString = new String(&#39;0&#39;, 2 - byteString.Length) + byteString;\n\n         numericString +=  byteString + &quot; &quot;;\n      }\n      return numericString.Trim();\n   }\n\n   private string HandleOtherFormats(string format, object arg)\n   {\n      if (arg is IFormattable) \n         return ((IFormattable)arg).ToString(format, CultureInfo.CurrentCulture);\n      else if (arg != null)\n         return arg.ToString();\n      else\n         return String.Empty;\n   }\n}\n</code></pre><p> <code>BinaryFormatter</code> can then be used to provide custom formatting by passing a <code>BinaryFormatter</code> object as the <code>provider</code> parameter of the <a class=\"xref\" href=\"system.string#System_String_Format_\" data-linktype=\"relative-path\">Format</a> method, as the following example shows.  </p>\n<pre><code class=\"lang-vb\" name=\"System.ICustomFormatter.Class#2\">Public Module Example\n   Public Sub Main\n      Console.WindowWidth = 100\n      \n      Dim byteValue As Byte = 124\n      Console.WriteLine(String.Format(New BinaryFormatter(), _\n                                      &quot;{0} (binary: {0:B}) (hex: {0:H})&quot;, byteValue))\n      \n      Dim intValue As Integer = 23045\n      Console.WriteLine(String.Format(New BinaryFormatter(), _\n                                      &quot;{0} (binary: {0:B}) (hex: {0:H})&quot;, intValue))\n      \n      Dim ulngValue As ULong = 31906574882\n      Console.WriteLine(String.Format(New BinaryFormatter(), _\n                                      &quot;{0} {1}   (binary: {0:B}) {1}   (hex: {0:H})&quot;, _\n                                      ulngValue, vbCrLf))\n\n      Dim bigIntValue As BigInteger = BigInteger.Multiply(Int64.MaxValue, 2)\n      Console.WriteLine(String.Format(New BinaryFormatter(), _\n                                      &quot;{0} {1}   (binary: {0:B}) {1}   (hex: {0:H})&quot;, _\n                                      bigIntValue, vbCrLf))\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;    124 (binary: 01111100) (hex: 7c)\n&#39;    23045 (binary: 00000000 00000000 01011010 00000101) (hex: 00 00 5a 05)\n&#39;    31906574882\n&#39;       (binary: 00000000 00000000 00000000 00000111 01101101 11000111 10110010 00100010)\n&#39;       (hex: 00 00 00 07 6d c7 b2 22)\n&#39;    18446744073709551614\n&#39;       (binary: 00000000 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111110)\n&#39;       (hex: 00 ff ff ff ff ff ff ff fe)\n</code></pre><pre><code class=\"lang-cs\" name=\"System.ICustomFormatter.Class#2\">public class Example\n{\n   public static void Main()\n   {\n      Console.WindowWidth = 100;\n      \n      byte byteValue = 124;\n      Console.WriteLine(String.Format(new BinaryFormatter(), \n                                      &quot;{0} (binary: {0:B}) (hex: {0:H})&quot;, byteValue));\n      \n      int intValue = 23045;\n      Console.WriteLine(String.Format(new BinaryFormatter(), \n                                      &quot;{0} (binary: {0:B}) (hex: {0:H})&quot;, intValue));\n      \n      ulong ulngValue = 31906574882;\n      Console.WriteLine(String.Format(new BinaryFormatter(), \n                                      &quot;{0}\\n   (binary: {0:B})\\n   (hex: {0:H})&quot;, \n                                      ulngValue));\n\n      BigInteger bigIntValue = BigInteger.Multiply(Int64.MaxValue, 2);\n      Console.WriteLine(String.Format(new BinaryFormatter(), \n                                      &quot;{0}\\n   (binary: {0:B})\\n   (hex: {0:H})&quot;, \n                                      bigIntValue));\n   }\n}\n// The example displays the following output:\n//    124 (binary: 01111100) (hex: 7c)\n//    23045 (binary: 00000000 00000000 01011010 00000101) (hex: 00 00 5a 05)\n//    31906574882\n//       (binary: 00000000 00000000 00000000 00000111 01101101 11000111 10110010 00100010)\n//       (hex: 00 00 00 07 6d c7 b2 22)\n//    18446744073709551614\n//       (binary: 00000000 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111110)\n//       (hex: 00 ff ff ff ff ff ff ff fe)\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>The ICustomFormatter interface includes a single method, <a class=\"xref\" href=\"system.icustomformatter#System_ICustomFormatter_Format_\" data-linktype=\"relative-path\">Format</a>. When this interface is implemented by a reference or value type, the <a class=\"xref\" href=\"system.icustomformatter#System_ICustomFormatter_Format_\" data-linktype=\"relative-path\">Format</a> method returns a custom-formatted string representation of an object&#39;s value.  </p>\n<p> Typically, the ICustomFormatter interface is implemented with the <a class=\"xref\" href=\"system.iformatprovider\" data-linktype=\"relative-path\">IFormatProvider</a> interface to customize the behavior of two .NET Framework composite string formatting methods that include an <a class=\"xref\" href=\"system.iformatprovider\" data-linktype=\"relative-path\">IFormatProvider</a> parameter. Specifically, the ICustomFormatter interface can provide custom formatting of the value of an object passed to the [String.Format(IFormatProvider, String, Object&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=fullName&gt; and [StringBuilder.AppendFormat(IFormatProvider, String, Object&lt;xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=fullName&gt; methods.  </p>\n<p> Providing a custom representation of an object&#39;s value requires that you do the following:  </p>\n<ol>\n<li><p>Define a class that implements the ICustomFormatter interface and its single member, the <a class=\"xref\" href=\"system.icustomformatter#System_ICustomFormatter_Format_\" data-linktype=\"relative-path\">Format</a> method.  </p>\n</li>\n<li><p>Define a class that implements the <a class=\"xref\" href=\"system.iformatprovider\" data-linktype=\"relative-path\">IFormatProvider</a> interface and its single member, the <a class=\"xref\" href=\"system.iformatprovider#System_IFormatProvider_GetFormat_\" data-linktype=\"relative-path\">GetFormat</a> method. The <a class=\"xref\" href=\"system.iformatprovider#System_IFormatProvider_GetFormat_\" data-linktype=\"relative-path\">GetFormat</a> method returns an instance of your ICustomFormatter implementation. Often, a single class implements both ICustomFormatter and <a class=\"xref\" href=\"system.iformatprovider\" data-linktype=\"relative-path\">IFormatProvider</a>. In that case, the class&#39;s <code>GetFormat</code> implementation just returns an instance of itself.  </p>\n</li>\n<li><p>Pass the <a class=\"xref\" href=\"system.iformatprovider\" data-linktype=\"relative-path\">IFormatProvider</a> implementation as the <code>provider</code> argument of the [String.Format(IFormatProvider, String, Object&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=fullName&gt; method or a comparable method.  </p>\n</li>\n</ol>\n<p> The .NET Framework method will then use your custom formatting instead of its own.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Methods\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_ICustomFormatter_Format_System_String_System_Object_System_IFormatProvider_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Format(String, Object, IFormatProvider)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Converts the value of a specified object to an equivalent string representation using specified format and culture-specific formatting information.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public string Format (string format, object arg, IFormatProvider formatProvider);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>format</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A format string containing formatting specifications.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>arg</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An object to format.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>formatProvider</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.iformatprovider\" data-linktype=\"relative-path\">IFormatProvider</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An object that supplies format information about the current instance.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>The string representation of the value of <code>arg</code>, formatted as specified by <code>format</code> and <code>formatProvider</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Format is a callback method. It is called by a method that supports custom formatting, such as [String.Format(IFormatProvider, String, Object&lt;xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=fullName&gt; or [StringBuilder.AppendFormat(IFormatProvider, String, Object&lt;xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=fullName&gt;. The implementation is called once for each format item in a <a href=\"../topic/composite%20formatting\" data-linktype=\"relative-path\">composite format string</a>. For example, in the following statement, the Format method is called three times.  </p>\n<pre><code class=\"lang-vb\" name=\"System.ICustomFormatter.Class#4\">Console.WriteLine(String.Format(New BinaryFormatter(), _\n                                &quot;{0} (binary: {0:B}) (hex: {0:H})&quot;, byteValue))\n</code></pre><pre><code class=\"lang-cs\" name=\"System.ICustomFormatter.Class#4\">Console.WriteLine(String.Format(new BinaryFormatter(), \n                                &quot;{0} (binary: {0:B}) (hex: {0:H})&quot;, byteValue));\n</code></pre><p> The <code>arg</code> parameter is the object in the object list whose zero-based position corresponds to the index of a particular format item.  </p>\n<p> The <code>format</code> parameter contains a format string, which is the <code>formatString</code> component of a format item. If the format item has no <code>formatString</code> component, the value of <code>format</code> is <code>null</code>. If <code>format</code> is <code>null</code>, depending on the type of <code>arg</code>, you may be able to use the default format specification of your choice.  </p>\n<p> The <code>formatProvider</code> parameter is the <a class=\"xref\" href=\"system.iformatprovider\" data-linktype=\"relative-path\">IFormatProvider</a> implementation that provides formatting for <code>arg</code>. Typically, it is an instance of your <a class=\"xref\" href=\"system.icustomformatter\" data-linktype=\"relative-path\">ICustomFormatter</a> implementation. If <code>formatProvider</code> is <code>null</code>, ignore that parameter.  </p>\n<p> Your implementation of the Format method must include the following functionality so the .NET Framework can provide formatting you do not support. If your format method does not support a format, determine whether the object being formatted implements the <a class=\"xref\" href=\"system.iformattable\" data-linktype=\"relative-path\">IFormattable</a> interface. If it does, invoke the <a class=\"xref\" href=\"system.iformattable#System_IFormattable_ToString_\" data-linktype=\"relative-path\">ToString</a> method of that interface. Otherwise, invoke the default <a class=\"xref\" href=\"system.object#System_Object_ToString_\" data-linktype=\"relative-path\">ToString</a> method of the underlying object. The following code illustrates this pattern.  </p>\n<pre><code class=\"lang-vb\" name=\"System.ICustomFormatter.Class#3\">If TypeOf arg Is IFormattable Then\n   Return DirectCast(arg, IFormattable).ToString(fmt, CultureInfo.CurrentCulture)\nElseIf arg IsNot Nothing Then\n   Return arg.ToString()\n</code></pre><pre><code class=\"lang-cs\" name=\"System.ICustomFormatter.Class#3\">if (arg is IFormattable) \n   return ((IFormattable)arg).ToString(format, CultureInfo.CurrentCulture);\nelse if (arg != null)\n   return arg.ToString();\n</code></pre>\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.ICustomFormatter.yml\">\r\n<meta name=\"APIName\" content=\"System.ICustomFormatter\">\r\n<meta name=\"APIName\" content=\"System.ICustomFormatter.Format\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-28 03:03 AM\">\r\n<meta name=\"document_id\" content=\"4d709fd4-19e3-deb8-c534-b99bd0fbe21d\">\r\n<meta name=\"internalonly\" content=\"false\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Defines a method that supports custom formatting of the value of an object.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.ICustomFormatter\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.ICustomFormatter.yml","open_to_public_contributors":false,"api_name":["System.ICustomFormatter","System.ICustomFormatter.Format"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.ICustomFormatter","System::ICustomFormatter","System.ICustomFormatter.Format","System::ICustomFormatter::Format"],"dev_langs":["csharp"],"updated_at":"2017-03-28 03:03 AM","document_id":"4d709fd4-19e3-deb8-c534-b99bd0fbe21d","content_git_url":"https://github.com/dotnet/docs/blob/master/xml/System/ICustomFormatter.xml","internalonly":false,"layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"ICustomFormatter interface | Microsoft Docs","_op_ogTitle":"ICustomFormatter interface","description":"Defines a method that supports custom formatting of the value of an object.\n","toc_asset_id":"api/_splitted/System/toc.json","toc_rel":"_splitted/System/toc.json","source_url":"","ms.assetid":"System.ICustomFormatter","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.icustomformatter","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.icustomformatter","fileRelativePath":"api/System.ICustomFormatter.html"},"themesRelativePathToOutputRoot":"_themes/"}