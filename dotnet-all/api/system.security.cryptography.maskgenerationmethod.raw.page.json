{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">MaskGenerationMethod</span>\r\n    \t\t\t\tClass\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Represents the abstract class from which all mask generator algorithms must derive.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(true)]\npublic abstract class MaskGenerationMethod</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><span class=\"lang-csharp\">MaskGenerationMethod</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Derived</dt><dd>\r\n  \t\t<div class=\"cdlHolder\">\r\n        \t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.pkcs1maskgenerationmethod\" data-linktype=\"relative-path\">PKCS1MaskGenerationMethod</a></span></div>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Attributes</dt><dd>\r\n  \t\t<div class=\"cdlHolder\">\r\n  \t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \t<h3 class=\"accented\">Inherited Members</h3>\r\n  \t<h4 class=\"accented\"></h4>\r\n  \t<div class=\"cdlHolder\">\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a></span></div>\r\n  \t</div>\r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following code example demonstrates how to derive from the MaskGenerationMethod class.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Security.Cryptography.MaskGenerationMethod#1\">using System;\nusing System.Security.Cryptography;\n\nnamespace Contoso\n{\n    class MaskGenerator : System.Security.Cryptography.MaskGenerationMethod\n    {\n        private String HashNameValue;\n\n        // Initialize a mask to encrypt using the SHA1 algorithm.\n        public MaskGenerator() \n        {\n            HashNameValue = &quot;SHA1&quot;;\n        }\n\n        // Create a mask with the specified seed.\n        override public byte[] GenerateMask(byte[] seed, int maskLength)\n        {\n            HashAlgorithm hash;\n            byte[] rgbCounter = new byte[4];\n            byte[] targetRgb = new byte[maskLength];\n            uint counter = 0;\n\n            for (int inc = 0; inc &lt; targetRgb.Length; )\n            {\n                ConvertIntToByteArray(counter++, ref rgbCounter);\n                hash = (HashAlgorithm)\n                    CryptoConfig.CreateFromName(HashNameValue);\n\n                byte[] temp = new byte[4 + seed.Length];\n                Buffer.BlockCopy(rgbCounter, 0, temp, 0, 4);\n                Buffer.BlockCopy(seed, 0, temp, 4, seed.Length);\n                hash.ComputeHash(temp);\n\n                if (targetRgb.Length - inc &gt; hash.HashSize/8) \n                {\n                    Buffer.BlockCopy(\n                        hash.Hash,\n                        0,\n                        targetRgb,\n                        inc,\n                        hash.Hash.Length);\n                }\n                else\n                {\n                    Buffer.BlockCopy(\n                        hash.Hash,\n                        0,\n                        targetRgb,\n                        inc,\n                        targetRgb.Length - inc);\n                }\n                inc += hash.Hash.Length;\n            }\n            return targetRgb;\n        }\n\n        // Convert the specified integer to the byte array.\n        private void ConvertIntToByteArray(\n            uint sourceInt,\n            ref byte[] targetBytes)\n        {\n            uint remainder;\n            int inc = 0;\n\n            // Clear the array prior to filling it.\n            Array.Clear(targetBytes, 0, targetBytes.Length);\n\n            while (sourceInt &gt; 0) \n            {\n                remainder = sourceInt % 256;\n                targetBytes[3 - inc] = (byte) remainder;\n                sourceInt = (sourceInt - remainder)/256;\n                inc++;\n            }\n        }\n    }\n// This class demonstrates how to create the MaskGenerator class \n// and call its GenerateMask member.\n    class MaskGeneratorImpl\n    {\n      public static void Main(string[] args)\n      {\n          byte[] seed = new byte[] {0x01, 0x02, 0x03, 0x04};\n          int length = 16;\n          MaskGenerator maskGenerator = new MaskGenerator();\n          byte[] mask = maskGenerator.GenerateMask(seed, length);\n          Console.WriteLine(&quot;Generated the following mask:&quot;);\n          Console.WriteLine(System.Text.Encoding.ASCII.GetString(mask));\n\n          Console.WriteLine(&quot;This sample completed successfully; &quot; +\n                &quot;press Enter to exit.&quot;);\n          Console.ReadLine();\n      }\n  }\n}\n//\n// This sample produces the following output:\n//\n// Generated the following mask:\n// ?&quot;TFd(?~OtO?\n// This sample completed successfully; press Enter to exit.\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Security.Cryptography.MaskGenerationMethod#1\">#using &lt;System.dll&gt;\n\nusing namespace System;\nusing namespace System::Security::Cryptography;\n\nnamespace Contoso\n{\n    ref class MaskGenerator: MaskGenerationMethod\n    {\n    private:\n        String^ hashNameValue;\n\n    public:\n        // Initialize a mask to encrypt using the SHA1 algorithm.\n        MaskGenerator()\n        {\n            hashNameValue = &quot;SHA1&quot;;\n        }\n\n        // Create a mask with the specified seed.\n        virtual array&lt;Byte&gt;^ GenerateMask(array&lt;Byte&gt;^ seed, int maskLength) override\n        {\n            HashAlgorithm^ hash;\n            array&lt;Byte&gt;^ rgbCounter = gcnew array&lt;Byte&gt;(4);\n            array&lt;Byte&gt;^ targetRgb = gcnew array&lt;Byte&gt;(maskLength);\n            UInt32 counter = 0;\n            for (int inc = 0; inc &lt; targetRgb-&gt;Length; )\n            {\n                ConvertIntToByteArray(counter++, rgbCounter);\n                hash = (HashAlgorithm^)CryptoConfig::CreateFromName(\n                    hashNameValue);\n                array&lt;Byte&gt;^ temp = gcnew array&lt;Byte&gt;(\n                    4 + seed-&gt;Length);\n                Buffer::BlockCopy(rgbCounter, 0, temp, 0, 4);\n                Buffer::BlockCopy(seed, 0, temp, 4, seed-&gt;Length);\n                hash-&gt;ComputeHash(temp);\n                if (targetRgb-&gt;Length - inc &gt; hash-&gt;HashSize / 8)\n                {\n                    Buffer::BlockCopy(hash-&gt;Hash, 0, targetRgb, inc,\n                        hash-&gt;Hash-&gt;Length);\n                }\n                else\n                {\n                    Buffer::BlockCopy(hash-&gt;Hash, 0, targetRgb, inc,\n                        targetRgb-&gt;Length - inc);\n                }\n\n                inc += hash-&gt;Hash-&gt;Length;\n            }\n            return targetRgb;\n        }\n\n    private:\n        // Convert the specified integer to the byte array.\n        void ConvertIntToByteArray(UInt32 source,\n            array&lt;Byte&gt;^ targetBytes)\n        {\n            UInt32 remainder;\n            int inc = 0;\n\n            // Clear the array prior to filling it.\n            Array::Clear(targetBytes, 0, targetBytes-&gt;Length);\n            while (source &gt; 0)\n            {\n                remainder = source % 256;\n                targetBytes[ 3 - inc ] = (Byte)remainder;\n                source = (source - remainder) / 256;\n                inc++;\n            }\n        }\n    };\n\n    // This class demonstrates how to create the MaskGenerator class \n    // and call its GenerateMask member.\n    ref class MaskGeneratorImpl\n    {\n    public:\n        void static Work()\n        {\n            array&lt;Byte&gt;^ seed = gcnew array&lt;Byte&gt;(4){\n                0x01,0x02,0x03,0x04};\n            int length = 16;\n            MaskGenerator^ maskGenerator = gcnew MaskGenerator;\n            array&lt;Byte&gt;^ mask = maskGenerator-&gt;GenerateMask(seed,\n                length);\n            Console::WriteLine(&quot;Generated the following mask:&quot;);\n            Console::WriteLine(System::Text::Encoding::\n                ASCII::get()-&gt;GetString(mask));\n            Console::WriteLine(&quot;This sample completed successfully;&quot;\n                &quot; press Enter to exit.&quot;);\n            Console::ReadLine();\n        }\n    };\n}\n\nvoid main()\n{\n    Contoso::MaskGeneratorImpl::Work();\n}\n\n//\n// This sample produces the following output:\n//\n// Generated the following mask:\n// ?&quot;TFd(?~OtO?\n// This sample completed successfully; press Enter to exit.\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Security.Cryptography.MaskGenerationMethod#1\">Imports System\nImports System.Security.Cryptography\n\nPublic Class MaskGenerator\n    Inherits System.Security.Cryptography.MaskGenerationMethod\n\n    Private HashNameValue As String\n\n    &#39; Initialize a mask to encrypt using the SHA1 algorithm.\n    Public Sub New()\n        HashNameValue = &quot;SHA1&quot;\n    End Sub\n\n    &#39; Create a mask with the specified seed.\n    Public Overrides Function GenerateMask( _\n        ByVal seed() As Byte, _\n        ByVal maskLength As Integer) As Byte()\n\n        Dim hash As HashAlgorithm\n        Dim rgbCounter(4) As Byte\n        Dim targetRgb(maskLength) As Byte\n        Dim counter As Integer\n\n        For inc As Int16 = 0 To targetRgb.Length\n            ConvertIntToByteArray(counter + 1, rgbCounter)\n            hash = CType( _\n                CryptoConfig.CreateFromName(HashNameValue), _\n                HashAlgorithm)\n            Dim temp(4 + seed.Length) As Byte\n            Buffer.BlockCopy(rgbCounter, 0, temp, 0, 4)\n            Buffer.BlockCopy(seed, 0, temp, 4, seed.Length)\n            hash.ComputeHash(temp)\n\n            If (targetRgb.Length - inc &gt; hash.HashSize / 8) Then\n                Buffer.BlockCopy( _\n                    hash.Hash, 0, targetRgb, inc, hash.Hash.Length)\n            Else\n                Buffer.BlockCopy( _\n                    hash.Hash, 0, targetRgb, inc, targetRgb.Length - inc)\n            End If\n\n            inc += hash.Hash.Length\n        Next\n\n        Return targetRgb\n    End Function\n\n    &#39; Convert the specified integer to the byte array.\n    Private Sub ConvertIntToByteArray( _\n        ByVal sourceInt As Integer, _\n        ByRef targetBytes() As Byte)\n        Dim remainder As Integer\n        Dim inc As Int16 = 0\n\n        &#39; Clear the array prior to filling it.\n        Array.Clear(targetBytes, 0, targetBytes.Length)\n\n        While (sourceInt &gt; 0)\n            remainder = sourceInt Mod 256\n            targetBytes(3 - inc) = CType(remainder, Byte)\n            sourceInt = (sourceInt - remainder) / 256\n            inc = inc + 1\n        End While\n    End Sub\nEnd Class\n\nPublic Class Form1\n    Inherits System.Windows.Forms.Form\n\n    &#39; Event handler for Run button.\n    Private Sub Button1_Click( _\n        ByVal sender As System.Object, _\n        ByVal e As System.EventArgs) Handles Button1.Click\n\n        tbxOutput.Cursor = Cursors.WaitCursor\n        tbxOutput.Text = &quot;&quot;\n\n        Dim seed() As Byte = {&amp;H1, &amp;H2, &amp;H3, &amp;H4}\n        Dim length As Int16 = 16\n        Dim maskGenerator As New MaskGenerator\n        Dim mask() As Byte = maskGenerator.GenerateMask(seed, length)\n\n        tbxOutput.AppendText(&quot;Generated the following mask:&quot;)\n        tbxOutput.AppendText(System.Text.Encoding.ASCII.GetString(mask))\n\n        &#39; Align interface and conclude application.\n        tbxOutput.AppendText(vbCrLf + &quot;This sample completed&quot; + _\n            &quot;successfully; press Exit to continue.&quot;)\n\n        tbxOutput.Cursor = Cursors.Default\n    End Sub\n    &#39; Event handler for Exit button.\n    Private Sub Button2_Click( _\n        ByVal sender As System.Object, _\n        ByVal e As System.EventArgs) Handles Button2.Click\n\n        Application.Exit()\n    End Sub\n#Region &quot; Windows Form Designer generated code &quot;\n\n    Public Sub New()\n        MyBase.New()\n\n        &#39;This call is required by the Windows Form Designer.\n        InitializeComponent()\n\n        &#39;Add any initialization after the InitializeComponent() call\n\n    End Sub\n\n    &#39;Form overrides dispose to clean up the component list.\n    Protected Overloads Overrides Sub Dispose(ByVal disposing As Boolean)\n        If disposing Then\n            If Not (components Is Nothing) Then\n                components.Dispose()\n            End If\n        End If\n        MyBase.Dispose(disposing)\n    End Sub\n\n    &#39;Required by the Windows Form Designer\n    Private components As System.ComponentModel.IContainer\n\n    &#39;NOTE: The following procedure is required by the Windows Form Designer\n    &#39;It can be modified using the Windows Form Designer.  \n    &#39;Do not modify it using the code editor.\n    Friend WithEvents Panel2 As System.Windows.Forms.Panel\n    Friend WithEvents Panel1 As System.Windows.Forms.Panel\n    Friend WithEvents Button1 As System.Windows.Forms.Button\n    Friend WithEvents Button2 As System.Windows.Forms.Button\n    Friend WithEvents tbxOutput As System.Windows.Forms.RichTextBox\n    &lt;System.Diagnostics.DebuggerStepThrough()&gt; _\n    Private Sub InitializeComponent()\n        Me.Panel2 = New System.Windows.Forms.Panel\n        Me.Button1 = New System.Windows.Forms.Button\n        Me.Button2 = New System.Windows.Forms.Button\n        Me.Panel1 = New System.Windows.Forms.Panel\n        Me.tbxOutput = New System.Windows.Forms.RichTextBox\n        Me.Panel2.SuspendLayout()\n        Me.Panel1.SuspendLayout()\n        Me.SuspendLayout()\n        &#39;\n        &#39;Panel2\n        &#39;\n        Me.Panel2.Controls.Add(Me.Button1)\n        Me.Panel2.Controls.Add(Me.Button2)\n        Me.Panel2.Dock = System.Windows.Forms.DockStyle.Bottom\n        Me.Panel2.DockPadding.All = 20\n        Me.Panel2.Location = New System.Drawing.Point(0, 320)\n        Me.Panel2.Name = &quot;Panel2&quot;\n        Me.Panel2.Size = New System.Drawing.Size(616, 64)\n        Me.Panel2.TabIndex = 1\n        &#39;\n        &#39;Button1\n        &#39;\n        Me.Button1.Dock = System.Windows.Forms.DockStyle.Right\n        Me.Button1.Font = New System.Drawing.Font( _\n            &quot;Microsoft Sans Serif&quot;, _\n            9.0!, _\n            System.Drawing.FontStyle.Regular, _\n            System.Drawing.GraphicsUnit.Point, _\n            CType(0, Byte))\n        Me.Button1.Location = New System.Drawing.Point(446, 20)\n        Me.Button1.Name = &quot;Button1&quot;\n        Me.Button1.Size = New System.Drawing.Size(75, 24)\n        Me.Button1.TabIndex = 2\n        Me.Button1.Text = &quot;&amp;Run&quot;\n        &#39;\n        &#39;Button2\n        &#39;\n        Me.Button2.Dock = System.Windows.Forms.DockStyle.Right\n        Me.Button2.Font = New System.Drawing.Font( _\n            &quot;Microsoft Sans Serif&quot;, _\n            9.0!, _\n            System.Drawing.FontStyle.Regular, _\n            System.Drawing.GraphicsUnit.Point, _\n            CType(0, Byte))\n        Me.Button2.Location = New System.Drawing.Point(521, 20)\n        Me.Button2.Name = &quot;Button2&quot;\n        Me.Button2.Size = New System.Drawing.Size(75, 24)\n        Me.Button2.TabIndex = 3\n        Me.Button2.Text = &quot;E&amp;xit&quot;\n        &#39;\n        &#39;Panel1\n        &#39;\n        Me.Panel1.Controls.Add(Me.tbxOutput)\n        Me.Panel1.Dock = System.Windows.Forms.DockStyle.Fill\n        Me.Panel1.DockPadding.All = 20\n        Me.Panel1.Location = New System.Drawing.Point(0, 0)\n        Me.Panel1.Name = &quot;Panel1&quot;\n        Me.Panel1.Size = New System.Drawing.Size(616, 320)\n        Me.Panel1.TabIndex = 2\n        &#39;\n        &#39;tbxOutput\n        &#39;\n        Me.tbxOutput.AccessibleDescription = _\n            &quot;Displays output from application.&quot;\n        Me.tbxOutput.AccessibleName = &quot;Output textbox.&quot;\n        Me.tbxOutput.Dock = System.Windows.Forms.DockStyle.Fill\n        Me.tbxOutput.Location = New System.Drawing.Point(20, 20)\n        Me.tbxOutput.Name = &quot;tbxOutput&quot;\n        Me.tbxOutput.Size = New System.Drawing.Size(576, 280)\n        Me.tbxOutput.TabIndex = 1\n        Me.tbxOutput.Text = &quot;Click the Run button to run the application.&quot;\n        &#39;\n        &#39;Form1\n        &#39;\n        Me.AutoScaleBaseSize = New System.Drawing.Size(6, 15)\n        Me.ClientSize = New System.Drawing.Size(616, 384)\n        Me.Controls.Add(Me.Panel1)\n        Me.Controls.Add(Me.Panel2)\n        Me.Name = &quot;Form1&quot;\n        Me.Text = &quot;MaskGenerationMethod&quot;\n        Me.Panel2.ResumeLayout(False)\n        Me.Panel1.ResumeLayout(False)\n        Me.ResumeLayout(False)\n\n    End Sub\n\n#End Region\nEnd Class\n&#39;\n&#39; This sample produces the following output:\n&#39;\n&#39; Generated the following mask:~&amp;*(uj98U(*UD989D\n&#39; This sample completedsuccessfully; press Exit to continue.\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>Derived classes of MaskGenerationMethod compute masks that are used in key exchange algorithms such as Optimal Asymmetric Encryption Padding (OAEP).  </p>\n<p> This class is used by implementations of key exchange algorithms only for mask generation. Application code does not use this class directly.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Constructors\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Security_Cryptography_MaskGenerationMethod__ctor_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_Cryptography_MaskGenerationMethod__ctor\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">MaskGenerationMethod()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Initializes a new instance of the <a class=\"xref\" href=\"system.security.cryptography.maskgenerationmethod\" data-linktype=\"relative-path\">MaskGenerationMethod</a> class.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">protected MaskGenerationMethod ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Methods\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Security_Cryptography_MaskGenerationMethod_GenerateMask_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_Cryptography_MaskGenerationMethod_GenerateMask_System_Byte___System_Int32_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">GenerateMask(Byte[], Int32)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>When overridden in a derived class, generates a mask with the specified length using the specified random seed.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public abstract byte[] GenerateMask (byte[] rgbSeed, int cbReturn);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>rgbSeed</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.byte\" data-linktype=\"relative-path\">Byte</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The random seed to use to compute the mask.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>cbReturn</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The length of the generated mask in bytes.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.byte\" data-linktype=\"relative-path\">Byte</a>[]</span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>A randomly generated mask whose length is equal to the <code>cbReturn</code> parameter.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Security.Cryptography.MaskGenerationMethod.yml\">\r\n<meta name=\"APIName\" content=\"System.Security.Cryptography.MaskGenerationMethod\">\r\n<meta name=\"APIName\" content=\"System.Security.Cryptography.MaskGenerationMethod..ctor\">\r\n<meta name=\"APIName\" content=\"System.Security.Cryptography.MaskGenerationMethod.GenerateMask\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-04-01 05:59 PM\">\r\n<meta name=\"document_id\" content=\"2ef883bc-05e2-f338-dc25-7dd5b8295a37\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Represents the abstract class from which all mask generator algorithms must derive.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.security.cryptography/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Security.Cryptography.MaskGenerationMethod\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","uhfHeaderId":"MSDocsHeader-DotNet","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Security.Cryptography.MaskGenerationMethod.yml","open_to_public_contributors":false,"api_name":["System.Security.Cryptography.MaskGenerationMethod","System.Security.Cryptography.MaskGenerationMethod..ctor","System.Security.Cryptography.MaskGenerationMethod.GenerateMask"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Security.Cryptography.MaskGenerationMethod","System::Security::Cryptography::MaskGenerationMethod","System.Security.Cryptography.MaskGenerationMethod.#ctor","System::Security::Cryptography::MaskGenerationMethod::#ctor","System.Security.Cryptography.MaskGenerationMethod.GenerateMask","System::Security::Cryptography::MaskGenerationMethod::GenerateMask"],"dev_langs":["csharp"],"updated_at":"2017-04-01 05:59 PM","document_id":"2ef883bc-05e2-f338-dc25-7dd5b8295a37","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Security.Cryptography/MaskGenerationMethod.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"MaskGenerationMethod class | Microsoft Docs","_op_ogTitle":"MaskGenerationMethod class","description":"Represents the abstract class from which all mask generator algorithms must derive.\n","toc_asset_id":"api/_splitted/System.Security.Cryptography/toc.json","toc_rel":"_splitted/System.Security.Cryptography/toc.json","source_url":"","ms.assetid":"System.Security.Cryptography.MaskGenerationMethod","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.maskgenerationmethod","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.maskgenerationmethod","fileRelativePath":"api/System.Security.Cryptography.MaskGenerationMethod.html"},"themesRelativePathToOutputRoot":"_themes/"}