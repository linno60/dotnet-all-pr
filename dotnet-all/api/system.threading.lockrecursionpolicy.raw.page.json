{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">LockRecursionPolicy</span>\r\n      Enum\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Specifies whether a lock can be entered multiple times by the same thread.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\r\n  \t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">public enum LockRecursionPolicy</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.valuetype\" data-linktype=\"relative-path\">ValueType</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.enum\" data-linktype=\"relative-path\">Enum</a></span></div><span class=\"lang-csharp\">LockRecursionPolicy</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following example shows two exception scenarios, one that depends on the LockRecursionPolicy setting and one that does not.  </p>\n<p> In the first scenario, the thread enters the lock in read mode and then tries to enter read mode recursively. If the <a class=\"xref\" href=\"system.threading.readerwriterlockslim\" data-linktype=\"relative-path\">ReaderWriterLockSlim</a> is created by using the default constructor, which sets recursion policy to NoRecursion, an exception is thrown. If SupportsRecursion is used to create the <a class=\"xref\" href=\"system.threading.readerwriterlockslim\" data-linktype=\"relative-path\">ReaderWriterLockSlim</a>, no exception is thrown.  </p>\n<p> In the second scenario, the thread enters the lock in read mode and then tries to enter the lock in write mode. <a class=\"xref\" href=\"system.threading.lockrecursionexception\" data-linktype=\"relative-path\">LockRecursionException</a> is thrown regardless of the lock recursion policy.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.LockRecursionPolicy#1\">using System;\nusing System.Threading;\n\nclass Example\n{\n    // By default, the lock recursion policy for a new \n    // ReaderWriterLockSlim does not allow recursion.\n    private static ReaderWriterLockSlim rwls = new ReaderWriterLockSlim();\n    private static ReaderWriterLockSlim rwlsWithRecursion =\n        new ReaderWriterLockSlim(LockRecursionPolicy.SupportsRecursion);\n\n    static void ThreadProc()\n    { \n        Console.WriteLine(&quot;1. Enter the read lock recursively.&quot;);\n        ReadRecursive(rwls);\n        ReadRecursive(rwlsWithRecursion);\n\n        Console.WriteLine(&quot;\\n2. Enter the write lock recursively from the read lock.&quot;);\n        ReadWriteRecursive(rwls);\n        ReadWriteRecursive(rwlsWithRecursion);\n    } \n\n    static void ReadRecursive(ReaderWriterLockSlim rwls)\n    {\n        Console.WriteLine(&quot;LockRecursionPolicy.{0}:&quot;, rwls.RecursionPolicy);\n        rwls.EnterReadLock();\n\n        try {\n            rwls.EnterReadLock();\n            Console.WriteLine(&quot;\\nThe read lock was entered recursively.&quot;);\n            rwls.ExitReadLock();\n        }    \n        catch (LockRecursionException lre) {\n            Console.WriteLine(&quot;\\n{0}: {1}&quot;,\n                lre.GetType().Name, lre.Message);\n        }\n\n        rwls.ExitReadLock();\n    }\n\n    static void ReadWriteRecursive(ReaderWriterLockSlim rwls)\n    {\n        Console.WriteLine(&quot;LockRecursionPolicy.{0}:&quot;, rwls.RecursionPolicy);\n        rwls.EnterReadLock();\n\n        try {\n            rwls.EnterWriteLock();\n            Console.WriteLine(&quot;\\nThe write lock was entered recursively.&quot;);\n        }\n        catch (LockRecursionException lre) {\n            Console.WriteLine(&quot;\\n{0}: {1}&quot;, \n                lre.GetType().Name, lre.Message);\n        }\n\n        rwls.ExitReadLock();\n    }\n\n    static void Main() \n    {\n        Thread t = new Thread(ThreadProc);\n        t.Start();\n        t.Join();\n        \n        // Dispose of ReaderWriterLockSlim objects&#39; unmanaged resources.\n        if (rwls != null) rwls.Dispose();\n        if (rwlsWithRecursion != null) rwlsWithRecursion.Dispose();\n    } \n} \n// This example displays output similar to the following:\n//    1. Enter the read lock recursively.\n//    LockRecursionPolicy.NoRecursion:\n//    \n//    LockRecursionException: Recursive read lock acquisitions not allowed in this mode.\n//    LockRecursionPolicy.SupportsRecursion:\n//    \n//    The read lock was entered recursively.\n//    \n//    2. Enter the write lock recursively from the read lock.\n//    LockRecursionPolicy.NoRecursion:\n//    \n//    LockRecursionException: Write lock may not be acquired with read lock held. This pattern i\n//    s prone to deadlocks. Please ensure that read locks are released before taking a write loc\n//    k. If an upgrade is necessary, use an upgrade lock in place of the read lock.\n//    LockRecursionPolicy.SupportsRecursion:\n//    \n//    LockRecursionException: Write lock may not be acquired with read lock held. This pattern i\n//    s prone to deadlocks. Please ensure that read locks are released before taking a write loc\n//    k. If an upgrade is necessary, use an upgrade lock in place of the read lock.\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.LockRecursionPolicy#1\">Imports System\nImports System.Threading\n\nClass Example\n    &#39; By default, the lock recursion policy for a new \n    &#39; ReaderWriterLockSlim does not allow recursion.\n    Private Shared rwls As New ReaderWriterLockSlim()\n    Private Shared rwlsWithRecursion _\n        As New ReaderWriterLockSlim(LockRecursionPolicy.SupportsRecursion)\n    \n    Shared Sub ThreadProc() \n        \n        Console.WriteLine(&quot;1. Enter the read lock recursively.&quot;)\n        ReadRecursive(rwls)\n        ReadRecursive(rwlsWithRecursion)\n    \n        Console.WriteLine(vbCrLf &amp; _\n            &quot;2. Enter the write lock recursively from the read lock.&quot;)\n        ReadWriteRecursive(rwls)\n        ReadWriteRecursive(rwlsWithRecursion)\n\n    End Sub \n\n    Shared Sub ReadRecursive(ByVal rwls As ReaderWriterLockSlim)\n\n        Console.WriteLine(&quot;LockRecursionPolicy.{0}:&quot;, rwls.RecursionPolicy)\n        rwls.EnterReadLock()\n        \n        Try\n            rwls.EnterReadLock()\n            Console.WriteLine(vbTab &amp; _\n                &quot;The read lock was entered recursively.&quot;)\n            rwls.ExitReadLock()\n        Catch lre As LockRecursionException\n            Console.WriteLine(vbTab &amp; &quot;{0}: {1}&quot;, _\n                lre.GetType().Name, lre.Message)\n        End Try\n\n        rwls.ExitReadLock()\n    End Sub\n\n    Shared Sub ReadWriteRecursive(ByVal rwls As ReaderWriterLockSlim)\n\n        Console.WriteLine(&quot;LockRecursionPolicy.{0}:&quot;, rwls.RecursionPolicy)\n        rwls.EnterReadLock()\n\n        Try\n            rwls.EnterWriteLock()\n            Console.WriteLine(vbTab &amp; _\n                &quot;The write lock was entered recursively.&quot;)\n        Catch lre As LockRecursionException\n            Console.WriteLine(vbTab &amp; &quot;{0}: {1}&quot;, _\n                lre.GetType().Name, lre.Message)\n        End Try\n\n        rwls.ExitReadLock()\n    End Sub\n    \n    Shared Sub Main() \n\n        Dim t As New Thread(AddressOf ThreadProc)\n        t.Start()\n        t.Join()\n\n        &#39; Dispose of ReaderWriterLockSlim objects&#39; unmanaged resources.\n        If rwls IsNot Nothing Then rwls.Dispose()\n        If rwlsWithRecursion IsNot Nothing Then _\n           rwlsWithRecursion.Dispose()\n    End Sub \nEnd Class \n\n&#39; This code example produces output similar to the following:\n&#39;\n&#39;1. Enter the read lock recursively.\n&#39;LockRecursionPolicy.NoRecursion:\n&#39;        LockRecursionException: Recursive read lock acquisitions not allowed in this mode.\n&#39;LockRecursionPolicy.SupportsRecursion:\n&#39;        The read lock was entered recursively.\n&#39;\n&#39;2. Enter the write lock recursively from the read lock.\n&#39;LockRecursionPolicy.NoRecursion:\n&#39;        LockRecursionException: Write lock may not be acquired with read lock held. This pattern is prone to deadlocks. Consider using the upgrade lock.\n&#39;LockRecursionPolicy.SupportsRecursion:\n&#39;        LockRecursionException: Write lock may not be acquired with read lock held. This pattern is prone to deadlocks. Consider using the upgrade lock.\n&#39; \n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>The default recursion policy depends on the type of lock. For the default policy and the precise behavior of lock recursion for any given lock type, see the documentation for the type. For example, the <a class=\"xref\" href=\"system.threading.readerwriterlockslim\" data-linktype=\"relative-path\">ReaderWriterLockSlim</a> class does not allow a thread to enter the lock in write mode if it already entered the lock in read mode, regardless of the lock policy setting, in order to reduce the chance of deadlocks.  </p>\n<p> Currently only one lock uses this enumeration:  </p>\n<ul>\n<li><a class=\"xref\" href=\"system.threading.readerwriterlockslim\" data-linktype=\"relative-path\">ReaderWriterLockSlim</a>. For more information, see the <a class=\"xref\" href=\"system.threading.readerwriterlockslim#System_Threading_ReaderWriterLockSlim_RecursionPolicy_\" data-linktype=\"relative-path\">RecursionPolicy</a> property.</li>\n</ul>\n\r\n  \r\n      \t<h2 class=\"accented\">Fields\r\n      </h2>\r\n      <table class=\"nameValue\">\r\n      \t<tr><td id=\"System_Threading_LockRecursionPolicy_NoRecursion\">\r\n      \t\t\t<span class=\"lang-csharp\">NoRecursion</span>\r\n      \t</td>\r\n      \t<td><p>If a thread tries to enter a lock recursively, an exception is thrown. Some classes may allow certain recursions when this setting is in effect.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Threading_LockRecursionPolicy_SupportsRecursion\">\r\n      \t\t\t<span class=\"lang-csharp\">SupportsRecursion</span>\r\n      \t</td>\r\n      \t<td><p>A thread can enter a lock recursively. Some classes may restrict this capability.</p>\n</td>\r\n      \t</tr>\r\n      </table>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Threading.LockRecursionPolicy.yml\">\r\n<meta name=\"APIName\" content=\"System.Threading.LockRecursionPolicy\">\r\n<meta name=\"APIName\" content=\"System.Threading.LockRecursionPolicy.NoRecursion\">\r\n<meta name=\"APIName\" content=\"System.Threading.LockRecursionPolicy.SupportsRecursion\">\r\n<meta name=\"APILocation\" content=\"System.Core.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-31 02:21 PM\">\r\n<meta name=\"document_id\" content=\"11164b5e-cfce-ec0a-d812-8bbeab8d5429\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Specifies whether a lock can be entered multiple times by the same thread.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.threading/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Threading.LockRecursionPolicy\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Threading.LockRecursionPolicy.yml","open_to_public_contributors":false,"api_name":["System.Threading.LockRecursionPolicy","System.Threading.LockRecursionPolicy.NoRecursion","System.Threading.LockRecursionPolicy.SupportsRecursion"],"api_location":["System.Core.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Threading.LockRecursionPolicy","System::Threading::LockRecursionPolicy","System.Threading.LockRecursionPolicy.NoRecursion","System::Threading::LockRecursionPolicy::NoRecursion","System.Threading.LockRecursionPolicy.SupportsRecursion","System::Threading::LockRecursionPolicy::SupportsRecursion"],"dev_langs":["csharp"],"updated_at":"2017-03-31 02:21 PM","document_id":"11164b5e-cfce-ec0a-d812-8bbeab8d5429","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Threading/LockRecursionPolicy.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"LockRecursionPolicy enum | Microsoft Docs","_op_ogTitle":"LockRecursionPolicy enum","description":"Specifies whether a lock can be entered multiple times by the same thread.\n","toc_asset_id":"api/_splitted/System.Threading/toc.json","toc_rel":"_splitted/System.Threading/toc.json","source_url":"","ms.assetid":"System.Threading.LockRecursionPolicy","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.threading.lockrecursionpolicy","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.threading.lockrecursionpolicy","fileRelativePath":"api/System.Threading.LockRecursionPolicy.html"},"themesRelativePathToOutputRoot":"_themes/"}