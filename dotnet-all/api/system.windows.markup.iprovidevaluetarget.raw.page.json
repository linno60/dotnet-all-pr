{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">IProvideValueTarget</span>\r\n      Interface\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Represents a service that reports situational object-property relationships for markup extension evaluation.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">public interface IProvideValueTarget</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>IProvideValueTarget represents a service that reports information regarding the object-property structure surrounding where a value converter is invoked.  </p>\n<p> Type converters and markup extensions can query for IProvideValueTarget as a service on the service context that is provided by a XAML object writer, when the XAML object writer invokes value conversion behavior. For more information, see <a href=\"../topic/type%20converters%20and%20markup%20extensions%20for%20xaml\" data-linktype=\"relative-path\">Type Converters and Markup Extensions for XAML</a> and <a href=\"../topic/service%20contexts%20available%20to%20type%20converters%20and%20markup%20extensions\" data-linktype=\"relative-path\">Service Contexts Available to Type Converters and Markup Extensions</a>.  </p>\n<p> For markup extensions specifically, a scenario where IProvideValueTarget is useful is to determine the validity of your markup extension&#39;s situational usage. For example, your markup extension might implement a value deferral mechanism, but using that mechanism might only be appropriate if the target object is capable of using other components of your deferral mechanism at run time. You could check the type system characteristics of the object returned as <a class=\"xref\" href=\"system.windows.markup.iprovidevaluetarget#System_Windows_Markup_IProvideValueTarget_TargetObject_\" data-linktype=\"relative-path\">TargetObject</a> and make sure that object supports your deferral technique. If so, your markup extension returns a value, and if not, your markup extension throws an exception that will be picked up as an inner exception by a XAML object writer. A similar scenario is assuring that a particular property supports a capability, by checking type system characteristics of the <a class=\"xref\" href=\"system.windows.markup.iprovidevaluetarget#System_Windows_Markup_IProvideValueTarget_TargetProperty_\" data-linktype=\"relative-path\">TargetProperty</a>.  </p>\n<p> Although the API name IProvideValueTarget might imply an association with <a class=\"xref\" href=\"system.windows.markup.markupextension#System_Windows_Markup_MarkupExtension_ProvideValue_\" data-linktype=\"relative-path\">ProvideValue</a>, the information reported by IProvideValueTarget can also be useful to a <a class=\"xref\" href=\"system.componentmodel.typeconverter\" data-linktype=\"relative-path\">TypeConverter</a> or <a class=\"xref\" href=\"system.windows.markup.valueserializer\" data-linktype=\"relative-path\">ValueSerializer</a>. A <a class=\"xref\" href=\"system.componentmodel.typeconverter\" data-linktype=\"relative-path\">TypeConverter</a> or <a class=\"xref\" href=\"system.windows.markup.valueserializer\" data-linktype=\"relative-path\">ValueSerializer</a> typically have more context than a markup extension because they are dedicated to a particular target type or target property, and thus the situational validity is usually predictable in the type system. However, other scenarios exist. The following is a list of some scenarios that might be implemented by either a type converter or a markup extension:  </p>\n<ul>\n<li><p>Get <a class=\"xref\" href=\"system.windows.markup.iprovidevaluetarget#System_Windows_Markup_IProvideValueTarget_TargetObject_\" data-linktype=\"relative-path\">TargetObject</a> to read instance values of other properties on that object. Note that your handling here might need to be robust for unset values, because the processing order of XAML members on the target object can be nondeterministic.  </p>\n</li>\n<li><p>Get <a class=\"xref\" href=\"system.windows.markup.iprovidevaluetarget#System_Windows_Markup_IProvideValueTarget_TargetObject_\" data-linktype=\"relative-path\">TargetObject</a> to read type-level metadata, or to verify that required interfaces are implemented by the type.  </p>\n</li>\n<li><p>Get <a class=\"xref\" href=\"system.windows.markup.iprovidevaluetarget#System_Windows_Markup_IProvideValueTarget_TargetProperty_\" data-linktype=\"relative-path\">TargetProperty</a> to read property metadata.  </p>\n</li>\n</ul>\n<p> One scenario is to use IProvideValueTarget information to limit which objects or properties are permitted to be set by your markup extension.  </p>\n<p> Before attempting to use the service, make sure that the service itself is not <code>null</code> when returned by the relevant service provider parameter you are using for context.  </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> When using the service, it is particularly important not to modify the object referenced by the <a class=\"xref\" href=\"system.windows.markup.iprovidevaluetarget#System_Windows_Markup_IProvideValueTarget_TargetObject_\" data-linktype=\"relative-path\">TargetObject</a> property, or other objects referenced by that object. For WPF specifically, these changes could cause unexpected changes that would invalidate the WPF property system.  </p>\n</div>\n<div class=\"NOTE\"><h5>Note</h5><p> Do not use the type of <a class=\"xref\" href=\"system.windows.markup.iprovidevaluetarget#System_Windows_Markup_IProvideValueTarget_TargetProperty_\" data-linktype=\"relative-path\">TargetProperty</a> to determine which precise type a markup extension or type converter should return. That is not a best practice. Your return type should be consistent with attributing (<a class=\"xref\" href=\"system.windows.markup.markupextensionreturntypeattribute\" data-linktype=\"relative-path\">MarkupExtensionReturnTypeAttribute</a> for markup extensions) or patterns (class name of the type converter).  </p>\n</div>\n<p> In previous versions of the .NET Framework, this interface existed in the WPF-specific assembly WindowsBase. In .NET Framework 4, IProvideValueTarget is in the System.Xaml assembly. For more information, see <a href=\"../topic/types%20migrated%20from%20wpf%20to%20system.xaml\" data-linktype=\"relative-path\">Types Migrated from WPF to System.Xaml</a>.  </p>\n<h3 class=\"accented\" id=\"wpf-usage-notes\">WPF Usage Notes</h3>\n<p> This service supports framework features such as binding on a dependency property.  </p>\n<p> In WPF, the service represented by IProvideValueTarget can return objects and properties for situations where the value to return from a markup extension or type converter depends on context.  </p>\n<p> IProvideValueTarget is leveraged heavily in the internal implementation of <a class=\"xref\" href=\"system.windows.data.bindingbase\" data-linktype=\"relative-path\">BindingBase</a>, the class that implements the binding mechanism for dependency properties in WPF.  </p>\n<p> A default internal service provider for WPF implements IProvideValueTarget for usage by a custom markup extension or type converter. The object and property reported by IProvideValueTarget can only be set by the internal WPF service. Going beyond this definition of how IProvideValueTarget operates would require defining your own service provider for markup extension and type converter usages that implements at the very least the IProvideValueTarget and <a class=\"xref\" href=\"system.windows.markup.ixamltyperesolver\" data-linktype=\"relative-path\">IXamlTypeResolver</a> services, and that is an advanced scenario that is not described here.  </p>\n<p> A null value for <a class=\"xref\" href=\"system.windows.markup.iprovidevaluetarget#System_Windows_Markup_IProvideValueTarget_TargetProperty_\" data-linktype=\"relative-path\">TargetProperty</a> or <a class=\"xref\" href=\"system.windows.markup.iprovidevaluetarget#System_Windows_Markup_IProvideValueTarget_TargetObject_\" data-linktype=\"relative-path\">TargetObject</a> does not necessarily mean that a markup extension or type converter cannot act, although that depends on your implementation. An example case where the values from IProvideValueTarget are null even if the service is available is if your markup extension is nested within another markup extension, such as a <a class=\"xref\" href=\"system.windows.data.binding\" data-linktype=\"relative-path\">Binding</a>. An implementation that relies on IProvideValueTarget should always check for null values if only for the purpose of throwing a specific exception, if that is your intended design.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Properties\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5\">\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Windows_Markup_IProvideValueTarget_TargetObject\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">TargetObject</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets the target object being reported.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public object TargetObject { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The target object being reported.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The value returned by TargetObject is the actual reference, not a type system identifier or other identifier. The value can also be <code>null</code>; see Remarks in <a class=\"xref\" href=\"system.windows.markup.iprovidevaluetarget\" data-linktype=\"relative-path\">IProvideValueTarget</a>.  </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> When using the service, it is particularly important not to modify the object referenced by the TargetObject property, or other objects referenced by that object as properties that are not specifically the value-conversion case you are handling. For WPF specifically, changing the target object could cause unexpected changes that would invalidate the WPF  property system.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5\">\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Windows_Markup_IProvideValueTarget_TargetProperty\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">TargetProperty</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets an identifier for the target property being reported.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public object TargetProperty { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An identifier for the target property being reported.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The value can also be <code>null</code>; see Remarks in <a class=\"xref\" href=\"system.windows.markup.iprovidevaluetarget\" data-linktype=\"relative-path\">IProvideValueTarget</a>.  </p>\n<h3 class=\"accented\" id=\"wpf-usage-notes\">WPF Usage Notes</h3>\n<p> For a dependency property, the default WPF service may return a <a class=\"xref\" href=\"system.windows.dependencyproperty\" data-linktype=\"relative-path\">DependencyProperty</a>, such that the markup extension or type converter can use metadata. Otherwise, the returned object can be a <a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a> for a CLR property.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Windows.Markup.IProvideValueTarget.yml\">\r\n<meta name=\"APIName\" content=\"System.Windows.Markup.IProvideValueTarget\">\r\n<meta name=\"APIName\" content=\"System.Windows.Markup.IProvideValueTarget.TargetObject\">\r\n<meta name=\"APIName\" content=\"System.Windows.Markup.IProvideValueTarget.TargetProperty\">\r\n<meta name=\"APILocation\" content=\"PresentationFramework.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-29 05:54 AM\">\r\n<meta name=\"document_id\" content=\"22712c2a-ff97-c48e-026b-deebc14c4bb6\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Represents a service that reports situational object-property relationships for markup extension evaluation.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.windows.markup/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Windows.Markup.IProvideValueTarget\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Windows.Markup.IProvideValueTarget.yml","open_to_public_contributors":false,"api_name":["System.Windows.Markup.IProvideValueTarget","System.Windows.Markup.IProvideValueTarget.TargetObject","System.Windows.Markup.IProvideValueTarget.TargetProperty"],"api_location":["PresentationFramework.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Windows.Markup.IProvideValueTarget","System::Windows::Markup::IProvideValueTarget","System.Windows.Markup.IProvideValueTarget.TargetObject","System::Windows::Markup::IProvideValueTarget::TargetObject","System.Windows.Markup.IProvideValueTarget.TargetProperty","System::Windows::Markup::IProvideValueTarget::TargetProperty"],"dev_langs":["csharp"],"updated_at":"2017-03-29 05:54 AM","document_id":"22712c2a-ff97-c48e-026b-deebc14c4bb6","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Windows.Markup/IProvideValueTarget.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"IProvideValueTarget interface | Microsoft Docs","_op_ogTitle":"IProvideValueTarget interface","description":"Represents a service that reports situational object-property relationships for markup extension evaluation.\n","toc_asset_id":"api/_splitted/System.Windows.Markup/toc.json","toc_rel":"_splitted/System.Windows.Markup/toc.json","source_url":"","ms.assetid":"System.Windows.Markup.IProvideValueTarget","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.windows.markup.iprovidevaluetarget","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.windows.markup.iprovidevaluetarget","fileRelativePath":"api/System.Windows.Markup.IProvideValueTarget.html"},"themesRelativePathToOutputRoot":"_themes/"}