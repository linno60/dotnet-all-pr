{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">OrderablePartitioner&lt;TSource&gt;</span>\r\n    \t\t\t\tClass\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Represents a particular manner of splitting an orderable data source into multiple partitions.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">public abstract class OrderablePartitioner&lt;TSource&gt; : System.Collections.Concurrent.Partitioner&lt;TSource&gt;</code></pre>\r\n  \r\n  \r\n  \r\n  \t\t<h3 class=\"accented\">Type Parameters</h3>\r\n  \t\t<table class=\"nameValue stack\">\r\n  \t\t\t<tr>\r\n  \t\t\t<td>TSource</td>\r\n  \t\t\t<td><p>Type of the elements in the collection.</p>\n</td>\r\n  \t\t\t</tr>\r\n  \t\t</table>\r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.concurrent.partitioner-1\" data-linktype=\"relative-path\">Partitioner&lt;TSource&gt;</a></span></div><span class=\"lang-csharp\">OrderablePartitioner&lt;TSource&gt;</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \r\n  \t<h3 class=\"accented\">Inherited Members</h3>\r\n  \t<h4 class=\"accented\"></h4>\r\n  \t<div class=\"cdlHolder\">\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.concurrent.partitioner-1#System_Collections_Concurrent_Partitioner_1_SupportsDynamicPartitions\" data-linktype=\"relative-path\">SupportsDynamicPartitions</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a></span></div>\r\n  \t</div>\r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following example shows how to implement an orderable partitioner that returns one element at a time:  </p>\n<pre><code class=\"lang-cs\" name=\"System.Collections.Concurrent.OrderablePartitioner#1\">using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Collections.Concurrent;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace OrderablePartitionerDemo\n{\n\n\n    // Simple partitioner that will extract one (index,item) pair at a time, \n    // in a thread-safe fashion, from the underlying collection.\n    class SingleElementOrderablePartitioner&lt;T&gt; : OrderablePartitioner&lt;T&gt;\n    {\n        // The collection being wrapped by this Partitioner\n        IEnumerable&lt;T&gt; m_referenceEnumerable;\n\n        // Class used to wrap m_index for the purpose of sharing access to it\n        // between an InternalEnumerable and multiple InternalEnumerators\n        private class Shared&lt;U&gt;\n        {\n            internal U Value;\n\n            public Shared(U item)\n            {\n                Value = item;\n            }\n        }\n\n        // Internal class that serves as a shared enumerable for the\n        // underlying collection.\n        private class InternalEnumerable : IEnumerable&lt;KeyValuePair&lt;long, T&gt;&gt;, IDisposable\n        {\n            IEnumerator&lt;T&gt; m_reader;\n            bool m_disposed = false;\n            Shared&lt;long&gt; m_index = null;\n\n            // These two are used to implement Dispose() when static partitioning is being performed\n            int m_activeEnumerators;\n            bool m_downcountEnumerators;\n\n            // &quot;downcountEnumerators&quot; will be true for static partitioning, false for\n            // dynamic partitioning.  \n            public InternalEnumerable(IEnumerator&lt;T&gt; reader, bool downcountEnumerators)\n            {\n                m_reader = reader;\n                m_index = new Shared&lt;long&gt;(0);\n                m_activeEnumerators = 0;\n                m_downcountEnumerators = downcountEnumerators;\n            }\n\n            public IEnumerator&lt;KeyValuePair&lt;long, T&gt;&gt; GetEnumerator()\n            {\n                if (m_disposed)\n                    throw new ObjectDisposedException(&quot;InternalEnumerable: Can&#39;t call GetEnumerator() after disposing&quot;);\n\n                // For static partitioning, keep track of the number of active enumerators.\n                if (m_downcountEnumerators) Interlocked.Increment(ref m_activeEnumerators);\n\n                return new InternalEnumerator(m_reader, this, m_index);\n            }\n\n            IEnumerator IEnumerable.GetEnumerator()\n            {\n                return ((IEnumerable&lt;KeyValuePair&lt;long, T&gt;&gt;)this).GetEnumerator();\n            }\n\n            public void Dispose()\n            {\n                if (!m_disposed)\n                {\n                    // Only dispose the source enumerator if you are doing dynamic partitioning\n                    if (!m_downcountEnumerators)\n                    {\n                        m_reader.Dispose();\n                    }\n                    m_disposed = true;\n                }\n            }\n\n            // Called from Dispose() method of spawned InternalEnumerator.  During\n            // static partitioning, the source enumerator will be automatically\n            // disposed once all requested InternalEnumerators have been disposed.\n            public void DisposeEnumerator()\n            {\n                if (m_downcountEnumerators)\n                {\n                    if (Interlocked.Decrement(ref m_activeEnumerators) == 0)\n                    {\n                        m_reader.Dispose();\n                    }\n                }\n            }\n        }\n\n        // Internal class that serves as a shared enumerator for \n        // the underlying collection.\n        private class InternalEnumerator : IEnumerator&lt;KeyValuePair&lt;long, T&gt;&gt;\n        {\n            KeyValuePair&lt;long, T&gt; m_current;\n            IEnumerator&lt;T&gt; m_source;\n            InternalEnumerable m_controllingEnumerable;\n            Shared&lt;long&gt; m_index = null;\n            bool m_disposed = false;\n\n\n            public InternalEnumerator(IEnumerator&lt;T&gt; source, InternalEnumerable controllingEnumerable, Shared&lt;long&gt; index)\n            {\n                m_source = source;\n                m_current = default(KeyValuePair&lt;long, T&gt;);\n                m_controllingEnumerable = controllingEnumerable;\n                m_index = index;\n            }\n\n            object IEnumerator.Current\n            {\n                get { return m_current; }\n            }\n\n            KeyValuePair&lt;long, T&gt; IEnumerator&lt;KeyValuePair&lt;long, T&gt;&gt;.Current\n            {\n                get { return m_current; }\n            }\n\n            void IEnumerator.Reset()\n            {\n                throw new NotSupportedException(&quot;Reset() not supported&quot;);\n            }\n\n            // This method is the crux of this class.  Under lock, it calls\n            // MoveNext() on the underlying enumerator, grabs Current and index, \n            // and increments the index.\n            bool IEnumerator.MoveNext()\n            {\n                bool rval = false;\n                lock (m_source)\n                {\n                    rval = m_source.MoveNext();\n                    if (rval)\n                    {\n                        m_current = new KeyValuePair&lt;long, T&gt;(m_index.Value, m_source.Current);\n                        m_index.Value = m_index.Value + 1;\n                    }\n                    else m_current = default(KeyValuePair&lt;long, T&gt;);\n                }\n                return rval;\n            }\n\n            void IDisposable.Dispose()\n            {\n                if (!m_disposed)\n                {\n                    // Delegate to parent enumerable&#39;s DisposeEnumerator() method\n                    m_controllingEnumerable.DisposeEnumerator();\n                    m_disposed = true;\n                }\n            }\n\n        }\n\n        // Constructor just grabs the collection to wrap\n        public SingleElementOrderablePartitioner(IEnumerable&lt;T&gt; enumerable)\n            : base(true, true, true)\n        {\n            // Verify that the source IEnumerable is not null\n            if (enumerable == null)\n                throw new ArgumentNullException(&quot;enumerable&quot;);\n\n            m_referenceEnumerable = enumerable;\n        }\n\n        // Produces a list of &quot;numPartitions&quot; IEnumerators that can each be\n        // used to traverse the underlying collection in a thread-safe manner.\n        // This will return a static number of enumerators, as opposed to\n        // GetOrderableDynamicPartitions(), the result of which can be used to produce\n        // any number of enumerators.\n        public override IList&lt;IEnumerator&lt;KeyValuePair&lt;long, T&gt;&gt;&gt; GetOrderablePartitions(int numPartitions)\n        {\n            if (numPartitions &lt; 1)\n                throw new ArgumentOutOfRangeException(&quot;NumPartitions&quot;);\n\n            List&lt;IEnumerator&lt;KeyValuePair&lt;long, T&gt;&gt;&gt; list = new List&lt;IEnumerator&lt;KeyValuePair&lt;long, T&gt;&gt;&gt;(numPartitions);\n\n            // Since we are doing static partitioning, create an InternalEnumerable with reference\n            // counting of spawned InternalEnumerators turned on.  Once all of the spawned enumerators\n            // are disposed, dynamicPartitions will be disposed.\n            var dynamicPartitions = new InternalEnumerable(m_referenceEnumerable.GetEnumerator(), true);\n            for (int i = 0; i &lt; numPartitions; i++)\n                list.Add(dynamicPartitions.GetEnumerator());\n\n            return list;\n        }\n\n        // Returns an instance of our internal Enumerable class.  GetEnumerator()\n        // can then be called on that (multiple times) to produce shared enumerators.\n        public override IEnumerable&lt;KeyValuePair&lt;long, T&gt;&gt; GetOrderableDynamicPartitions()\n        {\n            // Since we are doing dynamic partitioning, create an InternalEnumerable with reference\n            // counting of spawned InternalEnumerators turned off.  This returned InternalEnumerable\n            // will need to be explicitly disposed.\n            return new InternalEnumerable(m_referenceEnumerable.GetEnumerator(), false);\n        }\n\n        // Must be set to true if GetDynamicPartitions() is supported.\n        public override bool SupportsDynamicPartitions\n        {\n            get { return true; }\n        }\n    }\n\n    class Program\n    {\n        static void Main()\n        {\n            //\n            // First a fairly simple visual test\n            //\n            var someCollection = new string[] { &quot;four&quot;, &quot;score&quot;, &quot;and&quot;, &quot;twenty&quot;, &quot;years&quot;, &quot;ago&quot; };\n            var someOrderablePartitioner = new SingleElementOrderablePartitioner&lt;string&gt;(someCollection);\n            Parallel.ForEach(someOrderablePartitioner, (item, state, index) =&gt;\n            {\n                Console.WriteLine(&quot;ForEach: item = {0}, index = {1}, thread id = {2}&quot;, item, index, Thread.CurrentThread.ManagedThreadId);\n            });\n\n            //\n            // Now a test of static partitioning, using 2 partitions and 2 tasks\n            //\n            var staticPartitioner = someOrderablePartitioner.GetOrderablePartitions(2);\n\n            // staticAction will consume the shared enumerable\n            int partitionerListIndex = 0;\n            Action staticAction = () =&gt;\n            {\n                int myIndex = Interlocked.Increment(ref partitionerListIndex) - 1;\n                var enumerator = staticPartitioner[myIndex];\n                while (enumerator.MoveNext())\n                    Console.WriteLine(&quot;Static partitioning: item = {0}, index = {1}, thread id = {2}&quot;,\n                        enumerator.Current.Value, enumerator.Current.Key, Thread.CurrentThread.ManagedThreadId);\n                enumerator.Dispose();\n            };\n\n            // Now launch two of them\n            Parallel.Invoke(staticAction, staticAction);\n\n            //\n            // Now a more rigorous test of dynamic partitioning (used by Parallel.ForEach)\n            //\n            Console.WriteLine(&quot;OrderablePartitioner test: testing for index mismatches&quot;);\n            List&lt;int&gt; src = Enumerable.Range(0, 100000).ToList();\n            SingleElementOrderablePartitioner&lt;int&gt; myOP = new SingleElementOrderablePartitioner&lt;int&gt;(src);\n\n            int counter = 0;\n            bool mismatch = false;\n            Parallel.ForEach(myOP, (item, state, index) =&gt;\n            {\n                if (item != index) mismatch = true;\n                Interlocked.Increment(ref counter);\n            });\n\n            if (mismatch) Console.WriteLine(&quot;OrderablePartitioner Test: index mismatch detected&quot;);\n\n            Console.WriteLine(&quot;OrderablePartitioner test: counter = {0}, should be 100000&quot;, counter);\n\n\n        }\n    }\n\n\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Collections.Concurrent.OrderablePartitioner#1\">Imports System.Collections.Concurrent\nImports System.Threading\nImports System.Threading.Tasks\n\nModule OrderablePartitionerDemo\n\n\n    &#39; Simple partitioner that will extract one (index,item) pair at a time, \n    &#39; in a thread-safe fashion, from the underlying collection.\n    Class SingleElementOrderablePartitioner(Of T)\n        Inherits OrderablePartitioner(Of T)\n        &#39; The collection being wrapped by this Partitioner\n        Private m_referenceEnumerable As IEnumerable(Of T)\n\n        &#39; Class used to wrap m_index for the purpose of sharing access to it\n        &#39; between an InternalEnumerable and multiple InternalEnumerators\n        Private Class [Shared](Of U)\n            Friend Value As U\n\n            Public Sub New(ByVal item As U)\n                Value = item\n            End Sub\n        End Class\n\n        &#39; Internal class that serves as a shared enumerable for the\n        &#39; underlying collection.\n        Private Class InternalEnumerable\n            Implements IEnumerable(Of KeyValuePair(Of Long, T))\n            Implements IDisposable\n\n            Private m_reader As IEnumerator(Of T)\n            Private m_disposed As Boolean = False\n            Private m_index As [Shared](Of Long) = Nothing\n\n            &#39; These two are used to implement Dispose() when static partitioning is being performed\n            Private m_activeEnumerators As Integer\n            Private m_downcountEnumerators As Boolean\n\n            &#39; &quot;downcountEnumerators&quot; will be true for static partitioning, false for\n            &#39; dynamic partitioning. \n            Public Sub New(ByVal reader As IEnumerator(Of T), ByVal downcountEnumerators As Boolean)\n                m_reader = reader\n                m_index = New [Shared](Of Long)(0)\n                m_activeEnumerators = 0\n                m_downcountEnumerators = downcountEnumerators\n            End Sub\n\n            Public Function GetEnumerator() As IEnumerator(Of KeyValuePair(Of Long, T)) _\n                Implements IEnumerable(Of System.Collections.Generic.KeyValuePair(Of Long, T)).GetEnumerator\n\n                If m_disposed Then\n                    Throw New ObjectDisposedException(&quot;InternalEnumerable: Can&#39;t call GetEnumerator() after disposing&quot;)\n                End If\n\n                &#39; For static partitioning, keep track of the number of active enumerators.\n                If m_downcountEnumerators Then\n                    Interlocked.Increment(m_activeEnumerators)\n                End If\n\n                Return New InternalEnumerator(m_reader, Me, m_index)\n            End Function\n\n            Private Function GetEnumerator2() As IEnumerator Implements IEnumerable.GetEnumerator\n                Return DirectCast(Me, IEnumerable(Of KeyValuePair(Of Long, T))).GetEnumerator()\n            End Function\n\n            Public Sub Dispose() Implements IDisposable.Dispose\n                If Not m_disposed Then\n                    &#39; Only dispose the source enumerator if you are doing dynamic partitioning\n                    If Not m_downcountEnumerators Then\n                        m_reader.Dispose()\n                    End If\n                    m_disposed = True\n                End If\n            End Sub\n\n            &#39; Called from Dispose() method of spawned InternalEnumerator. During\n            &#39; static partitioning, the source enumerator will be automatically\n            &#39; disposed once all requested InternalEnumerators have been disposed.\n            Public Sub DisposeEnumerator()\n                If m_downcountEnumerators Then\n                    If Interlocked.Decrement(m_activeEnumerators) = 0 Then\n                        m_reader.Dispose()\n                    End If\n                End If\n            End Sub\n        End Class\n\n        &#39; Internal class that serves as a shared enumerator for \n        &#39; the underlying collection.\n        Private Class InternalEnumerator\n            Implements IEnumerator(Of KeyValuePair(Of Long, T))\n            Private m_current As KeyValuePair(Of Long, T)\n            Private m_source As IEnumerator(Of T)\n            Private m_controllingEnumerable As InternalEnumerable\n            Private m_index As [Shared](Of Long) = Nothing\n            Private m_disposed As Boolean = False\n\n\n            Public Sub New(ByVal source As IEnumerator(Of T), ByVal controllingEnumerable As InternalEnumerable, ByVal index As [Shared](Of Long))\n                m_source = source\n                m_current = Nothing\n                m_controllingEnumerable = controllingEnumerable\n                m_index = index\n            End Sub\n\n            Private ReadOnly Property Current2() As Object Implements IEnumerator.Current\n                Get\n                    Return m_current\n                End Get\n            End Property\n\n            Private ReadOnly Property Current() As KeyValuePair(Of Long, T) Implements IEnumerator(Of KeyValuePair(Of Long, T)).Current\n                Get\n                    Return m_current\n                End Get\n            End Property\n\n            Private Sub Reset() Implements IEnumerator.Reset\n                Throw New NotSupportedException(&quot;Reset() not supported&quot;)\n            End Sub\n\n            &#39; This method is the crux of this class. Under lock, it calls\n            &#39; MoveNext() on the underlying enumerator, grabs Current and index, \n            &#39; and increments the index.\n            Private Function MoveNext() As Boolean Implements IEnumerator.MoveNext\n                Dim rval As Boolean = False\n                SyncLock m_source\n                    rval = m_source.MoveNext()\n                    If rval Then\n                        m_current = New KeyValuePair(Of Long, T)(m_index.Value, m_source.Current)\n                        m_index.Value = m_index.Value + 1\n                    Else\n                        m_current = Nothing\n                    End If\n                End SyncLock\n                Return rval\n            End Function\n\n            Private Sub Dispose() Implements IDisposable.Dispose\n                If Not m_disposed Then\n                    &#39; Delegate to parent enumerable&#39;s DisposeEnumerator() method\n                    m_controllingEnumerable.DisposeEnumerator()\n                    m_disposed = True\n                End If\n            End Sub\n\n        End Class\n\n        &#39; Constructor just grabs the collection to wrap\n        Public Sub New(ByVal enumerable As IEnumerable(Of T))\n            MyBase.New(True, True, True)\n\n            &#39; Verify that the source IEnumerable is not null\n            If enumerable Is Nothing Then\n                Throw New ArgumentNullException(&quot;enumerable&quot;)\n            End If\n\n            m_referenceEnumerable = enumerable\n        End Sub\n\n        &#39; Produces a list of &quot;numPartitions&quot; IEnumerators that can each be\n        &#39; used to traverse the underlying collection in a thread-safe manner.\n        &#39; This will return a static number of enumerators, as opposed to\n        &#39; GetOrderableDynamicPartitions(), the result of which can be used to produce\n        &#39; any number of enumerators.\n        Public Overloads Overrides Function GetOrderablePartitions(ByVal numPartitions As Integer) As IList(Of IEnumerator(Of KeyValuePair(Of Long, T)))\n            If numPartitions &lt; 1 Then\n                Throw New ArgumentOutOfRangeException(&quot;NumPartitions&quot;)\n            End If\n\n            Dim list As New List(Of IEnumerator(Of KeyValuePair(Of Long, T)))(numPartitions)\n\n            &#39; Since we are doing static partitioning, create an InternalEnumerable with reference\n            &#39; counting of spawned InternalEnumerators turned on. Once all of the spawned enumerators\n            &#39; are disposed, dynamicPartitions will be disposed.\n            Dim dynamicPartitions = New InternalEnumerable(m_referenceEnumerable.GetEnumerator(), True)\n            For i As Integer = 0 To numPartitions - 1\n                list.Add(dynamicPartitions.GetEnumerator())\n            Next\n\n            Return list\n        End Function\n\n        &#39; Returns an instance of our internal Enumerable class. GetEnumerator()\n        &#39; can then be called on that (multiple times) to produce shared enumerators.\n        Public Overloads Overrides Function GetOrderableDynamicPartitions() As IEnumerable(Of KeyValuePair(Of Long, T))\n            &#39; Since we are doing dynamic partitioning, create an InternalEnumerable with reference\n            &#39; counting of spawned InternalEnumerators turned off. This returned InternalEnumerable\n            &#39; will need to be explicitly disposed.\n            Return New InternalEnumerable(m_referenceEnumerable.GetEnumerator(), False)\n        End Function\n\n        &#39; Must be set to true if GetDynamicPartitions() is supported.\n        Public Overloads Overrides ReadOnly Property SupportsDynamicPartitions() As Boolean\n            Get\n                Return True\n            End Get\n        End Property\n    End Class\n\n    Class Program\n        Shared Sub Main()\n            &#39;\n            &#39; First a fairly simple visual test\n            &#39;\n            Dim someCollection = New String() {&quot;four&quot;, &quot;score&quot;, &quot;and&quot;, &quot;twenty&quot;, &quot;years&quot;, &quot;ago&quot;}\n            Dim someOrderablePartitioner = New SingleElementOrderablePartitioner(Of String)(someCollection)\n            Parallel.ForEach(someOrderablePartitioner,\n                             Sub(item, state, index)\n                                 Console.WriteLine(&quot;ForEach: item = {0}, index = {1}, thread id = {2}&quot;, item, index, Thread.CurrentThread.ManagedThreadId)\n                             End Sub)\n\n            &#39;\n            &#39; Now a test of static partitioning, using 2 partitions and 2 tasks\n            &#39;\n            Dim staticPartitioner = someOrderablePartitioner.GetOrderablePartitions(2)\n\n            &#39; staticAction will consume the shared enumerable\n            Dim partitionerListIndex As Integer = 0\n            Dim staticAction As Action =\n                Sub()\n                    Dim myIndex As Integer = Interlocked.Increment(partitionerListIndex) - 1\n                    Dim enumerator = staticPartitioner(myIndex)\n                    While enumerator.MoveNext()\n                        Console.WriteLine(&quot;Static partitioning: item = {0}, index = {1}, thread id = {2}&quot;, enumerator.Current.Value, enumerator.Current.Key, Thread.CurrentThread.ManagedThreadId)\n                    End While\n                    enumerator.Dispose()\n                End Sub\n\n            &#39; Now launch two of them\n            Parallel.Invoke(staticAction, staticAction)\n\n            &#39;\n            &#39; Now a more rigorous test of dynamic partitioning (used by Parallel.ForEach)\n            &#39;\n            Console.WriteLine(&quot;OrderablePartitioner test: testing for index mismatches&quot;)\n            Dim src As List(Of Integer) = Enumerable.Range(0, 100000).ToList()\n            Dim myOP As New SingleElementOrderablePartitioner(Of Integer)(src)\n\n            Dim counter As Integer = 0\n            Dim mismatch As Boolean = False\n            Parallel.ForEach(myOP,\n                             Sub(item, state, index)\n                                 If item &lt;&gt; index Then\n                                     mismatch = True\n                                 End If\n                                 Interlocked.Increment(counter)\n                             End Sub)\n\n            If mismatch Then\n                Console.WriteLine(&quot;OrderablePartitioner Test: index mismatch detected&quot;)\n            End If\n\n\n\n            Console.WriteLine(&quot;OrderablePartitioner test: counter = {0}, should be 100000&quot;, counter)\n        End Sub\n    End Class\nEnd Module\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>The implementation of the derived class is responsible for ordering the elements into key-value pairs in whatever manner is appropriate. For more information, see <a href=\"../topic/custom%20partitioners%20for%20plinq%20and%20tpl\" data-linktype=\"relative-path\">Custom Partitioners for PLINQ and TPL</a>.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Constructors\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_Concurrent_OrderablePartitioner_1__ctor_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_Concurrent_OrderablePartitioner_1__ctor_System_Boolean_System_Boolean_System_Boolean_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">OrderablePartitioner&lt;TSource&gt;(Boolean, Boolean, Boolean)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Called from constructors in derived classes to initialize the <span class=\"xref\">stem.Collections.Concurrent.OrderablePartitioner`1</span> class with the specified constraints on the index keys.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">protected OrderablePartitioner (bool keysOrderedInEachPartition, bool keysOrderedAcrossPartitions, bool keysNormalized);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>keysOrderedInEachPartition</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>Indicates whether the elements in each partition are yielded in the order of increasing keys.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>keysOrderedAcrossPartitions</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>Indicates whether elements in an earlier partition always come before elements in a later partition. If true, each element in partition 0 has a smaller order key than any element in partition 1, each element in partition 1 has a smaller order key than any element in partition 2, and so on.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>keysNormalized</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>Indicates whether keys are normalized. If true, all order keys are distinct integers in the range [0 .. numberOfElements-1]. If false, order keys must still be distinct, but only their relative order is considered, not their absolute values.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>For more information, see <a href=\"../topic/custom%20partitioners%20for%20plinq%20and%20tpl\" data-linktype=\"relative-path\">Custom Partitioners for PLINQ and TPL</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Properties\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_Concurrent_OrderablePartitioner_1_KeysNormalized_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_Concurrent_OrderablePartitioner_1_KeysNormalized\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">KeysNormalized</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets whether order keys are normalized.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public bool KeysNormalized { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>true if the keys are normalized; otherwise false.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>If KeysNormalized returns true, all order keys are distinct integers in the range [0 .. numberOfElements-1]. If the property returns false, order keys must still be distinct, but only their relative order is considered, not their absolute values.  </p>\n<p> For more information, see <a href=\"../topic/custom%20partitioners%20for%20plinq%20and%20tpl\" data-linktype=\"relative-path\">Custom Partitioners for PLINQ and TPL</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_Concurrent_OrderablePartitioner_1_KeysOrderedAcrossPartitions_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_Concurrent_OrderablePartitioner_1_KeysOrderedAcrossPartitions\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">KeysOrderedAcrossPartitions</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets whether elements in an earlier partition always come before elements in a later partition.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public bool KeysOrderedAcrossPartitions { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>true if the elements in an earlier partition always come before elements in a later partition; otherwise false.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>If KeysOrderedAcrossPartitions returns true, each element in partition 0 has a smaller order key than any element in partition 1, each element in partition 1 has a smaller order key than any element in partition 2, and so on.  </p>\n<p> For more information, see <a href=\"../topic/custom%20partitioners%20for%20plinq%20and%20tpl\" data-linktype=\"relative-path\">Custom Partitioners for PLINQ and TPL</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_Concurrent_OrderablePartitioner_1_KeysOrderedInEachPartition_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_Concurrent_OrderablePartitioner_1_KeysOrderedInEachPartition\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">KeysOrderedInEachPartition</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets whether elements in each partition are yielded in the order of increasing keys.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public bool KeysOrderedInEachPartition { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>true if the elements in each partition are yielded in the order of increasing keys; otherwise false.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>For more information, see <a href=\"../topic/custom%20partitioners%20for%20plinq%20and%20tpl\" data-linktype=\"relative-path\">Custom Partitioners for PLINQ and TPL</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Methods\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_Concurrent_OrderablePartitioner_1_GetDynamicPartitions_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_Concurrent_OrderablePartitioner_1_GetDynamicPartitions\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">GetDynamicPartitions()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Creates an object that can partition the underlying collection into a variable number of partitions.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public override System.Collections.Generic.IEnumerable&lt;TSource&gt; GetDynamicPartitions ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable</a>&lt;<span class=\"xref\">TSource</span>&gt;</span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>An object that can create partitions over the underlying data source.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>Dynamic partitioning is not supported by the base class. It must be implemented in derived classes.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The returned object implements the <a class=\"xref\" href=\"system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">System.Collections.Generic.IEnumerable&lt;T&gt;</a> interface. Calling <a class=\"xref\" href=\"system.collections.generic.ienumerable-1#System_Collections_Generic_IEnumerable_1_GetEnumerator_\" data-linktype=\"relative-path\">GetEnumerator</a> on the object creates another partition over the sequence.  </p>\n<p> The default implementation provides the same behavior as <a class=\"xref\" href=\"system.collections.concurrent.orderablepartitioner-1#System_Collections_Concurrent_OrderablePartitioner_1_GetOrderableDynamicPartitions_\" data-linktype=\"relative-path\">GetOrderableDynamicPartitions</a> except that the returned set of partitions does not provide the keys for the elements.  </p>\n<p> The GetDynamicPartitions method is only supported if the <a class=\"xref\" href=\"system.collections.concurrent.partitioner-1#System_Collections_Concurrent_Partitioner_1_SupportsDynamicPartitions_\" data-linktype=\"relative-path\">SupportsDynamicPartitions</a> property returns true.  </p>\n<p> For more information, see <a href=\"../topic/custom%20partitioners%20for%20plinq%20and%20tpl\" data-linktype=\"relative-path\">Custom Partitioners for PLINQ and TPL</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_Concurrent_OrderablePartitioner_1_GetOrderableDynamicPartitions_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_Concurrent_OrderablePartitioner_1_GetOrderableDynamicPartitions\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">GetOrderableDynamicPartitions()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Creates an object that can partition the underlying collection into a variable number of partitions.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public virtual System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;long,TSource&gt;&gt; GetOrderableDynamicPartitions ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable</a>&lt;<a class=\"xref\" href=\"system.collections.generic.keyvaluepair-2\" data-linktype=\"relative-path\">KeyValuePair</a>&lt;<a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a>,<span class=\"xref\">TSource</span>&gt;&gt;</span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>An object that can create partitions over the underlying data source.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>Dynamic partitioning is not supported by this partitioner.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The returned object implements the <a class=\"xref\" href=\"system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">System.Collections.Generic.IEnumerable&lt;T&gt;</a> interface. Calling <a class=\"xref\" href=\"system.collections.generic.ienumerable-1#System_Collections_Generic_IEnumerable_1_GetEnumerator_\" data-linktype=\"relative-path\">GetEnumerator</a> on the object creates another partition over the sequence.  </p>\n<p> Each partition is represented as an enumerator over key-value pairs. The value in the pair is the element itself, and the key is an integer which determines the relative ordering of this element against other elements.  </p>\n<p> The GetOrderableDynamicPartitions method is only supported if the <a class=\"xref\" href=\"system.collections.concurrent.partitioner-1#System_Collections_Concurrent_Partitioner_1_SupportsDynamicPartitions_\" data-linktype=\"relative-path\">SupportsDynamicPartitions</a> property returns true.  </p>\n<p> For more information, see <a href=\"../topic/custom%20partitioners%20for%20plinq%20and%20tpl\" data-linktype=\"relative-path\">Custom Partitioners for PLINQ and TPL</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_Concurrent_OrderablePartitioner_1_GetOrderablePartitions_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_Concurrent_OrderablePartitioner_1_GetOrderablePartitions_System_Int32_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">GetOrderablePartitions(Int32)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Partitions the underlying collection into the specified number of orderable partitions.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public abstract System.Collections.Generic.IList&lt;System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;long,TSource&gt;&gt;&gt; GetOrderablePartitions (int partitionCount);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>partitionCount</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The number of partitions to create.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.generic.ilist-1\" data-linktype=\"relative-path\">IList</a>&lt;<a class=\"xref\" href=\"system.collections.generic.ienumerator-1\" data-linktype=\"relative-path\">IEnumerator</a>&lt;<a class=\"xref\" href=\"system.collections.generic.keyvaluepair-2\" data-linktype=\"relative-path\">KeyValuePair</a>&lt;<a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a>,<span class=\"xref\">TSource</span>&gt;&gt;&gt;</span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>A list containing <code>partitionCount</code> enumerators.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Each partition is represented as an enumerator over key-value pairs.  </p>\n<p> The value of the pair is the element itself, and the key is an integer which determines the relative ordering of this element against other elements in the data source.  </p>\n<p> For more information, see <a href=\"../topic/custom%20partitioners%20for%20plinq%20and%20tpl\" data-linktype=\"relative-path\">Custom Partitioners for PLINQ and TPL</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_Concurrent_OrderablePartitioner_1_GetPartitions_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_Concurrent_OrderablePartitioner_1_GetPartitions_System_Int32_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">GetPartitions(Int32)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Partitions the underlying collection into the given number of ordered partitions.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public override System.Collections.Generic.IList&lt;System.Collections.Generic.IEnumerator&lt;TSource&gt;&gt; GetPartitions (int partitionCount);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>partitionCount</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The number of partitions to create.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.generic.ilist-1\" data-linktype=\"relative-path\">IList</a>&lt;<a class=\"xref\" href=\"system.collections.generic.ienumerator-1\" data-linktype=\"relative-path\">IEnumerator</a>&lt;<span class=\"xref\">TSource</span>&gt;&gt;</span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>A list containing <code>partitionCount</code> enumerators.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The default implementation provides the same behavior as <a class=\"xref\" href=\"system.collections.concurrent.orderablepartitioner-1#System_Collections_Concurrent_OrderablePartitioner_1_GetOrderablePartitions_\" data-linktype=\"relative-path\">GetOrderablePartitions</a> except that the returned set of partitions does not provide the keys for the elements.  </p>\n<p> For more information, see <a href=\"../topic/custom%20partitioners%20for%20plinq%20and%20tpl\" data-linktype=\"relative-path\">Custom Partitioners for PLINQ and TPL</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \t<h2 class=\"accented\">Thread Safety</h2>\r\n  \tAll public members of OrderablePartitioner(TSource) are thread-safe and may be called from multiple threads concurrently.\r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Collections.Concurrent.OrderablePartitioner-1.yml\">\r\n<meta name=\"APIName\" content=\"System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;\">\r\n<meta name=\"APIName\" content=\"System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;..ctor\">\r\n<meta name=\"APIName\" content=\"System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;.GetDynamicPartitions\">\r\n<meta name=\"APIName\" content=\"System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;.GetOrderableDynamicPartitions\">\r\n<meta name=\"APIName\" content=\"System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;.GetOrderablePartitions\">\r\n<meta name=\"APIName\" content=\"System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;.GetPartitions\">\r\n<meta name=\"APIName\" content=\"System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;.KeysNormalized\">\r\n<meta name=\"APIName\" content=\"System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;.KeysOrderedAcrossPartitions\">\r\n<meta name=\"APIName\" content=\"System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;.KeysOrderedInEachPartition\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-04-01 05:59 PM\">\r\n<meta name=\"document_id\" content=\"6c0dc26f-51f6-bc19-ed3d-487f9bb8e3bd\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Represents a particular manner of splitting an orderable data source into multiple partitions.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.collections.concurrent/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Collections.Concurrent.OrderablePartitioner`1\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","uhfHeaderId":"MSDocsHeader-DotNet","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Collections.Concurrent.OrderablePartitioner-1.yml","open_to_public_contributors":false,"api_name":["System.Collections.Concurrent.OrderablePartitioner<TSource>","System.Collections.Concurrent.OrderablePartitioner<TSource>..ctor","System.Collections.Concurrent.OrderablePartitioner<TSource>.GetDynamicPartitions","System.Collections.Concurrent.OrderablePartitioner<TSource>.GetOrderableDynamicPartitions","System.Collections.Concurrent.OrderablePartitioner<TSource>.GetOrderablePartitions","System.Collections.Concurrent.OrderablePartitioner<TSource>.GetPartitions","System.Collections.Concurrent.OrderablePartitioner<TSource>.KeysNormalized","System.Collections.Concurrent.OrderablePartitioner<TSource>.KeysOrderedAcrossPartitions","System.Collections.Concurrent.OrderablePartitioner<TSource>.KeysOrderedInEachPartition"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Collections.Concurrent.OrderablePartitioner`1","System::Collections::Concurrent::OrderablePartitioner`1","System.Collections.Concurrent.OrderablePartitioner`1.#ctor","System::Collections::Concurrent::OrderablePartitioner`1::#ctor","System.Collections.Concurrent.OrderablePartitioner`1.GetDynamicPartitions","System::Collections::Concurrent::OrderablePartitioner`1::GetDynamicPartitions","System.Collections.Concurrent.OrderablePartitioner`1.GetOrderableDynamicPartitions","System::Collections::Concurrent::OrderablePartitioner`1::GetOrderableDynamicPartitions","System.Collections.Concurrent.OrderablePartitioner`1.GetOrderablePartitions","System::Collections::Concurrent::OrderablePartitioner`1::GetOrderablePartitions","System.Collections.Concurrent.OrderablePartitioner`1.GetPartitions","System::Collections::Concurrent::OrderablePartitioner`1::GetPartitions","System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized","System::Collections::Concurrent::OrderablePartitioner`1::KeysNormalized","System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedAcrossPartitions","System::Collections::Concurrent::OrderablePartitioner`1::KeysOrderedAcrossPartitions","System.Collections.Concurrent.OrderablePartitioner`1.KeysOrderedInEachPartition","System::Collections::Concurrent::OrderablePartitioner`1::KeysOrderedInEachPartition"],"dev_langs":["csharp"],"updated_at":"2017-04-01 05:59 PM","document_id":"6c0dc26f-51f6-bc19-ed3d-487f9bb8e3bd","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Collections.Concurrent/OrderablePartitioner`1.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"OrderablePartitioner<TSource> class | Microsoft Docs","_op_ogTitle":"OrderablePartitioner<TSource> class","description":"Represents a particular manner of splitting an orderable data source into multiple partitions.\n","toc_asset_id":"api/_splitted/System.Collections.Concurrent/toc.json","toc_rel":"_splitted/System.Collections.Concurrent/toc.json","source_url":"","ms.assetid":"System.Collections.Concurrent.OrderablePartitioner`1","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent.orderablepartitioner-1","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent.orderablepartitioner-1","fileRelativePath":"api/System.Collections.Concurrent.OrderablePartitioner-1.html"},"themesRelativePathToOutputRoot":"_themes/"}