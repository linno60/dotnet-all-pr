{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">ReaderWriterLock</span>\r\n    \t\t\t\tClass\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Defines a lock that supports single writers and multiple readers.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(true)]\npublic sealed class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtime.constrainedexecution.criticalfinalizerobject\" data-linktype=\"relative-path\">CriticalFinalizerObject</a></span></div><span class=\"lang-csharp\">ReaderWriterLock</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Attributes</dt><dd>\r\n  \t\t<div class=\"cdlHolder\">\r\n  \t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \t<h3 class=\"accented\">Inherited Members</h3>\r\n  \t<h4 class=\"accented\"></h4>\r\n  \t<div class=\"cdlHolder\">\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a></span></div>\r\n  \t</div>\r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following example demonstrates how to use a ReaderWriterLock to protect a shared resource, an integer value named <code>resource</code>, that is read concurrently and written exclusively by multiple threads. Note that the ReaderWriterLock is declared at the class level so that it is visible to all threads.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Threading.ReaderWriterLock#1\">// This example shows a ReaderWriterLock protecting a shared\n// resource that is read concurrently and written exclusively\n// by multiple threads.\n// The complete code is located in the ReaderWriterLock\n// class topic.\nusing namespace System;\nusing namespace System::Threading;\npublic ref class Test\n{\npublic:\n\n   // Declaring the ReaderWriterLock at the class level\n   // makes it visible to all threads.\n   static ReaderWriterLock^ rwl = gcnew ReaderWriterLock;\n\n   // For this example, the shared resource protected by the\n   // ReaderWriterLock is just an integer.\n   static int resource = 0;\n\n   literal int numThreads = 26;\n   static bool running = true;\n   static Random^ rnd = gcnew Random;\n\n   // Statistics.\n   static int readerTimeouts = 0;\n   static int writerTimeouts = 0;\n   static int reads = 0;\n   static int writes = 0;\n   static void ThreadProc()\n   {\n      \n      // As long as a thread runs, it randomly selects\n      // various ways to read and write from the shared \n      // resource. Each of the methods demonstrates one \n      // or more features of ReaderWriterLock.\n      while ( running )\n      {\n         double action = rnd-&gt;NextDouble();\n         if ( action &lt; .8 )\n                  ReadFromResource( 10 );\n         else\n         if ( action &lt; .81 )\n                  ReleaseRestore( 50 );\n         else\n         if ( action &lt; .90 )\n                  UpgradeDowngrade( 100 );\n         else\n                  WriteToResource( 100 );\n      }\n   }\n\n\n   // Shows how to request and release a reader lock, and\n   // how to handle time-outs.\n   static void ReadFromResource( int timeOut )\n   {\n      try\n      {\n         rwl-&gt;AcquireReaderLock( timeOut );\n         try\n         {\n            \n            // It is safe for this thread to read from\n            // the shared resource.\n            Display( String::Format( &quot;reads resource value {0}&quot;, resource ) );\n            Interlocked::Increment( reads );\n         }\n         finally\n         {\n            \n            // Ensure that the lock is released.\n            rwl-&gt;ReleaseReaderLock();\n         }\n\n      }\n      catch ( ApplicationException^ ) \n      {\n         \n         // The reader lock request timed out.\n         Interlocked::Increment( readerTimeouts );\n      }\n\n   }\n\n\n   // Shows how to request and release the writer lock, and\n   // how to handle time-outs.\n   static void WriteToResource( int timeOut )\n   {\n      try\n      {\n         rwl-&gt;AcquireWriterLock( timeOut );\n         try\n         {\n            \n            // It is safe for this thread to read or write\n            // from the shared resource.\n            resource = rnd-&gt;Next( 500 );\n            Display( String::Format( &quot;writes resource value {0}&quot;, resource ) );\n            Interlocked::Increment( writes );\n         }\n         finally\n         {\n            \n            // Ensure that the lock is released.\n            rwl-&gt;ReleaseWriterLock();\n         }\n\n      }\n      catch ( ApplicationException^ ) \n      {\n         \n         // The writer lock request timed out.\n         Interlocked::Increment( writerTimeouts );\n      }\n\n   }\n\n\n   // Shows how to request a reader lock, upgrade the\n   // reader lock to the writer lock, and downgrade to a\n   // reader lock again.\n   static void UpgradeDowngrade( int timeOut )\n   {\n      try\n      {\n         rwl-&gt;AcquireReaderLock( timeOut );\n         try\n         {\n            \n            // It is safe for this thread to read from\n            // the shared resource.\n            Display( String::Format( &quot;reads resource value {0}&quot;, resource ) );\n            Interlocked::Increment( reads );\n            \n            // If it is necessary to write to the resource,\n            // you must either release the reader lock and \n            // then request the writer lock, or upgrade the\n            // reader lock. Note that upgrading the reader lock\n            // puts the thread in the write queue, behind any\n            // other threads that might be waiting for the \n            // writer lock.\n            try\n            {\n               LockCookie lc = rwl-&gt;UpgradeToWriterLock( timeOut );\n               try\n               {\n                  \n                  // It is safe for this thread to read or write\n                  // from the shared resource.\n                  resource = rnd-&gt;Next( 500 );\n                  Display( String::Format( &quot;writes resource value {0}&quot;, resource ) );\n                  Interlocked::Increment( writes );\n               }\n               finally\n               {\n                  \n                  // Ensure that the lock is released.\n                  rwl-&gt;DowngradeFromWriterLock( lc );\n               }\n\n            }\n            catch ( ApplicationException^ ) \n            {\n               \n               // The upgrade request timed out.\n               Interlocked::Increment( writerTimeouts );\n            }\n\n            \n            // When the lock has been downgraded, it is \n            // still safe to read from the resource.\n            Display( String::Format( &quot;reads resource value {0}&quot;, resource ) );\n            Interlocked::Increment( reads );\n         }\n         finally\n         {\n            \n            // Ensure that the lock is released.\n            rwl-&gt;ReleaseReaderLock();\n         }\n\n      }\n      catch ( ApplicationException^ ) \n      {\n         \n         // The reader lock request timed out.\n         Interlocked::Increment( readerTimeouts );\n      }\n\n   }\n\n\n   // Shows how to release all locks and later restore\n   // the lock state. Shows how to use sequence numbers\n   // to determine whether another thread has obtained\n   // a writer lock since this thread last accessed the\n   // resource.\n   static void ReleaseRestore( int timeOut )\n   {\n      int lastWriter;\n      try\n      {\n         rwl-&gt;AcquireReaderLock( timeOut );\n         try\n         {\n            \n            // It is safe for this thread to read from\n            // the shared resource. Cache the value. (You\n            // might do this if reading the resource is\n            // an expensive operation.)\n            int resourceValue = resource;\n            Display( String::Format( &quot;reads resource value {0}&quot;, resourceValue ) );\n            Interlocked::Increment( reads );\n            \n            // Save the current writer sequence number.\n            lastWriter = rwl-&gt;WriterSeqNum;\n            \n            // Release the lock, and save a cookie so the\n            // lock can be restored later.\n            LockCookie lc = rwl-&gt;ReleaseLock();\n            \n            // Wait for a random interval (up to a \n            // quarter of a second), and then restore\n            // the previous state of the lock. Note that\n            // there is no timeout on the Restore method.\n            Thread::Sleep( rnd-&gt;Next( 250 ) );\n            rwl-&gt;RestoreLock( lc );\n            \n            // Check whether other threads obtained the\n            // writer lock in the interval. If not, then\n            // the cached value of the resource is still\n            // valid.\n            if ( rwl-&gt;AnyWritersSince( lastWriter ) )\n            {\n               resourceValue = resource;\n               Interlocked::Increment( reads );\n               Display( String::Format( &quot;resource has changed {0}&quot;, resourceValue ) );\n            }\n            else\n            {\n               Display( String::Format( &quot;resource has not changed {0}&quot;, resourceValue ) );\n            }\n         }\n         finally\n         {\n            \n            // Ensure that the lock is released.\n            rwl-&gt;ReleaseReaderLock();\n         }\n\n      }\n      catch ( ApplicationException^ ) \n      {\n         \n         // The reader lock request timed out.\n         Interlocked::Increment( readerTimeouts );\n      }\n\n   }\n\n\n   // Helper method briefly displays the most recent\n   // thread action. Comment out calls to Display to \n   // get a better idea of throughput.\n   static void Display( String^ msg )\n   {\n      Console::Write( &quot;Thread {0} {1}.       \\r&quot;, Thread::CurrentThread-&gt;Name, msg );\n   }\n\n};\n\n\nint main()\n{\n   array&lt;String^&gt;^args = Environment::GetCommandLineArgs();\n   \n   // Start a series of threads. Each thread randomly\n   // performs reads and writes on the shared resource.\n   array&lt;Thread^&gt;^t = gcnew array&lt;Thread^&gt;(Test::numThreads);\n   for ( int i = 0; i &lt; Test::numThreads; i++ )\n   {\n      t[ i ] = gcnew Thread( gcnew ThreadStart( Test::ThreadProc ) );\n      t[ i ]-&gt;Name = gcnew String( Convert::ToChar( i + 65 ),1 );\n      t[ i ]-&gt;Start();\n      if ( i &gt; 10 )\n            Thread::Sleep( 300 );\n\n   }\n   \n   // Tell the threads to shut down, then wait until they all\n   // finish.\n   Test::running = false;\n   for ( int i = 0; i &lt; Test::numThreads; i++ )\n   {\n      t[ i ]-&gt;Join();\n\n   }\n   \n   // Display statistics.\n   Console::WriteLine( &quot;\\r\\n {0} reads, {1} writes, {2} reader time-outs, {3} writer time-outs.&quot;, Test::reads, Test::writes, Test::readerTimeouts, Test::writerTimeouts );\n   Console::WriteLine( &quot;Press ENTER to exit.&quot; );\n   Console::ReadLine();\n   return 0;\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.ReaderWriterLock#1\">// The complete code is located in the ReaderWriterLock class topic.\nusing System;\nusing System.Threading;\n\npublic class Example\n{\n   static ReaderWriterLock rwl = new ReaderWriterLock();\n   // Define the shared resource protected by the ReaderWriterLock.\n   static int resource = 0;\n\n   const int numThreads = 26;\n   static bool running = true;\n   static Random rnd = new Random();\n\n   // Statistics.\n   static int readerTimeouts = 0;\n   static int writerTimeouts = 0;\n   static int reads = 0;\n   static int writes = 0;\n\n   public static void Main()\n   {\n      // Start a series of threads to randomly read from and\n      // write to the shared resource.\n      Thread[] t = new Thread[numThreads];\n      for (int i = 0; i &lt; numThreads; i++){\n         t[i] = new Thread(new ThreadStart(ThreadProc));\n         t[i].Name = new String(Convert.ToChar(i + 65), 1);\n         t[i].Start();\n         if (i &gt; 10)\n            Thread.Sleep(300);\n      }\n\n      // Tell the threads to shut down and wait until they all finish.\n      running = false;\n      for (int i = 0; i &lt; numThreads; i++)\n         t[i].Join();\n\n      // Display statistics.\n      Console.WriteLine(&quot;\\n{0} reads, {1} writes, {2} reader time-outs, {3} writer time-outs.&quot;,\n            reads, writes, readerTimeouts, writerTimeouts);\n      Console.Write(&quot;Press ENTER to exit... &quot;);\n      Console.ReadLine();\n   }\n\n   static void ThreadProc()\n   {\n      // Randomly select a way for the thread to read and write from the shared\n      // resource.\n      while (running) {\n         double action = rnd.NextDouble();\n         if (action &lt; .8)\n            ReadFromResource(10);\n         else if (action &lt; .81)\n            ReleaseRestore(50);\n         else if (action &lt; .90)\n            UpgradeDowngrade(100);\n         else\n            WriteToResource(100);\n      }\n   }\n\n   // Request and release a reader lock, and handle time-outs.\n   static void ReadFromResource(int timeOut)\n   {\n      try {\n         rwl.AcquireReaderLock(timeOut);\n         try {\n            // It is safe for this thread to read from the shared resource.\n            Display(&quot;reads resource value &quot; + resource);\n            Interlocked.Increment(ref reads);\n         }\n         finally {\n            // Ensure that the lock is released.\n            rwl.ReleaseReaderLock();\n         }\n      }\n      catch (ApplicationException) {\n         // The reader lock request timed out.\n         Interlocked.Increment(ref readerTimeouts);\n      }\n   }\n\n   // Request and release the writer lock, and handle time-outs.\n   static void WriteToResource(int timeOut)\n   {\n      try {\n         rwl.AcquireWriterLock(timeOut);\n         try {\n            // It&#39;s safe for this thread to access from the shared resource.\n            resource = rnd.Next(500);\n            Display(&quot;writes resource value &quot; + resource);\n            Interlocked.Increment(ref writes);\n         }\n         finally {\n            // Ensure that the lock is released.\n            rwl.ReleaseWriterLock();\n         }\n      }\n      catch (ApplicationException) {\n         // The writer lock request timed out.\n         Interlocked.Increment(ref writerTimeouts);\n      }\n   }\n\n   // Requests a reader lock, upgrades the reader lock to the writer\n   // lock, and downgrades it to a reader lock again.\n   static void UpgradeDowngrade(int timeOut)\n   {\n      try {\n         rwl.AcquireReaderLock(timeOut);\n         try {\n            // It&#39;s safe for this thread to read from the shared resource.\n            Display(&quot;reads resource value &quot; + resource);\n            Interlocked.Increment(ref reads);\n\n            // To write to the resource, either release the reader lock and\n            // request the writer lock, or upgrade the reader lock. Upgrading\n            // the reader lock puts the thread in the write queue, behind any\n            // other threads that might be waiting for the writer lock.\n            try {\n               LockCookie lc = rwl.UpgradeToWriterLock(timeOut);\n               try {\n                  // It&#39;s safe for this thread to read or write from the shared resource.\n                  resource = rnd.Next(500);\n                  Display(&quot;writes resource value &quot; + resource);\n                  Interlocked.Increment(ref writes);\n               }\n               finally {\n                  // Ensure that the lock is released.\n                  rwl.DowngradeFromWriterLock(ref lc);\n               }\n            }\n            catch (ApplicationException) {\n               // The upgrade request timed out.\n               Interlocked.Increment(ref writerTimeouts);\n            }\n\n            // If the lock was downgraded, it&#39;s still safe to read from the resource.\n            Display(&quot;reads resource value &quot; + resource);\n            Interlocked.Increment(ref reads);\n         }\n         finally {\n            // Ensure that the lock is released.\n            rwl.ReleaseReaderLock();\n         }\n      }\n      catch (ApplicationException) {\n         // The reader lock request timed out.\n         Interlocked.Increment(ref readerTimeouts);\n      }\n   }\n\n   // Release all locks and later restores the lock state.\n   // Uses sequence numbers to determine whether another thread has\n   // obtained a writer lock since this thread last accessed the resource.\n   static void ReleaseRestore(int timeOut)\n   {\n      int lastWriter;\n\n      try {\n         rwl.AcquireReaderLock(timeOut);\n         try {\n            // It&#39;s safe for this thread to read from the shared resource,\n            // so read and cache the resource value.\n            int resourceValue = resource;     // Cache the resource value.\n            Display(&quot;reads resource value &quot; + resourceValue);\n            Interlocked.Increment(ref reads);\n\n            // Save the current writer sequence number.\n            lastWriter = rwl.WriterSeqNum;\n\n            // Release the lock and save a cookie so the lock can be restored later.\n            LockCookie lc = rwl.ReleaseLock();\n\n            // Wait for a random interval and then restore the previous state of the lock.\n            Thread.Sleep(rnd.Next(250));\n            rwl.RestoreLock(ref lc);\n\n            // Check whether other threads obtained the writer lock in the interval.\n            // If not, then the cached value of the resource is still valid.\n            if (rwl.AnyWritersSince(lastWriter)) {\n               resourceValue = resource;\n               Interlocked.Increment(ref reads);\n               Display(&quot;resource has changed &quot; + resourceValue);\n            }\n            else {\n               Display(&quot;resource has not changed &quot; + resourceValue);\n            }\n         }\n         finally {\n            // Ensure that the lock is released.\n            rwl.ReleaseReaderLock();\n         }\n      }\n      catch (ApplicationException) {\n         // The reader lock request timed out.\n         Interlocked.Increment(ref readerTimeouts);\n      }\n   }\n\n   // Helper method briefly displays the most recent thread action.\n   static void Display(string msg)\n   {\n      Console.Write(&quot;Thread {0} {1}.       \\r&quot;, Thread.CurrentThread.Name, msg);\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.ReaderWriterLock#1\">&#39; The complete code is located in the ReaderWriterLock class topic.\nImports System.Threading\n\nPublic Module Example\n   Private rwl As New ReaderWriterLock()\n   &#39; Define the shared resource protected by the ReaderWriterLock.\n   Private resource As Integer = 0\n\n   Const numThreads As Integer = 26\n   Private running As Boolean = True\n   Private rnd As New Random()\n   \n   &#39; Statistics.\n   Private readerTimeouts As Integer = 0\n   Private writerTimeouts As Integer = 0\n   Private reads As Integer = 0\n   Private writes As Integer = 0\n  \n   Public Sub Main()\n      &#39; Start a series of threads to randomly read from and\n      &#39; write to the shared resource.\n      Dim t(numThreads - 1) As Thread\n      Dim i As Integer\n      For i = 0 To numThreads - 1\n         t(i) = New Thread(New ThreadStart(AddressOf ThreadProc))\n         t(i).Name = Chr(i + 65)\n         t(i).Start()\n         If i &gt; 10 Then\n            Thread.Sleep(300)\n         End If\n      Next\n\n      &#39; Tell the threads to shut down and wait until they all finish.\n      running = False\n      For i = 0 To numThreads - 1\n         t(i).Join()\n      Next\n      \n      &#39; Display statistics.\n      Console.WriteLine(vbCrLf &amp; &quot;{0} reads, {1} writes, {2} reader time-outs, {3} writer time-outs.&quot;,\n                        reads, writes, readerTimeouts, writerTimeouts)\n      Console.Write(&quot;Press ENTER to exit... &quot;)\n      Console.ReadLine()\n   End Sub\n\n   Sub ThreadProc()\n      &#39; Randomly select a way for the thread to read and write from the shared\n      &#39; resource.\n      While running\n         Dim action As Double = rnd.NextDouble()\n         If action &lt; 0.8 Then\n            ReadFromResource(10)\n         ElseIf action &lt; 0.81 Then\n            ReleaseRestore(50)\n         ElseIf action &lt; 0.9 Then\n            UpgradeDowngrade(100)\n         Else\n            WriteToResource(100)\n         End If\n      End While\n   End Sub\n    \n   &#39; Request and release a reader lock, and handle time-outs.\n   Sub ReadFromResource(timeOut As Integer)\n      Try\n         rwl.AcquireReaderLock(timeOut)\n         Try\n            &#39; It&#39;s safe for this thread to read from the shared resource.\n            Display(&quot;reads resource value &quot; &amp; resource)\n            Interlocked.Increment(reads)\n         Finally\n            &#39; Ensure that the lock is released.\n            rwl.ReleaseReaderLock()\n         End Try\n      Catch ex As ApplicationException\n         &#39; The reader lock request timed out.\n         Interlocked.Increment(readerTimeouts)\n      End Try\n   End Sub\n\n   &#39; Request and release the writer lock, and handle time-outs.\n   Sub WriteToResource(timeOut As Integer)\n      Try\n         rwl.AcquireWriterLock(timeOut)\n         Try\n            &#39; It&#39;s safe for this thread to read or write from the shared resource.\n            resource = rnd.Next(500)\n            Display(&quot;writes resource value &quot; &amp; resource)\n            Interlocked.Increment(writes)\n         Finally\n            &#39; Ensure that the lock is released.\n            rwl.ReleaseWriterLock()\n         End Try\n      Catch ex As ApplicationException\n         &#39; The writer lock request timed out.\n         Interlocked.Increment(writerTimeouts)\n      End Try\n   End Sub\n\n   &#39; Requests a reader lock, upgrades the reader lock to the writer\n   &#39; lock, and downgrades it to a reader lock again.\n   Sub UpgradeDowngrade(timeOut As Integer)\n      Try\n         rwl.AcquireReaderLock(timeOut)\n         Try\n            &#39; It&#39;s safe for this thread to read from the shared resource.\n            Display(&quot;reads resource value &quot; &amp; resource)\n            Interlocked.Increment(reads)\n            \n            &#39; To write to the resource, either release the reader lock and\n            &#39; request the writer lock, or upgrade the reader lock. Upgrading\n            &#39; the reader lock puts the thread in the write queue, behind any\n            &#39; other threads that might be waiting for the writer lock.\n            Try\n               Dim lc As LockCookie = rwl.UpgradeToWriterLock(timeOut)\n               Try\n                  &#39; It&#39;s safe for this thread to read or write from the shared resource.\n                  resource = rnd.Next(500)\n                  Display(&quot;writes resource value &quot; &amp; resource)\n                  Interlocked.Increment(writes)\n               Finally\n                  &#39; Ensure that the lock is released.\n                  rwl.DowngradeFromWriterLock(lc)\n               End Try\n            Catch ex As ApplicationException\n               &#39; The upgrade request timed out.\n               Interlocked.Increment(writerTimeouts)\n            End Try\n            \n            &#39; If the lock was downgraded, it&#39;s still safe to read from the resource.\n            Display(&quot;reads resource value &quot; &amp; resource)\n            Interlocked.Increment(reads)\n         Finally\n            &#39; Ensure that the lock is released.\n            rwl.ReleaseReaderLock()\n         End Try\n      Catch ex As ApplicationException\n         &#39; The reader lock request timed out.\n         Interlocked.Increment(readerTimeouts)\n      End Try\n   End Sub\n\n   &#39; Release all locks and later restores the lock state.\n   &#39; Uses sequence numbers to determine whether another thread has\n   &#39; obtained a writer lock since this thread last accessed the resource.\n   Sub ReleaseRestore(timeOut As Integer)\n      Dim lastWriter As Integer\n      \n      Try\n         rwl.AcquireReaderLock(timeOut)\n         Try\n            &#39; It&#39;s safe for this thread to read from the shared resource,\n            &#39; so read and cache the resource value.\n            Dim resourceValue As Integer = resource\n            Display(&quot;reads resource value &quot; &amp; resourceValue)\n            Interlocked.Increment(reads)\n            \n            &#39; Save the current writer sequence number.\n            lastWriter = rwl.WriterSeqNum\n            \n            &#39; Release the lock and save a cookie so the lock can be restored later.\n            Dim lc As LockCookie = rwl.ReleaseLock()\n            \n            &#39; Wait for a random interval and then restore the previous state of the lock.\n            Thread.Sleep(rnd.Next(250))\n            rwl.RestoreLock(lc)\n           \n            &#39; Check whether other threads obtained the writer lock in the interval.\n            &#39; If not, then the cached value of the resource is still valid.\n            If rwl.AnyWritersSince(lastWriter) Then\n               resourceValue = resource\n               Interlocked.Increment(reads)\n               Display(&quot;resource has changed &quot; &amp; resourceValue)\n            Else\n               Display(&quot;resource has not changed &quot; &amp; resourceValue)\n            End If\n         Finally\n            &#39; Ensure that the lock is released.\n            rwl.ReleaseReaderLock()\n         End Try\n      Catch ex As ApplicationException\n         &#39; The reader lock request timed out.\n         Interlocked.Increment(readerTimeouts)\n      End Try\n   End Sub\n\n   &#39; Helper method briefly displays the most recent thread action.\n   Sub Display(msg As String)\n      Console.Write(&quot;Thread {0} {1}.       &quot; &amp; vbCr, Thread.CurrentThread.Name, msg)\n   End Sub\nEnd Module\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<div class=\"IMPORTANT\"><h5>Important</h5><p> The .NET Framework has two reader-writer locks, <a class=\"xref\" href=\"system.threading.readerwriterlockslim\" data-linktype=\"relative-path\">ReaderWriterLockSlim</a> and ReaderWriterLock. <a class=\"xref\" href=\"system.threading.readerwriterlockslim\" data-linktype=\"relative-path\">ReaderWriterLockSlim</a> is recommended for all new development. <a class=\"xref\" href=\"system.threading.readerwriterlockslim\" data-linktype=\"relative-path\">ReaderWriterLockSlim</a> is similar to ReaderWriterLock, but it has simplified rules for recursion and for upgrading and downgrading lock state. <a class=\"xref\" href=\"system.threading.readerwriterlockslim\" data-linktype=\"relative-path\">ReaderWriterLockSlim</a> avoids many cases of potential deadlock. In addition, the performance of <a class=\"xref\" href=\"system.threading.readerwriterlockslim\" data-linktype=\"relative-path\">ReaderWriterLockSlim</a> is significantly better than ReaderWriterLock.  </p>\n</div>\n<p> ReaderWriterLock is used to synchronize access to a resource. At any given time, it allows either concurrent read access for multiple threads, or write access for a single thread. In a situation where a resource is changed infrequently, a <code>ReaderWriterLock</code> provides better throughput than a simple one-at-a-time lock, such as <a class=\"xref\" href=\"system.threading.monitor\" data-linktype=\"relative-path\">Monitor</a>.  </p>\n<p> <code>ReaderWriterLock</code> works best where most accesses are reads, while writes are infrequent and of short duration. Multiple readers alternate with single writers, so that neither readers nor writers are blocked for long periods.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Holding reader locks or writer locks for long periods will starve other threads. For best performance, consider restructuring your application to minimize the duration of writes.  </p>\n</div>\n<p> A thread can hold a reader lock or a writer lock, but not both at the same time. Instead of releasing a reader lock in order to acquire the writer lock, you can use <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_UpgradeToWriterLock_\" data-linktype=\"relative-path\">UpgradeToWriterLock</a> and <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_DowngradeFromWriterLock_\" data-linktype=\"relative-path\">DowngradeFromWriterLock</a>.  </p>\n<p> Recursive lock requests increase the lock count on a lock.  </p>\n<p> Readers and writers are queued separately. When a thread releases the writer lock, all threads waiting in the reader queue at that instant are granted reader locks; when all of those reader locks have been released, the next thread waiting in the writer queue, if any, is granted the writer lock, and so on. In other words, <code>ReaderWriterLock</code> alternates between a collection of readers, and one writer.  </p>\n<p> While a thread in the writer queue is waiting for active reader locks to be released, threads requesting new reader locks accumulate in the reader queue. Their requests are not granted, even though they could share concurrent access with existing reader-lock holders; this helps protect writers against indefinite blockage by readers.  </p>\n<p> Most methods for acquiring locks on a <code>ReaderWriterLock</code> accept time-out values. Use time-outs to avoid deadlocks in your application. For example, a thread might acquire the writer lock on one resource and then request a reader lock on a second resource; in the meantime, another thread might acquire the writer lock on the second resource, and request a reader lock on the first. Unless time-outs are used, the threads deadlock.  </p>\n<p> If the time-out interval expires and the lock request has not been granted, the method returns control to the calling thread by throwing an <a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a>. A thread can catch this exception and determine what action to take next.  </p>\n<p> Time-outs are expressed in milliseconds. If you use a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">System.TimeSpan</a> to specify the time-out, the value used is the total number of whole milliseconds represented by the <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a>. The following table shows the valid time-out values in milliseconds.  </p>\n<table>\n<thead>\n<tr>\n<th>Value</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-1</td>\n<td>The thread waits until the lock is acquired, regardless of how long it takes. For methods that specify integer time-outs, the constant <a class=\"xref\" href=\"system.threading.timeout#System_Threading_Timeout_Infinite\" data-linktype=\"relative-path\">Infinite</a> can be used.</td>\n</tr>\n<tr>\n<td>0</td>\n<td>The thread does not wait to acquire the lock. If the lock cannot be acquired immediately, the method returns.</td>\n</tr>\n<tr>\n<td>&gt;0</td>\n<td>The number of milliseconds to wait.</td>\n</tr>\n</tbody>\n</table>\n<p> With the exception of -1, negative time-out values are not allowed. If you specify a negative integer other than -1, a time-out value of zero is used instead. (That is, the method returns without waiting, if the lock cannot be acquired immediately.) If you specify a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents a negative number of milliseconds other than -1, <a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a> is thrown.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Constructors\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_ReaderWriterLock__ctor_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_ReaderWriterLock__ctor\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">ReaderWriterLock()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.readerwriterlock\" data-linktype=\"relative-path\">ReaderWriterLock</a> class.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public ReaderWriterLock ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitysafecriticalattribute\" title=\"System.Security.SecuritySafeCriticalAttribute\" data-linktype=\"relative-path\">SecuritySafeCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Properties\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_ReaderWriterLock_IsReaderLockHeld_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_ReaderWriterLock_IsReaderLockHeld\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">IsReaderLockHeld</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets a value indicating whether the current thread holds a reader lock.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public bool IsReaderLockHeld { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if the current thread holds a reader lock; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><span class=\"xref\">get: System.Runtime.ConstrainedExecution.ReliabilityContract</span></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><span class=\"xref\">get: System.Security.SecuritySafeCritical</span></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_ReaderWriterLock_IsWriterLockHeld_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_ReaderWriterLock_IsWriterLockHeld\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">IsWriterLockHeld</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets a value indicating whether the current thread holds the writer lock.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public bool IsWriterLockHeld { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if the current thread holds the writer lock; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><span class=\"xref\">get: System.Runtime.ConstrainedExecution.ReliabilityContract</span></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><span class=\"xref\">get: System.Security.SecuritySafeCritical</span></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_ReaderWriterLock_WriterSeqNum_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_ReaderWriterLock_WriterSeqNum\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">WriterSeqNum</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets the current sequence number.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public int WriterSeqNum { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The current sequence number.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><span class=\"xref\">get: System.Security.SecuritySafeCritical</span></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The sequence number increases whenever a thread acquires the writer lock. You can save the sequence number and pass it to <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_AnyWritersSince_\" data-linktype=\"relative-path\">AnyWritersSince</a> at a later time, if you want to determine whether other threads have acquired the writer lock in the meantime.  </p>\n<p> You can use <code>WriterSeqNum</code> to improve application performance. For example, a thread might cache the information it obtains while holding a reader lock. After releasing and later reacquiring the lock, the thread can determine whether other threads have written to the resource by calling <code>AnyWritersSince</code>; if not, the cached information can be used. This technique is useful when reading the information protected by the lock is expensive; for example, running a database query.  </p>\n<p> The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Methods\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_ReaderWriterLock_AcquireReaderLock_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_ReaderWriterLock_AcquireReaderLock_System_Int32_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">AcquireReaderLock(Int32)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Acquires a reader lock, using an <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a> value for the time-out.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void AcquireReaderLock (int millisecondsTimeout);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>millisecondsTimeout</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The time-out in milliseconds.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitysafecriticalattribute\" title=\"System.Security.SecuritySafeCriticalAttribute\" data-linktype=\"relative-path\">SecuritySafeCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>millisecondsTimeout</code> expires before the lock request is granted.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>AcquireReaderLock blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> If the current thread already has the writer lock, no reader lock is acquired. Instead, the lock count on the writer lock is incremented. This prevents a thread from blocking on its own writer lock. The result is exactly the same as calling <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_AcquireWriterLock_\" data-linktype=\"relative-path\">AcquireWriterLock</a>, and an additional call to <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_ReleaseWriterLock_\" data-linktype=\"relative-path\">ReleaseWriterLock</a> is required when releasing the writer lock.  </p>\n</div>\n<p> <code>AcquireReaderLock</code> supports recursive reader-lock requests. That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time. You must call <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_ReleaseReaderLock_\" data-linktype=\"relative-path\">ReleaseReaderLock</a> once for each time you call <code>AcquireReaderLock</code>. Alternatively, you can call <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_ReleaseLock_\" data-linktype=\"relative-path\">ReleaseLock</a> to reduce the lock count to zero immediately.  </p>\n<p> Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue. Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.  </p>\n<p> For valid time-out values, see <a class=\"xref\" href=\"system.threading.readerwriterlock\" data-linktype=\"relative-path\">ReaderWriterLock</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_ReaderWriterLock_AcquireReaderLock_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_ReaderWriterLock_AcquireReaderLock_System_TimeSpan_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">AcquireReaderLock(TimeSpan)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Acquires a reader lock, using a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> value for the time-out.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void AcquireReaderLock (TimeSpan timeout);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>timeout</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <code>TimeSpan</code> specifying the time-out period.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitysafecriticalattribute\" title=\"System.Security.SecuritySafeCriticalAttribute\" data-linktype=\"relative-path\">SecuritySafeCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>timeout</code> expires before the lock request is granted.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>timeout</code> specifies a negative value other than -1 milliseconds.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p><a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_AcquireReaderLock_\" data-linktype=\"relative-path\">AcquireReaderLock</a> blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> If the current thread already has the writer lock, no reader lock is acquired. Instead, the lock count on the writer lock is incremented. This prevents a thread from blocking on its own writer lock. The result is exactly the same as calling <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_AcquireWriterLock_\" data-linktype=\"relative-path\">AcquireWriterLock</a>, and an additional call to <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_ReleaseWriterLock_\" data-linktype=\"relative-path\">ReleaseWriterLock</a> is required when releasing the writer lock.  </p>\n</div>\n<p> <code>AcquireReaderLock</code> supports recursive reader-lock requests. That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time. You must call <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_ReleaseReaderLock_\" data-linktype=\"relative-path\">ReleaseReaderLock</a> once for each time you call <code>AcquireReaderLock</code>. Alternatively, you can call <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_ReleaseLock_\" data-linktype=\"relative-path\">ReleaseLock</a> to reduce the lock count to zero immediately.  </p>\n<p> Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue. Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.  </p>\n<p> For valid time-out values, see <a class=\"xref\" href=\"system.threading.readerwriterlock\" data-linktype=\"relative-path\">ReaderWriterLock</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_ReaderWriterLock_AcquireWriterLock_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_ReaderWriterLock_AcquireWriterLock_System_Int32_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">AcquireWriterLock(Int32)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Acquires the writer lock, using an <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a> value for the time-out.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void AcquireWriterLock (int millisecondsTimeout);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>millisecondsTimeout</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The time-out in milliseconds.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitysafecriticalattribute\" title=\"System.Security.SecuritySafeCriticalAttribute\" data-linktype=\"relative-path\">SecuritySafeCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>timeout</code> expires before the lock request is granted.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This method blocks if another thread has a reader lock or writer lock. For a description of the way the writer lock alternates with multiple concurrent reader locks, see the <a class=\"xref\" href=\"system.threading.readerwriterlock\" data-linktype=\"relative-path\">ReaderWriterLock</a> class.  </p>\n<p> A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling AcquireWriterLock, or by calling <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_UpgradeToWriterLock_\" data-linktype=\"relative-path\">UpgradeToWriterLock</a>.  </p>\n<div class=\"CAUTION\"><h5>Caution</h5><p> If a thread calls <code>AcquireWriterLock</code> while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock. To avoid such deadlocks, use <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_IsReaderLockHeld_\" data-linktype=\"relative-path\">IsReaderLockHeld</a> to determine whether the current thread already has a reader lock.  </p>\n</div>\n<p> <code>AcquireWriterLock</code> supports recursive writer-lock requests. That is, a thread can call <code>AcquireWriterLock</code> multiple times, which increments the lock count each time. You must call <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_ReleaseWriterLock_\" data-linktype=\"relative-path\">ReleaseWriterLock</a> once for each time you call <code>AcquireWriterLock</code>. Alternatively, you can call <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_ReleaseLock_\" data-linktype=\"relative-path\">ReleaseLock</a> to reduce the lock count to zero immediately.  </p>\n<p> Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.  </p>\n<p> For valid time-out values, see <a class=\"xref\" href=\"system.threading.readerwriterlock\" data-linktype=\"relative-path\">ReaderWriterLock</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_ReaderWriterLock_AcquireWriterLock_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_ReaderWriterLock_AcquireWriterLock_System_TimeSpan_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">AcquireWriterLock(TimeSpan)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Acquires the writer lock, using a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> value for the time-out.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void AcquireWriterLock (TimeSpan timeout);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>timeout</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The <code>TimeSpan</code> specifying the time-out period.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitysafecriticalattribute\" title=\"System.Security.SecuritySafeCriticalAttribute\" data-linktype=\"relative-path\">SecuritySafeCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>timeout</code> expires before the lock request is granted.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>timeout</code> specifies a negative value other than -1 milliseconds.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This method blocks if another thread has a reader lock or writer lock. For a description of the way the writer lock alternates with multiple concurrent reader locks, see the <a class=\"xref\" href=\"system.threading.readerwriterlock\" data-linktype=\"relative-path\">ReaderWriterLock</a> class.  </p>\n<p> A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_AcquireWriterLock_\" data-linktype=\"relative-path\">AcquireWriterLock</a>, or by calling <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_UpgradeToWriterLock_\" data-linktype=\"relative-path\">UpgradeToWriterLock</a>.  </p>\n<div class=\"CAUTION\"><h5>Caution</h5><p> If a thread calls <code>AcquireWriterLock</code> while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock. To avoid such deadlocks, use <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_IsReaderLockHeld_\" data-linktype=\"relative-path\">IsReaderLockHeld</a> to determine whether the current thread already has a reader lock.  </p>\n</div>\n<p> <code>AcquireWriterLock</code> supports recursive writer-lock requests. That is, a thread can call <code>AcquireWriterLock</code> multiple times, which increments the lock count each time. You must call <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_ReleaseWriterLock_\" data-linktype=\"relative-path\">ReleaseWriterLock</a> once for each time you call <code>AcquireWriterLock</code>. Alternatively, you can call <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_ReleaseLock_\" data-linktype=\"relative-path\">ReleaseLock</a> to reduce the lock count to zero immediately.  </p>\n<p> Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.  </p>\n<p> For valid time-out values, see <a class=\"xref\" href=\"system.threading.readerwriterlock\" data-linktype=\"relative-path\">ReaderWriterLock</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_ReaderWriterLock_AnyWritersSince_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_ReaderWriterLock_AnyWritersSince_System_Int32_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">AnyWritersSince(Int32)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Indicates whether the writer lock has been granted to any thread since the sequence number was obtained.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public bool AnyWritersSince (int seqNum);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>seqNum</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The sequence number.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if the writer lock has been granted to any thread since the sequence number was obtained; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitysafecriticalattribute\" title=\"System.Security.SecuritySafeCriticalAttribute\" data-linktype=\"relative-path\">SecuritySafeCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>You can use <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_WriterSeqNum_\" data-linktype=\"relative-path\">WriterSeqNum</a> and <code>AnyWritersSince</code> to improve application performance. For example, a thread might cache the information it obtains while holding a reader lock. After releasing and later reacquiring the lock, the thread can use <code>AnyWritersSince</code> to determine whether other threads have written to the resource in the interim; if not, the cached information can be used. This technique is useful where reading the information protected by the lock is expensive; for example, running a database query.  </p>\n<p> The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_ReaderWriterLock_DowngradeFromWriterLock_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_ReaderWriterLock_DowngradeFromWriterLock_System_Threading_LockCookie__\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">DowngradeFromWriterLock(LockCookie)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Restores the lock status of the thread to what it was before <span class=\"xref\">stem.Threading.ReaderWriterLock.UpgradeToWriterLock*</span> was called.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void DowngradeFromWriterLock (ref System.Threading.LockCookie lockCookie);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>lockCookie</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.lockcookie\" data-linktype=\"relative-path\">LockCookie</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <a class=\"xref\" href=\"system.threading.lockcookie\" data-linktype=\"relative-path\">LockCookie</a> returned by <span class=\"xref\">stem.Threading.ReaderWriterLock.UpgradeToWriterLock*</span>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitysafecriticalattribute\" title=\"System.Security.SecuritySafeCriticalAttribute\" data-linktype=\"relative-path\">SecuritySafeCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The thread does not have the writer lock.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The address of <code>lockCookie</code> is a null pointer.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>DowngradeFromWriterLock releases the writer lock, regardless of the recursive lock count, and restores the reader lock that was held by the thread before upgrading to the writer lock. The lock count on the reader lock is restored.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> <code>DowngradeFromWriterLock</code> accepts a <a class=\"xref\" href=\"system.threading.lockcookie\" data-linktype=\"relative-path\">LockCookie</a> obtained by calling <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_UpgradeToWriterLock_\" data-linktype=\"relative-path\">UpgradeToWriterLock</a>. Do not use a <code>LockCookie</code> returned by <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_ReleaseLock_\" data-linktype=\"relative-path\">ReleaseLock</a>.  </p>\n</div>\n<p> A thread does not block when downgrading from the writer lock, even if other threads are waiting for the writer lock, because all reader-lock requests are granted when the writer lock is released.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_ReaderWriterLock_Finalize_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_ReaderWriterLock_Finalize\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Finalize()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <a class=\"xref\" href=\"system.threading.readerwriterlock\" data-linktype=\"relative-path\">ReaderWriterLock</a> object.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">~ReaderWriterLock ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitysafecriticalattribute\" title=\"System.Security.SecuritySafeCriticalAttribute\" data-linktype=\"relative-path\">SecuritySafeCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The garbage collector calls Finalize when the current <a class=\"xref\" href=\"system.threading.readerwriterlock\" data-linktype=\"relative-path\">ReaderWriterLock</a> object is ready to be finalized.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_ReaderWriterLock_ReleaseLock_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_ReaderWriterLock_ReleaseLock\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">ReleaseLock()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Releases the lock, regardless of the number of times the thread acquired the lock.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Threading.LockCookie ReleaseLock ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.lockcookie\" data-linktype=\"relative-path\">LockCookie</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>A <a class=\"xref\" href=\"system.threading.lockcookie\" data-linktype=\"relative-path\">LockCookie</a> value representing the released lock.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitysafecriticalattribute\" title=\"System.Security.SecuritySafeCriticalAttribute\" data-linktype=\"relative-path\">SecuritySafeCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>ReleaseLock releases the reader lock or writer lock, regardless of the recursive lock count. To restore the state of the lock, including the lock count, pass the <a class=\"xref\" href=\"system.threading.lockcookie\" data-linktype=\"relative-path\">LockCookie</a> to <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_RestoreLock_\" data-linktype=\"relative-path\">RestoreLock</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_ReaderWriterLock_ReleaseReaderLock_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_ReaderWriterLock_ReleaseReaderLock\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">ReleaseReaderLock()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Decrements the lock count.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void ReleaseReaderLock ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.constrainedexecution.reliabilitycontractattribute\" title=\"System.Runtime.ConstrainedExecution.ReliabilityContractAttribute\" data-linktype=\"relative-path\">ReliabilityContractAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitysafecriticalattribute\" title=\"System.Security.SecuritySafeCriticalAttribute\" data-linktype=\"relative-path\">SecuritySafeCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The thread does not have any reader or writer locks.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>ReleaseReaderLock decrements the lock count. When the count reaches zero, the lock is released.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> If a thread has the writer lock, calling <code>ReleaseReaderLock</code> has the same effect as calling <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_ReleaseWriterLock_\" data-linktype=\"relative-path\">ReleaseWriterLock</a>. If a thread has no locks, calling <code>ReleaseReaderLock</code> throws an <a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a>.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_ReaderWriterLock_ReleaseWriterLock_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_ReaderWriterLock_ReleaseWriterLock\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">ReleaseWriterLock()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Decrements the lock count on the writer lock.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void ReleaseWriterLock ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.constrainedexecution.reliabilitycontractattribute\" title=\"System.Runtime.ConstrainedExecution.ReliabilityContractAttribute\" data-linktype=\"relative-path\">ReliabilityContractAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitysafecriticalattribute\" title=\"System.Security.SecuritySafeCriticalAttribute\" data-linktype=\"relative-path\">SecuritySafeCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The thread does not have the writer lock.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>ReleaseWriterLock decrements the writer lock count. When the count reaches zero, the writer lock is released.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> If a thread has a reader lock, or no locks, calling <code>ReleaseWriterLock</code> throws an <a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a>.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_ReaderWriterLock_RestoreLock_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_ReaderWriterLock_RestoreLock_System_Threading_LockCookie__\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">RestoreLock(LockCookie)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Restores the lock status of the thread to what it was before calling <span class=\"xref\">stem.Threading.ReaderWriterLock.ReleaseLock*</span>.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void RestoreLock (ref System.Threading.LockCookie lockCookie);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>lockCookie</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.lockcookie\" data-linktype=\"relative-path\">LockCookie</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <a class=\"xref\" href=\"system.threading.lockcookie\" data-linktype=\"relative-path\">LockCookie</a> returned by <span class=\"xref\">stem.Threading.ReaderWriterLock.ReleaseLock*</span>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitysafecriticalattribute\" title=\"System.Security.SecuritySafeCriticalAttribute\" data-linktype=\"relative-path\">SecuritySafeCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The address of <code>lockCookie</code> is a null pointer.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The state restored by <code>RestoreLock</code> includes the recursive lock count.  </p>\n<p> A thread blocks if it tries to restore a reader lock after another thread has acquired the writer lock, or if it tries to restore the writer lock after another thread has acquired a reader lock or writer lock. Because <code>RestoreLock</code> does not accept a time-out, you should take care to avoid possible deadlocks.  </p>\n<div class=\"CAUTION\"><h5>Caution</h5><p> Before calling <code>RestoreLock</code>, make sure you have released all locks acquired since the call to <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_ReleaseLock_\" data-linktype=\"relative-path\">ReleaseLock</a>. For example, a thread deadlocks if it acquires a reader lock, and then attempts to restore an earlier writer lock. Use <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_IsReaderLockHeld_\" data-linktype=\"relative-path\">IsReaderLockHeld</a> and <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_IsWriterLockHeld_\" data-linktype=\"relative-path\">IsWriterLockHeld</a> to detect such additional locks.  </p>\n</div>\n<p> Do not use a <a class=\"xref\" href=\"system.threading.lockcookie\" data-linktype=\"relative-path\">LockCookie</a> returned from <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_UpgradeToWriterLock_\" data-linktype=\"relative-path\">UpgradeToWriterLock</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_ReaderWriterLock_UpgradeToWriterLock_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_ReaderWriterLock_UpgradeToWriterLock_System_Int32_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">UpgradeToWriterLock(Int32)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Upgrades a reader lock to the writer lock, using an <code>Int32</code> value for the time-out.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Threading.LockCookie UpgradeToWriterLock (int millisecondsTimeout);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>millisecondsTimeout</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The time-out in milliseconds.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.lockcookie\" data-linktype=\"relative-path\">LockCookie</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>A <a class=\"xref\" href=\"system.threading.lockcookie\" data-linktype=\"relative-path\">LockCookie</a> value.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.security.securitysafecriticalattribute\" title=\"System.Security.SecuritySafeCriticalAttribute\" data-linktype=\"relative-path\">SecuritySafeCriticalAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>millisecondsTimeout</code> expires before the lock request is granted.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>When a thread calls <code>UpgradeToWriterLock</code> the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock. Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.  </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> The time-out exception is not thrown until the thread that called the UpgradeToWriterLock method can reacquire the reader lock. If there are no other threads waiting for the writer lock, this happens immediately. However, if another thread is queued for the writer lock, the thread that called the UpgradeToWriterLock method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock. This is true even if the other thread that requested the writer lock requested it after the current thread called the UpgradeToWriterLock method.  </p>\n</div>\n<p> To restore the lock state, call <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_DowngradeFromWriterLock_\" data-linktype=\"relative-path\">DowngradeFromWriterLock</a> using the <a class=\"xref\" href=\"system.threading.lockcookie\" data-linktype=\"relative-path\">LockCookie</a> returned by <code>UpgradeToWriterLock</code>. Do not use this <code>LockCookie</code> with <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_RestoreLock_\" data-linktype=\"relative-path\">RestoreLock</a>.  </p>\n<p> When a thread has no reader lock, do not use <code>UpgradeToWriterLock</code>. Use <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_AcquireWriterLock_\" data-linktype=\"relative-path\">AcquireWriterLock</a> instead.  </p>\n<p> For valid time-out values, see <a class=\"xref\" href=\"system.threading.readerwriterlock\" data-linktype=\"relative-path\">ReaderWriterLock</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Threading_ReaderWriterLock_UpgradeToWriterLock_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_ReaderWriterLock_UpgradeToWriterLock_System_TimeSpan_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">UpgradeToWriterLock(TimeSpan)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Upgrades a reader lock to the writer lock, using a <code>TimeSpan</code> value for the time-out.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Threading.LockCookie UpgradeToWriterLock (TimeSpan timeout);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>timeout</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The <code>TimeSpan</code> specifying the time-out period.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.lockcookie\" data-linktype=\"relative-path\">LockCookie</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>A <a class=\"xref\" href=\"system.threading.lockcookie\" data-linktype=\"relative-path\">LockCookie</a> value.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>timeout</code> expires before the lock request is granted.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>timeout</code> specifies a negative value other than -1 milliseconds.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>When a thread calls <code>UpgradeToWriterLock</code> the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock. Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.  </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> The time-out exception is not thrown until the thread that called the <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_UpgradeToWriterLock_\" data-linktype=\"relative-path\">UpgradeToWriterLock</a> method can reacquire the reader lock. If there are no other threads waiting for the writer lock, this happens immediately. However, if another thread is queued for the writer lock, the thread that called the <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_UpgradeToWriterLock_\" data-linktype=\"relative-path\">UpgradeToWriterLock</a> method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock. This is true even if the other thread that requested the writer lock requested it after the current thread called the <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_UpgradeToWriterLock_\" data-linktype=\"relative-path\">UpgradeToWriterLock</a> method.  </p>\n</div>\n<p> To restore the lock state, call <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_DowngradeFromWriterLock_\" data-linktype=\"relative-path\">DowngradeFromWriterLock</a> using the <a class=\"xref\" href=\"system.threading.lockcookie\" data-linktype=\"relative-path\">LockCookie</a> returned by <code>UpgradeToWriterLock</code>. Do not use this <code>LockCookie</code> with <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_RestoreLock_\" data-linktype=\"relative-path\">RestoreLock</a>.  </p>\n<p> When a thread has no reader lock, do not use <code>UpgradeToWriterLock</code>. Use <a class=\"xref\" href=\"system.threading.readerwriterlock#System_Threading_ReaderWriterLock_AcquireWriterLock_\" data-linktype=\"relative-path\">AcquireWriterLock</a> instead.  </p>\n<p> For valid time-out values, see <a class=\"xref\" href=\"system.threading.readerwriterlock\" data-linktype=\"relative-path\">ReaderWriterLock</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \t<h2 class=\"accented\">Thread Safety</h2>\r\n  \tThis type is thread safe.\r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Threading.ReaderWriterLock.yml\">\r\n<meta name=\"APIName\" content=\"System.Threading.ReaderWriterLock\">\r\n<meta name=\"APIName\" content=\"System.Threading.ReaderWriterLock..ctor\">\r\n<meta name=\"APIName\" content=\"System.Threading.ReaderWriterLock.AcquireReaderLock\">\r\n<meta name=\"APIName\" content=\"System.Threading.ReaderWriterLock.AcquireWriterLock\">\r\n<meta name=\"APIName\" content=\"System.Threading.ReaderWriterLock.AnyWritersSince\">\r\n<meta name=\"APIName\" content=\"System.Threading.ReaderWriterLock.DowngradeFromWriterLock\">\r\n<meta name=\"APIName\" content=\"System.Threading.ReaderWriterLock.Finalize\">\r\n<meta name=\"APIName\" content=\"System.Threading.ReaderWriterLock.IsReaderLockHeld\">\r\n<meta name=\"APIName\" content=\"System.Threading.ReaderWriterLock.IsWriterLockHeld\">\r\n<meta name=\"APIName\" content=\"System.Threading.ReaderWriterLock.ReleaseLock\">\r\n<meta name=\"APIName\" content=\"System.Threading.ReaderWriterLock.ReleaseReaderLock\">\r\n<meta name=\"APIName\" content=\"System.Threading.ReaderWriterLock.ReleaseWriterLock\">\r\n<meta name=\"APIName\" content=\"System.Threading.ReaderWriterLock.RestoreLock\">\r\n<meta name=\"APIName\" content=\"System.Threading.ReaderWriterLock.UpgradeToWriterLock\">\r\n<meta name=\"APIName\" content=\"System.Threading.ReaderWriterLock.WriterSeqNum\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-04-01 05:59 PM\">\r\n<meta name=\"document_id\" content=\"732a3b77-75bc-1c6d-a4c7-5cd91f41de8c\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Defines a lock that supports single writers and multiple readers.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.threading/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Threading.ReaderWriterLock\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","uhfHeaderId":"MSDocsHeader-DotNet","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Threading.ReaderWriterLock.yml","open_to_public_contributors":false,"api_name":["System.Threading.ReaderWriterLock","System.Threading.ReaderWriterLock..ctor","System.Threading.ReaderWriterLock.AcquireReaderLock","System.Threading.ReaderWriterLock.AcquireWriterLock","System.Threading.ReaderWriterLock.AnyWritersSince","System.Threading.ReaderWriterLock.DowngradeFromWriterLock","System.Threading.ReaderWriterLock.Finalize","System.Threading.ReaderWriterLock.IsReaderLockHeld","System.Threading.ReaderWriterLock.IsWriterLockHeld","System.Threading.ReaderWriterLock.ReleaseLock","System.Threading.ReaderWriterLock.ReleaseReaderLock","System.Threading.ReaderWriterLock.ReleaseWriterLock","System.Threading.ReaderWriterLock.RestoreLock","System.Threading.ReaderWriterLock.UpgradeToWriterLock","System.Threading.ReaderWriterLock.WriterSeqNum"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Threading.ReaderWriterLock","System::Threading::ReaderWriterLock","System.Threading.ReaderWriterLock.#ctor","System::Threading::ReaderWriterLock::#ctor","System.Threading.ReaderWriterLock.AcquireReaderLock","System::Threading::ReaderWriterLock::AcquireReaderLock","System.Threading.ReaderWriterLock.AcquireWriterLock","System::Threading::ReaderWriterLock::AcquireWriterLock","System.Threading.ReaderWriterLock.AnyWritersSince","System::Threading::ReaderWriterLock::AnyWritersSince","System.Threading.ReaderWriterLock.DowngradeFromWriterLock","System::Threading::ReaderWriterLock::DowngradeFromWriterLock","System.Threading.ReaderWriterLock.Finalize","System::Threading::ReaderWriterLock::Finalize","System.Threading.ReaderWriterLock.IsReaderLockHeld","System::Threading::ReaderWriterLock::IsReaderLockHeld","System.Threading.ReaderWriterLock.IsWriterLockHeld","System::Threading::ReaderWriterLock::IsWriterLockHeld","System.Threading.ReaderWriterLock.ReleaseLock","System::Threading::ReaderWriterLock::ReleaseLock","System.Threading.ReaderWriterLock.ReleaseReaderLock","System::Threading::ReaderWriterLock::ReleaseReaderLock","System.Threading.ReaderWriterLock.ReleaseWriterLock","System::Threading::ReaderWriterLock::ReleaseWriterLock","System.Threading.ReaderWriterLock.RestoreLock","System::Threading::ReaderWriterLock::RestoreLock","System.Threading.ReaderWriterLock.UpgradeToWriterLock","System::Threading::ReaderWriterLock::UpgradeToWriterLock","System.Threading.ReaderWriterLock.WriterSeqNum","System::Threading::ReaderWriterLock::WriterSeqNum"],"dev_langs":["csharp"],"updated_at":"2017-04-01 05:59 PM","document_id":"732a3b77-75bc-1c6d-a4c7-5cd91f41de8c","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Threading/ReaderWriterLock.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"ReaderWriterLock class | Microsoft Docs","_op_ogTitle":"ReaderWriterLock class","description":"Defines a lock that supports single writers and multiple readers.\n","toc_asset_id":"api/_splitted/System.Threading/toc.json","toc_rel":"_splitted/System.Threading/toc.json","source_url":"","ms.assetid":"System.Threading.ReaderWriterLock","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlock","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlock","fileRelativePath":"api/System.Threading.ReaderWriterLock.html"},"themesRelativePathToOutputRoot":"_themes/"}