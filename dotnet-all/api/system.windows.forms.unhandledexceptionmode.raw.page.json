{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">UnhandledExceptionMode</span>\r\n      Enum\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Defines where a Windows Forms application should send unhandled exceptions.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\r\n  \t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">public enum UnhandledExceptionMode</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.valuetype\" data-linktype=\"relative-path\">ValueType</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.enum\" data-linktype=\"relative-path\">Enum</a></span></div><span class=\"lang-csharp\">UnhandledExceptionMode</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following code example sets event handlers for both errors that occur on Windows Forms threads and errors that occur on other threads. It sets <a class=\"xref\" href=\"system.windows.forms.application#System_Windows_Forms_Application_SetUnhandledExceptionMode_\" data-linktype=\"relative-path\">SetUnhandledExceptionMode</a> so that all errors are handled by the application, regardless of the settings in the application&#39;s user configuration file. It uses the <a class=\"xref\" href=\"system.windows.forms.application#System_Windows_Forms_Application_ThreadException\" data-linktype=\"relative-path\">ThreadException</a> event for the former, and the <a class=\"xref\" href=\"system.appdomain#System_AppDomain_UnhandledException\" data-linktype=\"relative-path\">UnhandledException</a> event for the latter. Since <a class=\"xref\" href=\"system.appdomain#System_AppDomain_UnhandledException\" data-linktype=\"relative-path\">UnhandledException</a> cannot prevent an application from terminating, the example simply logs the error in the system Event Log prior to termination.  </p>\n<p> This sample assumes that you have defined two <a class=\"xref\" href=\"system.windows.forms.button\" data-linktype=\"relative-path\">Button</a> controls, <code>button1</code> and <code>button2</code>, on your <a class=\"xref\" href=\"system.windows.forms.form\" data-linktype=\"relative-path\">Form</a> class.  </p>\n<pre><code class=\"lang-cpp\" name=\"Classic Application.ThreadException Example#1\">   // Creates a class to throw the error.\npublic:\n   ref class ErrorHandler: public System::Windows::Forms::Form\n   {\n      // Inserts the code to create a form with a button.\n\n      // Programs the button to throw an exception when clicked.\n   private:\n      void button1_Click( Object^ /*sender*/, System::EventArgs^ /*e*/ )\n      {\n         throw gcnew ArgumentException( &quot;The parameter was invalid&quot; );\n      }\n\n   public:\n      static void Main()\n      {\n         // Creates an instance of the methods that will handle the exception.\n         CustomExceptionHandler ^ eh = gcnew CustomExceptionHandler;\n         \n         // Adds the event handler to to the event.\n         Application::ThreadException += gcnew ThreadExceptionEventHandler( eh, &amp;Form1::CustomExceptionHandler::OnThreadException );\n         \n         // Runs the application.\n         Application::Run( gcnew ErrorHandler );\n      }\n   };\n\n   // Creates a class to handle the exception event.\ninternal:\n   ref class CustomExceptionHandler\n   {\n      // Handles the exception event.\n   public:\n      void OnThreadException( Object^ /*sender*/, ThreadExceptionEventArgs^ t )\n      {\n         System::Windows::Forms::DialogResult result = ::DialogResult::Cancel;\n         try\n         {\n            result = this-&gt;ShowThreadExceptionDialog( t-&gt;Exception );\n         }\n         catch ( Exception^ ) \n         {\n            try\n            {\n               MessageBox::Show( &quot;Fatal Error&quot;, &quot;Fatal Error&quot;, MessageBoxButtons::AbortRetryIgnore, MessageBoxIcon::Stop );\n            }\n            finally\n            {\n               Application::Exit();\n            }\n         }\n         \n         // Exits the program when the user clicks Abort.\n         if ( result == ::DialogResult::Abort )\n         {\n            Application::Exit();\n         }\n      }\n\n      // Creates the error message and displays it.\n   private:\n      System::Windows::Forms::DialogResult ShowThreadExceptionDialog( Exception^ e )\n      {\n         String^ errorMsg = &quot;An error occurred please contact the adminstrator with the following information:\\n\\n&quot;;\n         errorMsg = String::Concat( errorMsg, e-&gt;Message, &quot;\\n\\nStack Trace:\\n&quot;, e-&gt;StackTrace );\n         return MessageBox::Show( errorMsg, &quot;Application Error&quot;, MessageBoxButtons::AbortRetryIgnore, MessageBoxIcon::Stop );\n      }\n   };\n</code></pre><pre><code class=\"lang-cs\" name=\"Classic Application.ThreadException Example#1\">Thread newThread = null;\n\n// Starts the application. \n[SecurityPermission(SecurityAction.Demand, Flags = SecurityPermissionFlag.ControlAppDomain)]\npublic static void Main(string[] args)\n{\n    // Add the event handler for handling UI thread exceptions to the event.\n    Application.ThreadException += new ThreadExceptionEventHandler(ErrorHandlerForm.Form1_UIThreadException);\n\n    // Set the unhandled exception mode to force all Windows Forms errors to go through\n    // our handler.\n    Application.SetUnhandledExceptionMode(UnhandledExceptionMode.CatchException);\n\n    // Add the event handler for handling non-UI thread exceptions to the event. \n    AppDomain.CurrentDomain.UnhandledException +=\n        new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);\n\n    // Runs the application.\n    Application.Run(new ErrorHandlerForm());\n}\n\n// Programs the button to throw an exception when clicked.\nprivate void button1_Click(object sender, System.EventArgs e)\n{\n    throw new ArgumentException(&quot;The parameter was invalid&quot;);\n}\n\n// Start a new thread, separate from Windows Forms, that will throw an exception.\nprivate void button2_Click(object sender, System.EventArgs e)\n{\n    ThreadStart newThreadStart = new ThreadStart(newThread_Execute);\n    newThread = new Thread(newThreadStart);\n    newThread.Start();\n}\n\n// The thread we start up to demonstrate non-UI exception handling. \nvoid newThread_Execute()\n{\n    throw new Exception(&quot;The method or operation is not implemented.&quot;);\n}\n\n// Handle the UI exceptions by showing a dialog box, and asking the user whether\n// or not they wish to abort execution.\nprivate static void Form1_UIThreadException(object sender, ThreadExceptionEventArgs t)\n{\n    DialogResult result = DialogResult.Cancel;\n    try\n    {\n        result = ShowThreadExceptionDialog(&quot;Windows Forms Error&quot;, t.Exception);\n    }\n    catch\n    {\n        try\n        {\n            MessageBox.Show(&quot;Fatal Windows Forms Error&quot;,\n                &quot;Fatal Windows Forms Error&quot;, MessageBoxButtons.AbortRetryIgnore, MessageBoxIcon.Stop);\n        }\n        finally\n        {\n            Application.Exit();\n        }\n    }\n\n    // Exits the program when the user clicks Abort.\n    if (result == DialogResult.Abort)\n        Application.Exit();\n}\n\n// Handle the UI exceptions by showing a dialog box, and asking the user whether\n// or not they wish to abort execution.\n// NOTE: This exception cannot be kept from terminating the application - it can only \n// log the event, and inform the user about it. \nprivate static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)\n{\n    try\n    {\n        Exception ex = (Exception)e.ExceptionObject;\n        string errorMsg = &quot;An application error occurred. Please contact the adminstrator &quot; +\n            &quot;with the following information:\\n\\n&quot;;\n\n        // Since we can&#39;t prevent the app from terminating, log this to the event log.\n        if (!EventLog.SourceExists(&quot;ThreadException&quot;))\n        {\n            EventLog.CreateEventSource(&quot;ThreadException&quot;, &quot;Application&quot;);\n        }\n\n        // Create an EventLog instance and assign its source.\n        EventLog myLog = new EventLog();\n        myLog.Source = &quot;ThreadException&quot;;\n        myLog.WriteEntry(errorMsg + ex.Message + &quot;\\n\\nStack Trace:\\n&quot; + ex.StackTrace);\n    }\n    catch (Exception exc)\n    {\n        try\n        {\n            MessageBox.Show(&quot;Fatal Non-UI Error&quot;,\n                &quot;Fatal Non-UI Error. Could not write the error to the event log. Reason: &quot;\n                + exc.Message, MessageBoxButtons.OK, MessageBoxIcon.Stop);\n        }\n        finally\n        {\n            Application.Exit();\n        }\n    }\n}\n\n// Creates the error message and displays it.\nprivate static DialogResult ShowThreadExceptionDialog(string title, Exception e)\n{\n    string errorMsg = &quot;An application error occurred. Please contact the adminstrator &quot; +\n        &quot;with the following information:\\n\\n&quot;;\n    errorMsg = errorMsg + e.Message + &quot;\\n\\nStack Trace:\\n&quot; + e.StackTrace;\n    return MessageBox.Show(errorMsg, title, MessageBoxButtons.AbortRetryIgnore,\n        MessageBoxIcon.Stop);\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Classic Application.ThreadException Example#1\">     Private newThread As Thread = Nothing\n\n     &#39; Starts the application. \n     &lt;SecurityPermission(SecurityAction.Demand, Flags:=SecurityPermissionFlag.ControlAppDomain)&gt; _\n     Public Shared Sub Main()\n         &#39; Add the event handler for handling UI thread exceptions to the event.\n         AddHandler Application.ThreadException, AddressOf ErrorHandlerForm.Form1_UIThreadException\n\n         &#39; Set the unhandled exception mode to force all Windows Forms errors to go through\n         &#39; our handler.\n         Application.SetUnhandledExceptionMode(UnhandledExceptionMode.CatchException)\n\n         &#39; Add the event handler for handling non-UI thread exceptions to the event. \n         AddHandler AppDomain.CurrentDomain.UnhandledException, AddressOf CurrentDomain_UnhandledException\n\n         &#39; Runs the application.\n         Application.Run(New ErrorHandlerForm())\n     End Sub\n\n\n     &#39; Programs the button to throw an exception when clicked.\n     Private Sub button1_Click(ByVal sender As Object, ByVal e As System.EventArgs) Handles button1.Click\n         Throw New ArgumentException(&quot;The parameter was invalid&quot;)\n     End Sub\n\n     &#39; Start a new thread, separate from Windows Forms, that will throw an exception.\n     Private Sub button2_Click(ByVal sender As Object, ByVal e As System.EventArgs) Handles button2.Click\n         Dim newThreadStart As New ThreadStart(AddressOf newThread_Execute)\n         newThread = New Thread(newThreadStart)\n         newThread.Start()\n     End Sub\n\n\n     &#39; The thread we start up to demonstrate non-UI exception handling. \n     Sub newThread_Execute()\n         Throw New Exception(&quot;The method or operation is not implemented.&quot;)\n     End Sub\n\n\n     &#39; Handle the UI exceptions by showing a dialog box, and asking the user whether\n     &#39; or not they wish to abort execution.\n     Private Shared Sub Form1_UIThreadException(ByVal sender As Object, ByVal t As ThreadExceptionEventArgs)\n         Dim result As System.Windows.Forms.DialogResult = _\n             System.Windows.Forms.DialogResult.Cancel\n         Try\n             result = ShowThreadExceptionDialog(&quot;Windows Forms Error&quot;, t.Exception)\n         Catch\n             Try\n                 MessageBox.Show(&quot;Fatal Windows Forms Error&quot;, _\n                     &quot;Fatal Windows Forms Error&quot;, MessageBoxButtons.AbortRetryIgnore, MessageBoxIcon.Stop)\n             Finally\n                 Application.Exit()\n             End Try\n         End Try\n\n         &#39; Exits the program when the user clicks Abort.\n         If result = DialogResult.Abort Then\n             Application.Exit()\n         End If\n     End Sub\n\n     &#39; Handle the UI exceptions by showing a dialog box, and asking the user whether\n     &#39; or not they wish to abort execution.\n     &#39; NOTE: This exception cannot be kept from terminating the application - it can only \n     &#39; log the event, and inform the user about it. \n     Private Shared Sub CurrentDomain_UnhandledException(ByVal sender As Object, _\n     ByVal e As UnhandledExceptionEventArgs)\n         Try\n             Dim ex As Exception = CType(e.ExceptionObject, Exception)\n             Dim errorMsg As String = &quot;An application error occurred. Please contact the adminstrator &quot; &amp; _\n                 &quot;with the following information:&quot; &amp; ControlChars.Lf &amp; ControlChars.Lf\n\n             &#39; Since we can&#39;t prevent the app from terminating, log this to the event log.\n             If (Not EventLog.SourceExists(&quot;ThreadException&quot;)) Then\n                 EventLog.CreateEventSource(&quot;ThreadException&quot;, &quot;Application&quot;)\n             End If\n\n             &#39; Create an EventLog instance and assign its source.\n             Dim myLog As New EventLog()\n             myLog.Source = &quot;ThreadException&quot;\n             myLog.WriteEntry((errorMsg + ex.Message &amp; ControlChars.Lf &amp; ControlChars.Lf &amp; _\n                 &quot;Stack Trace:&quot; &amp; ControlChars.Lf &amp; ex.StackTrace))\n         Catch exc As Exception\n             Try\n                 MessageBox.Show(&quot;Fatal Non-UI Error&quot;, &quot;Fatal Non-UI Error. Could not write the error to the event log. &quot; &amp; _\n                     &quot;Reason: &quot; &amp; exc.Message, MessageBoxButtons.OK, MessageBoxIcon.Stop)\n             Finally\n                 Application.Exit()\n             End Try\n         End Try\n     End Sub\n\n\n     &#39; Creates the error message and displays it.\n     Private Shared Function ShowThreadExceptionDialog(ByVal title As String, ByVal e As Exception) As DialogResult\n         Dim errorMsg As String = &quot;An application error occurred. Please contact the adminstrator &quot; &amp; _\n&quot;with the following information:&quot; &amp; ControlChars.Lf &amp; ControlChars.Lf\n         errorMsg = errorMsg &amp; e.Message &amp; ControlChars.Lf &amp; _\nControlChars.Lf &amp; &quot;Stack Trace:&quot; &amp; ControlChars.Lf &amp; e.StackTrace\n\n         Return MessageBox.Show(errorMsg, title, MessageBoxButtons.AbortRetryIgnore, MessageBoxIcon.Stop)\n     End Function\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>This enumeration is used by <a class=\"xref\" href=\"system.windows.forms.application#System_Windows_Forms_Application_SetUnhandledExceptionMode_\" data-linktype=\"relative-path\">SetUnhandledExceptionMode</a>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> In the .NET Framework version 2.0, the common language runtime behavior changed to allow unhandled exceptions to propagate up the call stack. This behavior can be disabled via the application configuration file. For more information, see <a href=\"../topic/exceptions%20in%20managed%20threads\" data-linktype=\"relative-path\">Exceptions in Managed Threads</a>.</p>\n</div>\n\r\n  \r\n      \t<h2 class=\"accented\">Fields\r\n      </h2>\r\n      <table class=\"nameValue\">\r\n      \t<tr><td id=\"System_Windows_Forms_UnhandledExceptionMode_Automatic\">\r\n      \t\t\t<span class=\"lang-csharp\">Automatic</span>\r\n      \t</td>\r\n      \t<td><p>Route all exceptions to the <a class=\"xref\" href=\"system.windows.forms.application#System_Windows_Forms_Application_ThreadException\" data-linktype=\"relative-path\">ThreadException</a> handler, unless the application&#39;s configuration file specifies otherwise.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Windows_Forms_UnhandledExceptionMode_CatchException\">\r\n      \t\t\t<span class=\"lang-csharp\">CatchException</span>\r\n      \t</td>\r\n      \t<td><p>Always route exceptions to the <a class=\"xref\" href=\"system.windows.forms.application#System_Windows_Forms_Application_ThreadException\" data-linktype=\"relative-path\">ThreadException</a> handler. Ignore the application configuration file.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Windows_Forms_UnhandledExceptionMode_ThrowException\">\r\n      \t\t\t<span class=\"lang-csharp\">ThrowException</span>\r\n      \t</td>\r\n      \t<td><p>Never route exceptions to the <a class=\"xref\" href=\"system.windows.forms.application#System_Windows_Forms_Application_ThreadException\" data-linktype=\"relative-path\">ThreadException</a> handler. Ignore the application configuration file.</p>\n</td>\r\n      \t</tr>\r\n      </table>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Windows.Forms.UnhandledExceptionMode.yml\">\r\n<meta name=\"APIName\" content=\"System.Windows.Forms.UnhandledExceptionMode\">\r\n<meta name=\"APIName\" content=\"System.Windows.Forms.UnhandledExceptionMode.Automatic\">\r\n<meta name=\"APIName\" content=\"System.Windows.Forms.UnhandledExceptionMode.CatchException\">\r\n<meta name=\"APIName\" content=\"System.Windows.Forms.UnhandledExceptionMode.ThrowException\">\r\n<meta name=\"APILocation\" content=\"System.Windows.Forms.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-04-01 05:59 PM\">\r\n<meta name=\"document_id\" content=\"54d1f47e-7571-c6fe-1fe0-ab6d87e58dc3\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Defines where a Windows Forms application should send unhandled exceptions.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.windows.forms/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Windows.Forms.UnhandledExceptionMode\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","uhfHeaderId":"MSDocsHeader-DotNet","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Windows.Forms.UnhandledExceptionMode.yml","open_to_public_contributors":false,"api_name":["System.Windows.Forms.UnhandledExceptionMode","System.Windows.Forms.UnhandledExceptionMode.Automatic","System.Windows.Forms.UnhandledExceptionMode.CatchException","System.Windows.Forms.UnhandledExceptionMode.ThrowException"],"api_location":["System.Windows.Forms.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Windows.Forms.UnhandledExceptionMode","System::Windows::Forms::UnhandledExceptionMode","System.Windows.Forms.UnhandledExceptionMode.Automatic","System::Windows::Forms::UnhandledExceptionMode::Automatic","System.Windows.Forms.UnhandledExceptionMode.CatchException","System::Windows::Forms::UnhandledExceptionMode::CatchException","System.Windows.Forms.UnhandledExceptionMode.ThrowException","System::Windows::Forms::UnhandledExceptionMode::ThrowException"],"dev_langs":["csharp"],"updated_at":"2017-04-01 05:59 PM","document_id":"54d1f47e-7571-c6fe-1fe0-ab6d87e58dc3","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Windows.Forms/UnhandledExceptionMode.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"UnhandledExceptionMode enum | Microsoft Docs","_op_ogTitle":"UnhandledExceptionMode enum","description":"Defines where a Windows Forms application should send unhandled exceptions.\n","toc_asset_id":"api/_splitted/System.Windows.Forms/toc.json","toc_rel":"_splitted/System.Windows.Forms/toc.json","source_url":"","ms.assetid":"System.Windows.Forms.UnhandledExceptionMode","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.windows.forms.unhandledexceptionmode","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.windows.forms.unhandledexceptionmode","fileRelativePath":"api/System.Windows.Forms.UnhandledExceptionMode.html"},"themesRelativePathToOutputRoot":"_themes/"}