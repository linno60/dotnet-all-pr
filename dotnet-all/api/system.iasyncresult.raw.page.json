{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">IAsyncResult</span>\r\n      Interface\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Represents the status of an asynchronous operation.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(true)]\npublic interface IAsyncResult</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Attributes</dt><dd>\r\n  \t\t<div class=\"cdlHolder\">\r\n  \t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following example demonstrates how to use the <a class=\"xref\" href=\"system.runtime.remoting.messaging.asyncresult#System_Runtime_Remoting_Messaging_AsyncResult_AsyncWaitHandle_\" data-linktype=\"relative-path\">AsyncWaitHandle</a> property to get a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, and how to wait for an asynchronous call on a delegate. The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> is signaled when the asynchronous call completes, and you can wait for it by calling the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> method.  </p>\n<p> The example consists of two classes: the class that contains the method that is called asynchronously, and the class that contains the <code>Main</code> method that makes the call.  </p>\n<p> For more information and more examples of calling methods asynchronously by using delegates, see <a href=\"../topic/calling%20synchronous%20methods%20asynchronously\" data-linktype=\"relative-path\">Calling Synchronous Methods Asynchronously</a>.  </p>\n<pre><code class=\"lang-vb\" name=\"AsyncDelegateExamples#1\">Imports System\nImports System.Threading\nImports System.Runtime.InteropServices \n\nNamespace Examples.AdvancedProgramming.AsynchronousOperations\n    Public Class AsyncDemo \n        &#39; The method to be executed asynchronously.\n        Public Function TestMethod(ByVal callDuration As Integer, _\n                &lt;Out&gt; ByRef threadId As Integer) As String\n            Console.WriteLine(&quot;Test method begins.&quot;)\n            Thread.Sleep(callDuration)\n            threadId = Thread.CurrentThread.ManagedThreadId()\n            return String.Format(&quot;My call time was {0}.&quot;, callDuration.ToString())\n        End Function\n    End Class\n\n    &#39; The delegate must have the same signature as the method\n    &#39; it will call asynchronously.\n    Public Delegate Function AsyncMethodCaller(ByVal callDuration As Integer, _\n        &lt;Out&gt; ByRef threadId As Integer) As String\nEnd Namespace\n</code></pre><pre><code class=\"lang-cs\" name=\"AsyncDelegateExamples#1\">using System;\nusing System.Threading; \n\nnamespace Examples.AdvancedProgramming.AsynchronousOperations\n{\n    public class AsyncDemo \n    {\n        // The method to be executed asynchronously.\n        public string TestMethod(int callDuration, out int threadId) \n        {\n            Console.WriteLine(&quot;Test method begins.&quot;);\n            Thread.Sleep(callDuration);\n            threadId = Thread.CurrentThread.ManagedThreadId;\n            return String.Format(&quot;My call time was {0}.&quot;, callDuration.ToString());\n        }\n    }\n    // The delegate must have the same signature as the method\n    // it will call asynchronously.\n    public delegate string AsyncMethodCaller(int callDuration, out int threadId);\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"AsyncDelegateExamples#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Runtime::InteropServices; \n\nnamespace Examples {\nnamespace AdvancedProgramming {\nnamespace AsynchronousOperations\n{\n    public ref class AsyncDemo \n    {\n    public:\n        // The method to be executed asynchronously.\n        String^ TestMethod(int callDuration, [OutAttribute] int% threadId) \n        {\n            Console::WriteLine(&quot;Test method begins.&quot;);\n            Thread::Sleep(callDuration);\n            threadId = Thread::CurrentThread-&gt;ManagedThreadId;\n            return String::Format(&quot;My call time was {0}.&quot;, callDuration);\n        }\n    };\n\n    // The delegate must have the same signature as the method\n    // it will call asynchronously.\n    public delegate String^ AsyncMethodCaller(int callDuration, [OutAttribute] int% threadId);\n}}}\n</code></pre><pre><code class=\"lang-vb\" name=\"AsyncDelegateExamples#3\">Imports System\nImports System.Threading\nImports System.Runtime.InteropServices \n\nNamespace Examples.AdvancedProgramming.AsynchronousOperations\n\n    Public Class AsyncMain \n        Shared Sub Main() \n            &#39; The asynchronous method puts the thread id here.\n            Dim threadId As Integer\n\n            &#39; Create an instance of the test class.\n            Dim ad As New AsyncDemo()\n\n            &#39; Create the delegate.\n            Dim caller As New AsyncMethodCaller(AddressOf ad.TestMethod)\n       \n            &#39; Initiate the asynchronous call.\n            Dim result As IAsyncResult = caller.BeginInvoke(3000, _\n                threadId, Nothing, Nothing)\n\n            Thread.Sleep(0)\n            Console.WriteLine(&quot;Main thread {0} does some work.&quot;, _\n                Thread.CurrentThread.ManagedThreadId)\n            &#39; Perform additional processing here and then\n            &#39; wait for the WaitHandle to be signaled.\n            result.AsyncWaitHandle.WaitOne()\n\n            &#39; Call EndInvoke to retrieve the results.\n            Dim returnValue As String = caller.EndInvoke(threadId, result)\n\n            &#39; Close the wait handle.\n            result.AsyncWaitHandle.Close()\n\n            Console.WriteLine(&quot;The call executed on thread {0}, with return value &quot;&quot;{1}&quot;&quot;.&quot;, _\n                threadId, returnValue)\n        End Sub\n    End Class\nEnd Namespace\n\n&#39;This example produces output similar to the following:\n&#39;\n&#39;Main thread 1 does some work.\n&#39;Test method begins.\n&#39;The call executed on thread 3, with return value &quot;My call time was 3000.&quot;.\n</code></pre><pre><code class=\"lang-cpp\" name=\"AsyncDelegateExamples#3\">#using &lt;TestMethod.dll&gt;\n\nusing namespace System;\nusing namespace System::Threading;\nusing namespace Examples::AdvancedProgramming::AsynchronousOperations;\n\nvoid main() \n{\n    // The asynchronous method puts the thread id here.\n    int threadId;\n\n    // Create an instance of the test class.\n    AsyncDemo^ ad = gcnew AsyncDemo();\n\n    // Create the delegate.\n    AsyncMethodCaller^ caller = gcnew AsyncMethodCaller(ad, &amp;AsyncDemo::TestMethod);\n       \n    // Initiate the asychronous call.\n    IAsyncResult^ result = caller-&gt;BeginInvoke(3000, \n        threadId, nullptr, nullptr);\n\n    Thread::Sleep(0);\n    Console::WriteLine(&quot;Main thread {0} does some work.&quot;,\n        Thread::CurrentThread-&gt;ManagedThreadId);\n\n    // Wait for the WaitHandle to become signaled.\n    result-&gt;AsyncWaitHandle-&gt;WaitOne();\n\n    // Perform additional processing here.\n    // Call EndInvoke to retrieve the results.\n    String^ returnValue = caller-&gt;EndInvoke(threadId, result);\n\n    // Close the wait handle.\n    result-&gt;AsyncWaitHandle-&gt;Close();\n\n    Console::WriteLine(&quot;The call executed on thread {0}, with return value \\&quot;{1}\\&quot;.&quot;,\n        threadId, returnValue);\n}\n\n/* This example produces output similar to the following:\n\nMain thread 1 does some work.\nTest method begins.\nThe call executed on thread 3, with return value &quot;My call time was 3000.&quot;.\n */\n</code></pre><pre><code class=\"lang-cs\" name=\"AsyncDelegateExamples#3\">using System;\nusing System.Threading;\n\nnamespace Examples.AdvancedProgramming.AsynchronousOperations\n{\n    public class AsyncMain \n    {\n        static void Main() \n        {\n            // The asynchronous method puts the thread id here.\n            int threadId;\n\n            // Create an instance of the test class.\n            AsyncDemo ad = new AsyncDemo();\n\n            // Create the delegate.\n            AsyncMethodCaller caller = new AsyncMethodCaller(ad.TestMethod);\n       \n            // Initiate the asychronous call.\n            IAsyncResult result = caller.BeginInvoke(3000, \n                out threadId, null, null);\n\n            Thread.Sleep(0);\n            Console.WriteLine(&quot;Main thread {0} does some work.&quot;,\n                Thread.CurrentThread.ManagedThreadId);\n\n            // Wait for the WaitHandle to become signaled.\n            result.AsyncWaitHandle.WaitOne();\n\n            // Perform additional processing here.\n            // Call EndInvoke to retrieve the results.\n            string returnValue = caller.EndInvoke(out threadId, result);\n\n            // Close the wait handle.\n            result.AsyncWaitHandle.Close();\n\n            Console.WriteLine(&quot;The call executed on thread {0}, with return value \\&quot;{1}\\&quot;.&quot;,\n                threadId, returnValue);\n        }\n    }\n}\n\n/* This example produces output similar to the following:\n\nMain thread 1 does some work.\nTest method begins.\nThe call executed on thread 3, with return value &quot;My call time was 3000.&quot;.\n */\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>The IAsyncResult interface is implemented by classes containing methods that can operate asynchronously. It is the return type of methods that initiate an asynchronous operation, such as <a class=\"xref\" href=\"system.io.filestream#System_IO_FileStream_BeginRead_\" data-linktype=\"relative-path\">BeginRead</a>, and it is passed to methods that conclude an asynchronous operation, such as <a class=\"xref\" href=\"system.io.filestream#System_IO_FileStream_EndRead_\" data-linktype=\"relative-path\">EndRead</a>. IAsyncResult objects are also passed to methods invoked by <a class=\"xref\" href=\"system.asynccallback\" data-linktype=\"relative-path\">AsyncCallback</a> delegates when an asynchronous operation completes.  </p>\n<p> An object that supports the IAsyncResult interface stores state information for an asynchronous operation and provides a synchronization object to allow threads to be signaled when the operation completes.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The <a class=\"xref\" href=\"system.runtime.remoting.messaging.asyncresult\" data-linktype=\"relative-path\">AsyncResult</a> class is the implementation of IAsyncResult that is returned by the <code>BeginInvoke</code> method when you use a delegate to call a method asynchronously.  </p>\n</div>\n<p> For a detailed description of how the IAsyncResult interface is used, see the <a href=\"../topic/calling%20synchronous%20methods%20asynchronously\" data-linktype=\"relative-path\">Calling Synchronous Methods Asynchronously</a> topic.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Properties\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_IAsyncResult_AsyncState_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_IAsyncResult_AsyncState\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">AsyncState</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets a user-defined object that qualifies or contains information about an asynchronous operation.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public object AsyncState { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A user-defined object that qualifies or contains information about an asynchronous operation.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This property returns the object that is the last parameter of the method that initiates an asynchronous operation.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_IAsyncResult_AsyncWaitHandle_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_IAsyncResult_AsyncWaitHandle\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">AsyncWaitHandle</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> that is used to wait for an asynchronous operation to complete.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Threading.WaitHandle AsyncWaitHandle { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> that is used to wait for an asynchronous operation to complete.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The return value allows the client to wait for an asynchronous operation to complete instead of polling <a class=\"xref\" href=\"system.iasyncresult#System_IAsyncResult_IsCompleted_\" data-linktype=\"relative-path\">IsCompleted</a> until the operation concludes. The return value can be used to perform a <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a>, <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a>, or <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> operation.  </p>\n<p> The common language runtime supplies a number of waitable objects, such as <a class=\"xref\" href=\"system.threading.manualresetevent\" data-linktype=\"relative-path\">ManualResetEvent</a>, <a class=\"xref\" href=\"system.threading.autoresetevent\" data-linktype=\"relative-path\">AutoResetEvent</a>, and <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a>, all of which mirror Win32 synchronization primitives.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_IAsyncResult_CompletedSynchronously_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_IAsyncResult_CompletedSynchronously\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">CompletedSynchronously</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets a value that indicates whether the asynchronous operation completed synchronously.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public bool CompletedSynchronously { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if the asynchronous operation completed synchronously; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>If the synchronous completion of the call is detected in the <a class=\"xref\" href=\"system.asynccallback\" data-linktype=\"relative-path\">AsyncCallback</a> delegate, it is probable that the thread that initiated the asynchronous operation is the current thread.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_IAsyncResult_IsCompleted_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_IAsyncResult_IsCompleted\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">IsCompleted</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets a value that indicates whether the asynchronous operation has completed.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public bool IsCompleted { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if the operation is complete; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>When this property is <code>true</code>, you can assume it is safe to discard any resources you allocate for use by the asynchronous operation.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.IAsyncResult.yml\">\r\n<meta name=\"APIName\" content=\"System.IAsyncResult\">\r\n<meta name=\"APIName\" content=\"System.IAsyncResult.AsyncState\">\r\n<meta name=\"APIName\" content=\"System.IAsyncResult.AsyncWaitHandle\">\r\n<meta name=\"APIName\" content=\"System.IAsyncResult.CompletedSynchronously\">\r\n<meta name=\"APIName\" content=\"System.IAsyncResult.IsCompleted\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-04-01 05:59 PM\">\r\n<meta name=\"document_id\" content=\"683862bd-b368-9585-8740-2185c41baee1\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Represents the status of an asynchronous operation.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.IAsyncResult\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","uhfHeaderId":"MSDocsHeader-DotNet","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.IAsyncResult.yml","open_to_public_contributors":false,"api_name":["System.IAsyncResult","System.IAsyncResult.AsyncState","System.IAsyncResult.AsyncWaitHandle","System.IAsyncResult.CompletedSynchronously","System.IAsyncResult.IsCompleted"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.IAsyncResult","System::IAsyncResult","System.IAsyncResult.AsyncState","System::IAsyncResult::AsyncState","System.IAsyncResult.AsyncWaitHandle","System::IAsyncResult::AsyncWaitHandle","System.IAsyncResult.CompletedSynchronously","System::IAsyncResult::CompletedSynchronously","System.IAsyncResult.IsCompleted","System::IAsyncResult::IsCompleted"],"dev_langs":["csharp"],"updated_at":"2017-04-01 05:59 PM","document_id":"683862bd-b368-9585-8740-2185c41baee1","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System/IAsyncResult.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"IAsyncResult interface | Microsoft Docs","_op_ogTitle":"IAsyncResult interface","description":"Represents the status of an asynchronous operation.\n","toc_asset_id":"api/_splitted/System/toc.json","toc_rel":"_splitted/System/toc.json","source_url":"","ms.assetid":"System.IAsyncResult","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.iasyncresult","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.iasyncresult","fileRelativePath":"api/System.IAsyncResult.html"},"themesRelativePathToOutputRoot":"_themes/"}