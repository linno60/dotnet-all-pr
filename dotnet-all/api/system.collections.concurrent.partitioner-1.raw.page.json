{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">Partitioner&lt;TSource&gt;</span>\r\n    \t\t\t\tClass\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Represents a particular manner of splitting a data source into multiple partitions.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">public abstract class Partitioner&lt;TSource&gt;</code></pre>\r\n  \r\n  \r\n  \r\n  \t\t<h3 class=\"accented\">Type Parameters</h3>\r\n  \t\t<table class=\"nameValue stack\">\r\n  \t\t\t<tr>\r\n  \t\t\t<td>TSource</td>\r\n  \t\t\t<td><p>Type of the elements in the collection.</p>\n</td>\r\n  \t\t\t</tr>\r\n  \t\t</table>\r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><span class=\"lang-csharp\">Partitioner&lt;TSource&gt;</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Derived</dt><dd>\r\n  \t\t<div class=\"cdlHolder\">\r\n        \t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.concurrent.orderablepartitioner-1\" data-linktype=\"relative-path\">OrderablePartitioner&lt;TSource&gt;</a></span></div>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \t<h3 class=\"accented\">Inherited Members</h3>\r\n  \t<h4 class=\"accented\"></h4>\r\n  \t<div class=\"cdlHolder\">\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a></span></div>\r\n  \t</div>\r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following example shows how to implement a partitioner that returns a single element at a time:  </p>\n<pre><code class=\"lang-cs\" name=\"System.Collections.Concurrent.Partitioner#1\">using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Collections.Concurrent;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace PartitionerDemo\n{\n    // Simple partitioner that will extract one item at a time, in a thread-safe fashion,\n    // from the underlying collection.\n    class SingleElementPartitioner&lt;T&gt; : Partitioner&lt;T&gt;\n    {\n        // The collection being wrapped by this Partitioner\n        IEnumerable&lt;T&gt; m_referenceEnumerable;\n\n        // Internal class that serves as a shared enumerable for the\n        // underlying collection.\n        private class InternalEnumerable : IEnumerable&lt;T&gt;, IDisposable\n        {\n            IEnumerator&lt;T&gt; m_reader;\n            bool m_disposed = false;\n\n            // These two are used to implement Dispose() when static partitioning is being performed\n            int m_activeEnumerators;\n            bool m_downcountEnumerators;\n\n            // &quot;downcountEnumerators&quot; will be true for static partitioning, false for\n            // dynamic partitioning.  \n            public InternalEnumerable(IEnumerator&lt;T&gt; reader, bool downcountEnumerators)\n            {\n                m_reader = reader;\n                m_activeEnumerators = 0;\n                m_downcountEnumerators = downcountEnumerators;\n            }\n\n            public IEnumerator&lt;T&gt; GetEnumerator()\n            {\n                if (m_disposed)\n                    throw new ObjectDisposedException(&quot;InternalEnumerable: Can&#39;t call GetEnumerator() after disposing&quot;);\n\n                // For static partitioning, keep track of the number of active enumerators.\n                if (m_downcountEnumerators) Interlocked.Increment(ref m_activeEnumerators);\n\n                return new InternalEnumerator(m_reader, this);\n            }\n\n            IEnumerator IEnumerable.GetEnumerator()\n            {\n                return ((IEnumerable&lt;T&gt;)this).GetEnumerator();\n            }\n\n            public void Dispose()\n            {\n                if (!m_disposed)\n                {\n                    // Only dispose the source enumerator if you are doing dynamic partitioning\n                    if (!m_downcountEnumerators)\n                    {\n                        m_reader.Dispose();\n                    }\n                    m_disposed = true;\n                }\n            }\n\n            // Called from Dispose() method of spawned InternalEnumerator.  During\n            // static partitioning, the source enumerator will be automatically\n            // disposed once all requested InternalEnumerators have been disposed.\n            public void DisposeEnumerator()\n            {\n                if (m_downcountEnumerators)\n                {\n                    if (Interlocked.Decrement(ref m_activeEnumerators) == 0)\n                    {\n                        m_reader.Dispose();\n                    }\n                }\n            }\n        }\n\n        // Internal class that serves as a shared enumerator for \n        // the underlying collection.\n        private class InternalEnumerator : IEnumerator&lt;T&gt;\n        {\n            T m_current;\n            IEnumerator&lt;T&gt; m_source;\n            InternalEnumerable m_controllingEnumerable;\n            bool m_disposed = false;\n\n            public InternalEnumerator(IEnumerator&lt;T&gt; source, InternalEnumerable controllingEnumerable)\n            {\n                m_source = source;\n                m_current = default(T);\n                m_controllingEnumerable = controllingEnumerable;\n            }\n\n            object IEnumerator.Current\n            {\n                get { return m_current; }\n            }\n\n            T IEnumerator&lt;T&gt;.Current\n            {\n                get { return m_current; }\n            }\n\n            void IEnumerator.Reset()\n            {\n                throw new NotSupportedException(&quot;Reset() not supported&quot;);\n            }\n\n            // This method is the crux of this class.  Under lock, it calls\n            // MoveNext() on the underlying enumerator and grabs Current.\n            bool IEnumerator.MoveNext()\n            {\n                bool rval = false;\n                lock (m_source)\n                {\n                    rval = m_source.MoveNext();\n                    m_current = rval ? m_source.Current : default(T);\n                }\n                return rval;\n            }\n\n            void IDisposable.Dispose()\n            {\n                if (!m_disposed)\n                {\n                    // Delegate to parent enumerable&#39;s DisposeEnumerator() method\n                    m_controllingEnumerable.DisposeEnumerator();\n                    m_disposed = true;\n                }\n            }\n\n        }\n\n        // Constructor just grabs the collection to wrap\n        public SingleElementPartitioner(IEnumerable&lt;T&gt; enumerable)\n        {\n            // Verify that the source IEnumerable is not null\n            if (enumerable == null)\n                throw new ArgumentNullException(&quot;enumerable&quot;);\n\n            m_referenceEnumerable = enumerable;\n        }\n\n        // Produces a list of &quot;numPartitions&quot; IEnumerators that can each be\n        // used to traverse the underlying collection in a thread-safe manner.\n        // This will return a static number of enumerators, as opposed to\n        // GetDynamicPartitions(), the result of which can be used to produce\n        // any number of enumerators.\n        public override IList&lt;IEnumerator&lt;T&gt;&gt; GetPartitions(int numPartitions)\n        {\n            if (numPartitions &lt; 1)\n                throw new ArgumentOutOfRangeException(&quot;NumPartitions&quot;);\n\n            List&lt;IEnumerator&lt;T&gt;&gt; list = new List&lt;IEnumerator&lt;T&gt;&gt;(numPartitions);\n\n            // Since we are doing static partitioning, create an InternalEnumerable with reference\n            // counting of spawned InternalEnumerators turned on.  Once all of the spawned enumerators\n            // are disposed, dynamicPartitions will be disposed.\n            var dynamicPartitions = new InternalEnumerable(m_referenceEnumerable.GetEnumerator(), true);\n            for (int i = 0; i &lt; numPartitions; i++)\n                list.Add(dynamicPartitions.GetEnumerator());\n\n            return list;\n        }\n\n        // Returns an instance of our internal Enumerable class.  GetEnumerator()\n        // can then be called on that (multiple times) to produce shared enumerators.\n        public override IEnumerable&lt;T&gt; GetDynamicPartitions()\n        {\n            // Since we are doing dynamic partitioning, create an InternalEnumerable with reference\n            // counting of spawned InternalEnumerators turned off.  This returned InternalEnumerable\n            // will need to be explicitly disposed.\n            return new InternalEnumerable(m_referenceEnumerable.GetEnumerator(), false);\n        }\n\n        // Must be set to true if GetDynamicPartitions() is supported.\n        public override bool SupportsDynamicPartitions\n        {\n            get { return true; }\n        }\n    }\n\n    class Program\n    {\n        // Test our SingleElementPartitioner(T) class\n        static void Main()\n        {\n            // Our sample collection\n            string[] collection = new string[] {&quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;indigo&quot;, \n                &quot;violet&quot;, &quot;black&quot;, &quot;white&quot;, &quot;grey&quot;};\n\n            // Instantiate a partitioner for our collection\n            SingleElementPartitioner&lt;string&gt; myPart = new SingleElementPartitioner&lt;string&gt;(collection);\n\n            //\n            // Simple test with ForEach\n            //\n            Console.WriteLine(&quot;Testing with Parallel.ForEach&quot;);\n            Parallel.ForEach(myPart, item =&gt;\n            {\n                Console.WriteLine(&quot;  item = {0}, thread id = {1}&quot;, item, Thread.CurrentThread.ManagedThreadId);\n            });\n\n            //\n            //\n            // Demonstrate the use of static partitioning, which really means\n            // &quot;using a static number of partitioners&quot;.  The partitioners themselves\n            // may still be &quot;dynamic&quot; in the sense that their outputs may not be\n            // deterministic.\n            //\n            //\n\n            // Perform static partitioning of collection\n            var staticPartitions = myPart.GetPartitions(2);\n            int index = 0;\n\n            Console.WriteLine(&quot;Static Partitioning, 2 partitions, 2 tasks:&quot;);\n\n            // Action will consume from static partitions\n            Action staticAction = () =&gt;\n            {\n                int myIndex = Interlocked.Increment(ref index) - 1; // compute your index\n                var myItems = staticPartitions[myIndex]; // grab your static partition\n                int id = Thread.CurrentThread.ManagedThreadId; // cache your thread id\n\n                // Enumerate through your static partition\n                while (myItems.MoveNext())\n                {\n                    Thread.Sleep(50); // guarantees that multiple threads have a chance to run\n                    Console.WriteLine(&quot;  item = {0}, thread id = {1}&quot;, myItems.Current, Thread.CurrentThread.ManagedThreadId);\n                }\n\n                myItems.Dispose();\n            };\n\n            // Spawn off 2 actions to consume 2 static partitions\n            Parallel.Invoke(staticAction, staticAction);\n\n            //\n            //\n            // Demonstrate the use of dynamic partitioning\n            //\n            //\n\n            // Grab an IEnumerable which can then be used to generate multiple\n            // shared IEnumerables.\n            var dynamicPartitions = myPart.GetDynamicPartitions();\n\n            Console.WriteLine(&quot;Dynamic Partitioning, 3 tasks:&quot;);\n\n            // Action will consume from dynamic partitions\n            Action dynamicAction = () =&gt;\n            {\n                // Grab an enumerator from the dynamic partitions\n                var enumerator = dynamicPartitions.GetEnumerator();\n                int id = Thread.CurrentThread.ManagedThreadId; // cache our thread id\n\n                // Enumerate through your dynamic enumerator\n                while (enumerator.MoveNext())\n                {\n                    Thread.Sleep(50); // guarantees that multiple threads will have a chance to run\n                    Console.WriteLine(&quot;  item = {0}, thread id = {1}&quot;, enumerator.Current, id);\n                }\n\n                enumerator.Dispose();\n            };\n\n            // Spawn 3 concurrent actions to consume the dynamic partitions\n            Parallel.Invoke(dynamicAction, dynamicAction, dynamicAction);\n\n            // Clean up\n            if (dynamicPartitions is IDisposable)\n                ((IDisposable)dynamicPartitions).Dispose();\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Collections.Concurrent.Partitioner#1\">Imports System.Collections.Concurrent\nImports System.Threading\nImports System.Threading.Tasks\n\nModule PartitionerDemo\n    &#39; Simple partitioner that will extract one item at a time, in a thread-safe fashion,\n    &#39; from the underlying collection.\n    Class SingleElementPartitioner(Of T)\n        Inherits Partitioner(Of T)\n        &#39; The collection being wrapped by this Partitioner\n        Private m_referenceEnumerable As IEnumerable(Of T)\n\n        &#39; Internal class that serves as a shared enumerable for the\n        &#39; underlying collection.\n        Private Class InternalEnumerable\n            Implements IEnumerable(Of T)\n            Implements IDisposable\n\n            Private m_reader As IEnumerator(Of T)\n            Private m_disposed As Boolean = False\n\n            &#39; These two are used to implement Dispose() when static partitioning is being performed\n            Private m_activeEnumerators As Integer\n            Private m_downcountEnumerators As Boolean\n\n            &#39; &quot;downcountEnumerators&quot; will be true for static partitioning, false for\n            &#39; dynamic partitioning. \n            Public Sub New(ByVal reader As IEnumerator(Of T), ByVal downcountEnumerators As Boolean)\n                m_reader = reader\n                m_activeEnumerators = 0\n                m_downcountEnumerators = downcountEnumerators\n            End Sub\n\n            Public Function GetEnumerator() As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator\n                If m_disposed Then\n                    Throw New ObjectDisposedException(&quot;InternalEnumerable: Can&#39;t call GetEnumerator() after disposing&quot;)\n                End If\n\n                &#39; For static partitioning, keep track of the number of active enumerators.\n                If m_downcountEnumerators Then\n                    Interlocked.Increment(m_activeEnumerators)\n                End If\n\n                Return New InternalEnumerator(m_reader, Me)\n            End Function\n\n            Private Function GetEnumerator2() As IEnumerator Implements IEnumerable.GetEnumerator\n                Return DirectCast(Me, IEnumerable(Of T)).GetEnumerator()\n            End Function\n\n            Public Sub Dispose() Implements IDisposable.Dispose\n                If Not m_disposed Then\n                    &#39; Only dispose the source enumerator if you are doing dynamic partitioning\n                    If Not m_downcountEnumerators Then\n                        m_reader.Dispose()\n                    End If\n                    m_disposed = True\n                End If\n            End Sub\n\n            &#39; Called from Dispose() method of spawned InternalEnumerator. During\n            &#39; static partitioning, the source enumerator will be automatically\n            &#39; disposed once all requested InternalEnumerators have been disposed.\n            Public Sub DisposeEnumerator()\n                If m_downcountEnumerators Then\n                    If Interlocked.Decrement(m_activeEnumerators) = 0 Then\n                        m_reader.Dispose()\n                    End If\n                End If\n            End Sub\n        End Class\n\n        &#39; Internal class that serves as a shared enumerator for \n        &#39; the underlying collection.\n        Private Class InternalEnumerator\n            Implements IEnumerator(Of T)\n\n            Private m_current As T\n            Private m_source As IEnumerator(Of T)\n            Private m_controllingEnumerable As InternalEnumerable\n            Private m_disposed As Boolean = False\n\n            Public Sub New(ByVal source As IEnumerator(Of T), ByVal controllingEnumerable As InternalEnumerable)\n                m_source = source\n                m_current = Nothing\n                m_controllingEnumerable = controllingEnumerable\n            End Sub\n\n            Private ReadOnly Property Current2() As Object Implements IEnumerator.Current\n                Get\n                    Return m_current\n                End Get\n            End Property\n\n            Private ReadOnly Property Current() As T Implements IEnumerator(Of T).Current\n                Get\n                    Return m_current\n                End Get\n            End Property\n\n            Private Sub Reset() Implements IEnumerator.Reset\n                Throw New NotSupportedException(&quot;Reset() not supported&quot;)\n            End Sub\n\n            &#39; This method is the crux of this class. Under lock, it calls\n            &#39; MoveNext() on the underlying enumerator and grabs Current.\n            Private Function MoveNext() As Boolean Implements IEnumerator.MoveNext\n                Dim rval As Boolean = False\n                SyncLock m_source\n                    rval = m_source.MoveNext()\n                    m_current = If(rval, m_source.Current, Nothing)\n                End SyncLock\n                Return rval\n            End Function\n\n            Private Sub Dispose() Implements IDisposable.Dispose\n                If Not m_disposed Then\n                    &#39; Delegate to parent enumerable&#39;s DisposeEnumerator() method\n                    m_controllingEnumerable.DisposeEnumerator()\n                    m_disposed = True\n                End If\n            End Sub\n\n        End Class\n\n        &#39; Constructor just grabs the collection to wrap\n        Public Sub New(ByVal enumerable As IEnumerable(Of T))\n\n            &#39; Verify that the source IEnumerable is not null\n            If enumerable Is Nothing Then\n                Throw New ArgumentNullException(&quot;enumerable&quot;)\n            End If\n\n            m_referenceEnumerable = enumerable\n        End Sub\n\n        &#39; Produces a list of &quot;numPartitions&quot; IEnumerators that can each be\n        &#39; used to traverse the underlying collection in a thread-safe manner.\n        &#39; This will return a static number of enumerators, as opposed to\n        &#39; GetDynamicPartitions(), the result of which can be used to produce\n        &#39; any number of enumerators.\n        Public Overloads Overrides Function GetPartitions(ByVal numPartitions As Integer) As IList(Of IEnumerator(Of T))\n            If numPartitions &lt; 1 Then\n                Throw New ArgumentOutOfRangeException(&quot;NumPartitions&quot;)\n            End If\n\n            Dim list As New List(Of IEnumerator(Of T))(numPartitions)\n\n            &#39; Since we are doing static partitioning, create an InternalEnumerable with reference\n            &#39; counting of spawned InternalEnumerators turned on. Once all of the spawned enumerators\n            &#39; are disposed, dynamicPartitions will be disposed.\n            Dim dynamicPartitions = New InternalEnumerable(m_referenceEnumerable.GetEnumerator(), True)\n            For i As Integer = 0 To numPartitions - 1\n                list.Add(dynamicPartitions.GetEnumerator())\n            Next\n\n            Return list\n        End Function\n\n        &#39; Returns an instance of our internal Enumerable class. GetEnumerator()\n        &#39; can then be called on that (multiple times) to produce shared enumerators.\n        Public Overloads Overrides Function GetDynamicPartitions() As IEnumerable(Of T)\n            &#39; Since we are doing dynamic partitioning, create an InternalEnumerable with reference\n            &#39; counting of spawned InternalEnumerators turned off. This returned InternalEnumerable\n            &#39; will need to be explicitly disposed.\n            Return New InternalEnumerable(m_referenceEnumerable.GetEnumerator(), False)\n        End Function\n\n        &#39; Must be set to true if GetDynamicPartitions() is supported.\n        Public Overloads Overrides ReadOnly Property SupportsDynamicPartitions() As Boolean\n            Get\n                Return True\n            End Get\n        End Property\n    End Class\n\n    Class Program\n        &#39; Test our SingleElementPartitioner(T) class\n        Shared Sub Main()\n            &#39; Our sample collection\n            Dim collection As String() = New String() {&quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;indigo&quot;, _\n            &quot;violet&quot;, &quot;black&quot;, &quot;white&quot;, &quot;grey&quot;}\n\n            &#39; Instantiate a partitioner for our collection\n            Dim myPart As New SingleElementPartitioner(Of String)(Collection)\n\n            &#39;\n            &#39; Simple test with ForEach\n            &#39;\n            Console.WriteLine(&quot;Testing with Parallel.ForEach&quot;)\n            Parallel.ForEach(myPart,\n                             Sub(item)\n                                 Console.WriteLine(&quot; item = {0}, thread id = {1}&quot;, item, Thread.CurrentThread.ManagedThreadId)\n                             End Sub)\n\n            &#39;\n            &#39;\n            &#39; Demonstrate the use of static partitioning, which really means\n            &#39; &quot;using a static number of partitioners&quot;. The partitioners themselves\n            &#39; may still be &quot;dynamic&quot; in the sense that their outputs may not be\n            &#39; deterministic.\n            &#39;\n            &#39;\n\n            &#39; Perform static partitioning of collection\n            Dim staticPartitions = myPart.GetPartitions(2)\n            Dim index As Integer = 0\n\n            Console.WriteLine(&quot;Static Partitioning, 2 partitions, 2 tasks:&quot;)\n\n            &#39; Action will consume from static partitions\n            Dim staticAction As Action =\n                Sub()\n                    Dim myIndex As Integer = Interlocked.Increment(index) - 1\n                    &#39; compute your index\n                    Dim myItems = staticPartitions(myIndex)\n                    &#39; grab your static partition\n                    Dim id As Integer = Thread.CurrentThread.ManagedThreadId\n                    &#39; cache your thread id\n                    &#39; Enumerate through your static partition\n                    While myItems.MoveNext()\n                        Thread.Sleep(50)\n                        &#39; guarantees that multiple threads have a chance to run\n                        Console.WriteLine(&quot; item = {0}, thread id = {1}&quot;, myItems.Current, Thread.CurrentThread.ManagedThreadId)\n                    End While\n\n                    myItems.Dispose()\n                End Sub\n\n            &#39; Spawn off 2 actions to consume 2 static partitions\n            Parallel.Invoke(staticAction, staticAction)\n\n            &#39;\n            &#39;\n            &#39; Demonstrate the use of dynamic partitioning\n            &#39;\n            &#39;\n\n            &#39; Grab an IEnumerable which can then be used to generate multiple\n            &#39; shared IEnumerables.\n            Dim dynamicPartitions = myPart.GetDynamicPartitions()\n\n            Console.WriteLine(&quot;Dynamic Partitioning, 3 tasks:&quot;)\n\n            &#39; Action will consume from dynamic partitions\n            Dim dynamicAction As Action =\n                Sub()\n                    &#39; Grab an enumerator from the dynamic partitioner\n                    Dim enumerator = dynamicPartitions.GetEnumerator()\n                    Dim id As Integer = Thread.CurrentThread.ManagedThreadId\n                    &#39; cache our thread id\n                    &#39; Enumerate through your dynamic enumerator\n                    While enumerator.MoveNext()\n                        Thread.Sleep(50)\n                        &#39; guarantees that multiple threads will have a chance to run\n                        Console.WriteLine(&quot; item = {0}, thread id = {1}&quot;, enumerator.Current, id)\n                    End While\n\n                    enumerator.Dispose()\n                End Sub\n\n            &#39; Spawn 3 concurrent actions to consume the dynamic partitions\n            Parallel.Invoke(dynamicAction, dynamicAction, dynamicAction)\n\n            &#39; Clean up\n            If TypeOf dynamicPartitions Is IDisposable Then\n                DirectCast(dynamicPartitions, IDisposable).Dispose()\n            End If\n        End Sub\n    End Class\n\nEnd Module\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>For more information, see <a href=\"../topic/custom%20partitioners%20for%20plinq%20and%20tpl\" data-linktype=\"relative-path\">Custom Partitioners for PLINQ and TPL</a>.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Constructors\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_Concurrent_Partitioner_1__ctor_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_Concurrent_Partitioner_1__ctor\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Partitioner&lt;TSource&gt;()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Creates a new partitioner instance.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">protected Partitioner ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Properties\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_Concurrent_Partitioner_1_SupportsDynamicPartitions_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_Concurrent_Partitioner_1_SupportsDynamicPartitions\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">SupportsDynamicPartitions</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets whether additional partitions can be created dynamically.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public virtual bool SupportsDynamicPartitions { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>true if the <span class=\"xref\">stem.Collections.Concurrent.Partitioner`1</span> can create partitions dynamically as they are requested; false if the <span class=\"xref\">stem.Collections.Concurrent.Partitioner`1</span> can only allocate partitions statically.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>If a derived class does not override and implement <a class=\"xref\" href=\"system.collections.concurrent.partitioner-1#System_Collections_Concurrent_Partitioner_1_GetDynamicPartitions_\" data-linktype=\"relative-path\">GetDynamicPartitions</a>, SupportsDynamicPartitions should return false. The value of SupportsDynamicPartitions should not vary over the lifetime of this instance. For more information, see <a href=\"../topic/custom%20partitioners%20for%20plinq%20and%20tpl\" data-linktype=\"relative-path\">Custom Partitioners for PLINQ and TPL</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Methods\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_Concurrent_Partitioner_1_GetDynamicPartitions_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_Concurrent_Partitioner_1_GetDynamicPartitions\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">GetDynamicPartitions()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Creates an object that can partition the underlying collection into a variable number of partitions.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public virtual System.Collections.Generic.IEnumerable&lt;TSource&gt; GetDynamicPartitions ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable</a>&lt;<span class=\"xref\">TSource</span>&gt;</span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>An object that can create partitions over the underlying data source.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>Dynamic partitioning is not supported by the base class. You must implement it in a derived class.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The returned object implements the <a class=\"xref\" href=\"system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">System.Collections.Generic.IEnumerable&lt;T&gt;</a>interface. Calling <a class=\"xref\" href=\"system.collections.generic.ienumerable-1#System_Collections_Generic_IEnumerable_1_GetEnumerator_\" data-linktype=\"relative-path\">GetEnumerator</a> on the object creates another partition over the sequence.  </p>\n<p> The GetDynamicPartitions method is only supported if the <a class=\"xref\" href=\"system.collections.concurrent.partitioner-1#System_Collections_Concurrent_Partitioner_1_SupportsDynamicPartitions_\" data-linktype=\"relative-path\">SupportsDynamicPartitions</a> property returns true. For more information, see <a href=\"../topic/custom%20partitioners%20for%20plinq%20and%20tpl\" data-linktype=\"relative-path\">Custom Partitioners for PLINQ and TPL</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_Concurrent_Partitioner_1_GetPartitions_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_Concurrent_Partitioner_1_GetPartitions_System_Int32_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">GetPartitions(Int32)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Partitions the underlying collection into the given number of partitions.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public abstract System.Collections.Generic.IList&lt;System.Collections.Generic.IEnumerator&lt;TSource&gt;&gt; GetPartitions (int partitionCount);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>partitionCount</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The number of partitions to create.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.generic.ilist-1\" data-linktype=\"relative-path\">IList</a>&lt;<a class=\"xref\" href=\"system.collections.generic.ienumerator-1\" data-linktype=\"relative-path\">IEnumerator</a>&lt;<span class=\"xref\">TSource</span>&gt;&gt;</span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>A list containing <code>partitionCount</code> enumerators.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>A class that implements this method is expected to return exactly the number of partitions that are specified in <code>partitionCount</code>. If a partition contains no elements, then return an empty enumerator rather than null (Nothing in Visual Basic). For more information, see <a href=\"../topic/custom%20partitioners%20for%20plinq%20and%20tpl\" data-linktype=\"relative-path\">Custom Partitioners for PLINQ and TPL</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \t<h2 class=\"accented\">Thread Safety</h2>\r\n  \tThe static methods on Partitioner(TSource) are all thread-safe and may be used concurrently from multiple threads. However, while a created partitioner is in use, the underlying data source should not be modified, whether from the same thread that is using a partitioner or from a separate thread.\r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Collections.Concurrent.Partitioner-1.yml\">\r\n<meta name=\"APIName\" content=\"System.Collections.Concurrent.Partitioner&lt;TSource&gt;\">\r\n<meta name=\"APIName\" content=\"System.Collections.Concurrent.Partitioner&lt;TSource&gt;..ctor\">\r\n<meta name=\"APIName\" content=\"System.Collections.Concurrent.Partitioner&lt;TSource&gt;.GetDynamicPartitions\">\r\n<meta name=\"APIName\" content=\"System.Collections.Concurrent.Partitioner&lt;TSource&gt;.GetPartitions\">\r\n<meta name=\"APIName\" content=\"System.Collections.Concurrent.Partitioner&lt;TSource&gt;.SupportsDynamicPartitions\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-31 02:21 PM\">\r\n<meta name=\"document_id\" content=\"399dab4a-586a-df6d-af47-31aacdd34a4e\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Represents a particular manner of splitting a data source into multiple partitions.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.collections.concurrent/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Collections.Concurrent.Partitioner`1\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Collections.Concurrent.Partitioner-1.yml","open_to_public_contributors":false,"api_name":["System.Collections.Concurrent.Partitioner<TSource>","System.Collections.Concurrent.Partitioner<TSource>..ctor","System.Collections.Concurrent.Partitioner<TSource>.GetDynamicPartitions","System.Collections.Concurrent.Partitioner<TSource>.GetPartitions","System.Collections.Concurrent.Partitioner<TSource>.SupportsDynamicPartitions"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Collections.Concurrent.Partitioner`1","System::Collections::Concurrent::Partitioner`1","System.Collections.Concurrent.Partitioner`1.#ctor","System::Collections::Concurrent::Partitioner`1::#ctor","System.Collections.Concurrent.Partitioner`1.GetDynamicPartitions","System::Collections::Concurrent::Partitioner`1::GetDynamicPartitions","System.Collections.Concurrent.Partitioner`1.GetPartitions","System::Collections::Concurrent::Partitioner`1::GetPartitions","System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions","System::Collections::Concurrent::Partitioner`1::SupportsDynamicPartitions"],"dev_langs":["csharp"],"updated_at":"2017-03-31 02:21 PM","document_id":"399dab4a-586a-df6d-af47-31aacdd34a4e","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Collections.Concurrent/Partitioner`1.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"Partitioner<TSource> class | Microsoft Docs","_op_ogTitle":"Partitioner<TSource> class","description":"Represents a particular manner of splitting a data source into multiple partitions.\n","toc_asset_id":"api/_splitted/System.Collections.Concurrent/toc.json","toc_rel":"_splitted/System.Collections.Concurrent/toc.json","source_url":"","ms.assetid":"System.Collections.Concurrent.Partitioner`1","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent.partitioner-1","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent.partitioner-1","fileRelativePath":"api/System.Collections.Concurrent.Partitioner-1.html"},"themesRelativePathToOutputRoot":"_themes/"}