{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">PublicKey</span>\r\n    \t\t\t\tClass\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Represents a certificate&#39;s public key information. This class cannot be inherited.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">public sealed class PublicKey</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><span class=\"lang-csharp\">PublicKey</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \r\n  \t<h3 class=\"accented\">Inherited Members</h3>\r\n  \t<h4 class=\"accented\"></h4>\r\n  \t<div class=\"cdlHolder\">\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a></span></div>\r\n  \t</div>\r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following example demonstrates how to use the public key from a <a class=\"xref\" href=\"system.security.cryptography.x509certificates.x509certificate2\" data-linktype=\"relative-path\">X509Certificate2</a> object to encrypt a file. It also shows how to decrypt the encrypted file using the private key for that certificate.  </p>\n<pre><code class=\"lang-vb\" name=\"X509Certificate2#1\">Imports System\nImports System.Security.Cryptography\nImports System.Security.Cryptography.X509Certificates\nImports System.IO\nImports System.Text\n\n\n&#39; To run this sample use the Certificate Creation Tool (Makecert.exe) to generate a test X.509 certificate and \n&#39; place it in the local user store. \n&#39; To generate an exchange key and make the key exportable run the following command from a Visual Studio command prompt: \n&#39;makecert -r -pe -n &quot;CN=CERT_SIGN_TEST_CERT&quot; -b 01/01/2010 -e 01/01/2012 -sky exchange -ss my\n\nClass Program\n\n    &#39; Path variables for source, encryption, and\n    &#39; decryption folders. Must end with a backslash.\n    Private Shared encrFolder As String = &quot;C:\\Encrypt\\&quot;\n    Private Shared decrFolder As String = &quot;C:\\Decrypt\\&quot;\n    Private Shared originalFile As String = &quot;TestData.txt&quot;\n    Private Shared encryptedFile As String = &quot;TestData.enc&quot;\n\n\n    Shared Sub Main(ByVal args() As String)\n\n        &#39; Create an input file with test data.\n        Dim sw As StreamWriter = File.CreateText(originalFile)\n        sw.WriteLine(&quot;Test data to be encrypted&quot;)\n        sw.Close()\n\n        &#39; Get the certifcate to use to encrypt the key.\n        Dim cert As X509Certificate2 = GetCertificateFromStore(&quot;CN=CERT_SIGN_TEST_CERT&quot;)\n        If cert Is Nothing Then\n            Console.WriteLine(&quot;Certificatge &#39;CN=CERT_SIGN_TEST_CERT&#39; not found.&quot;)\n            Console.ReadLine()\n        End If\n\n\n        &#39; Encrypt the file using the public key from the certificate.\n        EncryptFile(originalFile, CType(cert.PublicKey.Key, RSACryptoServiceProvider))\n\n        &#39; Decrypt the file using the private key from the certificate.\n        DecryptFile(encryptedFile, CType(cert.PrivateKey, RSACryptoServiceProvider))\n\n        &#39;Display the original data and the decrypted data.\n        Console.WriteLine(&quot;Original:   {0}&quot;, File.ReadAllText(originalFile))\n        Console.WriteLine(&quot;Round Trip: {0}&quot;, File.ReadAllText(decrFolder + originalFile))\n        Console.WriteLine(&quot;Press the Enter key to exit.&quot;)\n        Console.ReadLine()\n\n    End Sub &#39;Main\n\n    Private Shared Function GetCertificateFromStore(ByVal certName As String) As X509Certificate2\n        &#39; Get the certificate store for the current user.\n        Dim store As New X509Store(StoreLocation.CurrentUser)\n        Try\n            store.Open(OpenFlags.ReadOnly)\n\n            &#39; Place all certificates in an X509Certificate2Collection object.\n            Dim certCollection As X509Certificate2Collection = store.Certificates\n            &#39; If using a certificate with a trusted root you do not need to FindByTimeValid, instead use:\n            &#39; currentCerts.Find(X509FindType.FindBySubjectDistinguishedName, certName, true);\n            Dim currentCerts As X509Certificate2Collection = certCollection.Find(X509FindType.FindByTimeValid, DateTime.Now, False)\n            Dim signingCert As X509Certificate2Collection = currentCerts.Find(X509FindType.FindBySubjectDistinguishedName, certName, False)\n            If signingCert.Count = 0 Then\n                Return Nothing\n            End If &#39; Return the first certificate in the collection, has the right name and is current.\n            Return signingCert(0)\n        Finally\n            store.Close()\n        End Try\n\n\n    End Function &#39;GetCertificateFromStore\n\n    &#39; Encrypt a file using a public key.\n    Private Shared Sub EncryptFile(ByVal inFile As String, ByVal rsaPublicKey As RSACryptoServiceProvider)\n        Dim aesManaged As New AesManaged()\n        Try\n            &#39; Create instance of AesManaged for\n            &#39; symetric encryption of the data.\n            aesManaged.KeySize = 256\n            aesManaged.BlockSize = 128\n            aesManaged.Mode = CipherMode.CBC\n            Dim transform As ICryptoTransform = aesManaged.CreateEncryptor()\n            Try\n                Dim keyFormatter As New RSAPKCS1KeyExchangeFormatter(rsaPublicKey)\n                Dim keyEncrypted As Byte() = keyFormatter.CreateKeyExchange(aesManaged.Key, aesManaged.GetType())\n\n                &#39; Create byte arrays to contain\n                &#39; the length values of the key and IV.\n                Dim LenK(3) As Byte\n                Dim LenIV(3) As Byte\n\n                Dim lKey As Integer = keyEncrypted.Length\n                LenK = BitConverter.GetBytes(lKey)\n                Dim lIV As Integer = aesManaged.IV.Length\n                LenIV = BitConverter.GetBytes(lIV)\n\n                &#39; Write the following to the FileStream\n                &#39; for the encrypted file (outFs):\n                &#39; - length of the key\n                &#39; - length of the IV\n                &#39; - ecrypted key\n                &#39; - the IV\n                &#39; - the encrypted cipher content\n                Dim startFileName As Integer = inFile.LastIndexOf(&quot;\\&quot;) + 1\n                &#39; Change the file&#39;s extension to &quot;.enc&quot;\n                Dim outFile As String = encrFolder + inFile.Substring(startFileName, inFile.LastIndexOf(&quot;.&quot;) - startFileName) + &quot;.enc&quot;\n                Directory.CreateDirectory(encrFolder)\n\n                Dim outFs As New FileStream(outFile, FileMode.Create)\n                Try\n\n                    outFs.Write(LenK, 0, 4)\n                    outFs.Write(LenIV, 0, 4)\n                    outFs.Write(keyEncrypted, 0, lKey)\n                    outFs.Write(aesManaged.IV, 0, lIV)\n\n                    &#39; Now write the cipher text using\n                    &#39; a CryptoStream for encrypting.\n                    Dim outStreamEncrypted As New CryptoStream(outFs, transform, CryptoStreamMode.Write)\n                    Try\n\n                        &#39; By encrypting a chunk at\n                        &#39; a time, you can save memory\n                        &#39; and accommodate large files.\n                        Dim count As Integer = 0\n                        Dim offset As Integer = 0\n\n                        &#39; blockSizeBytes can be any arbitrary size.\n                        Dim blockSizeBytes As Integer = aesManaged.BlockSize / 8\n                        Dim data(blockSizeBytes) As Byte\n                        Dim bytesRead As Integer = 0\n\n                        Dim inFs As New FileStream(inFile, FileMode.Open)\n                        Try\n                            Do\n                                count = inFs.Read(data, 0, blockSizeBytes)\n                                offset += count\n                                outStreamEncrypted.Write(data, 0, count)\n                                bytesRead += blockSizeBytes\n                            Loop While count &gt; 0\n                            inFs.Close()\n                        Finally\n                            inFs.Dispose()\n                        End Try\n                        outStreamEncrypted.FlushFinalBlock()\n                        outStreamEncrypted.Close()\n                    Finally\n                        outStreamEncrypted.Dispose()\n                    End Try\n                    outFs.Close()\n                Finally\n                    outFs.Dispose()\n                End Try\n            Finally\n                transform.Dispose()\n            End Try\n        Finally\n            aesManaged.Dispose()\n        End Try\n\n    End Sub &#39;EncryptFile\n\n\n    &#39; Decrypt a file using a private key.\n    Private Shared Sub DecryptFile(ByVal inFile As String, ByVal rsaPrivateKey As RSACryptoServiceProvider)\n\n        &#39; Create instance of AesManaged for\n        &#39; symetric decryption of the data.\n        Dim aesManaged As New AesManaged()\n        Try\n            aesManaged.KeySize = 256\n            aesManaged.BlockSize = 128\n            aesManaged.Mode = CipherMode.CBC\n\n            &#39; Create byte arrays to get the length of\n            &#39; the encrypted key and IV.\n            &#39; These values were stored as 4 bytes each\n            &#39; at the beginning of the encrypted package.\n            Dim LenK() As Byte = New Byte(4 - 1) {}\n            Dim LenIV() As Byte = New Byte(4 - 1) {}\n\n            &#39; Consruct the file name for the decrypted file.\n            Dim outFile As String = decrFolder + inFile.Substring(0, inFile.LastIndexOf(&quot;.&quot;)) + &quot;.txt&quot;\n\n            &#39; Use FileStream objects to read the encrypted\n            &#39; file (inFs) and save the decrypted file (outFs).\n            Dim inFs As New FileStream(encrFolder + inFile, FileMode.Open)\n            Try\n\n                inFs.Seek(0, SeekOrigin.Begin)\n                inFs.Seek(0, SeekOrigin.Begin)\n                inFs.Read(LenK, 0, 3)\n                inFs.Seek(4, SeekOrigin.Begin)\n                inFs.Read(LenIV, 0, 3)\n\n                &#39; Convert the lengths to integer values.\n                Dim lengthK As Integer = BitConverter.ToInt32(LenK, 0)\n                Dim lengthIV As Integer = BitConverter.ToInt32(LenIV, 0)\n\n                &#39; Determine the start postition of\n                &#39; the ciphter text (startC)\n                &#39; and its length(lenC).\n                Dim startC As Integer = lengthK + lengthIV + 8\n                Dim lenC As Integer = (CType(inFs.Length, Integer) - startC)\n\n                &#39; Create the byte arrays for\n                &#39; the encrypted Rijndael key,\n                &#39; the IV, and the cipher text.\n                Dim KeyEncrypted() As Byte = New Byte(lengthK - 1) {}\n                Dim IV() As Byte = New Byte(lengthIV - 1) {}\n\n                &#39; Extract the key and IV\n                &#39; starting from index 8\n                &#39; after the length values.\n                inFs.Seek(8, SeekOrigin.Begin)\n                inFs.Read(KeyEncrypted, 0, lengthK)\n                inFs.Seek(8 + lengthK, SeekOrigin.Begin)\n                inFs.Read(IV, 0, lengthIV)\n                Directory.CreateDirectory(decrFolder)\n                &#39; Use RSACryptoServiceProvider\n                &#39; to decrypt the Rijndael key.\n                Dim KeyDecrypted As Byte() = rsaPrivateKey.Decrypt(KeyEncrypted, False)\n\n                &#39; Decrypt the key.\n                Dim transform As ICryptoTransform = aesManaged.CreateDecryptor(KeyDecrypted, IV)\n                &#39; Decrypt the cipher text from\n                &#39; from the FileSteam of the encrypted\n                &#39; file (inFs) into the FileStream\n                &#39; for the decrypted file (outFs).\n                Dim outFs As New FileStream(outFile, FileMode.Create)\n                Try\n                    &#39; Decrypt the cipher text from\n                    &#39; from the FileSteam of the encrypted\n                    &#39; file (inFs) into the FileStream\n                    &#39; for the decrypted file (outFs).\n\n                    Dim count As Integer = 0\n                    Dim offset As Integer = 0\n\n                    Dim blockSizeBytes As Integer = aesManaged.BlockSize / 8\n                    Dim data(blockSizeBytes) As Byte\n\n                    &#39; By decrypting a chunk a time,\n                    &#39; you can save memory and\n                    &#39; accommodate large files.\n                    &#39; Start at the beginning\n                    &#39; of the cipher text.\n                    inFs.Seek(startC, SeekOrigin.Begin)\n                    Dim outStreamDecrypted As New CryptoStream(outFs, transform, CryptoStreamMode.Write)\n                    Try\n                        Do\n                            count = inFs.Read(data, 0, blockSizeBytes)\n                            offset += count\n                            outStreamDecrypted.Write(data, 0, count)\n                        Loop While count &gt; 0\n\n                        outStreamDecrypted.FlushFinalBlock()\n                        outStreamDecrypted.Close()\n                    Finally\n                        outStreamDecrypted.Dispose()\n                    End Try\n                    outFs.Close()\n                Finally\n                    outFs.Dispose()\n                End Try\n                inFs.Close()\n\n            Finally\n                inFs.Dispose()\n\n            End Try\n\n        Finally\n            aesManaged.Dispose()\n        End Try\n\n\n    End Sub &#39;DecryptFile \nEnd Class &#39;Program\n</code></pre><pre><code class=\"lang-cs\" name=\"X509Certificate2#1\">using System;\nusing System.Security.Cryptography;\nusing System.Security.Cryptography.X509Certificates;\nusing System.IO;\nusing System.Text;\n\n// To run this sample use the Certificate Creation Tool (Makecert.exe) to generate a test X.509 certificate and \n// place it in the local user store. \n// To generate an exchange key and make the key exportable run the following command from a Visual Studio command prompt: \n\n//makecert -r -pe -n &quot;CN=CERT_SIGN_TEST_CERT&quot; -b 01/01/2010 -e 01/01/2012 -sky exchange -ss my\nnamespace X509CertEncrypt\n{\n    class Program\n    {\n\n        // Path variables for source, encryption, and\n        // decryption folders. Must end with a backslash.\n        private static string encrFolder = @&quot;C:\\Encrypt\\&quot;;\n        private static string decrFolder = @&quot;C:\\Decrypt\\&quot;;\n        private static string originalFile = &quot;TestData.txt&quot;;\n        private static string encryptedFile = &quot;TestData.enc&quot;;\n\n        static void Main(string[] args)\n        {\n\n            // Create an input file with test data.\n            StreamWriter sw = File.CreateText(originalFile);\n            sw.WriteLine(&quot;Test data to be encrypted&quot;);\n            sw.Close();\n\n            // Get the certifcate to use to encrypt the key.\n            X509Certificate2 cert = GetCertificateFromStore(&quot;CN=CERT_SIGN_TEST_CERT&quot;);\n            if (cert == null)\n            {\n                Console.WriteLine(&quot;Certificatge &#39;CN=CERT_SIGN_TEST_CERT&#39; not found.&quot;);\n                Console.ReadLine();\n            }\n\n\n            // Encrypt the file using the public key from the certificate.\n            EncryptFile(originalFile, (RSACryptoServiceProvider)cert.PublicKey.Key);\n\n            // Decrypt the file using the private key from the certificate.\n            DecryptFile(encryptedFile, (RSACryptoServiceProvider)cert.PrivateKey);\n\n            //Display the original data and the decrypted data.\n            Console.WriteLine(&quot;Original:   {0}&quot;, File.ReadAllText(originalFile));\n            Console.WriteLine(&quot;Round Trip: {0}&quot;, File.ReadAllText(decrFolder + originalFile));\n            Console.WriteLine(&quot;Press the Enter key to exit.&quot;);\n            Console.ReadLine();\n        }\n        private static X509Certificate2 GetCertificateFromStore(string certName)\n        {\n\n            // Get the certificate store for the current user.\n            X509Store store = new X509Store(StoreLocation.CurrentUser);\n            try\n            {\n                store.Open(OpenFlags.ReadOnly);\n\n                // Place all certificates in an X509Certificate2Collection object.\n                X509Certificate2Collection certCollection = store.Certificates;\n                // If using a certificate with a trusted root you do not need to FindByTimeValid, instead:\n                // currentCerts.Find(X509FindType.FindBySubjectDistinguishedName, certName, true);\n                X509Certificate2Collection currentCerts = certCollection.Find(X509FindType.FindByTimeValid, DateTime.Now, false);\n                X509Certificate2Collection signingCert = currentCerts.Find(X509FindType.FindBySubjectDistinguishedName, certName, false);\n                if (signingCert.Count == 0)\n                    return null;\n                // Return the first certificate in the collection, has the right name and is current.\n                return signingCert[0];\n            }\n            finally\n            {\n                store.Close();\n            }\n\n        }\n\n        // Encrypt a file using a public key.\n        private static void EncryptFile(string inFile, RSACryptoServiceProvider rsaPublicKey)\n        {\n            using (AesManaged aesManaged = new AesManaged())\n            {\n                // Create instance of AesManaged for\n                // symetric encryption of the data.\n                aesManaged.KeySize = 256;\n                aesManaged.BlockSize = 128;\n                aesManaged.Mode = CipherMode.CBC;\n                using (ICryptoTransform transform = aesManaged.CreateEncryptor())\n                {\n                    RSAPKCS1KeyExchangeFormatter keyFormatter = new RSAPKCS1KeyExchangeFormatter(rsaPublicKey);\n                    byte[] keyEncrypted = keyFormatter.CreateKeyExchange(aesManaged.Key, aesManaged.GetType());\n\n                    // Create byte arrays to contain\n                    // the length values of the key and IV.\n                    byte[] LenK = new byte[4];\n                    byte[] LenIV = new byte[4];\n\n                    int lKey = keyEncrypted.Length;\n                    LenK = BitConverter.GetBytes(lKey);\n                    int lIV = aesManaged.IV.Length;\n                    LenIV = BitConverter.GetBytes(lIV);\n\n                    // Write the following to the FileStream\n                    // for the encrypted file (outFs):\n                    // - length of the key\n                    // - length of the IV\n                    // - ecrypted key\n                    // - the IV\n                    // - the encrypted cipher content\n\n                    int startFileName = inFile.LastIndexOf(&quot;\\\\&quot;) + 1;\n                    // Change the file&#39;s extension to &quot;.enc&quot;\n                    string outFile = encrFolder + inFile.Substring(startFileName, inFile.LastIndexOf(&quot;.&quot;) - startFileName) + &quot;.enc&quot;;\n                    Directory.CreateDirectory(encrFolder);\n\n                    using (FileStream outFs = new FileStream(outFile, FileMode.Create))\n                    {\n\n                        outFs.Write(LenK, 0, 4);\n                        outFs.Write(LenIV, 0, 4);\n                        outFs.Write(keyEncrypted, 0, lKey);\n                        outFs.Write(aesManaged.IV, 0, lIV);\n\n                        // Now write the cipher text using\n                        // a CryptoStream for encrypting.\n                        using (CryptoStream outStreamEncrypted = new CryptoStream(outFs, transform, CryptoStreamMode.Write))\n                        {\n\n                            // By encrypting a chunk at\n                            // a time, you can save memory\n                            // and accommodate large files.\n                            int count = 0;\n                            int offset = 0;\n\n                            // blockSizeBytes can be any arbitrary size.\n                            int blockSizeBytes = aesManaged.BlockSize / 8;\n                            byte[] data = new byte[blockSizeBytes];\n                            int bytesRead = 0;\n\n                            using (FileStream inFs = new FileStream(inFile, FileMode.Open))\n                            {\n                                do\n                                {\n                                    count = inFs.Read(data, 0, blockSizeBytes);\n                                    offset += count;\n                                    outStreamEncrypted.Write(data, 0, count);\n                                    bytesRead += blockSizeBytes;\n                                }\n                                while (count &gt; 0);\n                                inFs.Close();\n                            }\n                            outStreamEncrypted.FlushFinalBlock();\n                            outStreamEncrypted.Close();\n                        }\n                        outFs.Close();\n                    }\n                }\n            }\n        }\n\n\n        // Decrypt a file using a private key.\n        private static void DecryptFile(string inFile, RSACryptoServiceProvider rsaPrivateKey)\n        {\n\n            // Create instance of AesManaged for\n            // symetric decryption of the data.\n            using (AesManaged aesManaged = new AesManaged())\n            {\n                aesManaged.KeySize = 256;\n                aesManaged.BlockSize = 128;\n                aesManaged.Mode = CipherMode.CBC;\n\n                // Create byte arrays to get the length of\n                // the encrypted key and IV.\n                // These values were stored as 4 bytes each\n                // at the beginning of the encrypted package.\n                byte[] LenK = new byte[4];\n                byte[] LenIV = new byte[4];\n\n                // Consruct the file name for the decrypted file.\n                string outFile = decrFolder + inFile.Substring(0, inFile.LastIndexOf(&quot;.&quot;)) + &quot;.txt&quot;;\n\n                // Use FileStream objects to read the encrypted\n                // file (inFs) and save the decrypted file (outFs).\n                using (FileStream inFs = new FileStream(encrFolder + inFile, FileMode.Open))\n                {\n\n                    inFs.Seek(0, SeekOrigin.Begin);\n                    inFs.Seek(0, SeekOrigin.Begin);\n                    inFs.Read(LenK, 0, 3);\n                    inFs.Seek(4, SeekOrigin.Begin);\n                    inFs.Read(LenIV, 0, 3);\n\n                    // Convert the lengths to integer values.\n                    int lenK = BitConverter.ToInt32(LenK, 0);\n                    int lenIV = BitConverter.ToInt32(LenIV, 0);\n\n                    // Determine the start postition of\n                    // the ciphter text (startC)\n                    // and its length(lenC).\n                    int startC = lenK + lenIV + 8;\n                    int lenC = (int)inFs.Length - startC;\n\n                    // Create the byte arrays for\n                    // the encrypted AesManaged key,\n                    // the IV, and the cipher text.\n                    byte[] KeyEncrypted = new byte[lenK];\n                    byte[] IV = new byte[lenIV];\n\n                    // Extract the key and IV\n                    // starting from index 8\n                    // after the length values.\n                    inFs.Seek(8, SeekOrigin.Begin);\n                    inFs.Read(KeyEncrypted, 0, lenK);\n                    inFs.Seek(8 + lenK, SeekOrigin.Begin);\n                    inFs.Read(IV, 0, lenIV);\n                    Directory.CreateDirectory(decrFolder);\n                    // Use RSACryptoServiceProvider\n                    // to decrypt the AesManaged key.\n                    byte[] KeyDecrypted = rsaPrivateKey.Decrypt(KeyEncrypted, false);\n\n                    // Decrypt the key.\n                    using (ICryptoTransform transform = aesManaged.CreateDecryptor(KeyDecrypted, IV))\n                    {\n\n                        // Decrypt the cipher text from\n                        // from the FileSteam of the encrypted\n                        // file (inFs) into the FileStream\n                        // for the decrypted file (outFs).\n                        using (FileStream outFs = new FileStream(outFile, FileMode.Create))\n                        {\n\n                            int count = 0;\n                            int offset = 0;\n\n                            int blockSizeBytes = aesManaged.BlockSize / 8;\n                            byte[] data = new byte[blockSizeBytes];\n\n                            // By decrypting a chunk a time,\n                            // you can save memory and\n                            // accommodate large files.\n\n                            // Start at the beginning\n                            // of the cipher text.\n                            inFs.Seek(startC, SeekOrigin.Begin);\n                            using (CryptoStream outStreamDecrypted = new CryptoStream(outFs, transform, CryptoStreamMode.Write))\n                            {\n                                do\n                                {\n                                    count = inFs.Read(data, 0, blockSizeBytes);\n                                    offset += count;\n                                    outStreamDecrypted.Write(data, 0, count);\n\n                                }\n                                while (count &gt; 0);\n\n                                outStreamDecrypted.FlushFinalBlock();\n                                outStreamDecrypted.Close();\n                            }\n                            outFs.Close();\n                        }\n                        inFs.Close();\n                    }\n\n                }\n\n            }\n        }\n\n    }\n}\n</code></pre><p> The following example creates a command-line executable that takes a certificate file as an argument and prints various certificate properties to the console.  </p>\n<pre><code class=\"lang-cpp\" name=\"CertInfo#1\">#using &lt;System.dll&gt;\n\nusing namespace System;\nusing namespace System::Security::Cryptography;\nusing namespace System::Security::Permissions;\nusing namespace System::IO;\nusing namespace System::Security::Cryptography::X509Certificates;\n\n//Reads a file.\narray&lt;Byte&gt;^ ReadFile( String^ fileName )\n{\n   FileStream^ f = gcnew FileStream( fileName,FileMode::Open,FileAccess::Read );\n   int size = (int)f-&gt;Length;\n   array&lt;Byte&gt;^data = gcnew array&lt;Byte&gt;(size);\n   size = f-&gt;Read( data, 0, size );\n   f-&gt;Close();\n   return data;\n}\n\n[SecurityPermissionAttribute(SecurityAction::LinkDemand, Unrestricted = true)]\nint main()\n{\n   array&lt;String^&gt;^args = Environment::GetCommandLineArgs();\n\n   //Test for correct number of arguments.\n   if ( args-&gt;Length &lt; 2 )\n   {\n      Console::WriteLine( &quot;Usage: CertInfo &lt;filename&gt;&quot; );\n      return  -1;\n   }\n\n   try\n   {\n      System::Security::Cryptography::X509Certificates::X509Certificate2 ^ x509 =\n            gcnew System::Security::Cryptography::X509Certificates::X509Certificate2;\n\n      //Create X509Certificate2 object from .cer file.\n      array&lt;Byte&gt;^rawData = ReadFile( args[ 1 ] );\n\n      x509-&gt;Import(rawData);\n\n      //Print to console information contained in the certificate.\n      Console::WriteLine( &quot;{0}Subject: {1}{0}&quot;, Environment::NewLine, x509-&gt;Subject );\n      Console::WriteLine( &quot;{0}Issuer: {1}{0}&quot;, Environment::NewLine, x509-&gt;Issuer );\n      Console::WriteLine( &quot;{0}Version: {1}{0}&quot;, Environment::NewLine, x509-&gt;Version );\n      Console::WriteLine( &quot;{0}Valid Date: {1}{0}&quot;, Environment::NewLine, x509-&gt;NotBefore );\n      Console::WriteLine( &quot;{0}Expiry Date: {1}{0}&quot;, Environment::NewLine, x509-&gt;NotAfter );\n      Console::WriteLine( &quot;{0}Thumbprint: {1}{0}&quot;, Environment::NewLine, x509-&gt;Thumbprint );\n      Console::WriteLine( &quot;{0}Serial Number: {1}{0}&quot;, Environment::NewLine, x509-&gt;SerialNumber );\n      Console::WriteLine( &quot;{0}Friendly Name: {1}{0}&quot;, Environment::NewLine, x509-&gt;PublicKey-&gt;Oid-&gt;FriendlyName );\n      Console::WriteLine( &quot;{0}Public Key Format: {1}{0}&quot;, Environment::NewLine, x509-&gt;PublicKey-&gt;EncodedKeyValue-&gt;Format(true) );\n      Console::WriteLine( &quot;{0}Raw Data Length: {1}{0}&quot;, Environment::NewLine, x509-&gt;RawData-&gt;Length );\n      Console::WriteLine( &quot;{0}Certificate to string: {1}{0}&quot;, Environment::NewLine, x509-&gt;ToString( true ) );\n      Console::WriteLine( &quot;{0}Certificate to XML String: {1}{0}&quot;, Environment::NewLine, x509-&gt;PublicKey-&gt;Key-&gt;ToXmlString( false ) );\n\n      //Add the certificate to a X509Store.\n      X509Store ^ store = gcnew X509Store;\n      store-&gt;Open( OpenFlags::MaxAllowed );\n      store-&gt;Add( x509 );\n      store-&gt;Close();\n   }\n   catch ( DirectoryNotFoundException^ )\n   {\n      Console::WriteLine( &quot;Error: The directory specified could not be found.&quot; );\n   }\n   catch ( IOException^ )\n   {\n      Console::WriteLine( &quot;Error: A file in the directory could not be accessed.&quot; );\n   }\n   catch ( NullReferenceException^ )\n   {\n      Console::WriteLine( &quot;File must be a .cer file. Program does not have access to that type of file.&quot; );\n   }\n\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"CertInfo#1\">using System;\nusing System.Security.Cryptography;\nusing System.Security.Permissions;\nusing System.IO;\nusing System.Security.Cryptography.X509Certificates;\n\n\nclass CertInfo\n{\n\t//Reads a file.\n\tinternal static byte[] ReadFile (string fileName)\n\t{\n\t\tFileStream f = new FileStream(fileName, FileMode.Open, FileAccess.Read);\n\t\tint size = (int)f.Length;\n\t\tbyte[] data = new byte[size];\n\t\tsize = f.Read(data, 0, size);\n\t\tf.Close();\n\t\treturn data;\n\t}\n\t//Main method begins here.\n\tstatic void Main(string[] args)\n\t{\n\t\t//Test for correct number of arguments.\n\t\tif (args.Length &lt; 1)\n\t\t{\n\t\t\tConsole.WriteLine(&quot;Usage: CertInfo &lt;filename&gt;&quot;);\n\t\t\treturn;\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tX509Certificate2 x509 = new X509Certificate2();\n\t\t\t//Create X509Certificate2 object from .cer file.\n\t\t\tbyte[] rawData = ReadFile(args[0]);\n\n\t\t\tx509.Import(rawData);\n\n\t\t\t//Print to console information contained in the certificate.\n\t\t\tConsole.WriteLine(&quot;{0}Subject: {1}{0}&quot;, Environment.NewLine,x509.Subject);\n\t\t\tConsole.WriteLine(&quot;{0}Issuer: {1}{0}&quot;, Environment.NewLine,x509.Issuer);\n\t\t\tConsole.WriteLine(&quot;{0}Version: {1}{0}&quot;, Environment.NewLine,x509.Version);\n\t\t\tConsole.WriteLine(&quot;{0}Valid Date: {1}{0}&quot;, Environment.NewLine,x509.NotBefore);\n\t\t\tConsole.WriteLine(&quot;{0}Expiry Date: {1}{0}&quot;, Environment.NewLine,x509.NotAfter);\n\t\t\tConsole.WriteLine(&quot;{0}Thumbprint: {1}{0}&quot;, Environment.NewLine,x509.Thumbprint);\n\t\t\tConsole.WriteLine(&quot;{0}Serial Number: {1}{0}&quot;, Environment.NewLine,x509.SerialNumber);\n\t\t\tConsole.WriteLine(&quot;{0}Friendly Name: {1}{0}&quot;, \t\t\t\t\t\t\t\tEnvironment.NewLine,x509.PublicKey.Oid.FriendlyName);\n\t\t\tConsole.WriteLine(&quot;{0}Public Key Format: {1}{0}&quot;, \t\t\t\t\t\t\t\t\t\t\tEnvironment.NewLine,x509.PublicKey.EncodedKeyValue.Format(true));\n\t\t\tConsole.WriteLine(&quot;{0}Raw Data Length: {1}{0}&quot;, Environment.NewLine,x509.RawData.Length);\n\t\t\tConsole.WriteLine(&quot;{0}Certificate to string: {1}{0}&quot;, Environment.NewLine,x509.ToString(true));\n\n\t\t\tConsole.WriteLine(&quot;{0}Certificate to XML String: {1}{0}&quot;, \t\t\t\t\t\t\t\tEnvironment.NewLine,x509.PublicKey.Key.ToXmlString(false));\n\n\t\t\t//Add the certificate to a X509Store.\n\t\t\tX509Store store = new X509Store();\n\t\t\tstore.Open(OpenFlags.MaxAllowed);\n\t\t\tstore.Add(x509);\n\t\t\tstore.Close();\n\t\t}\n\n\t\tcatch (DirectoryNotFoundException)\n\t\t\t{\n\t\t\t\t   Console.WriteLine(&quot;Error: The directory specified could not be found.&quot;);\n\t\t\t}\n\t\tcatch (IOException)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(&quot;Error: A file in the directory could not be accessed.&quot;);\n\t\t\t}\n\t\tcatch (NullReferenceException)\n\t\t\t{\n\t\t\t\tConsole.WriteLine(&quot;File must be a .cer file. Program does not have access to that type of file.&quot;);\n\t\t\t}\n\t}\n\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"CertInfo#1\">Imports System\nImports System.Security.Cryptography\nImports System.Security.Permissions\nImports System.IO\nImports System.Security.Cryptography.X509Certificates\nImports Microsoft.VisualBasic\n\n\n\n\nClass CertInfo\n\n    &#39;Reads a file.\n    Friend Shared Function ReadFile(ByVal fileName As String) As Byte()\n        Dim f As New FileStream(fileName, FileMode.Open, FileAccess.Read)\n        Dim size As Integer = Fix(f.Length)\n        Dim data(size) As Byte\n        size = f.Read(data, 0, size)\n        f.Close()\n        Return data\n\n    End Function \n\n    &lt;SecurityPermission(SecurityAction.LinkDemand, Unrestricted:=True)&gt; _\n    Shared Sub Main(ByVal args() As String)\n        &#39;Test for correct number of arguments.\n        If args.Length &lt; 1 Then\n            Console.WriteLine(&quot;Usage: CertInfo &lt;filename&gt;&quot;)\n            Return\n        End If\n        Try\n            Dim x509 As New X509Certificate2()\n            &#39;Create X509Certificate2 object from .cer file.\n            Dim rawData As Byte() = ReadFile(args(0))\n            \n            x509.Import(rawData)\n\n            &#39;Print to console information contained in the certificate.\n            Console.WriteLine(&quot;{0}Subject: {1}{0}&quot;, Environment.NewLine, x509.Subject)\n            Console.WriteLine(&quot;{0}Issuer: {1}{0}&quot;, Environment.NewLine, x509.Issuer)\n            Console.WriteLine(&quot;{0}Version: {1}{0}&quot;, Environment.NewLine, x509.Version)\n            Console.WriteLine(&quot;{0}Valid Date: {1}{0}&quot;, Environment.NewLine, x509.NotBefore)\n            Console.WriteLine(&quot;{0}Expiry Date: {1}{0}&quot;, Environment.NewLine, x509.NotAfter)\n            Console.WriteLine(&quot;{0}Thumbprint: {1}{0}&quot;, Environment.NewLine, x509.Thumbprint)\n            Console.WriteLine(&quot;{0}Serial Number: {1}{0}&quot;, Environment.NewLine, x509.SerialNumber)\n            Console.WriteLine(&quot;{0}Friendly Name: {1}{0}&quot;, Environment.NewLine, x509.PublicKey.Oid.FriendlyName)\n            Console.WriteLine(&quot;{0}Public Key Format: {1}{0}&quot;, Environment.NewLine, x509.PublicKey.EncodedKeyValue.Format(True))\n            Console.WriteLine(&quot;{0}Raw Data Length: {1}{0}&quot;, Environment.NewLine, x509.RawData.Length)\n            Console.WriteLine(&quot;{0}Certificate to string: {1}{0}&quot;, Environment.NewLine, x509.ToString(True))\n\n            Console.WriteLine(&quot;{0}Certificate to XML String: {1}{0}&quot;, Environment.NewLine, x509.PublicKey.Key.ToXmlString(False))\n\n            &#39;Add the certificate to a X509Store.\n            Dim store As New X509Store()\n            store.Open(OpenFlags.MaxAllowed)\n            store.Add(x509)\n            store.Close()\n\n        Catch dnfExcept As DirectoryNotFoundException\n            Console.WriteLine(&quot;Error: The directory specified could not be found.&quot;)\n        Catch ioExpcept As IOException\n            Console.WriteLine(&quot;Error: A file in the directory could not be accessed.&quot;)\n        Catch nrExcept As NullReferenceException\n            Console.WriteLine(&quot;File must be a .cer file. Program does not have access to that type of file.&quot;)\n        End Try\n\n    End Sub\nEnd Class\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>The PublicKey object contains the object identifier (<a class=\"xref\" href=\"system.security.cryptography.x509certificates.publickey#System_Security_Cryptography_X509Certificates_PublicKey_Oid_\" data-linktype=\"relative-path\">Oid</a>) representing the public key algorithm, the ASN-encoded parameters, and the ASN.1-encoded key value.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Constructors\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_Cryptography_X509Certificates_PublicKey__ctor_System_Security_Cryptography_Oid_System_Security_Cryptography_AsnEncodedData_System_Security_Cryptography_AsnEncodedData_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">PublicKey(Oid, AsnEncodedData, AsnEncodedData)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Initializes a new instance of the <a class=\"xref\" href=\"system.security.cryptography.x509certificates.publickey\" data-linktype=\"relative-path\">PublicKey</a> class using an object identifier (OID) object of the public key, an ASN.1-encoded representation of the public key parameters, and an ASN.1-encoded representation of the public key value.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public PublicKey (System.Security.Cryptography.Oid oid, System.Security.Cryptography.AsnEncodedData parameters, System.Security.Cryptography.AsnEncodedData keyValue);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>oid</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.oid\" data-linktype=\"relative-path\">Oid</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An object identifier (OID) object that represents the public key.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>parameters</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.asnencodeddata\" data-linktype=\"relative-path\">AsnEncodedData</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An ASN.1-encoded representation of the public key parameters.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>keyValue</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.asnencodeddata\" data-linktype=\"relative-path\">AsnEncodedData</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An ASN.1-encoded representation of the public key value.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Properties\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_Cryptography_X509Certificates_PublicKey_EncodedKeyValue\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">EncodedKeyValue</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets the ASN.1-encoded representation of the public key value.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Security.Cryptography.AsnEncodedData EncodedKeyValue { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.asnencodeddata\" data-linktype=\"relative-path\">AsnEncodedData</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The ASN.1-encoded representation of the public key value.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_Cryptography_X509Certificates_PublicKey_EncodedParameters\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">EncodedParameters</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets the ASN.1-encoded representation of the public key parameters.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Security.Cryptography.AsnEncodedData EncodedParameters { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.asnencodeddata\" data-linktype=\"relative-path\">AsnEncodedData</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The ASN.1-encoded representation of the public key parameters.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_Cryptography_X509Certificates_PublicKey_Key\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Key</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets an <a class=\"xref\" href=\"system.security.cryptography.rsacryptoserviceprovider\" data-linktype=\"relative-path\">RSACryptoServiceProvider</a> or <a class=\"xref\" href=\"system.security.cryptography.dsacryptoserviceprovider\" data-linktype=\"relative-path\">DSACryptoServiceProvider</a> object representing the public key.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Security.Cryptography.AsymmetricAlgorithm Key { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.asymmetricalgorithm\" data-linktype=\"relative-path\">AsymmetricAlgorithm</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An <a class=\"xref\" href=\"system.security.cryptography.asymmetricalgorithm\" data-linktype=\"relative-path\">AsymmetricAlgorithm</a> object representing the public key.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The key algorithm is not supported.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This property returns the public key. Both <a class=\"xref\" href=\"system.security.cryptography.rsa\" data-linktype=\"relative-path\">RSA</a> and <a class=\"xref\" href=\"system.security.cryptography.dsa\" data-linktype=\"relative-path\">DSA</a> keys are supported. Call this property to obtain a certificate&#39;s public key. Repeated calls to this property will return the same key.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_Cryptography_X509Certificates_PublicKey_Oid\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Oid</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets an object identifier (OID) object of the public key.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Security.Cryptography.Oid Oid { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.cryptography.oid\" data-linktype=\"relative-path\">Oid</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An object identifier (OID) object of the public key.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>An object identifier (OID) is a number that uniquely identifies an object class or attribute. An object identifier is represented as a dotted decimal string, such as &quot;1.2.3.4.&quot; Object identifiers are organized into a global hierarchy. National registration authorities issue root object identifiers to individuals or organizations, who manage the hierarchy of OIDs grouped below their root object identifier.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Security.Cryptography.X509Certificates.PublicKey.yml\">\r\n<meta name=\"APIName\" content=\"System.Security.Cryptography.X509Certificates.PublicKey\">\r\n<meta name=\"APIName\" content=\"System.Security.Cryptography.X509Certificates.PublicKey..ctor\">\r\n<meta name=\"APIName\" content=\"System.Security.Cryptography.X509Certificates.PublicKey.EncodedKeyValue\">\r\n<meta name=\"APIName\" content=\"System.Security.Cryptography.X509Certificates.PublicKey.EncodedParameters\">\r\n<meta name=\"APIName\" content=\"System.Security.Cryptography.X509Certificates.PublicKey.Key\">\r\n<meta name=\"APIName\" content=\"System.Security.Cryptography.X509Certificates.PublicKey.Oid\">\r\n<meta name=\"APILocation\" content=\"System.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-28 03:03 AM\">\r\n<meta name=\"document_id\" content=\"0020d9db-d398-e51e-4099-f9016107a037\">\r\n<meta name=\"internalonly\" content=\"false\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Represents a certificate&amp;#39;s public key information. This class cannot be inherited.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.security.cryptography.x509certificates/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Security.Cryptography.X509Certificates.PublicKey\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Security.Cryptography.X509Certificates.PublicKey.yml","open_to_public_contributors":false,"api_name":["System.Security.Cryptography.X509Certificates.PublicKey","System.Security.Cryptography.X509Certificates.PublicKey..ctor","System.Security.Cryptography.X509Certificates.PublicKey.EncodedKeyValue","System.Security.Cryptography.X509Certificates.PublicKey.EncodedParameters","System.Security.Cryptography.X509Certificates.PublicKey.Key","System.Security.Cryptography.X509Certificates.PublicKey.Oid"],"api_location":["System.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Security.Cryptography.X509Certificates.PublicKey","System::Security::Cryptography::X509Certificates::PublicKey","System.Security.Cryptography.X509Certificates.PublicKey.#ctor","System::Security::Cryptography::X509Certificates::PublicKey::#ctor","System.Security.Cryptography.X509Certificates.PublicKey.EncodedKeyValue","System::Security::Cryptography::X509Certificates::PublicKey::EncodedKeyValue","System.Security.Cryptography.X509Certificates.PublicKey.EncodedParameters","System::Security::Cryptography::X509Certificates::PublicKey::EncodedParameters","System.Security.Cryptography.X509Certificates.PublicKey.Key","System::Security::Cryptography::X509Certificates::PublicKey::Key","System.Security.Cryptography.X509Certificates.PublicKey.Oid","System::Security::Cryptography::X509Certificates::PublicKey::Oid"],"dev_langs":["csharp"],"updated_at":"2017-03-28 03:03 AM","document_id":"0020d9db-d398-e51e-4099-f9016107a037","content_git_url":"https://github.com/dotnet/docs/blob/master/xml/System.Security.Cryptography.X509Certificates/PublicKey.xml","internalonly":false,"layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"PublicKey class | Microsoft Docs","_op_ogTitle":"PublicKey class","description":"Represents a certificate&#39;s public key information. This class cannot be inherited.\n","toc_asset_id":"api/_splitted/System.Security.Cryptography.X509Certificates/toc.json","toc_rel":"_splitted/System.Security.Cryptography.X509Certificates/toc.json","source_url":"","ms.assetid":"System.Security.Cryptography.X509Certificates.PublicKey","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.x509certificates.publickey","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.x509certificates.publickey","fileRelativePath":"api/System.Security.Cryptography.X509Certificates.PublicKey.html"},"themesRelativePathToOutputRoot":"_themes/"}