{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">BufferedGraphics</span>\r\n    \t\t\t\tClass\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Provides a graphics buffer for double buffering.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">public sealed class BufferedGraphics : IDisposable</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><span class=\"lang-csharp\">BufferedGraphics</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \r\n  \t<h3 class=\"accented\">Inherited Members</h3>\r\n  \t<h4 class=\"accented\"></h4>\r\n  \t<div class=\"cdlHolder\">\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object, Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a></span></div>\r\n  \t</div>\r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following code example demonstrates using a BufferedGraphics object to draw graphics using several types of buffering implementations. Clicking the form alternately starts and stops a timer that causes draw updates. The draw updates allow you to observe the effect of double buffering. Right-clicking the form cycles through the following drawing modes:  </p>\n<ul>\n<li><p>Drawing directly to the <a class=\"xref\" href=\"system.windows.forms.control#System_Windows_Forms_Control_Handle_\" data-linktype=\"relative-path\">Handle</a> for a <a class=\"xref\" href=\"system.windows.forms.form\" data-linktype=\"relative-path\">Form</a>.  </p>\n</li>\n<li><p>Drawing by overriding the <a class=\"xref\" href=\"system.windows.forms.form#System_Windows_Forms_Form_OnPaint_\" data-linktype=\"relative-path\">OnPaint</a> method using the <a class=\"xref\" href=\"system.windows.forms.controlstyles\" data-linktype=\"relative-path\">ControlStyles</a> control style.  </p>\n</li>\n<li><p>Drawing by overriding the <a class=\"xref\" href=\"system.windows.forms.form#System_Windows_Forms_Form_OnPaint_\" data-linktype=\"relative-path\">OnPaint</a> method for the form method without using the <a class=\"xref\" href=\"system.windows.forms.controlstyles\" data-linktype=\"relative-path\">ControlStyles</a> control style.  </p>\n</li>\n</ul>\n<p> In each mode, text is drawn that identifies the current mode and describes the behavior that occurs when each mouse button is pressed.  </p>\n<pre><code class=\"lang-cpp\" name=\"BufferedGraphicsExample#1\">#using &lt;System.Windows.Forms.dll&gt;\n#using &lt;System.Drawing.dll&gt;\n#using &lt;System.dll&gt;\n\nusing namespace System;\nusing namespace System::ComponentModel;\nusing namespace System::Drawing;\nusing namespace System::Windows::Forms;\n\nnamespace BufferingExample\n{\n   public ref class BufferingExample: public Form\n   {\n   private:\n      BufferedGraphicsContext^ context;\n      BufferedGraphics^ grafx;\n      Byte bufferingMode;\n      array&lt;String^&gt;^bufferingModeStrings;\n      System::Windows::Forms::Timer^ timer1;\n      Byte count;\n\n   public:\n      BufferingExample()\n         : Form()\n      {\n         array&lt;String^&gt;^tempStrings = {&quot;Draw to Form without OptimizedDoubleBufferring control style&quot;,&quot;Draw to Form using OptimizedDoubleBuffering control style&quot;,&quot;Draw to HDC for form&quot;};\n         bufferingModeStrings = tempStrings;\n\n         // Configure the Form for this example.\n         this-&gt;Text = &quot;User double buffering&quot;;\n         this-&gt;MouseDown += gcnew MouseEventHandler( this, &amp;BufferingExample::MouseDownHandler );\n         this-&gt;Resize += gcnew EventHandler( this, &amp;BufferingExample::OnResize );\n         this-&gt;SetStyle( static_cast&lt;ControlStyles&gt;(ControlStyles::AllPaintingInWmPaint | ControlStyles::UserPaint), true );\n\n         // Configure a timer to draw graphics updates.\n         timer1 = gcnew System::Windows::Forms::Timer;\n         timer1-&gt;Interval = 200;\n         timer1-&gt;Tick += gcnew EventHandler( this, &amp;BufferingExample::OnTimer );\n         bufferingMode = 2;\n         count = 0;\n\n         // Retrieves the BufferedGraphicsContext for the \n         // current application domain.\n         context = BufferedGraphicsManager::Current;\n\n         // Sets the maximum size for the primary graphics buffer\n         // of the buffered graphics context for the application\n         // domain.  Any allocation requests for a buffer larger \n         // than this will create a temporary buffered graphics \n         // context to host the graphics buffer.\n         context-&gt;MaximumBuffer = System::Drawing::Size( this-&gt;Width + 1, this-&gt;Height + 1 );\n\n         // Allocates a graphics buffer the size of this form\n         // using the pixel format of the Graphics created by \n         // the Form.CreateGraphics() method, which returns a \n         // Graphics object that matches the pixel format of the form.\n         grafx = context-&gt;Allocate( this-&gt;CreateGraphics(), Rectangle(0,0,this-&gt;Width,this-&gt;Height) );\n\n         // Draw the first frame to the buffer.\n         DrawToBuffer( grafx-&gt;Graphics );\n      }\n\n   private:\n      void MouseDownHandler( Object^ /*sender*/, MouseEventArgs^ e )\n      {\n         if ( e-&gt;Button == ::MouseButtons::Right )\n         {\n            // Cycle the buffering mode.\n            if ( ++bufferingMode &gt; 2 )\n                        bufferingMode = 0;\n\n            // If the previous buffering mode used \n            // the OptimizedDoubleBuffering ControlStyle,\n            // disable the control style.\n            if ( bufferingMode == 1 )\n                        this-&gt;SetStyle( ControlStyles::OptimizedDoubleBuffer, true );\n\n            // If the current buffering mode uses\n            // the OptimizedDoubleBuffering ControlStyle,\n            // enabke the control style.\n            if ( bufferingMode == 2 )\n                        this-&gt;SetStyle( ControlStyles::OptimizedDoubleBuffer, false );\n\n            // Cause the background to be cleared and redraw.\n            count = 6;\n            DrawToBuffer( grafx-&gt;Graphics );\n            this-&gt;Refresh();\n         }\n         else\n         {\n            \n            // Toggle whether the redraw timer is active.\n            if ( timer1-&gt;Enabled )\n                        timer1-&gt;Stop();\n            else\n                        timer1-&gt;Start();\n         }\n      }\n\n   private:\n      void OnTimer( Object^ /*sender*/, EventArgs^ /*e*/ )\n      {\n         // Draw randomly positioned ellipses to the buffer.\n         DrawToBuffer( grafx-&gt;Graphics );\n\n         // If in bufferingMode 2, draw to the form&#39;s HDC.\n         if ( bufferingMode == 2 )\n\n         // Render the graphics buffer to the form&#39;s HDC.\n         grafx-&gt;Render( Graphics::FromHwnd( this-&gt;Handle ) );\n         // If in bufferingMode 0 or 1, draw in the paint method.\n         else\n\n         // If in bufferingMode 0 or 1, draw in the paint method.\n         this-&gt;Refresh();\n      }\n\n      void OnResize( Object^ /*sender*/, EventArgs^ /*e*/ )\n      {\n         // Re-create the graphics buffer for a new window size.\n         context-&gt;MaximumBuffer = System::Drawing::Size( this-&gt;Width + 1, this-&gt;Height + 1 );\n         if ( grafx != nullptr )\n         {\n            delete grafx;\n            grafx = nullptr;\n         }\n\n         grafx = context-&gt;Allocate( this-&gt;CreateGraphics(), Rectangle(0,0,this-&gt;Width,this-&gt;Height) );\n\n         // Cause the background to be cleared and redraw.\n         count = 6;\n         DrawToBuffer( grafx-&gt;Graphics );\n         this-&gt;Refresh();\n      }\n\n      void DrawToBuffer( Graphics^ g )\n      {\n         // Clear the graphics buffer every five updates.\n         if ( ++count &gt; 5 )\n         {\n            count = 0;\n            grafx-&gt;Graphics-&gt;FillRectangle( Brushes::Black, 0, 0, this-&gt;Width, this-&gt;Height );\n         }\n\n         // Draw randomly positioned and colored ellipses.\n         Random^ rnd = gcnew Random;\n         for ( int i = 0; i &lt; 20; i++ )\n         {\n            int px = rnd-&gt;Next( 20, this-&gt;Width - 40 );\n            int py = rnd-&gt;Next( 20, this-&gt;Height - 40 );\n            g-&gt;DrawEllipse( gcnew Pen( Color::FromArgb( rnd-&gt;Next( 0, 255 ), rnd-&gt;Next( 0, 255 ), rnd-&gt;Next( 0, 255 ) ), 1.0f ), px, py, px + rnd-&gt;Next( 0, this-&gt;Width - px - 20 ), py + rnd-&gt;Next( 0, this-&gt;Height - py - 20 ) );\n         }\n\n         // Draw information strings.\n         g-&gt;DrawString( String::Format( &quot;Buffering Mode: {0}&quot;, bufferingModeStrings[ bufferingMode ] ), gcnew System::Drawing::Font( &quot;Arial&quot;,8 ), Brushes::White, 10, 10 );\n         g-&gt;DrawString( &quot;Right-click to cycle buffering mode&quot;, gcnew System::Drawing::Font( &quot;Arial&quot;,8 ), Brushes::White, 10, 22 );\n         g-&gt;DrawString( &quot;Left-click to toggle timed display refresh&quot;, gcnew System::Drawing::Font( &quot;Arial&quot;,8 ), Brushes::White, 10, 34 );\n      }\n\n   protected:\n      virtual void OnPaint( PaintEventArgs^ e ) override\n      {\n         grafx-&gt;Render( e-&gt;Graphics );\n      }\n   };\n}\n\n[STAThread]\nint main()\n{\n   Application::Run( gcnew BufferingExample::BufferingExample );\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"BufferedGraphicsExample#1\">using System;\nusing System.ComponentModel;\nusing System.Drawing;\nusing System.Windows.Forms;\n\nnamespace BufferingExample \n{\n    public class BufferingExample : Form\n    {\n        private BufferedGraphicsContext context;\n        private BufferedGraphics grafx;\n\n\tprivate byte bufferingMode;\n\tprivate string[] bufferingModeStrings = \n\t\t{ &quot;Draw to Form without OptimizedDoubleBufferring control style&quot;,\n\t\t  &quot;Draw to Form using OptimizedDoubleBuffering control style&quot;,\n\t\t  &quot;Draw to HDC for form&quot; };\n\n\tprivate System.Windows.Forms.Timer timer1;\n\tprivate byte count;\n\n        public BufferingExample() : base()\n        {\n            // Configure the Form for this example.\n            this.Text = &quot;User double buffering&quot;;\n            this.MouseDown += new MouseEventHandler(this.MouseDownHandler);\n            this.Resize += new EventHandler(this.OnResize);\n            this.SetStyle( ControlStyles.AllPaintingInWmPaint | ControlStyles.UserPaint, true );\n\n            // Configure a timer to draw graphics updates.\n\t    timer1 = new System.Windows.Forms.Timer();\n\t    timer1.Interval = 200;\n\t    timer1.Tick += new EventHandler(this.OnTimer);\n\n\t    bufferingMode = 2;\n\t    count = 0;\n\n            // Retrieves the BufferedGraphicsContext for the \n            // current application domain.\n            context = BufferedGraphicsManager.Current;\n\n            // Sets the maximum size for the primary graphics buffer\n            // of the buffered graphics context for the application\n            // domain.  Any allocation requests for a buffer larger \n            // than this will create a temporary buffered graphics \n            // context to host the graphics buffer.\n            context.MaximumBuffer = new Size(this.Width+1, this.Height+1);\n\n            // Allocates a graphics buffer the size of this form\n            // using the pixel format of the Graphics created by \n            // the Form.CreateGraphics() method, which returns a \n            // Graphics object that matches the pixel format of the form.\n            grafx = context.Allocate(this.CreateGraphics(), \n                 new Rectangle( 0, 0, this.Width, this.Height ));\n\n\t    // Draw the first frame to the buffer.\n\t    DrawToBuffer(grafx.Graphics);\n        }\n\n\tprivate void MouseDownHandler(object sender, MouseEventArgs e)\n        {\n\t    if( e.Button == MouseButtons.Right )\n\t    {\n                 // Cycle the buffering mode.\n\t         if( ++bufferingMode &gt; 2 )\n                     bufferingMode = 0;\n\n                 // If the previous buffering mode used \n                 // the OptimizedDoubleBuffering ControlStyle,\n                 // disable the control style.\n                 if( bufferingMode == 1 )\n                     this.SetStyle( ControlStyles.OptimizedDoubleBuffer, true );\n\n                 // If the current buffering mode uses\n                 // the OptimizedDoubleBuffering ControlStyle,\n                 // enabke the control style.\n                 if( bufferingMode == 2 )\n                     this.SetStyle( ControlStyles.OptimizedDoubleBuffer, false );\n\n                 // Cause the background to be cleared and redraw.\n                 count = 6;\n    \t         DrawToBuffer(grafx.Graphics);                 \n\t\t this.Refresh();\n\t    }\n\t    else\n\t    {\n                // Toggle whether the redraw timer is active.\n\t\tif( timer1.Enabled )\n\t\t\ttimer1.Stop();\n\t\telse\n\t\t\ttimer1.Start(); \n\t    }\n        }\n\n\tprivate void OnTimer(object sender, EventArgs e)\n\t{\n            // Draw randomly positioned ellipses to the buffer.\n\t    DrawToBuffer(grafx.Graphics);\n\n            // If in bufferingMode 2, draw to the form&#39;s HDC.\n\t    if( bufferingMode == 2 )            \n                    // Render the graphics buffer to the form&#39;s HDC.\n\t\t    grafx.Render(Graphics.FromHwnd(this.Handle));            \n            // If in bufferingMode 0 or 1, draw in the paint method.\n\t    else\n  \t\t    this.Refresh();\n\t}\n\n        private void OnResize(object sender, EventArgs e)\n        {\n           // Re-create the graphics buffer for a new window size.\n           context.MaximumBuffer = new Size(this.Width+1, this.Height+1);\n           if( grafx != null )\n           {\n\t       grafx.Dispose();\n               grafx = null;               \n           }\n           grafx = context.Allocate(this.CreateGraphics(), \n               new Rectangle( 0, 0, this.Width, this.Height ));\n           \n           // Cause the background to be cleared and redraw.\n           count = 6;\n    \t   DrawToBuffer(grafx.Graphics);                 \n\t   this.Refresh();\n        }\t\n\n\tprivate void DrawToBuffer(Graphics g)\n\t{\n            // Clear the graphics buffer every five updates.\n\t    if( ++count &gt; 5 )\n            {\n                count = 0;                \n                grafx.Graphics.FillRectangle(Brushes.Black, 0, 0, this.Width, this.Height);\n            }\n\n            // Draw randomly positioned and colored ellipses.\n\t    Random rnd = new Random();\n\t    for( int i=0; i&lt;20; i++ )\n\t    {\n\t\tint px = rnd.Next(20,this.Width-40);\n\t\tint py = rnd.Next(20,this.Height-40);\n\t\tg.DrawEllipse(new Pen(Color.FromArgb(rnd.Next(0, 255), rnd.Next(0,255), rnd.Next(0,255)), 1), \n\t\t\tpx, py, px+rnd.Next(0, this.Width-px-20), py+rnd.Next(0, this.Height-py-20)); \t    \t\t\t\n\t    }\n\n            // Draw information strings.\n\t    g.DrawString(&quot;Buffering Mode: &quot;+bufferingModeStrings[bufferingMode], new Font(&quot;Arial&quot;, 8), Brushes.White, 10, 10);\n            g.DrawString(&quot;Right-click to cycle buffering mode&quot;, new Font(&quot;Arial&quot;, 8), Brushes.White, 10, 22);\n            g.DrawString(&quot;Left-click to toggle timed display refresh&quot;, new Font(&quot;Arial&quot;, 8), Brushes.White, 10, 34);\n\t}\n\n\tprotected override void OnPaint(PaintEventArgs e)\n        {            \n\t    grafx.Render(e.Graphics);\n\t}\n\n        [STAThread]\n        public static void Main(string[] args)\n        {\n\t    Application.Run(new BufferingExample());\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"BufferedGraphicsExample#1\">Imports System\nImports System.ComponentModel\nImports System.Drawing\nImports System.Windows.Forms\n\nPublic Class BufferingExample\n    Inherits Form\n    Private context As BufferedGraphicsContext\n    Private grafx As BufferedGraphics\n    \n    Private bufferingMode As Byte\n    Private bufferingModeStrings As String() = _\n        {&quot;Draw to Form without OptimizedDoubleBufferring control style&quot;, _\n         &quot;Draw to Form using OptimizedDoubleBuffering control style&quot;, _\n         &quot;Draw to HDC for form&quot;}\n    \n    Private timer1 As System.Windows.Forms.Timer\n    Private count As Byte    \n    \n    Public Sub New()\n        &#39; Configure the Form for this example.\n        Me.Text = &quot;User double buffering&quot;\n        AddHandler Me.MouseDown, AddressOf Me.MouseDownHandler\n        AddHandler Me.Resize, AddressOf Me.ResizeHandler\n        Me.SetStyle(ControlStyles.AllPaintingInWmPaint Or ControlStyles.UserPaint, True)\n        \n        &#39; Configure a timer to draw graphics updates.\n        timer1 = New System.Windows.Forms.Timer()\n        timer1.Interval = 200\n        AddHandler timer1.Tick, AddressOf Me.OnTimer\n        \n        bufferingMode = 2\n        count = 0\n        \n        &#39; Retrieves the BufferedGraphicsContext for the \n        &#39; current application domain.\n        context = BufferedGraphicsManager.Current\n        \n        &#39; Sets the maximum size for the primary graphics buffer\n        &#39; of the buffered graphics context for the application\n        &#39; domain.  Any allocation requests for a buffer larger \n        &#39; than this will create a temporary buffered graphics \n        &#39; context to host the graphics buffer.\n        context.MaximumBuffer = New Size(Me.Width + 1, Me.Height + 1)\n        \n        &#39; Allocates a graphics buffer the size of this form\n        &#39; using the pixel format of the Graphics created by \n        &#39; the Form.CreateGraphics() method, which returns a \n        &#39; Graphics object that matches the pixel format of the form.\n        grafx = context.Allocate(Me.CreateGraphics(), _\n            New Rectangle(0, 0, Me.Width, Me.Height))\n        \n        &#39; Draw the first frame to the buffer.\n        DrawToBuffer(grafx.Graphics)\n    End Sub    \n    \n    Private Sub MouseDownHandler(sender As Object, e As MouseEventArgs)\n        If e.Button = MouseButtons.Right Then\n            &#39; Cycle the buffering mode.\n            bufferingMode = bufferingMode+1\n            If bufferingMode &gt; 2 Then\n                bufferingMode = 0\n            End If \n            &#39; If the previous buffering mode used \n            &#39; the OptimizedDoubleBuffering ControlStyle,\n            &#39; disable the control style.\n            If bufferingMode = 1 Then\n                Me.SetStyle(ControlStyles.OptimizedDoubleBuffer, True)\n            End If \n            &#39; If the current buffering mode uses\n            &#39; the OptimizedDoubleBuffering ControlStyle,\n            &#39; enabke the control style.\n            If bufferingMode = 2 Then\n                Me.SetStyle(ControlStyles.OptimizedDoubleBuffer, False)\n            End If \n            &#39; Cause the background to be cleared and redraw.\n            count = 6\n            DrawToBuffer(grafx.Graphics)\n            Me.Refresh()\n        Else\n            &#39; Toggle whether the redraw timer is active.\n            If timer1.Enabled Then\n                timer1.Stop()\n            Else\n                timer1.Start()\n            End If\n        End If\n    End Sub\n     \n    Private Sub OnTimer(sender As Object, e As EventArgs)\n        &#39; Draw randomly positioned ellipses to the buffer.\n        DrawToBuffer(grafx.Graphics)\n        \n        &#39; If in bufferingMode 2, draw to the form&#39;s HDC.\n        If bufferingMode = 2 Then\n            &#39; Render the graphics buffer to the form&#39;s HDC.\n            grafx.Render(Graphics.FromHwnd(Me.Handle))\n        &#39; If in bufferingMode 0 or 1, draw in the paint method.\n        Else\n            Me.Refresh()\n        End If\n    End Sub\n     \n    Private Sub ResizeHandler(sender As Object, e As EventArgs)\n        &#39; Re-create the graphics buffer for a new window size.\n        context.MaximumBuffer = New Size(Me.Width + 1, Me.Height + 1)\n        If (grafx IsNot Nothing) Then\n            grafx.Dispose()\n            grafx = Nothing\n        End If\n        grafx = context.Allocate(Me.CreateGraphics(), New Rectangle(0, 0, Me.Width, Me.Height))\n        \n        &#39; Cause the background to be cleared and redraw.\n        count = 6\n        DrawToBuffer(grafx.Graphics)\n        Me.Refresh()\n    End Sub    \n    \n    Private Sub DrawToBuffer(g As Graphics)\n        &#39; Clear the graphics buffer every five updates.\n        count = count+1\n        If count &gt; 5 Then\n            count = 0\n            grafx.Graphics.FillRectangle(Brushes.Black, 0, 0, Me.Width, Me.Height)\n        End If\n        \n        &#39; Draw randomly positioned and colored ellipses.\n        Dim rnd As New Random()\n        Dim i As Integer\n        For i = 0 To 21\n            Dim px As Integer = rnd.Next(20, Me.Width - 40)\n            Dim py As Integer = rnd.Next(20, Me.Height - 40)\n            g.DrawEllipse(New Pen(Color.FromArgb(rnd.Next(0, 255), rnd.Next(0, 255), _\n                rnd.Next(0, 255)), 1), px, py, px + rnd.Next(0, Me.Width - px - 20), _\n                py + rnd.Next(0, Me.Height - py - 20))\n        Next i\n        \n        &#39; Draw information strings.\n        g.DrawString(&quot;Buffering Mode: &quot; + bufferingModeStrings(bufferingMode), _\n            New Font(&quot;Arial&quot;, 8), Brushes.White, 10, 10)\n        g.DrawString(&quot;Right-click to cycle buffering mode&quot;, New Font(&quot;Arial&quot;, 8), _\n            Brushes.White, 10, 22)\n        g.DrawString(&quot;Left-click to toggle timed display refresh&quot;, _\n            New Font(&quot;Arial&quot;, 8), Brushes.White, 10, 34)\n    End Sub    \n    \n    Protected Overrides Sub OnPaint(e As PaintEventArgs)\n        grafx.Render(e.Graphics)\n    End Sub   \n    \n    &lt;STAThread()&gt;  _\n    Public Shared Sub Main(args() As String)\n        Application.Run(New BufferingExample())\n    End Sub\n\nEnd Class\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>The BufferedGraphics class allows you to implement custom double buffering for your graphics. It provides a wrapper for a graphics buffer, along with methods that you can use to write to the buffer and render its contents to an output device.  </p>\n<p> Graphics that use double buffering can reduce or eliminate flicker that is caused by redrawing a display surface. When you use double buffering, updated graphics are first drawn to a buffer in memory, and the contents of this buffer are then quickly written to some or all of the displayed surface. This relatively brief overwrite of the displayed graphics typically reduces or eliminates the flicker that sometimes occurs when graphics are updated.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The simplest way to use double buffering is to set the <a class=\"xref\" href=\"system.windows.forms.controlstyles\" data-linktype=\"relative-path\">ControlStyles</a> control style flag on a control using the <a class=\"xref\" href=\"system.windows.forms.control#System_Windows_Forms_Control_SetStyle_\" data-linktype=\"relative-path\">SetStyle</a> method. Setting the <a class=\"xref\" href=\"system.windows.forms.controlstyles\" data-linktype=\"relative-path\">ControlStyles</a> flag for a control redirects all painting for the control through a default graphics buffer, without requiring any additional code. This flag is set to <code>true</code> by default.  </p>\n</div>\n<p> The BufferedGraphics class has no public constructor and must be created by the <a class=\"xref\" href=\"system.drawing.bufferedgraphicscontext\" data-linktype=\"relative-path\">BufferedGraphicsContext</a> for an application domain using its <a class=\"xref\" href=\"system.drawing.bufferedgraphicscontext#System_Drawing_BufferedGraphicsContext_Allocate_\" data-linktype=\"relative-path\">Allocate</a> method. You can retrieve the <a class=\"xref\" href=\"system.drawing.bufferedgraphicscontext\" data-linktype=\"relative-path\">BufferedGraphicsContext</a> for the current application domain from the static <a class=\"xref\" href=\"system.drawing.bufferedgraphicsmanager#System_Drawing_BufferedGraphicsManager_Current_\" data-linktype=\"relative-path\">Current</a> property.  </p>\n<p> The <a class=\"xref\" href=\"system.drawing.bufferedgraphics#System_Drawing_BufferedGraphics_Graphics_\" data-linktype=\"relative-path\">Graphics</a> property can be used for drawing to the graphics buffer. This property provides access to the <a class=\"xref\" href=\"system.drawing.graphics\" data-linktype=\"relative-path\">Graphics</a> object that draws to the graphics buffer allocated for this BufferedGraphics object.  </p>\n<p> The <a class=\"xref\" href=\"system.drawing.bufferedgraphics#System_Drawing_BufferedGraphics_Render_\" data-linktype=\"relative-path\">Render</a> method with no arguments draws the contents of the graphics buffer to the surface specified when the buffer was allocated. Other overloads of the <a class=\"xref\" href=\"system.drawing.bufferedgraphics#System_Drawing_BufferedGraphics_Render_\" data-linktype=\"relative-path\">Render</a> method allow you to specify a <a class=\"xref\" href=\"system.drawing.graphics\" data-linktype=\"relative-path\">Graphics</a> object or an <a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a> object that points to a device context to which to draw the contents of the graphics buffer.  </p>\n<p> For more information about drawing double-buffered graphics, see <a href=\"../topic/double%20buffered%20graphics\" data-linktype=\"relative-path\">Double Buffered Graphics</a>.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Properties\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Drawing_BufferedGraphics_Graphics_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Drawing_BufferedGraphics_Graphics\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Graphics</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets a <a class=\"xref\" href=\"system.drawing.graphics\" data-linktype=\"relative-path\">Graphics</a> object that outputs to the graphics buffer.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Drawing.Graphics Graphics { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.drawing.graphics\" data-linktype=\"relative-path\">Graphics</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <a class=\"xref\" href=\"system.drawing.graphics\" data-linktype=\"relative-path\">Graphics</a> object that outputs to the graphics buffer.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This property provides a <a class=\"xref\" href=\"system.drawing.graphics\" data-linktype=\"relative-path\">Graphics</a> object that draws to the graphics buffer allocated for this <a class=\"xref\" href=\"system.drawing.bufferedgraphics\" data-linktype=\"relative-path\">BufferedGraphics</a> object.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Methods\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Drawing_BufferedGraphics_Dispose_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Drawing_BufferedGraphics_Dispose\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Dispose()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Releases all resources used by the <a class=\"xref\" href=\"system.drawing.bufferedgraphics\" data-linktype=\"relative-path\">BufferedGraphics</a> object.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void Dispose ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Call Dispose when you are finished using the <a class=\"xref\" href=\"system.drawing.bufferedgraphics\" data-linktype=\"relative-path\">BufferedGraphics</a> object. The Dispose method leaves the <a class=\"xref\" href=\"system.drawing.bufferedgraphics\" data-linktype=\"relative-path\">BufferedGraphics</a> object in an unusable state. After calling Dispose, you must release all references to the <a class=\"xref\" href=\"system.drawing.bufferedgraphics\" data-linktype=\"relative-path\">BufferedGraphics</a> object so the garbage collector can reclaim the memory that the <a class=\"xref\" href=\"system.drawing.bufferedgraphics\" data-linktype=\"relative-path\">BufferedGraphics</a> object was occupying. For more information, see <a href=\"../topic/cleaning%20up%20unmanaged%20resources\" data-linktype=\"relative-path\">Cleaning Up Unmanaged Resources</a> and <a href=\"../topic/implementing%20a%20dispose%20method\" data-linktype=\"relative-path\">Implementing a Dispose Method</a>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Always call Dispose before you release your last reference to the <a class=\"xref\" href=\"system.drawing.bufferedgraphics\" data-linktype=\"relative-path\">BufferedGraphics</a> object. Otherwise, the resources it is using will not be freed until the garbage collector calls the <a class=\"xref\" href=\"system.drawing.bufferedgraphics\" data-linktype=\"relative-path\">BufferedGraphics</a> object&#39;s <code>Finalize</code> method.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Drawing_BufferedGraphics_Finalize_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Drawing_BufferedGraphics_Finalize\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Finalize()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">~BufferedGraphics ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Drawing_BufferedGraphics_Render_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Drawing_BufferedGraphics_Render\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Render()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Writes the contents of the graphics buffer to the default device.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void Render ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This method writes the contents of the graphics buffer to the device specified by calling the <a class=\"xref\" href=\"system.drawing.bufferedgraphicscontext#System_Drawing_BufferedGraphicsContext_Allocate_\" data-linktype=\"relative-path\">Allocate</a> method of the <a class=\"xref\" href=\"system.drawing.bufferedgraphicscontext\" data-linktype=\"relative-path\">BufferedGraphicsContext</a> used to create this <a class=\"xref\" href=\"system.drawing.bufferedgraphics\" data-linktype=\"relative-path\">BufferedGraphics</a> object.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Drawing_BufferedGraphics_Render_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Drawing_BufferedGraphics_Render_System_Drawing_Graphics_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Render(Graphics)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Writes the contents of the graphics buffer to the specified <a class=\"xref\" href=\"system.drawing.graphics\" data-linktype=\"relative-path\">Graphics</a> object.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void Render (System.Drawing.Graphics target);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>target</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.drawing.graphics\" data-linktype=\"relative-path\">Graphics</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <a class=\"xref\" href=\"system.drawing.graphics\" data-linktype=\"relative-path\">Graphics</a> object to which to write the contents of the graphics buffer.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This method writes the contents of the graphics buffer to the specified <a class=\"xref\" href=\"system.drawing.graphics\" data-linktype=\"relative-path\">Graphics</a> object.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Drawing_BufferedGraphics_Render_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Drawing_BufferedGraphics_Render_System_IntPtr_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Render(IntPtr)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Writes the contents of the graphics buffer to the device context associated with the specified <a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a> handle.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void Render (IntPtr targetDC);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>targetDC</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An <a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a> that points to the device context to which to write the contents of the graphics buffer.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This method writes the contents of the graphics buffer to the device context associated with the specified <a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a> handle.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \t<h2 class=\"accented\">Thread Safety</h2>\r\n  \tThe BufferedGraphics class is not thread safe. When accessing a graphics buffer from separate threads, it is important to use a thread-access control mechanism to prevent conflicts.\r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Drawing.BufferedGraphics.yml\">\r\n<meta name=\"APIName\" content=\"System.Drawing.BufferedGraphics\">\r\n<meta name=\"APIName\" content=\"System.Drawing.BufferedGraphics.Dispose\">\r\n<meta name=\"APIName\" content=\"System.Drawing.BufferedGraphics.Finalize\">\r\n<meta name=\"APIName\" content=\"System.Drawing.BufferedGraphics.Graphics\">\r\n<meta name=\"APIName\" content=\"System.Drawing.BufferedGraphics.Render\">\r\n<meta name=\"APILocation\" content=\"System.Drawing.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-31 05:47 AM\">\r\n<meta name=\"document_id\" content=\"3247a7a5-81f1-5971-6aaa-eb65e29286dc\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Provides a graphics buffer for double buffering.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.drawing/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Drawing.BufferedGraphics\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Drawing.BufferedGraphics.yml","open_to_public_contributors":false,"api_name":["System.Drawing.BufferedGraphics","System.Drawing.BufferedGraphics.Dispose","System.Drawing.BufferedGraphics.Finalize","System.Drawing.BufferedGraphics.Graphics","System.Drawing.BufferedGraphics.Render"],"api_location":["System.Drawing.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Drawing.BufferedGraphics","System::Drawing::BufferedGraphics","System.Drawing.BufferedGraphics.Dispose","System::Drawing::BufferedGraphics::Dispose","System.Drawing.BufferedGraphics.Finalize","System::Drawing::BufferedGraphics::Finalize","System.Drawing.BufferedGraphics.Graphics","System::Drawing::BufferedGraphics::Graphics","System.Drawing.BufferedGraphics.Render","System::Drawing::BufferedGraphics::Render"],"dev_langs":["csharp"],"updated_at":"2017-03-31 05:47 AM","document_id":"3247a7a5-81f1-5971-6aaa-eb65e29286dc","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Drawing/BufferedGraphics.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"BufferedGraphics class | Microsoft Docs","_op_ogTitle":"BufferedGraphics class","description":"Provides a graphics buffer for double buffering.\n","toc_asset_id":"api/_splitted/System.Drawing/toc.json","toc_rel":"_splitted/System.Drawing/toc.json","source_url":"","ms.assetid":"System.Drawing.BufferedGraphics","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.drawing.bufferedgraphics","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.drawing.bufferedgraphics","fileRelativePath":"api/System.Drawing.BufferedGraphics.html"},"themesRelativePathToOutputRoot":"_themes/"}