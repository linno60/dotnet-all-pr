{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">IPermission</span>\r\n      Interface\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Defines methods implemented by permission types.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(true)]\npublic interface IPermission : System.Security.ISecurityEncodable</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Attributes</dt><dd>\r\n  \t\t<div class=\"cdlHolder\">\r\n  \t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>This example shows how to define a permission class for use with code access security. All of the necessary permission interfaces are implemented.  </p>\n<pre><code class=\"lang-cs\" name=\"Permission#1\">using System;\nusing System.Security;\nusing System.Security.Permissions;\nusing System.Reflection;\n\n// Enumerated type for permission states.\n[Serializable]\npublic enum SoundPermissionState\n{\n    NoSound = 0,\n    PlaySystemSounds = 1,\n    PlayAnySound = 2\n}\n\n// Derive from CodeAccessPermission to gain implementations of the following\n// sealed IStackWalk methods: Assert, Demand, Deny, and PermitOnly.\n// Implement the following abstract IPermission methods: Copy, Intersect, and IsSubSetOf.\n// Implementing the Union method of the IPermission class is optional.\n// Implement the following abstract ISecurityEncodable methods: FromXml and ToXml.\n// Making the class &#39;sealed&#39; is optional.\n\npublic sealed class SoundPermission : CodeAccessPermission, IPermission,\n    IUnrestrictedPermission, ISecurityEncodable, ICloneable\n{\n    private Boolean m_specifiedAsUnrestricted = false;\n    private SoundPermissionState m_flags = SoundPermissionState.NoSound;\n\n    // This constructor creates and initializes a permission with generic access.\n    public SoundPermission(PermissionState state)\n    {\n        m_specifiedAsUnrestricted = (state == PermissionState.Unrestricted);\n    }\n\n    // This constructor creates and initializes a permission with specific access.        \n    public SoundPermission(SoundPermissionState flags)\n    {\n        if (!Enum.IsDefined(typeof(SoundPermissionState), flags))\n            throw new ArgumentException\n                (&quot;flags value is not valid for the SoundPermissionState enuemrated type&quot;);\n        m_specifiedAsUnrestricted = false;\n        m_flags = flags;\n    }\n\n    // For debugging, return the state of this object as XML.\n    public override String ToString() { return ToXml().ToString(); }\n\n    // Private method to cast (if possible) an IPermission to the type.\n    private SoundPermission VerifyTypeMatch(IPermission target)\n    {\n        if (GetType() != target.GetType())\n            throw new ArgumentException(String.Format(&quot;target must be of the {0} type&quot;,\n                GetType().FullName));\n        return (SoundPermission)target;\n    }\n\n    // This is the Private Clone helper method. \n    private SoundPermission Clone(Boolean specifiedAsUnrestricted, SoundPermissionState flags)\n    {\n        SoundPermission soundPerm = (SoundPermission)Clone();\n        soundPerm.m_specifiedAsUnrestricted = specifiedAsUnrestricted;\n        soundPerm.m_flags = specifiedAsUnrestricted ? SoundPermissionState.PlayAnySound : m_flags;\n        return soundPerm;\n    }\n\n    #region IPermission Members\n    // Return a new object that contains the intersection of &#39;this&#39; and &#39;target&#39;.\n    public override IPermission Intersect(IPermission target)\n    {\n        // If &#39;target&#39; is null, return null.\n        if (target == null) return null;\n\n        // Both objects must be the same type.\n        SoundPermission soundPerm = VerifyTypeMatch(target);\n\n        // If &#39;this&#39; and &#39;target&#39; are unrestricted, return a new unrestricted permission.\n        if (m_specifiedAsUnrestricted &amp;&amp; soundPerm.m_specifiedAsUnrestricted)\n            return Clone(true, SoundPermissionState.PlayAnySound);\n\n        // Calculate the intersected permissions. If there are none, return null.\n        SoundPermissionState val = (SoundPermissionState)\n            Math.Min((Int32)m_flags, (Int32)soundPerm.m_flags);\n        if (val == 0) return null;\n\n        // Return a new object with the intersected permission value.\n        return Clone(false, val);\n    }\n\n    // Called by the Demand method: returns true if &#39;this&#39; is a subset of &#39;target&#39;.\n    public override Boolean IsSubsetOf(IPermission target)\n    {\n        // If &#39;target&#39; is null and this permission allows nothing, return true.\n        if (target == null) return m_flags == 0;\n\n        // Both objects must be the same type.\n        SoundPermission soundPerm = VerifyTypeMatch(target);\n\n        // Return true if the permissions of &#39;this&#39; is a subset of &#39;target&#39;.\n        return m_flags &lt;= soundPerm.m_flags;\n    }\n\n    // Return a new object that matches &#39;this&#39; object&#39;s permissions.\n    public sealed override IPermission Copy()\n    {\n        return (IPermission)Clone();\n    }\n\n    // Return a new object that contains the union of &#39;this&#39; and &#39;target&#39;.\n    // Note: You do not have to implement this method. If you do not, the version\n    // in CodeAccessPermission does this:\n    //    1. If target is not null, a NotSupportedException is thrown.\n    //    2. If target is null, then Copy is called and the new object is returned.\n    public override IPermission Union(IPermission target)\n    {\n        // If &#39;target&#39; is null, then return a copy of &#39;this&#39;.\n        if (target == null) return Copy();\n\n        // Both objects must be the same type.\n        SoundPermission soundPerm = VerifyTypeMatch(target);\n\n        // If &#39;this&#39; or &#39;target&#39; are unrestricted, return a new unrestricted permission.\n        if (m_specifiedAsUnrestricted || soundPerm.m_specifiedAsUnrestricted)\n            return Clone(true, SoundPermissionState.PlayAnySound);\n\n        // Return a new object with the calculated, unioned permission value.\n        return Clone(false, (SoundPermissionState)\n            Math.Max((Int32)m_flags, (Int32)soundPerm.m_flags));\n    }\n    #endregion\n\n    #region ISecurityEncodable Members\n    // Populate the permission&#39;s fields from XML.\n    public override void FromXml(SecurityElement e)\n    {\n        m_specifiedAsUnrestricted = false;\n        m_flags = 0;\n\n        // If XML indicates an unrestricted permission, make this permission unrestricted.\n        String s = (String)e.Attributes[&quot;Unrestricted&quot;];\n        if (s != null)\n        {\n            m_specifiedAsUnrestricted = Convert.ToBoolean(s);\n            if (m_specifiedAsUnrestricted)\n                m_flags = SoundPermissionState.PlayAnySound;\n        }\n\n        // If XML indicates a restricted permission, parse the flags.\n        if (!m_specifiedAsUnrestricted)\n        {\n            s = (String)e.Attributes[&quot;Flags&quot;];\n            if (s != null)\n            {\n                m_flags = (SoundPermissionState)\n                Convert.ToInt32(Enum.Parse(typeof(SoundPermission), s, true));\n            }\n        }\n    }\n\n    // Produce XML from the permission&#39;s fields.\n    public override SecurityElement ToXml()\n    {\n        // These first three lines create an element with the required format.\n        SecurityElement e = new SecurityElement(&quot;IPermission&quot;);\n        // Replace the double quotation marks (��) with single quotation marks (��)\n        // to remain XML compliant when the culture is not neutral.\n        e.AddAttribute(&quot;class&quot;, GetType().AssemblyQualifiedName.Replace(&#39;\\&quot;&#39;, &#39;\\&#39;&#39;));\n        e.AddAttribute(&quot;version&quot;, &quot;1&quot;);\n\n        if (!m_specifiedAsUnrestricted)\n            e.AddAttribute(&quot;Flags&quot;, Enum.Format(typeof(SoundPermissionState), m_flags, &quot;G&quot;));\n        else\n            e.AddAttribute(&quot;Unrestricted&quot;, &quot;true&quot;);\n        return e;\n    }\n    #endregion\n\n    #region IUnrestrictedPermission Members\n    // Returns true if permission is effectively unrestricted.\n    public Boolean IsUnrestricted()\n    {\n        // This means that the object is unrestricted at runtime.\n        return m_flags == SoundPermissionState.PlayAnySound;\n    }\n    #endregion\n\n    #region ICloneable Members\n\n    // Return a copy of the permission.\n    public Object Clone() { return MemberwiseClone(); }\n\n    #endregion\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Permission#1\">Imports System\nImports System.Security\nImports System.Security.Permissions\nImports System.Reflection\n\n\n&#39; Enumerated type for permission states.\n&lt;Serializable()&gt;  _\nPublic Enum SoundPermissionState\n    NoSound = 0\n    PlaySystemSounds = 1\n    PlayAnySound = 2\nEnd Enum &#39;SoundPermissionState\n\n&#39; Derive from CodeAccessPermission to gain implementations of the following\n&#39; sealed IStackWalk methods: Assert, Demand, Deny, and PermitOnly.\n&#39; Implement the following abstract IPermission methods: Copy, Intersect, and IsSubSetOf.\n&#39; Implementing the Union method of the IPermission class is optional.\n&#39; Implement the following abstract ISecurityEncodable methods: FromXml and ToXml.\n&#39; Making the class &#39;sealed&#39; is optional.\n\nNotInheritable Public Class SoundPermission\n    Inherits CodeAccessPermission\n    Implements IPermission, IUnrestrictedPermission, ISecurityEncodable, ICloneable\n    Private m_specifiedAsUnrestricted As [Boolean] = False\n    Private m_flags As SoundPermissionState = SoundPermissionState.NoSound\n    &#39; This constructor creates and initializes a permission with generic access.\n    Public Sub New(ByVal state As PermissionState) \n        m_specifiedAsUnrestricted = state = PermissionState.Unrestricted\n    \n    End Sub &#39;New    \n    &#39; This constructor creates and initializes a permission with specific access.        \n    Public Sub New(ByVal flags As SoundPermissionState) \n        If Not [Enum].IsDefined(GetType(SoundPermissionState), flags) Then\n            Throw New ArgumentException(&quot;flags value is not valid for the SoundPermissionState enuemrated type&quot;)\n        End If\n        m_specifiedAsUnrestricted = False\n        m_flags = flags\n    \n    End Sub &#39;New   \n    &#39; For debugging, return the state of this object as XML.\n    Public Overrides Function ToString() As String \n        Return ToXml().ToString()\n    \n    End Function &#39;ToString   \n    &#39; Private method to cast (if possible) an IPermission to the type.\n    Private Function VerifyTypeMatch(ByVal target As IPermission) As SoundPermission\n        If [GetType]() &lt;&gt; target.GetType() Then\n            Throw New ArgumentException(String.Format(&quot;target must be of the {0} type&quot;, [GetType]().FullName))\n        End If\n        Return CType(target, SoundPermission)\n\n    End Function &#39;VerifyTypeMatch\n    &#39; This is the Private Clone helper method. \n    Private Function Clone(ByVal specifiedAsUnrestricted As [Boolean], ByVal flags As SoundPermissionState) As SoundPermission\n        Dim soundPerm As SoundPermission = CType(Clone(), SoundPermission)\n        soundPerm.m_specifiedAsUnrestricted = specifiedAsUnrestricted\n        soundPerm.m_flags = IIf(specifiedAsUnrestricted, SoundPermissionState.PlayAnySound, m_flags)\n        Return soundPerm\n\n    End Function &#39;Clone\n\n#Region &quot;IPermission Members&quot;\n\n    &#39; Return a new object that contains the intersection of &#39;this&#39; and &#39;target&#39;.\n    Public Overrides Function Intersect(ByVal target As IPermission) As IPermission\n        &#39; If &#39;target&#39; is null, return null.\n        If target Is Nothing Then\n            Return Nothing\n        End If\n        &#39; Both objects must be the same type.\n        Dim soundPerm As SoundPermission = VerifyTypeMatch(target)\n\n        &#39; If &#39;this&#39; and &#39;target&#39; are unrestricted, return a new unrestricted permission.\n        If m_specifiedAsUnrestricted AndAlso soundPerm.m_specifiedAsUnrestricted Then\n            Return Clone(True, SoundPermissionState.PlayAnySound)\n        End If\n        &#39; Calculate the intersected permissions. If there are none, return null.\n        Dim val As SoundPermissionState = CType(Math.Min(CType(m_flags, Int32), CType(soundPerm.m_flags, Int32)), SoundPermissionState)\n        If val = 0 Then\n            Return Nothing\n        End If\n        &#39; Return a new object with the intersected permission value.\n        Return Clone(False, val)\n\n    End Function &#39;Intersect\n\n    &#39; Called by the Demand method: returns true if &#39;this&#39; is a subset of &#39;target&#39;.\n    Public Overrides Function IsSubsetOf(ByVal target As IPermission) As [Boolean]\n        &#39; If &#39;target&#39; is null and this permission allows nothing, return true.\n        If target Is Nothing Then\n            Return m_flags = 0\n        End If\n        &#39; Both objects must be the same type.\n        Dim soundPerm As SoundPermission = VerifyTypeMatch(target)\n\n        &#39; Return true if the permissions of &#39;this&#39; is a subset of &#39;target&#39;.\n        Return m_flags &lt;= soundPerm.m_flags\n\n    End Function &#39;IsSubsetOf\n\n    &#39; Return a new object that matches &#39;this&#39; object&#39;s permissions.\n    Public Overrides Function Copy() As IPermission\n        Return CType(Clone(), IPermission)\n\n    End Function &#39;Copy\n\n    &#39; Return a new object that contains the union of &#39;this&#39; and &#39;target&#39;.\n    &#39; Note: You do not have to implement this method. If you do not, the version\n    &#39; in CodeAccessPermission does this:\n    &#39;    1. If target is not null, a NotSupportedException is thrown.\n    &#39;    2. If target is null, then Copy is called and the new object is returned.\n    Public Overrides Function Union(ByVal target As IPermission) As IPermission\n        &#39; If &#39;target&#39; is null, then return a copy of &#39;this&#39;.\n        If target Is Nothing Then\n            Return Copy()\n        End If\n        &#39; Both objects must be the same type.\n        Dim soundPerm As SoundPermission = VerifyTypeMatch(target)\n\n        &#39; If &#39;this&#39; or &#39;target&#39; are unrestricted, return a new unrestricted permission.\n        If m_specifiedAsUnrestricted OrElse soundPerm.m_specifiedAsUnrestricted Then\n            Return Clone(True, SoundPermissionState.PlayAnySound)\n        End If\n        &#39; Return a new object with the calculated, unioned permission value.\n        Return Clone(False, CType(Math.Max(CType(m_flags, Int32), CType(soundPerm.m_flags, Int32)), SoundPermissionState))\n\n    End Function &#39;Union\n#End Region\n#Region &quot;ISecurityEncodable Members&quot;\n\n    &#39; Populate the permission&#39;s fields from XML.\n    Public Overrides Sub FromXml(ByVal e As SecurityElement)\n        m_specifiedAsUnrestricted = False\n        m_flags = 0\n\n        &#39; If XML indicates an unrestricted permission, make this permission unrestricted.\n        Dim s As String = CStr(e.Attributes(&quot;Unrestricted&quot;))\n        If Not (s Is Nothing) Then\n            m_specifiedAsUnrestricted = Convert.ToBoolean(s)\n            If m_specifiedAsUnrestricted Then\n                m_flags = SoundPermissionState.PlayAnySound\n            End If\n        End If\n        &#39; If XML indicates a restricted permission, parse the flags.\n        If Not m_specifiedAsUnrestricted Then\n            s = CStr(e.Attributes(&quot;Flags&quot;))\n            If Not (s Is Nothing) Then\n                m_flags = CType(Convert.ToInt32([Enum].Parse(GetType(SoundPermission), s, True)), SoundPermissionState)\n            End If\n        End If\n\n    End Sub &#39;FromXml\n\n    &#39; Produce XML from the permission&#39;s fields.\n    Public Overrides Function ToXml() As SecurityElement\n        &#39; These first three lines create an element with the required format.\n        Dim e As New SecurityElement(&quot;IPermission&quot;)\n        &#39; Replace the double quotation marks (“”) with single quotation marks (‘’)\n        &#39; to remain XML compliant when the culture is not neutral.\n        e.AddAttribute(&quot;class&quot;, [GetType]().AssemblyQualifiedName.Replace(ControlChars.Quote, &quot;&#39;&quot;c))\n        e.AddAttribute(&quot;version&quot;, &quot;1&quot;)\n\n        If Not m_specifiedAsUnrestricted Then\n            e.AddAttribute(&quot;Flags&quot;, [Enum].Format(GetType(SoundPermissionState), m_flags, &quot;G&quot;))\n        Else\n            e.AddAttribute(&quot;Unrestricted&quot;, &quot;true&quot;)\n        End If\n        Return e\n\n    End Function &#39;ToXml\n#End Region\n#Region &quot;IUnrestrictedPermission Members&quot;\n\n    &#39; Returns true if permission is effectively unrestricted.\n    Public Function IsUnrestricted() As [Boolean] Implements IUnrestrictedPermission.IsUnrestricted\n        &#39; This means that the object is unrestricted at runtime.\n        Return m_flags = SoundPermissionState.PlayAnySound\n\n    End Function &#39;IsUnrestricted\n#End Region\n#Region &quot;ICloneable Members&quot;\n    &#39; Return a copy of the permission.\n    Public Function Clone() As [Object] Implements System.ICloneable.Clone\n        Return MemberwiseClone()\n\n    End Function &#39;Clone \n#End Region\n\nEnd Class &#39;SoundPermission\n</code></pre><pre><code class=\"lang-cpp\" name=\"Permission#1\">using namespace System;\nusing namespace System::Security;\nusing namespace System::Security::Permissions;\nusing namespace System::Reflection;\n\n// Enumerated type for permission states.\n[Serializable]\npublic enum class SoundPermissionState\n{\n    NoSound = 0,\n    PlaySystemSounds = 1,\n    PlayAnySound = 2\n};\n\n// Derive from CodeAccessPermission to gain implementations of the following\n// sealed IStackWalk methods: Assert, Demand, Deny, and PermitOnly.\n// Implement the following abstract IPermission methods: \n// Copy, Intersect, and IsSubSetOf.\n// Implementing the Union method of the IPermission class is optional.\n// Implement the following abstract ISecurityEncodable methods: \n// FromXml and ToXml.\n// Making the class &#39;sealed&#39; is optional.\n\npublic ref class SoundPermission sealed : public CodeAccessPermission, \n    public IPermission, public IUnrestrictedPermission, \n    public ISecurityEncodable, public ICloneable\n{\nprivate:\n    bool specifiedAsUnrestricted;\nprivate:\n    SoundPermissionState stateFlags;\n\n    // This constructor creates and initializes \n    // a permission with generic access.\npublic:\n    SoundPermission(PermissionState^ state)\n    {\n        specifiedAsUnrestricted = (state == PermissionState::Unrestricted);\n    }\n\n    // This constructor creates and initializes \n    // a permission with specific access.\npublic:\n    SoundPermission(SoundPermissionState flags)\n    {\n        if (flags &lt; SoundPermissionState::NoSound ||\n            flags &gt; SoundPermissionState::PlayAnySound)\n        {\n            throw gcnew ArgumentException(&quot;The value of \\&quot;flags\\&quot; is not&quot; +\n                &quot; valid for the SoundPermissionState enumerated type&quot;);\n        }\n        stateFlags = flags;\n    }\n\n    // For debugging, return the state of this object as XML.\npublic:\n    virtual String^ ToString() override\n    {\n        return ToXml()-&gt;ToString();\n    }\n\n    // Private method to cast (if possible) an IPermission to the type.\nprivate:\n    SoundPermission^ VerifyTypeMatch(IPermission^ target)\n    {\n        if (GetType() != target-&gt;GetType())\n        {\n            throw gcnew ArgumentException(String::Format(\n                &quot;The variable \\&quot;target\\&quot; must be of the {0} type&quot;,\n                GetType()-&gt;FullName));\n        }\n        return (SoundPermission^) target;\n    }\n\n    // This is the Private Clone helper method.\nprivate:\n    SoundPermission^ Clone(bool specifiedAsUnrestricted, \n        SoundPermissionState flags)\n    {\n        SoundPermission^ soundPerm = (SoundPermission^) Clone();\n        soundPerm-&gt;specifiedAsUnrestricted = specifiedAsUnrestricted;\n        soundPerm-&gt;stateFlags = specifiedAsUnrestricted ? \n            SoundPermissionState::PlayAnySound : flags;\n        return soundPerm;\n    }\n\n    #pragma region IPermission^ Members\n    // Return a new object that contains the intersection \n    // of &#39;this&#39; and &#39;target&#39;.\npublic:\n    virtual IPermission^ Intersect(IPermission^ target) override\n    {\n        // If &#39;target&#39; is null, return null.\n        if (target == nullptr)\n        {\n            return nullptr;\n        }\n\n        // Both objects must be the same type.\n        SoundPermission^ soundPerm = VerifyTypeMatch(target);\n\n        // If &#39;this&#39; and &#39;target&#39; are unrestricted, \n        // return a new unrestricted permission.\n        if (specifiedAsUnrestricted &amp;&amp; soundPerm-&gt;specifiedAsUnrestricted)\n        {\n            return Clone(true, SoundPermissionState::PlayAnySound);\n        }\n\n        // Calculate the intersected permissions. \n        // If there are none, return null.\n        SoundPermissionState minimumPermission = (SoundPermissionState)\n            Math::Min((int) stateFlags, (int) soundPerm-&gt;stateFlags);\n        if ((int)minimumPermission == 0)\n        {\n            return nullptr;\n        }\n\n        // Return a new object with the intersected permission value.\n        return Clone(false, minimumPermission);\n    }\n\n    // Called by the Demand method: returns true \n    // if &#39;this&#39; is a subset of &#39;target&#39;.\npublic:\n    virtual bool IsSubsetOf(IPermission^ target) override\n    {\n        // If &#39;target&#39; is null and this permission allows nothing, \n        // return true.\n        if (target == nullptr)\n        {\n            return (int)stateFlags == 0;\n        }\n\n        // Both objects must be the same type.\n        SoundPermission^ soundPerm = VerifyTypeMatch(target);\n\n        // Return true if the permissions of &#39;this&#39; \n        // is a subset of &#39;target&#39;.\n        return stateFlags &lt;= soundPerm-&gt;stateFlags;\n    }\n\n    // Return a new object that matches &#39;this&#39; object&#39;s permissions.\npublic:\n    virtual IPermission^ Copy () override sealed\n    {\n        return (IPermission^) Clone();\n    }\n\n    // Return a new object that contains the union of &#39;this&#39; and &#39;target&#39;.\n    // Note: You do not have to implement this method. \n    // If you do not, the version\n    // in CodeAccessPermission does this:\n    //    1. If target is not null, a NotSupportedException is thrown.\n    //    2. If target is null, then Copy is called and \n    //       the new object is returned.\npublic:\n    virtual IPermission^ Union(IPermission^ target) override\n    {\n        // If &#39;target&#39; is null, then return a copy of &#39;this&#39;.\n        if (target == nullptr)\n        {\n            return Copy();\n        }\n\n        // Both objects must be the same type.\n        SoundPermission^ soundPerm = VerifyTypeMatch(target);\n\n        // If &#39;this&#39; or &#39;target&#39; are unrestricted, \n        // return a new unrestricted permission.\n        if (specifiedAsUnrestricted || soundPerm-&gt;specifiedAsUnrestricted)\n        {\n            return Clone(true, SoundPermissionState::PlayAnySound);\n        }\n\n        // Return a new object with the calculated, unioned permission value.\n        return Clone(false, (SoundPermissionState)\n            Math::Max((int) stateFlags, (int) soundPerm-&gt;stateFlags));\n    }\n    #pragma endregion\n\n    #pragma region ISecurityEncodable^ Members\n    // Populate the permission&#39;s fields from XML.\npublic:\n    virtual void FromXml(SecurityElement^ element) override\n    {\n        specifiedAsUnrestricted = false;\n        stateFlags = (SoundPermissionState)0;\n\n        // If XML indicates an unrestricted permission, \n        // make this permission unrestricted.\n        String^ attributeString = \n            (String^) element-&gt;Attributes[&quot;Unrestricted&quot;];\n        if (attributeString != nullptr)\n        {\n            specifiedAsUnrestricted = Convert::ToBoolean(attributeString);\n            if (specifiedAsUnrestricted)\n            {\n                stateFlags = SoundPermissionState::PlayAnySound;\n            }\n        }\n\n        // If XML indicates a restricted permission, parse the flags.\n        if (!specifiedAsUnrestricted)\n        {\n            attributeString = (String^) element-&gt;Attributes[&quot;Flags&quot;];\n            if (attributeString != nullptr)\n            {\n                stateFlags = (SoundPermissionState) Convert::ToInt32(\n                    Enum::Parse(SoundPermissionState::typeid, \n                    attributeString, true));\n            }\n        }\n    }\n\n    // Produce XML from the permission&#39;s fields.\npublic:\n    virtual SecurityElement^ ToXml() override\n    {\n        // These first three lines create an element with the required format.\n        SecurityElement^ element = gcnew SecurityElement(&quot;IPermission&quot;);\n        // Replace the double quotation marks () \n        // with single quotation marks ()\n        // to remain XML compliant when the culture is not neutral.\n        element-&gt;AddAttribute(&quot;class&quot;, \n            GetType()-&gt;AssemblyQualifiedName-&gt;Replace(&#39;\\&quot;&#39;, &#39;\\&#39;&#39;));\n        element-&gt;AddAttribute(&quot;version&quot;, &quot;1&quot;);\n\n        if (!specifiedAsUnrestricted)\n        {\n            element-&gt;AddAttribute(&quot;Flags&quot;, \n                Enum::Format(SoundPermissionState::typeid, stateFlags, &quot;G&quot;));\n        }   \n        else\n        {\n            element-&gt;AddAttribute(&quot;Unrestricted&quot;, &quot;true&quot;);\n        }\n        return element;\n    }\n    #pragma endregion\n\n    #pragma region IUnrestrictedPermission^ Members\n    // Returns true if permission is effectively unrestricted.\npublic:\n    virtual bool IsUnrestricted()\n    {\n        // This means that the object is unrestricted at runtime.\n        return stateFlags == SoundPermissionState::PlayAnySound;\n    }\n    #pragma endregion\n\n    #pragma region ICloneable^ Members\n\n    // Return a copy of the permission.\npublic:\n    virtual Object^ Clone()\n    {\n        return MemberwiseClone();\n    }\n\n    #pragma endregion\n};\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>Permissions in the common language runtime are objects that describe sets of operations that can be secured for specified resources. A permission object describes operations or access that is subject to security control; it does not represent access or a right to perform operations. Permissions are used by both application code and the .NET Framework security system in the following ways.  </p>\n<ul>\n<li><p>Code requests the permissions it needs in order to run.  </p>\n</li>\n<li><p>The security system policy grants permissions to code in order for it to run.  </p>\n</li>\n<li><p>Code demands that calling code has a permission.  </p>\n</li>\n<li><p>Code overrides the security stack using assert/deny/permit-only.  </p>\n</li>\n</ul>\n<div class=\"NOTE\"><h5>Note</h5><p> If you write a new permission, you must implement this interface in your class.  </p>\n</div>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> A permission can be accessed by multiple threads. When implementing this interface, you must guarantee that the <a class=\"xref\" href=\"system.security.ipermission#System_Security_IPermission_IsSubsetOf_\" data-linktype=\"relative-path\">IsSubsetOf</a>, <a class=\"xref\" href=\"system.security.ipermission#System_Security_IPermission_Intersect_\" data-linktype=\"relative-path\">Intersect</a>, <a class=\"xref\" href=\"system.security.ipermission#System_Security_IPermission_Union_\" data-linktype=\"relative-path\">Union</a>, and <a class=\"xref\" href=\"system.security.ipermission#System_Security_IPermission_Copy_\" data-linktype=\"relative-path\">Copy</a> method implementations are thread safe.</p>\n</div>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Methods\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Security_IPermission_Copy_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_IPermission_Copy\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Copy()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Creates and returns an identical copy of the current permission.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Security.IPermission Copy ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.ipermission\" data-linktype=\"relative-path\">IPermission</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>A copy of the current permission.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>A copy of a permission represents the same access to resources as the original permission.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Security_IPermission_Demand_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_IPermission_Demand\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Demand()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Throws a <a class=\"xref\" href=\"system.security.securityexception\" data-linktype=\"relative-path\">SecurityException</a> at run time if the security requirement is not met.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void Demand ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This method is typically used by secure libraries to ensure that callers have permission to access a resource. For example, a file class in a secure class library calls <a class=\"xref\" href=\"system.security.codeaccesspermission#System_Security_CodeAccessPermission_Demand_\" data-linktype=\"relative-path\">Demand</a> for the necessary <a class=\"xref\" href=\"system.security.permissions.fileiopermission\" data-linktype=\"relative-path\">FileIOPermission</a> before performing a file operation requested by the caller.  </p>\n<p> Although the majority of the classes that implement this interface method satisfy the security criteria by performing a full stack walk, a stack walk is not necessarily performed. An example of an implementation that does not perform a stack walk is <a class=\"xref\" href=\"system.security.permissions.principalpermission#System_Security_Permissions_PrincipalPermission_Demand_\" data-linktype=\"relative-path\">Demand</a>.  </p>\n<p> When a stack walk is performed, the permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack. The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack. <a class=\"xref\" href=\"system.security.codeaccesspermission#System_Security_CodeAccessPermission_Demand_\" data-linktype=\"relative-path\">Demand</a> succeeds only if no <a class=\"xref\" href=\"system.security.securityexception\" data-linktype=\"relative-path\">SecurityException</a> is raised.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Security_IPermission_Intersect_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_IPermission_Intersect_System_Security_IPermission_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Intersect(IPermission)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Creates and returns a permission that is the intersection of the current permission and the specified permission.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Security.IPermission Intersect (System.Security.IPermission target);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>target</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.ipermission\" data-linktype=\"relative-path\">IPermission</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A permission to intersect with the current permission. It must be of the same type as the current permission.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.ipermission\" data-linktype=\"relative-path\">IPermission</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>A new permission that represents the intersection of the current permission and the specified permission. This new permission is <code>null</code> if the intersection is empty.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>target</code> parameter is not <code>null</code> and is not an instance of the same class as the current permission.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The intersection of two permissions is a permission that describes the set of operations they both describe in common. Only a demand that passes both original permissions will pass the intersection.  </p>\n<p> The following statements are required to be true for all implementations of the Intersect method. <code>X</code> and <code>Y</code> represent <a class=\"xref\" href=\"system.security.ipermission\" data-linktype=\"relative-path\">IPermission</a> object references that are not <code>null</code>.  </p>\n<ul>\n<li><p><code>X</code>.Intersect(<code>X</code>) returns a value equal to <code>X</code>.  </p>\n</li>\n<li><p><code>X</code>.Intersect(<code>Y</code>) returns the same value as <code>Y</code>.Intersect(<code>X</code>).  </p>\n</li>\n<li><p><code>X</code>.Intersect(<code>null</code>) returns <code>null</code>.</p>\n</li>\n</ul>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Security_IPermission_IsSubsetOf_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_IPermission_IsSubsetOf_System_Security_IPermission_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">IsSubsetOf(IPermission)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Determines whether the current permission is a subset of the specified permission.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public bool IsSubsetOf (System.Security.IPermission target);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>target</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.ipermission\" data-linktype=\"relative-path\">IPermission</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A permission that is to be tested for the subset relationship. This permission must be of the same type as the current permission.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if the current permission is a subset of the specified permission; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>target</code> parameter is not <code>null</code> and is not of the same type as the current permission.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The current permission is a subset of the specified permission if the current permission specifies a set of operations that is wholly contained by the specified permission. For example, a permission that represents access to C:\\example.txt is a subset of a permission that represents access to C:\\. If this method returns <code>true</code>, the current permission represents no more access to the protected resource than does the specified permission.  </p>\n<p> The following statements are required to be true for all implementations of the IsSubsetOf method. <code>X</code>, <code>Y</code>, and <code>Z</code> represent <a class=\"xref\" href=\"system.security.ipermission\" data-linktype=\"relative-path\">IPermission</a> objects that are not <code>null</code>.  </p>\n<ul>\n<li><p><code>X</code>.IsSubsetOf(<code>X</code>) returns <code>true</code>.  </p>\n</li>\n<li><p><code>X</code>.IsSubsetOf(<code>Y</code>) returns the same value as <code>Y</code>.IsSubsetOf(<code>X</code>) if and only if <code>X</code> and <code>Y</code> represent the same set of permissions.  </p>\n</li>\n<li><p>If <code>X</code>.IsSubsetOf(<code>Y</code>) and <code>Y</code>.IsSubsetOf(<code>Z</code>) both return <code>true</code>, <code>X</code>.IsSubsetOf(<code>Z</code>) returns <code>true</code>.  </p>\n<p>If <code>X</code> represents an empty <a class=\"xref\" href=\"system.security.ipermission\" data-linktype=\"relative-path\">IPermission</a> object with a permission state of <a class=\"xref\" href=\"system.security.permissions.permissionstate\" data-linktype=\"relative-path\">PermissionState</a> and <code>Y</code> represents an <a class=\"xref\" href=\"system.security.ipermission\" data-linktype=\"relative-path\">IPermission</a> object that is <code>null</code>, <code>X</code>.IsSubsetOf(<code>Y</code>) returns <code>true</code>. If <code>Z</code> is also an empty permission, the compound set operation <code>X</code>.Union(Z).IsSubsetOf(Y) also returns <code>true</code> because the union of two empty permissions is an empty permission.</p>\n</li>\n</ul>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Security_IPermission_Union_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_IPermission_Union_System_Security_IPermission_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Union(IPermission)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Creates a permission that is the union of the current permission and the specified permission.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Security.IPermission Union (System.Security.IPermission target);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>target</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.ipermission\" data-linktype=\"relative-path\">IPermission</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A permission to combine with the current permission. It must be of the same type as the current permission.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.ipermission\" data-linktype=\"relative-path\">IPermission</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>A new permission that represents the union of the current permission and the specified permission.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>target</code> parameter is not <code>null</code> and is not of the same type as the current permission.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The result of a call to Union is a permission that represents all the operations represented by both the current permission and the specified permission. Any demand that passes either permission passes their union.  </p>\n<p> The following statements are required to be true for all implementations of the Union method. <code>X</code> and <code>Y</code> represent <a class=\"xref\" href=\"system.security.ipermission\" data-linktype=\"relative-path\">IPermission</a> objects that are not <code>null</code>.  </p>\n<ul>\n<li><p><code>X</code>.Union(<code>X</code>) returns an object that has the same value as <code>X</code>.  </p>\n</li>\n<li><p><code>X</code>.Union(<code>Y</code>) returns an object that has the same value as the object returned by <code>Y</code>.Union(<code>X</code>).  </p>\n</li>\n<li><p><code>X</code>.Union(<code>null</code>) returns an object that has the same value as <code>X</code>.</p>\n</li>\n</ul>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Security.IPermission.yml\">\r\n<meta name=\"APIName\" content=\"System.Security.IPermission\">\r\n<meta name=\"APIName\" content=\"System.Security.IPermission.Copy\">\r\n<meta name=\"APIName\" content=\"System.Security.IPermission.Demand\">\r\n<meta name=\"APIName\" content=\"System.Security.IPermission.Intersect\">\r\n<meta name=\"APIName\" content=\"System.Security.IPermission.IsSubsetOf\">\r\n<meta name=\"APIName\" content=\"System.Security.IPermission.Union\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-04-01 05:59 PM\">\r\n<meta name=\"document_id\" content=\"6c437e09-221f-ed07-7f34-b0c4c670b91e\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Defines methods implemented by permission types.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.security/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Security.IPermission\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","uhfHeaderId":"MSDocsHeader-DotNet","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Security.IPermission.yml","open_to_public_contributors":false,"api_name":["System.Security.IPermission","System.Security.IPermission.Copy","System.Security.IPermission.Demand","System.Security.IPermission.Intersect","System.Security.IPermission.IsSubsetOf","System.Security.IPermission.Union"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Security.IPermission","System::Security::IPermission","System.Security.IPermission.Copy","System::Security::IPermission::Copy","System.Security.IPermission.Demand","System::Security::IPermission::Demand","System.Security.IPermission.Intersect","System::Security::IPermission::Intersect","System.Security.IPermission.IsSubsetOf","System::Security::IPermission::IsSubsetOf","System.Security.IPermission.Union","System::Security::IPermission::Union"],"dev_langs":["csharp"],"updated_at":"2017-04-01 05:59 PM","document_id":"6c437e09-221f-ed07-7f34-b0c4c670b91e","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Security/IPermission.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"IPermission interface | Microsoft Docs","_op_ogTitle":"IPermission interface","description":"Defines methods implemented by permission types.\n","toc_asset_id":"api/_splitted/System.Security/toc.json","toc_rel":"_splitted/System.Security/toc.json","source_url":"","ms.assetid":"System.Security.IPermission","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.security.ipermission","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.security.ipermission","fileRelativePath":"api/System.Security.IPermission.html"},"themesRelativePathToOutputRoot":"_themes/"}