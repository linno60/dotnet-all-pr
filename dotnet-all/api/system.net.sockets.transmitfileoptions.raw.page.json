{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">TransmitFileOptions</span>\r\n      Enum\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>The TransmitFileOptions enumeration defines values used in file transfer requests.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\r\n  \t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Flags]\npublic enum TransmitFileOptions</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.valuetype\" data-linktype=\"relative-path\">ValueType</a></span></div><div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.enum\" data-linktype=\"relative-path\">Enum</a></span></div><span class=\"lang-csharp\">TransmitFileOptions</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Attributes</dt><dd>\r\n  \t\t<div class=\"cdlHolder\">\r\n  \t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.flagsattribute\" title=\"System.FlagsAttribute\" data-linktype=\"relative-path\">FlagsAttribute</a></span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following example demonstrates the use of TransmitFileOptions in a call to <a class=\"xref\" href=\"system.net.sockets.socket#System_Net_Sockets_Socket_SendFile_\" data-linktype=\"relative-path\">SendFile</a>. The file &quot;test.txt&quot; is located in the root directory of the local machine. In this example, a prebuffer and postbuffer of data are created and sent to the remote host with the file. To use the system&#39;s default thread, UseDefaultWorkerThread is specified.  </p>\n<pre><code class=\"lang-cs\" name=\"NCLSocketEnhancements#4\">// Establish the local endpoint for the socket.\nIPHostEntry ipHost = Dns.GetHostEntry(Dns.GetHostName());\nIPAddress  ipAddr = ipHost.AddressList[0];\nIPEndPoint ipEndPoint = new IPEndPoint(ipAddr, 11000);\n\n// Create a TCP socket.\nSocket client = new Socket(AddressFamily.InterNetwork,\n        SocketType.Stream, ProtocolType.Tcp);\n\n// Connect the socket to the remote endpoint.\nclient.Connect(ipEndPoint);\n\n// Send file fileName to the remote host with preBuffer and postBuffer data.\n// There is a text file test.txt located in the root directory.\nstring fileName = &quot;C:\\\\test.txt&quot;;\n\n// Create the preBuffer data.\nstring string1 = String.Format(&quot;This is text data that precedes the file.{0}&quot;, Environment.NewLine);\nbyte[] preBuf = Encoding.ASCII.GetBytes(string1);\n\n// Create the postBuffer data.\nstring string2 = String.Format(&quot;This is text data that will follow the file.{0}&quot;, Environment.NewLine);\nbyte[] postBuf = Encoding.ASCII.GetBytes(string2);\n\n//Send file fileName with buffers and default flags to the remote device.\nConsole.WriteLine(&quot;Sending {0} with buffers to the host.{1}&quot;, fileName, Environment.NewLine);\nclient.SendFile(fileName, preBuf, postBuf, TransmitFileOptions.UseDefaultWorkerThread);\n\n// Release the socket.\nclient.Shutdown(SocketShutdown.Both);\nclient.Close();\n</code></pre><pre><code class=\"lang-cpp\" name=\"NCLSocketEnhancements#4\">// Establish the local endpoint for the socket.\nIPHostEntry^ ipHost = Dns::GetHostEntry( Dns::GetHostName() );\nIPAddress^ ipAddr = ipHost-&gt;AddressList[ 0 ];\nIPEndPoint^ ipEndPoint = gcnew IPEndPoint( ipAddr,11000 );\n\n// Create a TCP socket.\nSocket^ client = gcnew Socket( AddressFamily::InterNetwork,SocketType::Stream,ProtocolType::Tcp );\n\n// Connect the socket to the remote endpoint.\nclient-&gt;Connect( ipEndPoint );\n\n// Send file fileName to the remote host with preBuffer and postBuffer data.\n// There is a text file test.txt located in the root directory.\nString^ fileName = &quot;C:\\\\test.txt&quot;;\n\n// Create the preBuffer data.\nString^ string1 = String::Format( &quot;This is text data that precedes the file.{0}&quot;, Environment::NewLine );\narray&lt;Byte&gt;^preBuf = Encoding::ASCII-&gt;GetBytes( string1 );\n\n// Create the postBuffer data.\nString^ string2 = String::Format( &quot;This is text data that will follow the file.{0}&quot;, Environment::NewLine );\narray&lt;Byte&gt;^postBuf = Encoding::ASCII-&gt;GetBytes( string2 );\n\n//Send file fileName with buffers and default flags to the remote device.\nConsole::WriteLine( &quot;Sending {0} with buffers to the host.{1}&quot;, fileName, Environment::NewLine );\nclient-&gt;SendFile( fileName, preBuf, postBuf, TransmitFileOptions::UseDefaultWorkerThread );\n\n// Release the socket.\nclient-&gt;Shutdown( SocketShutdown::Both );\nclient-&gt;Close();\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p><strong>Note</strong> The flags Disconnect and ReuseSocket return the socket to a disconnected, reusable state after the file has been transmitted. These flags should not be used on a socket where quality of service (QOS) has been requested, because the service provider might immediately delete any quality of service associated with the socket before the file transfer has completed. The best approach for a QOS-enabled socket is to call <a class=\"xref\" href=\"system.net.sockets.socket#System_Net_Sockets_Socket_Close_\" data-linktype=\"relative-path\">Close</a> when the file transfer has completed, rather than relying on these flags.</p>\n\r\n  \r\n      \t<h2 class=\"accented\">Fields\r\n      </h2>\r\n      <table class=\"nameValue\">\r\n      \t<tr><td id=\"System_Net_Sockets_TransmitFileOptions_Disconnect\">\r\n      \t\t\t<span class=\"lang-csharp\">Disconnect</span>\r\n      \t</td>\r\n      \t<td><p>Start a transport-level disconnect after all the file data has been queued for transmission. When used with ReuseSocket, these flags return the socket to a disconnected, reusable state after the file has been transmitted.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Net_Sockets_TransmitFileOptions_ReuseSocket\">\r\n      \t\t\t<span class=\"lang-csharp\">ReuseSocket</span>\r\n      \t</td>\r\n      \t<td><p>The socket handle may be reused when the request completes. This flag is valid only if Disconnect is also specified. When used with Disconnect, these flags return the socket to a disconnected, reusable state after the file has been transmitted.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Net_Sockets_TransmitFileOptions_UseDefaultWorkerThread\">\r\n      \t\t\t<span class=\"lang-csharp\">UseDefaultWorkerThread</span>\r\n      \t</td>\r\n      \t<td><p>Use the default thread to process long file transfer requests.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Net_Sockets_TransmitFileOptions_UseKernelApc\">\r\n      \t\t\t<span class=\"lang-csharp\">UseKernelApc</span>\r\n      \t</td>\r\n      \t<td><p>Use kernel asynchronous procedure calls (APCs) instead of worker threads to process long file transfer requests. Long requests are defined as requests that require more than a single read from the file or a cache; the request therefore depends on the size of the file and the specified length of the send packet.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Net_Sockets_TransmitFileOptions_UseSystemThread\">\r\n      \t\t\t<span class=\"lang-csharp\">UseSystemThread</span>\r\n      \t</td>\r\n      \t<td><p>Use system threads to process long file transfer requests.</p>\n</td>\r\n      \t</tr>\r\n      \t<tr><td id=\"System_Net_Sockets_TransmitFileOptions_WriteBehind\">\r\n      \t\t\t<span class=\"lang-csharp\">WriteBehind</span>\r\n      \t</td>\r\n      \t<td><p>Complete the file transfer request immediately, without pending. If this flag is specified and the file transfer succeeds, the data has been accepted by the system but not necessarily acknowledged by the remote end. Do not use this flag with the Disconnect and ReuseSocket flags.</p>\n</td>\r\n      \t</tr>\r\n      </table>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Net.Sockets.TransmitFileOptions.yml\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TransmitFileOptions\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TransmitFileOptions.Disconnect\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TransmitFileOptions.ReuseSocket\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TransmitFileOptions.UseKernelApc\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TransmitFileOptions.UseSystemThread\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TransmitFileOptions.WriteBehind\">\r\n<meta name=\"APILocation\" content=\"System.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-04-01 05:59 PM\">\r\n<meta name=\"document_id\" content=\"76edc620-5b79-3ab0-38f2-87fe6846e7d1\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"The TransmitFileOptions enumeration defines values used in file transfer requests.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.net.sockets/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Net.Sockets.TransmitFileOptions\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","uhfHeaderId":"MSDocsHeader-DotNet","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Net.Sockets.TransmitFileOptions.yml","open_to_public_contributors":false,"api_name":["System.Net.Sockets.TransmitFileOptions","System.Net.Sockets.TransmitFileOptions.Disconnect","System.Net.Sockets.TransmitFileOptions.ReuseSocket","System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread","System.Net.Sockets.TransmitFileOptions.UseKernelApc","System.Net.Sockets.TransmitFileOptions.UseSystemThread","System.Net.Sockets.TransmitFileOptions.WriteBehind"],"api_location":["System.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Net.Sockets.TransmitFileOptions","System::Net::Sockets::TransmitFileOptions","System.Net.Sockets.TransmitFileOptions.Disconnect","System::Net::Sockets::TransmitFileOptions::Disconnect","System.Net.Sockets.TransmitFileOptions.ReuseSocket","System::Net::Sockets::TransmitFileOptions::ReuseSocket","System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread","System::Net::Sockets::TransmitFileOptions::UseDefaultWorkerThread","System.Net.Sockets.TransmitFileOptions.UseKernelApc","System::Net::Sockets::TransmitFileOptions::UseKernelApc","System.Net.Sockets.TransmitFileOptions.UseSystemThread","System::Net::Sockets::TransmitFileOptions::UseSystemThread","System.Net.Sockets.TransmitFileOptions.WriteBehind","System::Net::Sockets::TransmitFileOptions::WriteBehind"],"dev_langs":["csharp"],"updated_at":"2017-04-01 05:59 PM","document_id":"76edc620-5b79-3ab0-38f2-87fe6846e7d1","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Net.Sockets/TransmitFileOptions.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"TransmitFileOptions enum | Microsoft Docs","_op_ogTitle":"TransmitFileOptions enum","description":"The TransmitFileOptions enumeration defines values used in file transfer requests.\n","toc_asset_id":"api/_splitted/System.Net.Sockets/toc.json","toc_rel":"_splitted/System.Net.Sockets/toc.json","source_url":"","ms.assetid":"System.Net.Sockets.TransmitFileOptions","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.transmitfileoptions","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.transmitfileoptions","fileRelativePath":"api/System.Net.Sockets.TransmitFileOptions.html"},"themesRelativePathToOutputRoot":"_themes/"}