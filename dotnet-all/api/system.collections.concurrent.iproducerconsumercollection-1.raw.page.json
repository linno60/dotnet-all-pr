{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">IProducerConsumerCollection&lt;T&gt;</span>\r\n      Interface\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Defines methods to manipulate thread-safe collections intended for producer/consumer usage. This interface provides a unified representation for producer/consumer collections so that higher level abstractions such as <span class=\"xref\">stem.Collections.Concurrent.BlockingCollection`1</span> can use the collection as the underlying storage mechanism.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">public interface IProducerConsumerCollection&lt;T&gt; : System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.ICollection</code></pre>\r\n  \r\n  \r\n  \r\n  \t\t<h3 class=\"accented\">Type Parameters</h3>\r\n  \t\t<table class=\"nameValue stack\">\r\n  \t\t\t<tr>\r\n  \t\t\t<td>T</td>\r\n  \t\t\t<td><p>Specifies the type of elements in the collection.</p>\n</td>\r\n  \t\t\t</tr>\r\n  \t\t</table>\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>The following example shows a stack data structure that implements IProducerConsumerCollection(T).  </p>\n<pre><code class=\"lang-vb\" name=\"System.Collections.Concurrent.IProducerConsumerCollection#1\">Imports System.Collections.Concurrent\n\nModule IProdCon\n    &#39; Sample implementation of IProducerConsumerCollection(T) -- in this case,\n    &#39; a thread-safe stack.\n    Public Class SafeStack(Of T)\n        Implements IProducerConsumerCollection(Of T)\n\n        &#39; Used for enforcing thread-safety\n        Private m_lockObject As New Object()\n\n        &#39; We&#39;ll use a regular old Stack for our core operations\n        Private m_sequentialStack As Stack(Of T) = Nothing\n\n        &#39;\n        &#39; Constructors\n        &#39;\n        Public Sub New()\n            m_sequentialStack = New Stack(Of T)()\n        End Sub\n\n        Public Sub New(ByVal collection As IEnumerable(Of T))\n            m_sequentialStack = New Stack(Of T)(collection)\n        End Sub\n\n        &#39;\n        &#39; Safe Push/Pop support\n        &#39;\n        Public Sub Push(ByVal item As T)\n            SyncLock m_lockObject\n                m_sequentialStack.Push(item)\n            End SyncLock\n        End Sub\n\n        Public Function TryPop(ByRef item As T) As Boolean\n            Dim rval As Boolean = True\n            SyncLock m_lockObject\n                If m_sequentialStack.Count = 0 Then\n                    item = Nothing\n                    rval = False\n                Else\n                    item = m_sequentialStack.Pop()\n                End If\n            End SyncLock\n            Return rval\n        End Function\n\n        &#39;\n        &#39; IProducerConsumerCollection(T) support\n        &#39;\n        Public Function TryTake(ByRef item As T) As Boolean Implements IProducerConsumerCollection(Of T).TryTake\n            Return TryPop(item)\n        End Function\n\n        Public Function TryAdd(ByVal item As T) As Boolean Implements IProducerConsumerCollection(Of T).TryAdd\n            Push(item)\n            &#39; Push doesn&#39;t fail\n            Return True\n        End Function\n\n        Public Function ToArray() As T() Implements IProducerConsumerCollection(Of T).ToArray\n            Dim rval As T() = Nothing\n            SyncLock m_lockObject\n                rval = m_sequentialStack.ToArray()\n            End SyncLock\n            Return rval\n        End Function\n\n        Public Sub CopyTo(ByVal array As T(), ByVal index As Integer) Implements IProducerConsumerCollection(Of T).CopyTo\n            SyncLock m_lockObject\n                m_sequentialStack.CopyTo(array, index)\n            End SyncLock\n        End Sub\n\n\n\n        &#39;\n        &#39; Support for IEnumerable(T)\n        &#39;\n        Public Function GetEnumerator() As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator\n            &#39; The performance here will be unfortunate for large stacks,\n            &#39; but thread-safety is effectively implemented.\n            Dim stackCopy As Stack(Of T) = Nothing\n            SyncLock m_lockObject\n                stackCopy = New Stack(Of T)(m_sequentialStack)\n            End SyncLock\n            Return stackCopy.GetEnumerator()\n        End Function\n\n\n        &#39;\n        &#39; Support for IEnumerable\n        &#39;\n        Private Function GetEnumerator2() As IEnumerator Implements IEnumerable.GetEnumerator\n            Return DirectCast(Me, IEnumerable(Of T)).GetEnumerator()\n        End Function\n\n        &#39; \n        &#39; Support for ICollection\n        &#39;\n        Public ReadOnly Property IsSynchronized() As Boolean Implements ICollection.IsSynchronized\n            Get\n                Return True\n            End Get\n        End Property\n\n        Public ReadOnly Property SyncRoot() As Object Implements ICollection.SyncRoot\n            Get\n                Return m_lockObject\n            End Get\n        End Property\n\n        Public ReadOnly Property Count() As Integer Implements ICollection.Count\n            Get\n                Return m_sequentialStack.Count\n            End Get\n        End Property\n\n        Public Sub CopyTo(ByVal array As Array, ByVal index As Integer) Implements ICollection.CopyTo\n            SyncLock m_lockObject\n                DirectCast(m_sequentialStack, ICollection).CopyTo(array, index)\n            End SyncLock\n        End Sub\n    End Class\n\n    &#39; Test our implementation of IProducerConsumerCollection(T)\n    &#39; Demonstrates:\n    &#39; IPCC(T).TryAdd()\n    &#39; IPCC(T).TryTake()\n    &#39; IPCC(T).CopyTo()\n    Private Sub TestSafeStack()\n        Dim stack As New SafeStack(Of Integer)()\n        Dim ipcc As IProducerConsumerCollection(Of Integer) = DirectCast(stack, IProducerConsumerCollection(Of Integer))\n\n        &#39; Test Push()/TryAdd()\n        stack.Push(10)\n        Console.WriteLine(&quot;Pushed 10&quot;)\n        ipcc.TryAdd(20)\n        Console.WriteLine(&quot;IPCC.TryAdded 20&quot;)\n        stack.Push(15)\n        Console.WriteLine(&quot;Pushed 15&quot;)\n\n        Dim testArray As Integer() = New Integer(2) {}\n\n        &#39; Try CopyTo() within boundaries\n        Try\n            ipcc.CopyTo(testArray, 0)\n            Console.WriteLine(&quot;CopyTo() within boundaries worked, as expected&quot;)\n        Catch e As Exception\n            Console.WriteLine(&quot;CopyTo() within boundaries unexpectedly threw an exception: {0}&quot;, e.Message)\n        End Try\n\n        &#39; Try CopyTo() that overflows\n        Try\n            ipcc.CopyTo(testArray, 1)\n            Console.WriteLine(&quot;CopyTo() with index overflow worked, and it SHOULD NOT HAVE&quot;)\n        Catch e As Exception\n            Console.WriteLine(&quot;CopyTo() with index overflow threw an exception, as expected: {0}&quot;, e.Message)\n        End Try\n\n        &#39; Test enumeration\n        Console.Write(&quot;Enumeration (should be three items): &quot;)\n        For Each item As Integer In stack\n            Console.Write(&quot;{0} &quot;, item)\n        Next\n        Console.WriteLine(&quot;&quot;)\n\n        &#39; Test TryPop()\n        Dim popped As Integer = 0\n        If stack.TryPop(popped) Then\n            Console.WriteLine(&quot;Successfully popped {0}&quot;, popped)\n        Else\n            Console.WriteLine(&quot;FAILED to pop!!&quot;)\n        End If\n\n        &#39; Test Count\n        Console.WriteLine(&quot;stack count is {0}, should be 2&quot;, stack.Count)\n\n        &#39; Test TryTake()\n        If ipcc.TryTake(popped) Then\n            Console.WriteLine(&quot;Successfully IPCC-TryTaked {0}&quot;, popped)\n        Else\n            Console.WriteLine(&quot;FAILED to IPCC.TryTake!!&quot;)\n        End If\n    End Sub\n\n    Sub Main()\n        TestSafeStack()\n\n        &#39; Keep the console window open in debug mode\n        Console.WriteLine(&quot;Press any key to exit.&quot;)\n        Console.ReadKey()\n\n    End Sub\n\nEnd Module\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Collections.Concurrent.IProducerConsumerCollection#1\">using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Collections.Concurrent;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\n\n\n// Sample implementation of IProducerConsumerCollection(T) \n// -- in this case, a thread-safe stack.\npublic class SafeStack&lt;T&gt; : IProducerConsumerCollection&lt;T&gt;\n{\n    // Used for enforcing thread-safety\n    private object m_lockObject = new object();\n\n    // We&#39;ll use a regular old Stack for our core operations\n    private Stack&lt;T&gt; m_sequentialStack = null;\n\n    //\n    // Constructors\n    //\n    public SafeStack()\n    {\n        m_sequentialStack = new Stack&lt;T&gt;();\n    }\n\n    public SafeStack(IEnumerable&lt;T&gt; collection)\n    {\n        m_sequentialStack = new Stack&lt;T&gt;(collection);\n    }\n\n    //\n    // Safe Push/Pop support\n    //\n    public void Push(T item)\n    {\n        lock (m_lockObject) m_sequentialStack.Push(item);\n    }\n\n    public bool TryPop(out T item)\n    {\n        bool rval = true;\n        lock (m_lockObject)\n        {\n            if (m_sequentialStack.Count == 0) { item = default(T); rval = false; }\n            else item = m_sequentialStack.Pop();\n        }\n        return rval;\n    }\n\n    //\n    // IProducerConsumerCollection(T) support\n    //\n    public bool TryTake(out T item)\n    {\n        return TryPop(out item);\n    }\n\n    public bool TryAdd(T item)\n    {\n        Push(item);\n        return true; // Push doesn&#39;t fail\n    }\n\n    public T[] ToArray()\n    {\n        T[] rval = null;\n        lock (m_lockObject) rval = m_sequentialStack.ToArray();\n        return rval;\n    }\n\n    public void CopyTo(T[] array, int index)\n    {\n        lock (m_lockObject) m_sequentialStack.CopyTo(array, index);\n    }\n\n\n\n    //\n    // Support for IEnumerable(T)\n    //\n    public IEnumerator&lt;T&gt; GetEnumerator()\n    {\n        // The performance here will be unfortunate for large stacks,\n        // but thread-safety is effectively implemented.\n        Stack&lt;T&gt; stackCopy = null;\n        lock (m_lockObject) stackCopy = new Stack&lt;T&gt;(m_sequentialStack);\n        return stackCopy.GetEnumerator();\n    }\n\n\n    //\n    // Support for IEnumerable\n    //\n    IEnumerator IEnumerable.GetEnumerator()\n    {\n        return ((IEnumerable&lt;T&gt;)this).GetEnumerator();\n    }\n\n    // \n    // Support for ICollection\n    //\n    public bool IsSynchronized\n    {\n        get { return true; }\n    }\n\n    public object SyncRoot\n    {\n        get { return m_lockObject; }\n    }\n\n    public int Count\n    {\n        get { return m_sequentialStack.Count; }\n    }\n\n    public void CopyTo(Array array, int index)\n    {\n        lock (m_lockObject) ((ICollection)m_sequentialStack).CopyTo(array, index);\n    }\n}\n\npublic class Program\n{\n    static void Main()\n    {\n        TestSafeStack();\n\n        // Keep the console window open in debug mode.\n        Console.WriteLine(&quot;Press any key to exit.&quot;);\n        Console.ReadKey();\n    }\n\n    // Test our implementation of IProducerConsumerCollection(T)\n    // Demonstrates:\n    //      IPCC(T).TryAdd()\n    //      IPCC(T).TryTake()\n    //      IPCC(T).CopyTo()\n    static void TestSafeStack()\n    {\n        SafeStack&lt;int&gt; stack = new SafeStack&lt;int&gt;();\n        IProducerConsumerCollection&lt;int&gt; ipcc = (IProducerConsumerCollection&lt;int&gt;)stack;\n\n        // Test Push()/TryAdd()\n        stack.Push(10); Console.WriteLine(&quot;Pushed 10&quot;);\n        ipcc.TryAdd(20); Console.WriteLine(&quot;IPCC.TryAdded 20&quot;);\n        stack.Push(15); Console.WriteLine(&quot;Pushed 15&quot;);\n\n        int[] testArray = new int[3];\n\n        // Try CopyTo() within boundaries\n        try\n        {\n            ipcc.CopyTo(testArray, 0);\n            Console.WriteLine(&quot;CopyTo() within boundaries worked, as expected&quot;);\n        }\n        catch (Exception e)\n        {\n            Console.WriteLine(&quot;CopyTo() within boundaries unexpectedly threw an exception: {0}&quot;, e.Message);\n        }\n\n        // Try CopyTo() that overflows\n        try\n        {\n            ipcc.CopyTo(testArray, 1);\n            Console.WriteLine(&quot;CopyTo() with index overflow worked, and it SHOULD NOT HAVE&quot;);\n        }\n        catch (Exception e)\n        {\n            Console.WriteLine(&quot;CopyTo() with index overflow threw an exception, as expected: {0}&quot;, e.Message);\n        }\n\n        // Test enumeration\n        Console.Write(&quot;Enumeration (should be three items): &quot;);\n        foreach (int item in stack) Console.Write(&quot;{0} &quot;, item);\n        Console.WriteLine(&quot;&quot;);\n\n        // Test TryPop()\n        int popped = 0;\n        if (stack.TryPop(out popped))\n        {\n            Console.WriteLine(&quot;Successfully popped {0}&quot;, popped);\n        }\n        else Console.WriteLine(&quot;FAILED to pop!!&quot;);\n\n        // Test Count\n        Console.WriteLine(&quot;stack count is {0}, should be 2&quot;, stack.Count);\n\n        // Test TryTake()\n        if (ipcc.TryTake(out popped))\n        {\n            Console.WriteLine(&quot;Successfully IPCC-TryTaked {0}&quot;, popped);\n        }\n        else Console.WriteLine(&quot;FAILED to IPCC.TryTake!!&quot;);\n    }\n}\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>For more information, see <a href=\"../topic/thread-safe%20collections\" data-linktype=\"relative-path\">Thread-Safe Collections</a> and <a href=\"../topic/blockingcollection%20overview\" data-linktype=\"relative-path\">BlockingCollection Overview</a>.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Methods\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_Concurrent_IProducerConsumerCollection_1_CopyTo_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_Concurrent_IProducerConsumerCollection_1_CopyTo__0___System_Int32_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">CopyTo(T[], Int32)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Copies the elements of the <span class=\"xref\">stem.Collections.Concurrent.IProducerConsumerCollection`1</span> to an <a class=\"xref\" href=\"system.array\" data-linktype=\"relative-path\">Array</a>, starting at a specified index.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void CopyTo (T[] array, int index);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>array</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><span class=\"xref\">T</span>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The one-dimensional <a class=\"xref\" href=\"system.array\" data-linktype=\"relative-path\">Array</a> that is the destination of the elements copied from the <span class=\"xref\">stem.Collections.Concurrent.IProducerConsumerCollection`1</span>.  </p>\n<p> The array must have zero-based indexing.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>index</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The zero-based index in <code>array</code> at which copying begins.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>array</code> is a null reference (Nothing in Visual Basic).</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>index</code> is less than zero.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>index</code> is equal to or greater than the length of the <code>array</code> -or- The number of elements in the collection is greater than the available space from <code>index</code> to the end of the destination <code>array</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The method provides a snapshot of the underlying collection. It is possible for other threads to add or remove items immediately after the copy is made.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_Concurrent_IProducerConsumerCollection_1_ToArray_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_Concurrent_IProducerConsumerCollection_1_ToArray\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">ToArray()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Copies the elements contained in the <span class=\"xref\">stem.Collections.Concurrent.IProducerConsumerCollection`1</span> to a new array.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public T[] ToArray ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><span class=\"xref\">T</span>[]</span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>A new array containing the elements copied from the <span class=\"xref\">stem.Collections.Concurrent.IProducerConsumerCollection`1</span>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The method provides a snapshot of the underlying collection. It is possible for other threads to add or remove items immediately after the array is made.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_Concurrent_IProducerConsumerCollection_1_TryAdd_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_Concurrent_IProducerConsumerCollection_1_TryAdd__0_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">TryAdd(T)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Attempts to add an object to the <span class=\"xref\">stem.Collections.Concurrent.IProducerConsumerCollection`1</span>.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public bool TryAdd (T item);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>item</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><span class=\"xref\">T</span></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The object to add to the <span class=\"xref\">stem.Collections.Concurrent.IProducerConsumerCollection`1</span>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>true if the object was added successfully; otherwise, false.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>item</code> was invalid for this collection.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\t\t\t<div data-moniker=\" netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Collections_Concurrent_IProducerConsumerCollection_1_TryTake_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Collections_Concurrent_IProducerConsumerCollection_1_TryTake__0__\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">TryTake(T)</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Attempts to remove and return an object from the <span class=\"xref\">stem.Collections.Concurrent.IProducerConsumerCollection`1</span>.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public bool TryTake (out T item);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Parameters</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>item</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><span class=\"xref\">T</span></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>When this method returns, if the object was removed and returned successfully, <code>item</code> contains the removed object. If no object was available to be removed, the value is unspecified.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p>true if an object was removed and returned successfully; otherwise, false.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \t<h2 class=\"accented\">Thread Safety</h2>\r\n  \tAll implementations of this interface must enable all members of this interface to be used concurrently from multiple threads.\r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Collections.Concurrent.IProducerConsumerCollection-1.yml\">\r\n<meta name=\"APIName\" content=\"System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;\">\r\n<meta name=\"APIName\" content=\"System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;.CopyTo\">\r\n<meta name=\"APIName\" content=\"System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;.ToArray\">\r\n<meta name=\"APIName\" content=\"System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;.TryAdd\">\r\n<meta name=\"APIName\" content=\"System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;.TryTake\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-31 02:21 PM\">\r\n<meta name=\"document_id\" content=\"6f08f8d7-e500-309f-477f-bbcf174c997e\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Defines methods to manipulate thread-safe collections intended for producer/consumer usage. This interface provides a unified representation for producer/consumer collections so that higher level abs…\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.collections.concurrent/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Collections.Concurrent.IProducerConsumerCollection`1\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Collections.Concurrent.IProducerConsumerCollection-1.yml","open_to_public_contributors":false,"api_name":["System.Collections.Concurrent.IProducerConsumerCollection<T>","System.Collections.Concurrent.IProducerConsumerCollection<T>.CopyTo","System.Collections.Concurrent.IProducerConsumerCollection<T>.ToArray","System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd","System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Collections.Concurrent.IProducerConsumerCollection`1","System::Collections::Concurrent::IProducerConsumerCollection`1","System.Collections.Concurrent.IProducerConsumerCollection`1.CopyTo","System::Collections::Concurrent::IProducerConsumerCollection`1::CopyTo","System.Collections.Concurrent.IProducerConsumerCollection`1.ToArray","System::Collections::Concurrent::IProducerConsumerCollection`1::ToArray","System.Collections.Concurrent.IProducerConsumerCollection`1.TryAdd","System::Collections::Concurrent::IProducerConsumerCollection`1::TryAdd","System.Collections.Concurrent.IProducerConsumerCollection`1.TryTake","System::Collections::Concurrent::IProducerConsumerCollection`1::TryTake"],"dev_langs":["csharp"],"updated_at":"2017-03-31 02:21 PM","document_id":"6f08f8d7-e500-309f-477f-bbcf174c997e","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Collections.Concurrent/IProducerConsumerCollection`1.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"IProducerConsumerCollection<T> interface | Microsoft Docs","_op_ogTitle":"IProducerConsumerCollection<T> interface","description":"Defines methods to manipulate thread-safe collections intended for producer/consumer usage. This interface provides a unified representation for producer/consumer collections so that higher level abs…","toc_asset_id":"api/_splitted/System.Collections.Concurrent/toc.json","toc_rel":"_splitted/System.Collections.Concurrent/toc.json","source_url":"","ms.assetid":"System.Collections.Concurrent.IProducerConsumerCollection`1","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent.iproducerconsumercollection-1","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent.iproducerconsumercollection-1","fileRelativePath":"api/System.Collections.Concurrent.IProducerConsumerCollection-1.html"},"themesRelativePathToOutputRoot":"_themes/"}