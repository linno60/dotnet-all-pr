{"content":"\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">IUnrestrictedPermission</span>\r\n      Interface\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Allows a permission to expose an unrestricted state.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(true)]\npublic interface IUnrestrictedPermission</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Attributes</dt><dd>\r\n  \t\t<div class=\"cdlHolder\">\r\n  \t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \t<h2 class=\"accented\">Examples</h2>\r\n  \t<p>This example shows how to define a permission class for use with code access security. All of the necessary permission interfaces are implemented.  </p>\n<p> The following code example demonstrates the behavior of the IUnrestrictedPermission methods.  </p>\n<p> The example is intended to show how the methods perform if you execute the methods from your code. In general, the methods of permission classes are used by the security infrastructure; they are not typically used in applications.  </p>\n<pre><code class=\"lang-cs\" name=\"Permission#1\">using System;\nusing System.Security;\nusing System.Security.Permissions;\nusing System.Reflection;\n\n// Enumerated type for permission states.\n[Serializable]\npublic enum SoundPermissionState\n{\n    NoSound = 0,\n    PlaySystemSounds = 1,\n    PlayAnySound = 2\n}\n\n// Derive from CodeAccessPermission to gain implementations of the following\n// sealed IStackWalk methods: Assert, Demand, Deny, and PermitOnly.\n// Implement the following abstract IPermission methods: Copy, Intersect, and IsSubSetOf.\n// Implementing the Union method of the IPermission class is optional.\n// Implement the following abstract ISecurityEncodable methods: FromXml and ToXml.\n// Making the class &#39;sealed&#39; is optional.\n\npublic sealed class SoundPermission : CodeAccessPermission, IPermission,\n    IUnrestrictedPermission, ISecurityEncodable, ICloneable\n{\n    private Boolean m_specifiedAsUnrestricted = false;\n    private SoundPermissionState m_flags = SoundPermissionState.NoSound;\n\n    // This constructor creates and initializes a permission with generic access.\n    public SoundPermission(PermissionState state)\n    {\n        m_specifiedAsUnrestricted = (state == PermissionState.Unrestricted);\n    }\n\n    // This constructor creates and initializes a permission with specific access.        \n    public SoundPermission(SoundPermissionState flags)\n    {\n        if (!Enum.IsDefined(typeof(SoundPermissionState), flags))\n            throw new ArgumentException\n                (&quot;flags value is not valid for the SoundPermissionState enuemrated type&quot;);\n        m_specifiedAsUnrestricted = false;\n        m_flags = flags;\n    }\n\n    // For debugging, return the state of this object as XML.\n    public override String ToString() { return ToXml().ToString(); }\n\n    // Private method to cast (if possible) an IPermission to the type.\n    private SoundPermission VerifyTypeMatch(IPermission target)\n    {\n        if (GetType() != target.GetType())\n            throw new ArgumentException(String.Format(&quot;target must be of the {0} type&quot;,\n                GetType().FullName));\n        return (SoundPermission)target;\n    }\n\n    // This is the Private Clone helper method. \n    private SoundPermission Clone(Boolean specifiedAsUnrestricted, SoundPermissionState flags)\n    {\n        SoundPermission soundPerm = (SoundPermission)Clone();\n        soundPerm.m_specifiedAsUnrestricted = specifiedAsUnrestricted;\n        soundPerm.m_flags = specifiedAsUnrestricted ? SoundPermissionState.PlayAnySound : m_flags;\n        return soundPerm;\n    }\n\n    #region IPermission Members\n    // Return a new object that contains the intersection of &#39;this&#39; and &#39;target&#39;.\n    public override IPermission Intersect(IPermission target)\n    {\n        // If &#39;target&#39; is null, return null.\n        if (target == null) return null;\n\n        // Both objects must be the same type.\n        SoundPermission soundPerm = VerifyTypeMatch(target);\n\n        // If &#39;this&#39; and &#39;target&#39; are unrestricted, return a new unrestricted permission.\n        if (m_specifiedAsUnrestricted &amp;&amp; soundPerm.m_specifiedAsUnrestricted)\n            return Clone(true, SoundPermissionState.PlayAnySound);\n\n        // Calculate the intersected permissions. If there are none, return null.\n        SoundPermissionState val = (SoundPermissionState)\n            Math.Min((Int32)m_flags, (Int32)soundPerm.m_flags);\n        if (val == 0) return null;\n\n        // Return a new object with the intersected permission value.\n        return Clone(false, val);\n    }\n\n    // Called by the Demand method: returns true if &#39;this&#39; is a subset of &#39;target&#39;.\n    public override Boolean IsSubsetOf(IPermission target)\n    {\n        // If &#39;target&#39; is null and this permission allows nothing, return true.\n        if (target == null) return m_flags == 0;\n\n        // Both objects must be the same type.\n        SoundPermission soundPerm = VerifyTypeMatch(target);\n\n        // Return true if the permissions of &#39;this&#39; is a subset of &#39;target&#39;.\n        return m_flags &lt;= soundPerm.m_flags;\n    }\n\n    // Return a new object that matches &#39;this&#39; object&#39;s permissions.\n    public sealed override IPermission Copy()\n    {\n        return (IPermission)Clone();\n    }\n\n    // Return a new object that contains the union of &#39;this&#39; and &#39;target&#39;.\n    // Note: You do not have to implement this method. If you do not, the version\n    // in CodeAccessPermission does this:\n    //    1. If target is not null, a NotSupportedException is thrown.\n    //    2. If target is null, then Copy is called and the new object is returned.\n    public override IPermission Union(IPermission target)\n    {\n        // If &#39;target&#39; is null, then return a copy of &#39;this&#39;.\n        if (target == null) return Copy();\n\n        // Both objects must be the same type.\n        SoundPermission soundPerm = VerifyTypeMatch(target);\n\n        // If &#39;this&#39; or &#39;target&#39; are unrestricted, return a new unrestricted permission.\n        if (m_specifiedAsUnrestricted || soundPerm.m_specifiedAsUnrestricted)\n            return Clone(true, SoundPermissionState.PlayAnySound);\n\n        // Return a new object with the calculated, unioned permission value.\n        return Clone(false, (SoundPermissionState)\n            Math.Max((Int32)m_flags, (Int32)soundPerm.m_flags));\n    }\n    #endregion\n\n    #region ISecurityEncodable Members\n    // Populate the permission&#39;s fields from XML.\n    public override void FromXml(SecurityElement e)\n    {\n        m_specifiedAsUnrestricted = false;\n        m_flags = 0;\n\n        // If XML indicates an unrestricted permission, make this permission unrestricted.\n        String s = (String)e.Attributes[&quot;Unrestricted&quot;];\n        if (s != null)\n        {\n            m_specifiedAsUnrestricted = Convert.ToBoolean(s);\n            if (m_specifiedAsUnrestricted)\n                m_flags = SoundPermissionState.PlayAnySound;\n        }\n\n        // If XML indicates a restricted permission, parse the flags.\n        if (!m_specifiedAsUnrestricted)\n        {\n            s = (String)e.Attributes[&quot;Flags&quot;];\n            if (s != null)\n            {\n                m_flags = (SoundPermissionState)\n                Convert.ToInt32(Enum.Parse(typeof(SoundPermission), s, true));\n            }\n        }\n    }\n\n    // Produce XML from the permission&#39;s fields.\n    public override SecurityElement ToXml()\n    {\n        // These first three lines create an element with the required format.\n        SecurityElement e = new SecurityElement(&quot;IPermission&quot;);\n        // Replace the double quotation marks (��) with single quotation marks (��)\n        // to remain XML compliant when the culture is not neutral.\n        e.AddAttribute(&quot;class&quot;, GetType().AssemblyQualifiedName.Replace(&#39;\\&quot;&#39;, &#39;\\&#39;&#39;));\n        e.AddAttribute(&quot;version&quot;, &quot;1&quot;);\n\n        if (!m_specifiedAsUnrestricted)\n            e.AddAttribute(&quot;Flags&quot;, Enum.Format(typeof(SoundPermissionState), m_flags, &quot;G&quot;));\n        else\n            e.AddAttribute(&quot;Unrestricted&quot;, &quot;true&quot;);\n        return e;\n    }\n    #endregion\n\n    #region IUnrestrictedPermission Members\n    // Returns true if permission is effectively unrestricted.\n    public Boolean IsUnrestricted()\n    {\n        // This means that the object is unrestricted at runtime.\n        return m_flags == SoundPermissionState.PlayAnySound;\n    }\n    #endregion\n\n    #region ICloneable Members\n\n    // Return a copy of the permission.\n    public Object Clone() { return MemberwiseClone(); }\n\n    #endregion\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Permission#1\">Imports System\nImports System.Security\nImports System.Security.Permissions\nImports System.Reflection\n\n\n&#39; Enumerated type for permission states.\n&lt;Serializable()&gt;  _\nPublic Enum SoundPermissionState\n    NoSound = 0\n    PlaySystemSounds = 1\n    PlayAnySound = 2\nEnd Enum &#39;SoundPermissionState\n\n&#39; Derive from CodeAccessPermission to gain implementations of the following\n&#39; sealed IStackWalk methods: Assert, Demand, Deny, and PermitOnly.\n&#39; Implement the following abstract IPermission methods: Copy, Intersect, and IsSubSetOf.\n&#39; Implementing the Union method of the IPermission class is optional.\n&#39; Implement the following abstract ISecurityEncodable methods: FromXml and ToXml.\n&#39; Making the class &#39;sealed&#39; is optional.\n\nNotInheritable Public Class SoundPermission\n    Inherits CodeAccessPermission\n    Implements IPermission, IUnrestrictedPermission, ISecurityEncodable, ICloneable\n    Private m_specifiedAsUnrestricted As [Boolean] = False\n    Private m_flags As SoundPermissionState = SoundPermissionState.NoSound\n    &#39; This constructor creates and initializes a permission with generic access.\n    Public Sub New(ByVal state As PermissionState) \n        m_specifiedAsUnrestricted = state = PermissionState.Unrestricted\n    \n    End Sub &#39;New    \n    &#39; This constructor creates and initializes a permission with specific access.        \n    Public Sub New(ByVal flags As SoundPermissionState) \n        If Not [Enum].IsDefined(GetType(SoundPermissionState), flags) Then\n            Throw New ArgumentException(&quot;flags value is not valid for the SoundPermissionState enuemrated type&quot;)\n        End If\n        m_specifiedAsUnrestricted = False\n        m_flags = flags\n    \n    End Sub &#39;New   \n    &#39; For debugging, return the state of this object as XML.\n    Public Overrides Function ToString() As String \n        Return ToXml().ToString()\n    \n    End Function &#39;ToString   \n    &#39; Private method to cast (if possible) an IPermission to the type.\n    Private Function VerifyTypeMatch(ByVal target As IPermission) As SoundPermission\n        If [GetType]() &lt;&gt; target.GetType() Then\n            Throw New ArgumentException(String.Format(&quot;target must be of the {0} type&quot;, [GetType]().FullName))\n        End If\n        Return CType(target, SoundPermission)\n\n    End Function &#39;VerifyTypeMatch\n    &#39; This is the Private Clone helper method. \n    Private Function Clone(ByVal specifiedAsUnrestricted As [Boolean], ByVal flags As SoundPermissionState) As SoundPermission\n        Dim soundPerm As SoundPermission = CType(Clone(), SoundPermission)\n        soundPerm.m_specifiedAsUnrestricted = specifiedAsUnrestricted\n        soundPerm.m_flags = IIf(specifiedAsUnrestricted, SoundPermissionState.PlayAnySound, m_flags)\n        Return soundPerm\n\n    End Function &#39;Clone\n\n#Region &quot;IPermission Members&quot;\n\n    &#39; Return a new object that contains the intersection of &#39;this&#39; and &#39;target&#39;.\n    Public Overrides Function Intersect(ByVal target As IPermission) As IPermission\n        &#39; If &#39;target&#39; is null, return null.\n        If target Is Nothing Then\n            Return Nothing\n        End If\n        &#39; Both objects must be the same type.\n        Dim soundPerm As SoundPermission = VerifyTypeMatch(target)\n\n        &#39; If &#39;this&#39; and &#39;target&#39; are unrestricted, return a new unrestricted permission.\n        If m_specifiedAsUnrestricted AndAlso soundPerm.m_specifiedAsUnrestricted Then\n            Return Clone(True, SoundPermissionState.PlayAnySound)\n        End If\n        &#39; Calculate the intersected permissions. If there are none, return null.\n        Dim val As SoundPermissionState = CType(Math.Min(CType(m_flags, Int32), CType(soundPerm.m_flags, Int32)), SoundPermissionState)\n        If val = 0 Then\n            Return Nothing\n        End If\n        &#39; Return a new object with the intersected permission value.\n        Return Clone(False, val)\n\n    End Function &#39;Intersect\n\n    &#39; Called by the Demand method: returns true if &#39;this&#39; is a subset of &#39;target&#39;.\n    Public Overrides Function IsSubsetOf(ByVal target As IPermission) As [Boolean]\n        &#39; If &#39;target&#39; is null and this permission allows nothing, return true.\n        If target Is Nothing Then\n            Return m_flags = 0\n        End If\n        &#39; Both objects must be the same type.\n        Dim soundPerm As SoundPermission = VerifyTypeMatch(target)\n\n        &#39; Return true if the permissions of &#39;this&#39; is a subset of &#39;target&#39;.\n        Return m_flags &lt;= soundPerm.m_flags\n\n    End Function &#39;IsSubsetOf\n\n    &#39; Return a new object that matches &#39;this&#39; object&#39;s permissions.\n    Public Overrides Function Copy() As IPermission\n        Return CType(Clone(), IPermission)\n\n    End Function &#39;Copy\n\n    &#39; Return a new object that contains the union of &#39;this&#39; and &#39;target&#39;.\n    &#39; Note: You do not have to implement this method. If you do not, the version\n    &#39; in CodeAccessPermission does this:\n    &#39;    1. If target is not null, a NotSupportedException is thrown.\n    &#39;    2. If target is null, then Copy is called and the new object is returned.\n    Public Overrides Function Union(ByVal target As IPermission) As IPermission\n        &#39; If &#39;target&#39; is null, then return a copy of &#39;this&#39;.\n        If target Is Nothing Then\n            Return Copy()\n        End If\n        &#39; Both objects must be the same type.\n        Dim soundPerm As SoundPermission = VerifyTypeMatch(target)\n\n        &#39; If &#39;this&#39; or &#39;target&#39; are unrestricted, return a new unrestricted permission.\n        If m_specifiedAsUnrestricted OrElse soundPerm.m_specifiedAsUnrestricted Then\n            Return Clone(True, SoundPermissionState.PlayAnySound)\n        End If\n        &#39; Return a new object with the calculated, unioned permission value.\n        Return Clone(False, CType(Math.Max(CType(m_flags, Int32), CType(soundPerm.m_flags, Int32)), SoundPermissionState))\n\n    End Function &#39;Union\n#End Region\n#Region &quot;ISecurityEncodable Members&quot;\n\n    &#39; Populate the permission&#39;s fields from XML.\n    Public Overrides Sub FromXml(ByVal e As SecurityElement)\n        m_specifiedAsUnrestricted = False\n        m_flags = 0\n\n        &#39; If XML indicates an unrestricted permission, make this permission unrestricted.\n        Dim s As String = CStr(e.Attributes(&quot;Unrestricted&quot;))\n        If Not (s Is Nothing) Then\n            m_specifiedAsUnrestricted = Convert.ToBoolean(s)\n            If m_specifiedAsUnrestricted Then\n                m_flags = SoundPermissionState.PlayAnySound\n            End If\n        End If\n        &#39; If XML indicates a restricted permission, parse the flags.\n        If Not m_specifiedAsUnrestricted Then\n            s = CStr(e.Attributes(&quot;Flags&quot;))\n            If Not (s Is Nothing) Then\n                m_flags = CType(Convert.ToInt32([Enum].Parse(GetType(SoundPermission), s, True)), SoundPermissionState)\n            End If\n        End If\n\n    End Sub &#39;FromXml\n\n    &#39; Produce XML from the permission&#39;s fields.\n    Public Overrides Function ToXml() As SecurityElement\n        &#39; These first three lines create an element with the required format.\n        Dim e As New SecurityElement(&quot;IPermission&quot;)\n        &#39; Replace the double quotation marks (“”) with single quotation marks (‘’)\n        &#39; to remain XML compliant when the culture is not neutral.\n        e.AddAttribute(&quot;class&quot;, [GetType]().AssemblyQualifiedName.Replace(ControlChars.Quote, &quot;&#39;&quot;c))\n        e.AddAttribute(&quot;version&quot;, &quot;1&quot;)\n\n        If Not m_specifiedAsUnrestricted Then\n            e.AddAttribute(&quot;Flags&quot;, [Enum].Format(GetType(SoundPermissionState), m_flags, &quot;G&quot;))\n        Else\n            e.AddAttribute(&quot;Unrestricted&quot;, &quot;true&quot;)\n        End If\n        Return e\n\n    End Function &#39;ToXml\n#End Region\n#Region &quot;IUnrestrictedPermission Members&quot;\n\n    &#39; Returns true if permission is effectively unrestricted.\n    Public Function IsUnrestricted() As [Boolean] Implements IUnrestrictedPermission.IsUnrestricted\n        &#39; This means that the object is unrestricted at runtime.\n        Return m_flags = SoundPermissionState.PlayAnySound\n\n    End Function &#39;IsUnrestricted\n#End Region\n#Region &quot;ICloneable Members&quot;\n    &#39; Return a copy of the permission.\n    Public Function Clone() As [Object] Implements System.ICloneable.Clone\n        Return MemberwiseClone()\n\n    End Function &#39;Clone \n#End Region\n\nEnd Class &#39;SoundPermission\n</code></pre><pre><code class=\"lang-cpp\" name=\"Permission#1\">using namespace System;\nusing namespace System::Security;\nusing namespace System::Security::Permissions;\nusing namespace System::Reflection;\n\n// Enumerated type for permission states.\n[Serializable]\npublic enum class SoundPermissionState\n{\n    NoSound = 0,\n    PlaySystemSounds = 1,\n    PlayAnySound = 2\n};\n\n// Derive from CodeAccessPermission to gain implementations of the following\n// sealed IStackWalk methods: Assert, Demand, Deny, and PermitOnly.\n// Implement the following abstract IPermission methods: \n// Copy, Intersect, and IsSubSetOf.\n// Implementing the Union method of the IPermission class is optional.\n// Implement the following abstract ISecurityEncodable methods: \n// FromXml and ToXml.\n// Making the class &#39;sealed&#39; is optional.\n\npublic ref class SoundPermission sealed : public CodeAccessPermission, \n    public IPermission, public IUnrestrictedPermission, \n    public ISecurityEncodable, public ICloneable\n{\nprivate:\n    bool specifiedAsUnrestricted;\nprivate:\n    SoundPermissionState stateFlags;\n\n    // This constructor creates and initializes \n    // a permission with generic access.\npublic:\n    SoundPermission(PermissionState^ state)\n    {\n        specifiedAsUnrestricted = (state == PermissionState::Unrestricted);\n    }\n\n    // This constructor creates and initializes \n    // a permission with specific access.\npublic:\n    SoundPermission(SoundPermissionState flags)\n    {\n        if (flags &lt; SoundPermissionState::NoSound ||\n            flags &gt; SoundPermissionState::PlayAnySound)\n        {\n            throw gcnew ArgumentException(&quot;The value of \\&quot;flags\\&quot; is not&quot; +\n                &quot; valid for the SoundPermissionState enumerated type&quot;);\n        }\n        stateFlags = flags;\n    }\n\n    // For debugging, return the state of this object as XML.\npublic:\n    virtual String^ ToString() override\n    {\n        return ToXml()-&gt;ToString();\n    }\n\n    // Private method to cast (if possible) an IPermission to the type.\nprivate:\n    SoundPermission^ VerifyTypeMatch(IPermission^ target)\n    {\n        if (GetType() != target-&gt;GetType())\n        {\n            throw gcnew ArgumentException(String::Format(\n                &quot;The variable \\&quot;target\\&quot; must be of the {0} type&quot;,\n                GetType()-&gt;FullName));\n        }\n        return (SoundPermission^) target;\n    }\n\n    // This is the Private Clone helper method.\nprivate:\n    SoundPermission^ Clone(bool specifiedAsUnrestricted, \n        SoundPermissionState flags)\n    {\n        SoundPermission^ soundPerm = (SoundPermission^) Clone();\n        soundPerm-&gt;specifiedAsUnrestricted = specifiedAsUnrestricted;\n        soundPerm-&gt;stateFlags = specifiedAsUnrestricted ? \n            SoundPermissionState::PlayAnySound : flags;\n        return soundPerm;\n    }\n\n    #pragma region IPermission^ Members\n    // Return a new object that contains the intersection \n    // of &#39;this&#39; and &#39;target&#39;.\npublic:\n    virtual IPermission^ Intersect(IPermission^ target) override\n    {\n        // If &#39;target&#39; is null, return null.\n        if (target == nullptr)\n        {\n            return nullptr;\n        }\n\n        // Both objects must be the same type.\n        SoundPermission^ soundPerm = VerifyTypeMatch(target);\n\n        // If &#39;this&#39; and &#39;target&#39; are unrestricted, \n        // return a new unrestricted permission.\n        if (specifiedAsUnrestricted &amp;&amp; soundPerm-&gt;specifiedAsUnrestricted)\n        {\n            return Clone(true, SoundPermissionState::PlayAnySound);\n        }\n\n        // Calculate the intersected permissions. \n        // If there are none, return null.\n        SoundPermissionState minimumPermission = (SoundPermissionState)\n            Math::Min((int) stateFlags, (int) soundPerm-&gt;stateFlags);\n        if ((int)minimumPermission == 0)\n        {\n            return nullptr;\n        }\n\n        // Return a new object with the intersected permission value.\n        return Clone(false, minimumPermission);\n    }\n\n    // Called by the Demand method: returns true \n    // if &#39;this&#39; is a subset of &#39;target&#39;.\npublic:\n    virtual bool IsSubsetOf(IPermission^ target) override\n    {\n        // If &#39;target&#39; is null and this permission allows nothing, \n        // return true.\n        if (target == nullptr)\n        {\n            return (int)stateFlags == 0;\n        }\n\n        // Both objects must be the same type.\n        SoundPermission^ soundPerm = VerifyTypeMatch(target);\n\n        // Return true if the permissions of &#39;this&#39; \n        // is a subset of &#39;target&#39;.\n        return stateFlags &lt;= soundPerm-&gt;stateFlags;\n    }\n\n    // Return a new object that matches &#39;this&#39; object&#39;s permissions.\npublic:\n    virtual IPermission^ Copy () override sealed\n    {\n        return (IPermission^) Clone();\n    }\n\n    // Return a new object that contains the union of &#39;this&#39; and &#39;target&#39;.\n    // Note: You do not have to implement this method. \n    // If you do not, the version\n    // in CodeAccessPermission does this:\n    //    1. If target is not null, a NotSupportedException is thrown.\n    //    2. If target is null, then Copy is called and \n    //       the new object is returned.\npublic:\n    virtual IPermission^ Union(IPermission^ target) override\n    {\n        // If &#39;target&#39; is null, then return a copy of &#39;this&#39;.\n        if (target == nullptr)\n        {\n            return Copy();\n        }\n\n        // Both objects must be the same type.\n        SoundPermission^ soundPerm = VerifyTypeMatch(target);\n\n        // If &#39;this&#39; or &#39;target&#39; are unrestricted, \n        // return a new unrestricted permission.\n        if (specifiedAsUnrestricted || soundPerm-&gt;specifiedAsUnrestricted)\n        {\n            return Clone(true, SoundPermissionState::PlayAnySound);\n        }\n\n        // Return a new object with the calculated, unioned permission value.\n        return Clone(false, (SoundPermissionState)\n            Math::Max((int) stateFlags, (int) soundPerm-&gt;stateFlags));\n    }\n    #pragma endregion\n\n    #pragma region ISecurityEncodable^ Members\n    // Populate the permission&#39;s fields from XML.\npublic:\n    virtual void FromXml(SecurityElement^ element) override\n    {\n        specifiedAsUnrestricted = false;\n        stateFlags = (SoundPermissionState)0;\n\n        // If XML indicates an unrestricted permission, \n        // make this permission unrestricted.\n        String^ attributeString = \n            (String^) element-&gt;Attributes[&quot;Unrestricted&quot;];\n        if (attributeString != nullptr)\n        {\n            specifiedAsUnrestricted = Convert::ToBoolean(attributeString);\n            if (specifiedAsUnrestricted)\n            {\n                stateFlags = SoundPermissionState::PlayAnySound;\n            }\n        }\n\n        // If XML indicates a restricted permission, parse the flags.\n        if (!specifiedAsUnrestricted)\n        {\n            attributeString = (String^) element-&gt;Attributes[&quot;Flags&quot;];\n            if (attributeString != nullptr)\n            {\n                stateFlags = (SoundPermissionState) Convert::ToInt32(\n                    Enum::Parse(SoundPermissionState::typeid, \n                    attributeString, true));\n            }\n        }\n    }\n\n    // Produce XML from the permission&#39;s fields.\npublic:\n    virtual SecurityElement^ ToXml() override\n    {\n        // These first three lines create an element with the required format.\n        SecurityElement^ element = gcnew SecurityElement(&quot;IPermission&quot;);\n        // Replace the double quotation marks () \n        // with single quotation marks ()\n        // to remain XML compliant when the culture is not neutral.\n        element-&gt;AddAttribute(&quot;class&quot;, \n            GetType()-&gt;AssemblyQualifiedName-&gt;Replace(&#39;\\&quot;&#39;, &#39;\\&#39;&#39;));\n        element-&gt;AddAttribute(&quot;version&quot;, &quot;1&quot;);\n\n        if (!specifiedAsUnrestricted)\n        {\n            element-&gt;AddAttribute(&quot;Flags&quot;, \n                Enum::Format(SoundPermissionState::typeid, stateFlags, &quot;G&quot;));\n        }   \n        else\n        {\n            element-&gt;AddAttribute(&quot;Unrestricted&quot;, &quot;true&quot;);\n        }\n        return element;\n    }\n    #pragma endregion\n\n    #pragma region IUnrestrictedPermission^ Members\n    // Returns true if permission is effectively unrestricted.\npublic:\n    virtual bool IsUnrestricted()\n    {\n        // This means that the object is unrestricted at runtime.\n        return stateFlags == SoundPermissionState::PlayAnySound;\n    }\n    #pragma endregion\n\n    #pragma region ICloneable^ Members\n\n    // Return a copy of the permission.\npublic:\n    virtual Object^ Clone()\n    {\n        return MemberwiseClone();\n    }\n\n    #pragma endregion\n};\n</code></pre>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>All code access permissions should implement IUnrestrictedPermission.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Methods\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\t\t\t<div data-moniker=\" netframework-3.0 netframework-3.5-client netframework-3.5 netframework-4.0-client netframework-4.0 netframework-4.5.1 netframework-4.5.2 netframework-4.5 netframework-4.6.1 netframework-4.6.2 netframework-4.6\">\r\n  \t\t\r\n  \t\t\t\t\t<a id=\"System_Security_Permissions_IUnrestrictedPermission_IsUnrestricted_\"></a>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Security_Permissions_IUnrestrictedPermission_IsUnrestricted\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">IsUnrestricted()</span>\r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Returns a value indicating whether unrestricted access to the resource protected by the permission is allowed.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public bool IsUnrestricted ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Returns</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if unrestricted use of the resource protected by the permission is allowed; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Attributes</dt><dd>\r\n  \t\t\t\t\t\t\t\t<div class=\"cdlHolder\">\r\n  \t\t\t\t\t\t\t\t\t<span class=\"cdl\"><a class=\"xref\" href=\"system.runtime.interopservices.comvisibleattribute\" title=\"System.Runtime.InteropServices.ComVisibleAttribute\" data-linktype=\"relative-path\">ComVisibleAttribute</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\t</div>\r\n  \t\t\r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.topic\" content=\"managed-reference\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/api/System.Security.Permissions.IUnrestrictedPermission.yml\">\r\n<meta name=\"APIName\" content=\"System.Security.Permissions.IUnrestrictedPermission\">\r\n<meta name=\"APIName\" content=\"System.Security.Permissions.IUnrestrictedPermission.IsUnrestricted\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-04-01 05:59 PM\">\r\n<meta name=\"document_id\" content=\"66009826-526b-31da-2959-3b0266707bd0\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Allows a permission to expose an unrestricted state.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/system.security.permissions/toc2.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Security.Permissions.IUnrestrictedPermission\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","ms.topic":"managed-reference","ms.prod":".net","uhfHeaderId":"MSDocsHeader-DotNet","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitRefSkeletonCommitHistory":[],"original_ref_skeleton_git_url":"https://github.com/dotnet/docs-internal/blob/master/api/System.Security.Permissions.IUnrestrictedPermission.yml","open_to_public_contributors":false,"api_name":["System.Security.Permissions.IUnrestrictedPermission","System.Security.Permissions.IUnrestrictedPermission.IsUnrestricted"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Security.Permissions.IUnrestrictedPermission","System::Security::Permissions::IUnrestrictedPermission","System.Security.Permissions.IUnrestrictedPermission.IsUnrestricted","System::Security::Permissions::IUnrestrictedPermission::IsUnrestricted"],"dev_langs":["csharp"],"updated_at":"2017-04-01 05:59 PM","document_id":"66009826-526b-31da-2959-3b0266707bd0","content_git_url":"https://github.com/dotnet/docs-internal/blob/master/xml/System.Security.Permissions/IUnrestrictedPermission.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"IUnrestrictedPermission interface | Microsoft Docs","_op_ogTitle":"IUnrestrictedPermission interface","description":"Allows a permission to expose an unrestricted state.\n","toc_asset_id":"api/_splitted/System.Security.Permissions/toc.json","toc_rel":"_splitted/System.Security.Permissions/toc.json","source_url":"","ms.assetid":"System.Security.Permissions.IUnrestrictedPermission","canonical_url":"https://docs.microsoft.com/en-us/dotnet/api/system.security.permissions.iunrestrictedpermission","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/api/system.security.permissions.iunrestrictedpermission","fileRelativePath":"api/System.Security.Permissions.IUnrestrictedPermission.html"},"themesRelativePathToOutputRoot":"_themes/"}