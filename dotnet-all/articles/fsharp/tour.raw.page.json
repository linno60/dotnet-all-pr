{"content":"<div><div class=\"content\">\n<p>The best way to learn about F# is to read and write F# code.  This article will act as a tour through some of the key features of the F# language and give you some code snippets that you can execute on your machine.  To learn about setting up a development environment, check out <a href=\"tutorials/getting-started/index\" data-linktype=\"relative-path\">Getting Started</a>.</p>\n<p>There are two primary concepts in F#: functions and types.  This tour will emphasize features of the language which fall into these two concepts.</p>\n<h2 id=\"how-to-run-the-code-samples\">How to Run the Code Samples</h2>\n<div class=\"NOTE\"><h5>Note</h5><p>Eventually, this documentation site will have the ability to run these code samples directly in your browser.  If your browser supports Silverlight, you can use <a href=\"http://www.tryfsharp.org/Create\" data-linktype=\"external\">TryFsharp</a> for the time being.</p>\n</div>\n<p>The quickest way to run these code samples is to use <a href=\"tutorials/fsharp-interactive/index\" data-linktype=\"relative-path\">F# Interactive</a>.  Just copy/paste the code samples and run them there.  Alternatively you can set up a project to compile and run the code as a Console Application in <a href=\"tutorials/getting-started/getting-started-visual-studio\" data-linktype=\"relative-path\">Visual Studio</a> or <a href=\"tutorials/getting-started/getting-started-vscode\" data-linktype=\"relative-path\">Visual Studio Code and Ionide</a>.</p>\n<h2 id=\"functions-and-modules\">Functions and Modules</h2>\n<p>The most fundamental pieces of any F# program are <strong><em>functions</em></strong> organized into <strong><em>modules</em></strong>.  <a href=\"language-reference/functions/index\" data-linktype=\"relative-path\">Functions</a> perform work on inputs to produce outputs, and they are organized under <a href=\"language-reference/modules\" data-linktype=\"relative-path\">Modules</a>, which are the primary way you group things in F#.  They are defined using the <a href=\"language-reference/functions/let-bindings\" data-linktype=\"relative-path\"><code>let</code> binding</a>, which give the function a name and define its arguments.</p>\n<pre><code class=\"lang-fsharp\" name=\"BasicFunctions\">module BasicFunctions = \n\n    /// You use &#39;let&#39; to define a function. This one accepts an integer argument and returns an integer. \n    /// Parentheses are optional for function arguments, except for when you use an explicit type annotation.\n    let sampleFunction1 x = x*x + 3\n\n    /// Apply the function, naming the function return result using &#39;let&#39;. \n    /// The variable type is inferred from the function return type.\n    let result1 = sampleFunction1 4573\n\n    // This line uses &#39;%d&#39; to print the result as an integer. This is type-safe.\n    // If &#39;result1&#39; were not of type &#39;int&#39;, then the line would fail to compile.\n    printfn &quot;The result of squaring the integer 4573 and adding 3 is %d&quot; result1\n\n    /// When needed, annotate the type of a parameter name using &#39;(argument:type)&#39;.  Parentheses are required.\n    let sampleFunction2 (x:int) = 2*x*x - x/5 + 3\n\n    let result2 = sampleFunction2 (7 + 4)\n    printfn &quot;The result of applying the 2nd sample function to (7 + 4) is %d&quot; result2\n\n    /// Conditionals use if/then/elif/else.\n    ///\n    /// Note that F# uses whitespace indentation-aware syntax, similar to languages like Python.\n    let sampleFunction3 x = \n        if x &lt; 100.0 then \n            2.0*x*x - x/5.0 + 3.0\n        else \n            2.0*x*x + x/5.0 - 37.0\n\n    let result3 = sampleFunction3 (6.5 + 4.5)\n\n    // This line uses &#39;%f&#39; to print the result as a float.  As with &#39;%d&#39; above, this is type-safe.\n    printfn &quot;The result of applying the 2nd sample function to (6.5 + 4.5) is %f&quot; result3\n</code></pre><p><code>let</code> bindings are also how you bind a value to a name, similar to a variable in other languages.  <code>let</code> bindings are <strong><em>immutable</em></strong> by default, which means that once a value or function is bound to a name, it cannot be changed in-place.  This is in contrast to variables in other languages, which are <strong><em>mutable</em></strong>, meaning their values can be changed at any point in time.  If you require a mutable binding, you can use <code>let mutable ...</code> syntax.</p>\n<pre><code class=\"lang-fsharp\" name=\"Immutability\">module Immutability =\n\n    /// Binding a value to a name via &#39;let&#39; makes it immutable.\n    ///\n    /// The second line of code fails to compile because &#39;number&#39; is immutable and bound.\n    /// Re-defining &#39;number&#39; to be a different value is not allowed in F#.\n    let number = 2\n    // let number = 3\n\n    /// A mutable binding.  This is required to be able to mutate the value of &#39;otherNumber&#39;.\n    let mutable otherNumber = 2\n\n    printfn &quot;&#39;otherNumber&#39; is %d&quot; otherNumber\n\n    // When mutating a value, use &#39;&lt;-&#39; to assign a new value.\n    //\n    // Note that &#39;=&#39; is not the same as this.  &#39;=&#39; is used to test equality.\n    otherNumber &lt;- otherNumber + 1\n\n    printfn &quot;&#39;otherNumber&#39; changed to be %d&quot; otherNumber\n</code></pre><h2 id=\"numbers-booleans-and-strings\">Numbers, Booleans, and Strings</h2>\n<p>As a .NET language, F# supports the same underlying <a href=\"language-reference/primitive-types\" data-linktype=\"relative-path\">primitive types</a> that exist in .NET.</p>\n<p>Here is how various numeric types are represented in F#:</p>\n<pre><code class=\"lang-fsharp\" name=\"Numbers\">module IntegersAndNumbers = \n\n    /// This is a sample integer.\n    let sampleInteger = 176\n\n    /// This is a sample floating point number.\n    let sampleDouble = 4.1\n\n    /// This computed a new number by some arithmetic.  Numeric types are converted using\n    /// functions &#39;int&#39;, &#39;double&#39; and so on.\n    let sampleInteger2 = (sampleInteger/4 + 5 - 7) * 4 + int sampleDouble\n\n    /// This is a list of the numbers from 0 to 99.\n    let sampleNumbers = [ 0 .. 99 ]\n\n    /// This is a list of all tuples containing all the numbers from 0 to 99 and their squares.\n    let sampleTableOfSquares = [ for i in 0 .. 99 -&gt; (i, i*i) ]\n\n    // The next line prints a list that includes tuples, using &#39;%A&#39; for generic printing.\n    printfn &quot;The table of squares from 0 to 99 is:\\n%A&quot; sampleTableOfSquares\n</code></pre><p>Here&#39;s what Boolean values and performing basic conditional logic looks like:</p>\n<pre><code class=\"lang-fsharp\" name=\"Bools\">module Booleans =\n\n    /// Booleans values are &#39;true&#39; and &#39;false&#39;.\n    let boolean1 = true\n    let boolean2 = false\n\n    /// Operators on booleans are &#39;not&#39;, &#39;&amp;&amp;&#39; and &#39;||&#39;.\n    let boolean3 = not boolean1 &amp;&amp; (boolean2 || false)\n\n    // This line uses &#39;%b&#39;to print a boolean value.  This is type-safe.\n    printfn &quot;The expression &#39;not boolean1 &amp;&amp; (boolean2 || false)&#39; is %b&quot; boolean3\n</code></pre><p>And here&#39;s what basic <a href=\"language-reference/strings\" data-linktype=\"relative-path\">string</a> manipulation looks like:</p>\n<pre><code class=\"lang-fsharp\" name=\"Strings\">module StringManipulation = \n\n    /// Strings use double quotes.\n    let string1 = &quot;Hello&quot;\n    let string2  = &quot;world&quot;\n\n    /// Strings can also use @ to create a verbatim string literal.\n    /// This will ignore escape characters such as &#39;\\&#39;, &#39;\\n&#39;, &#39;\\t&#39;, etc.\n    let string3 = @&quot;C:\\Program Files\\&quot;\n\n    /// String literals can also use triple-quotes.\n    let string4 = &quot;&quot;&quot;The computer said &quot;hello world&quot; when I told it to!&quot;&quot;&quot;\n\n    /// String concatenation is normally done with the &#39;+&#39; operator.\n    let helloWorld = string1 + &quot; &quot; + string2 \n\n    // This line uses &#39;%s&#39; to print a string value.  This is type-safe.\n    printfn &quot;%s&quot; helloWorld\n\n    /// Substrings use the indexer notation.  This line extracts the first 7 characters as a substring.\n    /// Note that like many languages, Strings are zero-indexed in F#.\n    let substring = helloWorld.[0..6]\n    printfn &quot;%s&quot; substring\n</code></pre><h2 id=\"tuples\">Tuples</h2>\n<p><a href=\"language-reference/tuples\" data-linktype=\"relative-path\">Tuples</a> are a big deal in F#.  They are a grouping of unnamed, but ordered values, that can be treated as values themselves.  Think of them as values which are aggregated from other values.  They have many uses, such as conveniently returning multiple values from a function, or grouping values for some ad-hoc convenience.</p>\n<pre><code class=\"lang-fsharp\" name=\"Tuples\">module Tuples =\n\n    /// A simple tuple of integers.\n    let tuple1 = (1, 2, 3)\n\n    /// A function that swaps the order of two values in a tuple. \n    ///\n    /// F# Type Inference will automatically generalize the function to have a generic type,\n    /// meaning that it will work with any type.\n    let swapElems (a, b) = (b, a)\n\n    printfn &quot;The result of swapping (1, 2) is %A&quot; (swapElems (1,2))\n\n    /// A tuple consisting of an integer, a string,\n    /// and a double-precision floating point number.\n    let tuple2 = (1, &quot;fred&quot;, 3.1415)\n\n    printfn &quot;tuple1: %A\\ttuple2: %A&quot; tuple1 tuple2\n</code></pre><p>As of F# 4.1, you can also create <code>struct</code> tuples.  These also interoperate fully with C#7/Visual Basic 15 tuples, which are also <code>struct</code> tuples:</p>\n<pre><code class=\"lang-fsharp\" name=\"Tuples\">/// Tuples are normally objects, but they can also be represented as structs.\n///\n/// These interoperate completely with structs in C# and Visual Basic.NET; however,\n/// struct tuples are not implicitly convertible with object tuples (often called reference tuples).\n///\n/// The second line below will fail to compile because of this.  Uncomment it to see what happens.\nlet sampleStructTuple = struct (1, 2)\n//let thisWillNotCompile: (int*int) = struct (1, 2)\n\n// Although you can\nlet convertFromStructTuple (struct(a, b)) = (a, b)\nlet convertToStructTuple (a, b) = struct(a, b)\n\nprintfn &quot;Struct Tuple: %A\\nReference tuple made from the Struct Tuple: %A&quot; sampleStructTuple (sampleStructTuple |&gt; convertFromStructTuple)\n</code></pre><p>It&#39;s important to note that because <code>struct</code> tuples are value types, they cannot be implicitly converted to reference tuples, or vice versa.  You must explicitly convert between a reference and struct tuple.</p>\n<h2 id=\"pipelines-and-composition\">Pipelines and Composition</h2>\n<p>Pipe operators (<code>|&gt;</code>, <code>&lt;|</code>, <code>||&gt;</code>, <code>&lt;||</code>, <code>|||&gt;</code>, <code>&lt;|||</code>) and composition operators (<code>&gt;&gt;</code> and <code>&lt;&lt;</code>) are used extensively when processing data in F#.  These operators are functions which allow you to establish &quot;pipelines&quot; of functions in a flexible manner.  The following example walks through how you could take advantage of these operators to build a simple functional pipeline.</p>\n<pre><code class=\"lang-fsharp\" name=\"Pipelines\">module PipelinesAndComposition =\n\n    /// Squares a value.\n    let square x = x * x\n\n    /// Adds 1 to a value.\n    let addOne x = x + 1\n\n    /// Tests if an integer value is odd via modulo.\n    let isOdd x = x % 2 &lt;&gt; 0\n\n    /// A list of 5 numbers.  More on lists later.\n    let numbers = [ 1; 2; 3; 4; 5 ]\n\n    /// Given a list of integers, it filters out the even numbers,\n    /// squares the resulting odds, and adds 1 to the squared odds.\n    let squareOddValuesAndAddOne values = \n        let odds = List.filter isOdd values\n        let squares = List.map square odds\n        let result = List.map addOne squares\n        result\n\n    printfn &quot;processing %A through &#39;squareOddValuesAndAddOne&#39; produces: %A&quot; numbers (squareOddValuesAndAddOne numbers)\n    \n    /// A shorter way to write &#39;squareOddValuesAndAddOne&#39; is to nest each\n    /// sub-result into the function calls themselves.\n    ///\n    /// This makes the function much shorter, but it&#39;s difficult to see the\n    /// order in which the data is processed.\n    let squareOddValuesAndAddOneNested values = \n        List.map addOne (List.map square (List.filter isOdd values))\n\n    printfn &quot;processing %A through &#39;squareOddValuesAndAddOneNested&#39; produces: %A&quot; numbers (squareOddValuesAndAddOneNested numbers)\n\n    /// A preferred way to write &#39;squareOddValuesAndAddOne&#39; is to use F# pipe operators.\n    /// This allows you to avoid creating intermediate results, but is much more readable\n    /// than nesting function calls like &#39;squareOddValuesAndAddOneNested&#39;\n    let squareOddValuesAndAddOnePipeline values =\n        values\n        |&gt; List.filter isOdd\n        |&gt; List.map square\n        |&gt; List.map addOne\n\n    printfn &quot;processing %A through &#39;squareOddValuesAndAddOnePipeline&#39; produces: %A&quot; numbers (squareOddValuesAndAddOnePipeline numbers)\n\n    /// You can shorten &#39;squareOddValuesAndAddOnePipeline&#39; by moving the second `List.map` call\n    /// into the first, using a Lambda Function.\n    ///\n    /// Note that pipelines are also being used inside the lambda function.  F# pipe operators\n    /// can be used for single values as well.  This makes them very powerful for processing data.\n    let squareOddValuesAndAddOneShorterPipeline values =\n        values\n        |&gt; List.filter isOdd\n        |&gt; List.map(fun x -&gt; x |&gt; square |&gt; addOne)\n\n    printfn &quot;processing %A through &#39;squareOddValuesAndAddOneShorterPipeline&#39; produces: %A&quot; numbers (squareOddValuesAndAddOneShorterPipeline numbers)\n\n    /// Lastly, you can eliminate the need to explicitly take &#39;values&#39; in as a parameter by using &#39;&gt;&gt;&#39;\n    /// to compose the two core operations: filtering out even numbers, then squaring and adding one.\n    /// Likewise, the &#39;fun x -&gt; ...&#39; bit of the lambda expression is also not needed, because &#39;x&#39; is simply\n    /// being defined in that scope so that it can be passed to a functional pipeline.  Thus, &#39;&gt;&gt;&#39; can be used\n    /// there as well.\n    ///\n    /// The result of &#39;squareOddValuesAndAddOneComposition&#39; is itself another function which takes a\n    /// list of integers as its input.  If you execute &#39;squareOddValuesAndAddOneComposition&#39; with a list\n    /// of integers, you&#39;ll notice that it produces the same results as previous functions.\n    ///\n    /// This is using what is known as function composition.  This is possible because functions in F#\n    /// use Partial Application and the input and output types of each data processing operation match\n    /// the signatures of the functions we&#39;re using.\n    let squareOddValuesAndAddOneComposition =\n        List.filter isOdd &gt;&gt; List.map (square &gt;&gt; addOne)\n\n    printfn &quot;processing %A through &#39;squareOddValuesAndAddOneComposition&#39; produces: %A&quot; numbers (squareOddValuesAndAddOneComposition numbers)\n</code></pre><p>The above sample made use of many features of F#, including list processing functions, first-class functions, and <a href=\"language-reference/functions/index#partial-application-of-arguments\" data-linktype=\"relative-path\">partial application</a>.  Although a deep understanding of each of those concepts can become somewhat advanced, it should be clear how easily functions can be used to process data when building pipelines.</p>\n<h2 id=\"lists-arrays-and-sequences\">Lists, Arrays, and Sequences</h2>\n<p>Lists, Arrays, and Sequences are three primary collection types in the F# core library.</p>\n<p><a href=\"language-reference/lists\" data-linktype=\"relative-path\">Lists</a> are ordered, immutable collections of elements of the same type.  They are singly-linked lists, which means they are meant for enumeration, but a poor choice for random access and concatenation if they&#39;re large.  This in contrast to Lists in other popular languages, which typically do not use a singly-linked list to represent Lists.</p>\n<pre><code class=\"lang-fsharp\" name=\"Lists\">module Lists =\n\n    /// Lists are defined using [ ... ].  This is an empty list.\n    let list1 = [ ]  \n\n    /// This is a list with 3 elements.  &#39;;&#39; is used to separate elements on the same line.\n    let list2 = [ 1; 2; 3 ]\n\n    /// You can also separate elements by placing them on their own lines.\n    let list3 = [\n        1\n        2\n        3\n    ]\n\n    /// This is a list of integers from 1 to 1000\n    let numberList = [ 1 .. 1000 ]  \n\n    /// Lists can also be generated by computations. This is a list containing \n    /// all the days of the year.\n    let daysList = \n        [ for month in 1 .. 12 do\n              for day in 1 .. System.DateTime.DaysInMonth(2017, month) do \n                  yield System.DateTime(2017, month, day) ]\n\n    // Print the first 5 elements of &#39;daysList&#39; using &#39;List.take&#39;.\n    printfn &quot;The first 5 days of 2017 are: %A&quot; (daysList |&gt; List.take 5)\n\n    /// Computations can include conditionals.  This is a list containing the tuples\n    /// which are the coordinates of the black squares on a chess board.\n    let blackSquares = \n        [ for i in 0 .. 7 do\n              for j in 0 .. 7 do \n                  if (i+j) % 2 = 1 then \n                      yield (i, j) ]\n\n    /// Lists can be transformed using &#39;List.map&#39; and other functional programming combinators.\n    /// This definition produces a new list by squaring the numbers in numberList, using the pipeline \n    /// operator to pass an argument to List.map.\n    let squares = \n        numberList \n        |&gt; List.map (fun x -&gt; x*x) \n\n    /// There are many other list combinations. The following computes the sum of the squares of the \n    /// numbers divisible by 3.\n    let sumOfSquares = \n        numberList\n        |&gt; List.filter (fun x -&gt; x % 3 = 0)\n        |&gt; List.sumBy (fun x -&gt; x * x)\n\n    printfn &quot;The sum of the squares of numbers up to 1000 that are divisible by 3 is: %d&quot; sumOfSquares\n</code></pre><p><a href=\"language-reference/arrays\" data-linktype=\"relative-path\">Arrays</a> are fixed-size, <em>mutable</em> collections of elements of the same type.  They support fast random access of elements, and are faster than F# lists because they are just contiguous blocks of memory.</p>\n<pre><code class=\"lang-fsharp\" name=\"Arrays\">module Arrays =\n\n    /// This is The empty array.  Note that the syntax is similar to that of Lists, but uses `[| ... |]` instead.\n    let array1 = [| |]\n\n    /// Arrays are specified using the same range of constructs as lists.\n    let array2 = [| &quot;hello&quot;; &quot;world&quot;; &quot;and&quot;; &quot;hello&quot;; &quot;world&quot;; &quot;again&quot; |]\n\n    /// This is an array of numbers from 1 to 1000.\n    let array3 = [| 1 .. 1000 |]\n\n    /// This is an array containing only the words &quot;hello&quot; and &quot;world&quot;.\n    let array4 = \n        [| for word in array2 do\n               if word.Contains(&quot;l&quot;) then \n                   yield word |]\n\n    /// This is an array initialized by index and containing the even numbers from 0 to 2000.\n    let evenNumbers = Array.init 1001 (fun n -&gt; n * 2) \n\n    /// Sub-arrays are extracted using slicing notation.\n    let evenNumbersSlice = evenNumbers.[0..500]\n\n    /// You can loop over arrays and lists using &#39;for&#39; loops.\n    for word in array4 do \n        printfn &quot;word: %s&quot; word\n\n    // You can modify the contents of an an array element by using the left arrow assignment operator.\n    //\n    // To learn more about this operator, see: https://docs.microsoft.com/dotnet/articles/fsharp/language-reference/values/index#mutable-variables\n    array2.[1] &lt;- &quot;WORLD!&quot;\n\n    /// You can transform arrays using &#39;Array.map&#39; and other functional programming operations.\n    /// The following calculates the sum of the lengths of the words that start with &#39;h&#39;.\n    let sumOfLengthsOfWords = \n        array2\n        |&gt; Array.filter (fun x -&gt; x.StartsWith &quot;h&quot;)\n        |&gt; Array.sumBy (fun x -&gt; x.Length)\n\n    printfn &quot;The sum of the lengths of the words in Array 2 is: %d&quot; sumOfLengthsOfWords\n</code></pre><p><a href=\"language-reference/sequences\" data-linktype=\"relative-path\">Sequences</a> are a logical series of elements, all of the same type.  These are a more general type than Lists and Arrays, capable of being your &quot;view&quot; into any logical series of elements.  They also stand out because they can be <strong><em>lazy</em></strong>, which means that elements can be computed only when they are needed.</p>\n<pre><code class=\"lang-fsharp\" name=\"Sequences\">module Sequences = \n\n    /// This is the empty sequence.\n    let seq1 = Seq.empty\n\n    /// This a sequence of values.\n    let seq2 = seq { yield &quot;hello&quot;; yield &quot;world&quot;; yield &quot;and&quot;; yield &quot;hello&quot;; yield &quot;world&quot;; yield &quot;again&quot; }\n\n    /// This is an on-demand sequence from 1 to 1000.\n    let numbersSeq = seq { 1 .. 1000 }\n\n    /// This is a sequence producing the words &quot;hello&quot; and &quot;world&quot;\n    let seq3 = \n        seq { for word in seq2 do\n                  if word.Contains(&quot;l&quot;) then \n                      yield word }\n\n    /// This sequence producing the even numbers up to 2000.\n    let evenNumbers = Seq.init 1001 (fun n -&gt; n * 2) \n\n    let rnd = System.Random()\n\n    /// This is an infinite sequence which is a random walk.\n    /// This example uses yield! to return each element of a subsequence.\n    let rec randomWalk x =\n        seq { yield x\n              yield! randomWalk (x + rnd.NextDouble() - 0.5) }\n\n    /// This example shows the first 100 elements of the random walk.\n    let first100ValuesOfRandomWalk = \n        randomWalk 5.0 \n        |&gt; Seq.truncate 100\n        |&gt; Seq.toList\n\n    printfn &quot;First 100 elements of a random walk: %A&quot; first100ValuesOfRandomWalk\n</code></pre><h2 id=\"recursive-functions\">Recursive Functions</h2>\n<p>Processing collections or sequences of elements is typically done with <a href=\"language-reference/functions/index#recursive-functions\" data-linktype=\"relative-path\">recursion</a> in F#.  Although F# has support for loops and imperative programming, recursion is preferred because it is easier to guarantee correctness.</p>\n<div class=\"NOTE\"><h5>Note</h5><p>The following example makes use of the pattern matching via the <code>match</code> expression.  This fundamental construct is covered later in this article.</p>\n</div>\n<pre><code class=\"lang-fsharp\" name=\"RecursiveFunctions\">module RecursiveFunctions = \n              \n    /// This example shows a recursive function that computes the factorial of an \n    /// integer. It uses &#39;let rec&#39; to define a recursive function.\n    let rec factorial n = \n        if n = 0 then 1 else n * factorial (n-1)\n\n    printfn &quot;Factorial of 6 is: %d&quot; (factorial 6)\n\n    /// Computes the greatest common factor of two integers.\n    ///\n    /// Since all of the recursive calls are tail calls,\n    /// the compiler will turn the function into a loop,\n    /// which improves performance and reduces memory consumption.\n    let rec greatestCommonFactor a b =\n        if a = 0 then b\n        elif a &lt; b then greatestCommonFactor a (b - a)\n        else greatestCommonFactor (a - b) b\n\n    printfn &quot;The Greatest Common Factor of 300 and 620 is %d&quot; (greatestCommonFactor 300 620)\n\n    /// This example computes the sum of a list of integers using recursion.\n    let rec sumList xs =\n        match xs with\n        | []    -&gt; 0\n        | y::ys -&gt; y + sumList ys\n\n    /// This makes &#39;sumList&#39; tail recursive, using a helper function with a result accumulator.\n    let rec private sumListTailRecHelper accumulator xs =\n        match xs with\n        | []    -&gt; accumulator\n        | y::ys -&gt; sumListTailRecHelper (accumulator+y) ys\n    \n    /// This invokes the tail recursive helper function, providing &#39;0&#39; as a seed accumulator.\n    /// An approach like this is common in F#.\n    let sumListTailRecursive xs = sumListTailRecHelper 0 xs\n\n    let oneThroughTen = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10]\n\n    printfn &quot;The sum 1-10 is %d&quot; (sumListTailRecursive oneThroughTen)\n</code></pre><p>F# also has full support for Tail Call Optimization, which is a way to optimize recursive calls so that they are just as fast as a loop construct.</p>\n<h2 id=\"record-and-discriminated-union-types\">Record and Discriminated Union Types</h2>\n<p>Record and Union types are two fundamental data types used in F# code, and are generally the best way to represent data in an F# program.  Although this makes them similar to classes in other languages, one of their primary differences is that they have structural equality semantics.  This means that they are &quot;natively&quot; comparable and equality is straightforward - just check if one is equal to the other.</p>\n<p><a href=\"language-reference/records\" data-linktype=\"relative-path\">Records</a> are an aggregate of named values, with optional members (such as methods).  If you&#39;re familiar with C# or Java, then these should feel similar to POCOs or POJOs - just with structural equality and less ceremony.</p>\n<pre><code class=\"lang-fsharp\" name=\"Records\">module RecordTypes = \n\n    /// This example shows how to define a new record type.  \n    type ContactCard = \n        { Name     : string\n          Phone    : string\n          Verified : bool }\n              \n    /// This example shows how to instantiate a record type.\n    let contact1 = \n        { Name = &quot;Alf&quot; \n          Phone = &quot;(206) 555-0157&quot; \n          Verified = false }\n\n    /// You can also do this on the same line with &#39;;&#39; separators.\n    let contactOnSameLine = { Name = &quot;Alf&quot;; Phone = &quot;(206) 555-0157&quot;; Verified = false }\n\n    /// This example shows how to use &quot;copy-and-update&quot; on record values. It creates \n    /// a new record value that is a copy of contact1, but has different values for \n    /// the &#39;Phone&#39; and &#39;Verified&#39; fields.\n    ///\n    /// To learn more, see: https://docs.microsoft.com/dotnet/articles/fsharp/language-reference/copy-and-update-record-expressions\n    let contact2 = \n        { contact1 with \n            Phone = &quot;(206) 555-0112&quot;\n            Verified = true }\n\n    /// This example shows how to write a function that processes a record value.\n    /// It converts a &#39;ContactCard&#39; object to a string.\n    let showContactCard (c: ContactCard) = \n        c.Name + &quot; Phone: &quot; + c.Phone + (if not c.Verified then &quot; (unverified)&quot; else &quot;&quot;)\n\n    printfn &quot;Alf&#39;s Contact Card: %s&quot; (showContactCard contact1)\n\n    /// This is an example of a Record with a member.\n    type ContactCardAlternate =\n        { Name     : string\n          Phone    : string\n          Address  : string\n          Verified : bool }\n\n        /// Members can implement object-oriented members.\n        member this.PrintedContactCard =\n            this.Name + &quot; Phone: &quot; + this.Phone + (if not this.Verified then &quot; (unverified)&quot; else &quot;&quot;) + this.Address\n\n    let contactAlternate = \n        { Name = &quot;Alf&quot; \n          Phone = &quot;(206) 555-0157&quot; \n          Verified = false \n          Address = &quot;111 Alf Street&quot; }\n   \n    // Members are accessed via the &#39;.&#39; operator on an instantiated type.\n    printfn &quot;Alf&#39;s alternate contact card is %s&quot; contactAlternate.PrintedContactCard\n</code></pre><p>As of F# 4.1, you can also represent Records as <code>struct</code>s.  This is done with the <code>[&lt;Struct&gt;]</code> attribute:</p>\n<pre><code class=\"lang-fsharp\" name=\"Records\">/// Records can also be represented as structs via the &#39;Struct&#39; attribute.\n/// This is helpful in situations where the performance of structs outweighs\n/// the flexibility of reference types.\n[&lt;Struct&gt;]\ntype ContactCardStruct = \n    { Name     : string\n      Phone    : string\n      Verified : bool }\n</code></pre><p><a href=\"language-reference/discriminated-unions\" data-linktype=\"relative-path\">Discriminated Unions (DUs)</a> are values which could be a number of named forms or cases.  Data stored in the type can be one of several distinct values.</p>\n<pre><code class=\"lang-fsharp\" name=\"Unions\">module DiscriminatedUnions = \n\n    /// The following represents the suit of a playing card.\n    type Suit = \n        | Hearts \n        | Clubs \n        | Diamonds \n        | Spades\n\n    /// A Discriminated Union can also be used to represent the rank of a playing card.\n    type Rank = \n        /// Represents the rank of cards 2 .. 10\n        | Value of int\n        | Ace\n        | King\n        | Queen\n        | Jack\n\n        /// Discriminated Unions can also implement object-oriented members.\n        static member GetAllRanks() = \n            [ yield Ace\n              for i in 2 .. 10 do yield Value i\n              yield Jack\n              yield Queen\n              yield King ]\n                                   \n    /// This is a record type that combines a Suit and a Rank.\n    /// It&#39;s common to use both Records and Discriminated Unions when representing data.\n    type Card = { Suit: Suit; Rank: Rank }\n              \n    /// This computes a list representing all the cards in the deck.\n    let fullDeck = \n        [ for suit in [ Hearts; Diamonds; Clubs; Spades] do\n              for rank in Rank.GetAllRanks() do \n                  yield { Suit=suit; Rank=rank } ]\n\n    /// This example converts a &#39;Card&#39; object to a string.\n    let showPlayingCard (c: Card) = \n        let rankString = \n            match c.Rank with \n            | Ace -&gt; &quot;Ace&quot;\n            | King -&gt; &quot;King&quot;\n            | Queen -&gt; &quot;Queen&quot;\n            | Jack -&gt; &quot;Jack&quot;\n            | Value n -&gt; string n\n        let suitString = \n            match c.Suit with \n            | Clubs -&gt; &quot;clubs&quot;\n            | Diamonds -&gt; &quot;diamonds&quot;\n            | Spades -&gt; &quot;spades&quot;\n            | Hearts -&gt; &quot;hearts&quot;\n        rankString  + &quot; of &quot; + suitString\n\n    /// This example prints all the cards in a playing deck.\n    let printAllCards() = \n        for card in fullDeck do \n            printfn &quot;%s&quot; (showPlayingCard card)\n</code></pre><p>You can also use DUs as <em>Single-Case Discriminated Unions</em>, to help with domain modeling over primitive types.  Often times, strings and other primitive types are used to represent something, and are thus given a particular meaning.  However, using only the primitive representation of the data can result in mistakenly assigning an incorrect value!  Representing each type of information as a distinct single-case union can enforce correctness in this scenario.</p>\n<pre><code class=\"lang-fsharp\" name=\"Unions\">// Single-case DUs are often used for domain modeling.  This can buy you extra type safety\n// over primitive types such as strings and ints.\n//\n// Single-case DUs cannot be implicitly converted to or from the type they wrap.\n// For example, a function which takes in an Address cannot accept a string as that input,\n// or vice versa.\ntype Address = Address of string\ntype Name = Name of string\ntype SSN = SSN of int\n\n// You can easily instantiate a single-case DU as follows.\nlet address = Address &quot;111 Alf Way&quot;\nlet name = Name &quot;Alf&quot;\nlet ssn = SSN 1234567890\n\n/// When you need the value, you can unwrap the underlying value with a simple function.\nlet unwrapAddress (Address a) = a\nlet unwrapName (Name n) = n\nlet unwrapSSN (SSN s) = s\n\n// Printing single-case DUs is simple with unwrapping functions.\nprintfn &quot;Address: %s, Name: %s, and SSN: %d&quot; (address |&gt; unwrapAddress) (name |&gt; unwrapName) (ssn |&gt; unwrapSSN)\n</code></pre><p>As the above sample demonstrates, to get the underlying value in a single-case Discriminated Union, you must explicitly unwrap it.</p>\n<p>Additionally, DUs also support recursive definitions, allowing you to easily represent trees and inherently recursive data.  For example, here&#39;s how you can represent a Binary Search Tree with <code>exists</code> and <code>insert</code> functions.</p>\n<pre><code class=\"lang-fsharp\" name=\"Unions\">/// Discriminated Unions also support recursive definitions.\n///\n/// This represents a Binary Search Tree, with one case being the Empty tree,\n/// and the other being a Node with a value and two subtrees.\ntype BST&lt;&#39;T&gt; =\n    | Empty\n    | Node of value:&#39;T * left: BST&lt;&#39;T&gt; * right: BST&lt;&#39;T&gt;\n\n/// Check if an item exists in the binary search tree.\n/// Searches recursively using Pattern Matching.  Returns true if it exists; otherwise, false.\nlet rec exists item bst =\n    match bst with\n    | Empty -&gt; false\n    | Node (x, left, right) -&gt;\n        if item = x then true\n        elif item &lt; x then (exists item left) // Check the left subtree.\n        else (exists item right) // Check the right subtree.\n\n/// Inserts an item in the Binary Search Tree.\n/// Finds the place to insert recursively using Pattern Matching, then inserts a new node.\n/// If the item is already present, it does not insert anything.\nlet rec insert item bst =\n    match bst with\n    | Empty -&gt; Node(item, Empty, Empty)\n    | Node(x, left, right) as node -&gt;\n        if item = x then node // No need to insert, it already exists; return the node.\n        elif item &lt; x then Node(x, insert item left, right) // Call into left subtree.\n        else Node(x, left, insert item right) // Call into right subtree.\n</code></pre><p>Because DUs allow you to represent the recursive structure of the tree in the data type, operating on this recursive structure is straightforward and guarantees correctness.  It is also supported in pattern matching, as shown below.</p>\n<p>Additionally, you can represent DUs as <code>struct</code>s with the <code>[&lt;Struct&gt;]</code> attribute:</p>\n<pre><code class=\"lang-fsharp\" name=\"Unions\">/// Discriminated Unions can also be represented as structs via the &#39;Struct&#39; attribute.\n/// This is helpful in situations where the performance of structs outweighs\n/// the flexibility of reference types.\n///\n/// However, there are two important things to know when doing this:\n///     1. A struct DU cannot be recursively-defined.\n///     2. A struct DU must have unique names for each of its cases.\n[&lt;Struct&gt;]\ntype Shape =\n    | Circle of radius: float\n    | Square of side: float\n    | Triangle of height: float * width: float\n</code></pre><p>However, there are two key things to keep in mind when doing so:</p>\n<ol>\n<li>A struct DU cannot be recursively-defined.</li>\n<li>A struct DU must have unique names for each of its cases.</li>\n</ol>\n<p>Failure to follow the above will result in a compilation error.</p>\n<h2 id=\"pattern-matching\">Pattern Matching</h2>\n<p><a href=\"language-reference/pattern-matching\" data-linktype=\"relative-path\">Pattern Matching</a> is the F# language feature which enables correctness for operating on F# types.  In the above samples, you probably noticed quite a bit of <code>match x with ...</code> syntax.  This construct allows the compiler, which can understand the &quot;shape&quot; of data types, to force you to account for all possible cases when using a data type through what is known as Exhaustive Pattern Matching.  This is incredibly powerful for correctness, and can be cleverly used to &quot;lift&quot; what would normally be a runtime concern into compile-time.</p>\n<pre><code class=\"lang-fsharp\" name=\"PatternMatching\">module PatternMatching =\n\n    /// A record for a person&#39;s first and last name\n    type Person = {\n        First : string\n        Last  : string\n    }\n\n    /// A Discriminated Union of 3 different kinds of employees\n    type Employee =\n        | Engineer of engineer: Person\n        | Manager of manager: Person * reports: List&lt;Employee&gt;\n        | Executive of executive: Person * reports: List&lt;Employee&gt; * assistant: Employee\n\n    /// Count everyone underneath the employee in the management hierarchy,\n    /// including the employee.\n    let rec countReports(emp : Employee) =\n        1 + match emp with\n            | Engineer(id) -&gt;\n                0\n            | Manager(id, reports) -&gt;\n                reports |&gt; List.sumBy countReports\n            | Executive(id, reports, assistant) -&gt;\n                (reports |&gt; List.sumBy countReports) + countReports assistant\n\n\n    /// Find all managers/executives named &quot;Dave&quot; who do not have any reports.\n    /// This uses the &#39;function&#39; shorthand to as a lambda expression.\n    let rec findDaveWithOpenPosition(emps : List&lt;Employee&gt;) =\n        emps\n        |&gt; List.filter(function\n                       | Manager({First = &quot;Dave&quot;}, []) -&gt; true // [] matches an empty list.\n                       | Executive({First = &quot;Dave&quot;}, [], _) -&gt; true\n                       | _ -&gt; false) // &#39;_&#39; is a wildcard pattern that matches anything.\n                                     // This handles the &quot;or else&quot; case.\n</code></pre><p>You can also use the shorthand <code>function</code> construct for pattern matching, which is useful when you&#39;re writing functions which make use of <a href=\"language-reference/functions/index#partial-application-of-arguments\" data-linktype=\"relative-path\">Partial Application</a>:</p>\n<pre><code class=\"lang-fsharp\" name=\"PatternMatching\">open System\n\n/// You can also use the shorthand function construct for pattern matching, \n/// which is useful when you&#39;re writing functions which make use of Partial Application.\nlet private parseHelper f = f &gt;&gt; function\n    | (true, item) -&gt; Some item\n    | (false, _) -&gt; None\n\nlet parseDateTimeOffset = parseHelper DateTimeOffset.TryParse\n\nlet result = parseDateTimeOffset &quot;1970-01-01&quot;\nmatch result with\n| Some dto -&gt; printfn &quot;It parsed!&quot;\n| None -&gt; printfn &quot;It didn&#39;t parse!&quot;\n\n// Define some more functions which parse with the helper function.\nlet parseInt = parseHelper Int32.TryParse\nlet parseDouble = parseHelper Double.TryParse\nlet parseTimeSpan = parseHelper TimeSpan.TryParse\n</code></pre><p>Something you may have noticed is the use of the <code>_</code> pattern.  This is known as the <a href=\"language-reference/pattern-matching#wildcard-pattern\" data-linktype=\"relative-path\">Wildcard Pattern</a>, which is a way of saying &quot;I don&#39;t care what something is&quot;.  Although convenient, you can accidentally bypass Exhaustive Pattern Matching and no longer benefit from compile-time enforcements if you aren&#39;t careful in using <code>_</code>.  It is best used when you don&#39;t care about certain pieces of a decomposed type when pattern matching, or the final clause when you have enumerated all meaningful cases in a pattern matching expression.</p>\n<p><a href=\"language-reference/active-patterns\" data-linktype=\"relative-path\">Active Patterns</a> are another powerful construct to use with pattern matching.  They allow you to partition input data into custom forms, decomposing them at the pattern match call site.  They can also be parameterized, thus allowing to define the partition as a function.  Expanding the previous example to support Active Patterns looks something like this:</p>\n<pre><code class=\"lang-fsharp\" name=\"ActivePatterns\">// Active Patterns are another powerful construct to use with pattern matching.\n// They allow you to partition input data into custom forms, decomposing them at the pattern match call site. \n//\n// To learn more, see: https://docs.microsoft.com/dotnet/articles/fsharp/language-reference/active-patterns\nlet (|Int|_|) = parseInt\nlet (|Double|_|) = parseDouble\nlet (|Date|_|) = parseDateTimeOffset\nlet (|TimeSpan|_|) = parseTimeSpan\n\n/// Pattern Matching via &#39;function&#39; keyword and Active Patterns often looks like this.\nlet printParseResult = function\n    | Int x -&gt; printfn &quot;%d&quot; x\n    | Double x -&gt; printfn &quot;%f&quot; x\n    | Date d -&gt; printfn &quot;%s&quot; (d.ToString())\n    | TimeSpan t -&gt; printfn &quot;%s&quot; (t.ToString())\n    | _ -&gt; printfn &quot;Nothing was parse-able!&quot;\n\n// Call the printer with some different values to parse.\nprintParseResult &quot;12&quot;\nprintParseResult &quot;12.045&quot;\nprintParseResult &quot;12/28/2016&quot;\nprintParseResult &quot;9:01PM&quot;\nprintParseResult &quot;banana!&quot;\n</code></pre><h2 id=\"optional-types\">Optional Types</h2>\n<p>One special case of Discriminated Union types is the Option Type, which is so useful that it&#39;s a part of the F# core library.</p>\n<p><a href=\"language-reference/options\" data-linktype=\"relative-path\">The Option Type</a> is a type which represents one of two cases: a value, or nothing at all.  It is used in any scenario where a value may or may not result from a particular operation.  This then forces you to account for both cases, making it a compile-time concern rather than a runtime concern.  These are often used in APIs where <code>null</code> is used to represent &quot;nothing&quot; instead, thus eliminating the need to worry about <code>NullReferenceException</code> in many circumstances.</p>\n<pre><code class=\"lang-fsharp\" name=\"Options\">module OptionValues = \n\n    /// First, define a zip code defined via Single-case Discriminated Union.\n    type ZipCode = ZipCode of string\n\n    /// Next, define a type where the ZipCode is optional.\n    type Customer = { ZipCode: ZipCode option }\n\n    /// Next, define an interface type the represents an object to compute the shipping zone for the customer&#39;s zip code, \n    /// given implementations for the &#39;getState&#39; and &#39;getShippingZone&#39; abstract methods.\n    type IShippingCalculator =\n        abstract GetState : ZipCode -&gt; string option\n        abstract GetShippingZone : string -&gt; int\n\n    /// Next, calculate a shipping zone for a customer using a calculator instance.\n    /// This uses combinators in the Option module to allow a functional pipeline for\n    /// transforming data with Optionals.\n    let CustomerShippingZone (calculator: IShippingCalculator, customer: Customer) =\n        customer.ZipCode \n        |&gt; Option.bind calculator.GetState \n        |&gt; Option.map calculator.GetShippingZone\n</code></pre><h2 id=\"units-of-measure\">Units of Measure</h2>\n<p>One unique feature of F#&#39;s type system is the ability to provide context for numeric literals through Units of Measure.</p>\n<p><a href=\"language-reference/units-of-measure\" data-linktype=\"relative-path\">Units of Measure</a> allow you to associate a numeric type to a unit, such as Meters, and have functions perform work on units rather than numeric literals.  This enables the compiler to verify that the types of numeric literals passed in make sense under a certain context, thus eliminating runtime errors associated with that kind of work.</p>\n<pre><code class=\"lang-fsharp\" name=\"UnitsOfMeasure\">module UnitsOfMeasure = \n\n    /// First, open a collection of common unit names\n    open Microsoft.FSharp.Data.UnitSystems.SI.UnitNames\n\n    /// Define a unitized constant\n    let sampleValue1 = 1600.0&lt;meter&gt;          \n\n    /// Next, define a new unit type\n    [&lt;Measure&gt;]\n    type mile =\n        /// Conversion factor mile to meter.\n        static member asMeter = 1609.34&lt;meter/mile&gt;\n\n    /// Define a unitized constant\n    let sampleValue2  = 500.0&lt;mile&gt;          \n\n    /// Compute  metric-system constant\n    let sampleValue3 = sampleValue2 * mile.asMeter   \n\n    // Values using Units of Measure can be used just like the primitive numeric type for things like printing.\n    printfn &quot;After a %f race I would walk %f miles which would be %f meters&quot; sampleValue1 sampleValue2 sampleValue3\n</code></pre><p>The F# Core library defines many SI unit types and unit conversions.  To learn more, check out the <a href=\"https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.data.unitsystems.si-namespace-%5bfsharp%5d\" data-linktype=\"external\">Microsoft.FSharp.Data.UnitSystems.SI Namespace</a>.</p>\n<h2 id=\"classes-and-interfaces\">Classes and Interfaces</h2>\n<p>F# also has full support for .NET classes, <a href=\"language-reference/interfaces\" data-linktype=\"relative-path\">Interfaces</a>, <a href=\"language-reference/abstract-classes\" data-linktype=\"relative-path\">Abstract Classes</a>, <a href=\"language-reference/inheritance\" data-linktype=\"relative-path\">Inheritance</a>, and so on.</p>\n<p><a href=\"language-reference/classes\" data-linktype=\"relative-path\">Classes</a> are types that represent .NET objects, which can have properties, methods, and events as its <a href=\"language-reference/members/index\" data-linktype=\"relative-path\">Members</a>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Classes\">module DefiningClasses = \n\n    /// A simple two-dimensional Vector class.\n    ///\n    /// The class&#39;s constructor is on the first line,\n    /// and takes two arguments: dx and dy, both of type &#39;double&#39;.\n    type Vector2D(dx : double, dy : double) =\n\n        /// This internal field stores the length of the vector, computed when the \n        /// object is constructed\n        let length = sqrt (dx*dx + dy*dy)\n\n        // &#39;this&#39; specifies a name for the object&#39;s self-identifier.\n        // In instance methods, it must appear before the member name.\n        member this.DX = dx\n\n        member this.DY = dy\n\n        member this.Length = length\n\n        /// This member is a method.  The previous members were properties.\n        member this.Scale(k) = Vector2D(k * this.DX, k * this.DY)\n    \n    /// This is how you instantiate the Vector2D class.\n    let vector1 = Vector2D(3.0, 4.0)\n\n    /// Get a new scaled vector object, without modifying the original object.\n    let vector2 = vector1.Scale(10.0)\n\n    printfn &quot;Length of vector1: %f\\nLength of vector2: %f&quot; vector1.Length vector2.Length\n</code></pre><p>Defining generic classes is also very straightforward.</p>\n<pre><code class=\"lang-fsharp\" name=\"Classes\">module DefiningGenericClasses = \n\n    type StateTracker&lt;&#39;T&gt;(initialElement: &#39;T) = \n\n        /// This internal field store the states in a list.\n        let mutable states = [ initialElement ]\n\n        /// Add a new element to the list of states.\n        member this.UpdateState newState = \n            states &lt;- newState :: states  // use the &#39;&lt;-&#39; operator to mutate the value.\n\n        /// Get the entire list of historical states.\n        member this.History = states\n\n        /// Get the latest state.\n        member this.Current = states.Head\n\n    /// An &#39;int&#39; instance of the state tracker class. Note that the type parameter is inferred.\n    let tracker = StateTracker 10\n\n    // Add a state\n    tracker.UpdateState 17\n</code></pre><p>To implement an Interface, you can use either <code>interface ... with</code> syntax or an <a href=\"language-reference/object-expressions\" data-linktype=\"relative-path\">Object Expression</a>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Classes\">module ImplementingInterfaces =\n\n    /// This is a type that implements IDisposable.\n    type ReadFile() =\n\n        let file = new System.IO.StreamReader(&quot;readme.txt&quot;)\n\n        member this.ReadLine() = file.ReadLine()\n\n        // This is the implementation of IDisposable members.\n        interface System.IDisposable with\n            member this.Dispose() = file.Close()\n\n\n    /// This is an object that implements IDisposable via an Object Expression\n    /// Unlike other languages such as C# or Java, a new type definition is not needed \n    /// to implement an interface.\n    let interfaceImplementation =\n        { new System.IDisposable with\n            member this.Dispose() = printfn &quot;disposed&quot; }\n</code></pre><h2 id=\"which-types-to-use\">Which Types to Use</h2>\n<p>The presence of Classes, Records, Discriminated Unions, and Tuples leads to an important question: which should you use?  Like most everything in life, the answer depends on your circumstances.</p>\n<p>Tuples are great for returning multiple values from a function, and using an ad-hoc aggregate of values as a value itself.</p>\n<p>Records are a &quot;step up&quot; from Tuples, having named labels and support for optional members.  They are great for a low-ceremony representation of data in-transit through your program.  Because they have structural equality, they can be used in Pattern Matching.</p>\n<p>Discriminated Unions have many reasons, but the core benefit is to be able to utilize them in conjunction with Pattern Matching to account for all possible &quot;shapes&quot; that a data can have.  </p>\n<p>Classes are great for a huge number of reasons, such as when you need to represent information and also tie that information to functionality.  As a rule of thumb, when you have functionality which is conceptually tied to some data, using Classes and the principles of Object-Oriented Programming is a big benefit.  Classes are also the preferred data type when interoperating with C# and Visual Basic, as these languages use classes for nearly everything.</p>\n<h2 id=\"next-steps\">Next Steps</h2>\n<p>Now that you&#39;ve seen some of the primary features of the language, you should be ready to write your first F# programs!  Check out <a href=\"tutorials/getting-started/index\" data-linktype=\"relative-path\">Getting Started</a> to learn how to set up your development environment and write some code.</p>\n<p>The next steps for learning more can be whatever you like, but we recommend an <a href=\"introduction-to-functional-programming/index\" data-linktype=\"relative-path\">Introduction to Functional Programming in F#</a> to get comfortable with core Functional Programming concepts.  These will be essential in building robust programs in F#.</p>\n<p>Also, check out the <a href=\"language-reference/index\" data-linktype=\"relative-path\">F# Language Reference</a> to see a comprehensive collection of conceptual content on F#.</p>\n</div></div>","outputRootRelativePath":"../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet/toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"49775139-082e-442f-b5a2-dd402399b5d2\">\r\n<meta name=\"description\" content=\"Tour of F#\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming, .NET, tour\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"01/24/2017\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/e48967d2f92399efc1b0f7d1d39649466d0405ee/docs/fsharp/tour.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/tour.md\">\r\n<meta name=\"document_id\" content=\"6d36e1d2-3dfc-8aa4-0e0a-1e3592789fbf\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../toc2.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Tour of F# | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"49775139-082e-442f-b5a2-dd402399b5d2","description":"Tour of F#","keywords":"visual f#, f#, functional programming, .NET, tour","ms.topic":"article","ms.date":"01/24/2017","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Jaxel Rojas","author_email":"jaxelr@gmail.com","committer_name":"Phillip Carter","comitter_email":"phillip.carter@outlook.com","message":"Fixed Typos on tour.md. (#1603)","commit_sha":"e48967d2f92399efc1b0f7d1d39649466d0405ee","commit_date":"2017-02-27 13:49:05 -0800"},{"author_name":"Attie Naude","author_email":"attie.naude@live.com","committer_name":"Phillip Carter","comitter_email":"phillip.carter@outlook.com","message":"Update tour.md (#1589)","commit_sha":"13236b18499885f1242e0fa4e7a8e200f6ff1cb7","commit_date":"2017-02-22 22:06:59 -0800"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update tour.md","commit_sha":"56f4804cdba37446dbc2c8fe749d38e4ef4ffa92","commit_date":"2017-02-12 19:39:51 -0800"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update line range for pipelines and composition (#1444)","commit_sha":"2a36b0b5132925fe76cd827c642b4f5ad4fab8a1","commit_date":"2017-02-12 19:39:12 -0800"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update F# Tour (#1392)","commit_sha":"da0586ea9b4a1cef33d8e2b74a508800c141c7a3","commit_date":"2017-01-15 15:03:10 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Adjust comments and line lengths in F# Tour (#1006)","commit_sha":"48a00a7f5d6205fd352b9362599ded86a51a637e","commit_date":"2016-09-06 12:37:23 -0700"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"fixed absolute and msdn links (#1001)","commit_sha":"de0dab146fc811e895dc32f98f877db5e757f82b","commit_date":"2016-09-06 10:59:39 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Fix spelling and link (#931)","commit_sha":"c46b4365afc5d83e98dd68c0f9b55be7107961d8","commit_date":"2016-08-19 16:32:02 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update tour.fs to clarify some things (#930)","commit_sha":"bbbab37db00f01d493f5b45aadc18d6719d0c048","commit_date":"2016-08-19 13:05:37 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update F# Tour metadata and code tags (#918)","commit_sha":"7e00f788f368e03dc42592e9c023fcaa2a267f9e","commit_date":"2016-08-18 14:28:16 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Tour of F# (#908)","commit_sha":"b07269aaa2cc042b1843207d7a31437034833cc6","commit_date":"2016-08-18 12:48:30 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"F# Docs: Update intro, move files, rename language reference for better URLS (#902)","commit_sha":"70a10b9c3e21291c96d927d13f8710d9e0738d4c","commit_date":"2016-08-13 11:22:39 -0700"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/Jaxelr","display_name":"Jaxel Rojas","id":"5913008"},{"profile_url":"https://github.com/RecursiveRobot","display_name":"Attie Naude","id":"11936937"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/e48967d2f92399efc1b0f7d1d39649466d0405ee/docs/fsharp/tour.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/tour.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/tour.md","document_id":"6d36e1d2-3dfc-8aa4-0e0a-1e3592789fbf","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tour","toc_asset_id":"articles/toc.json","toc_rel":"../toc.json","_op_ogTitle":"Tour of F#","_op_displayDate":"2017-1-24","_op_displayDate_source":"2017-01-24T00:00:00Z","_op_wordCount":6369,"_op_rawTitle":"<h1 id=\"tour-of-f\" sourcefile=\"docs/fsharp/tour.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Tour of F#</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tour","fileRelativePath":"articles/fsharp/tour.html"},"themesRelativePathToOutputRoot":"_themes/"}