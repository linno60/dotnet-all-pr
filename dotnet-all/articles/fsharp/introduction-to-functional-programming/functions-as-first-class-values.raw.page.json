{"content":"<div><div class=\"content\">\n<p>A defining characteristic of functional programming languages is the elevation of functions to first-class status. You should be able to do with a function whatever you can do with values of the other built-in types, and be able to do so with a comparable degree of effort.</p>\n<p>Typical measures of first-class status include the following:</p>\n<ul>\n<li><p>Can you bind functions to identifiers? That is, can you give them names?</p>\n</li>\n<li><p>Can you store functions in data structures, such as in a list?</p>\n</li>\n<li><p>Can you pass a function as an argument in a function call?</p>\n</li>\n<li><p>Can you return a function from a function call?</p>\n</li>\n</ul>\n<p>The last two measures define what are known as <em>higher-order operations</em> or <em>higher-order functions</em>. Higher-order functions accept functions as arguments and return functions as the value of function calls. These operations support such mainstays of functional programming as mapping functions and composition of functions.</p>\n<h2 id=\"give-the-value-a-name\">Give the Value a Name</h2>\n<p>If a function is a first-class value, you must be able to name it, just as you can name integers, strings, and other built-in types. This is referred to in functional programming literature as binding an identifier to a value. F# uses <a href=\"../language-reference/functions/let-bindings\" data-linktype=\"relative-path\"><code>let</code> bindings</a> to bind names to values: <code>let &lt;identifier&gt; = &lt;value&gt;</code>. The following code shows two examples.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Integer and string.\nlet num = 10\nlet str = &quot;F#&quot;\n</code></pre><p>You can name a function just as easily. The following example defines a function named <code>squareIt</code> by binding the identifier <code>squareIt</code> to the <a href=\"../language-reference/functions/lambda-expressions-the-fun-keyword\" data-linktype=\"relative-path\">lambda expression</a> <code>fun n -&gt; n * n</code>. Function <code>squareIt</code> has one parameter, <code>n</code>, and it returns the square of that parameter.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let squareIt = fun n -&gt; n * n\n</code></pre><p>F# provides the following more concise syntax to achieve the same result with less typing.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let squareIt2 n = n * n\n</code></pre><p>The examples that follow mostly use the first style, <code>let &lt;function-name&gt; = &lt;lambda-expression&gt;</code>, to emphasize the similarities between the declaration of functions and the declaration of other types of values. However, all the named functions can also be written with the concise syntax. Some of the examples are written in both ways.</p>\n<h2 id=\"store-the-value-in-a-data-structure\">Store the Value in a Data Structure</h2>\n<p>A first-class value can be stored in a data structure. The following code shows examples that store values in lists and in tuples.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Lists.\n\n// Storing integers and strings.\nlet integerList = [ 1; 2; 3; 4; 5; 6; 7 ]\nlet stringList = [ &quot;one&quot;; &quot;two&quot;; &quot;three&quot; ]\n\n// You cannot mix types in a list. The following declaration causes a\n// type-mismatch compiler error.\n//let failedList = [ 5; &quot;six&quot; ]\n\n// In F#, functions can be stored in a list, as long as the functions\n// have the same signature.\n\n// Function doubleIt has the same signature as squareIt, declared previously.\n//let squareIt = fun n -&gt; n * n\nlet doubleIt = fun n -&gt; 2 * n\n\n// Functions squareIt and doubleIt can be stored together in a list.\nlet funList = [ squareIt; doubleIt ]\n\n// Function squareIt cannot be stored in a list together with a function\n// that has a different signature, such as the following body mass\n// index (BMI) calculator.\nlet BMICalculator = fun ht wt -&gt;\n                    (float wt / float (squareIt ht)) * 703.0\n\n// The following expression causes a type-mismatch compiler error.\n//let failedFunList = [ squareIt; BMICalculator ]\n\n\n// Tuples.\n\n// Integers and strings.\nlet integerTuple = ( 1, -7 )\nlet stringTuple = ( &quot;one&quot;, &quot;two&quot;, &quot;three&quot; )\n\n// A tuple does not require its elements to be of the same type.\nlet mixedTuple = ( 1, &quot;two&quot;, 3.3 )\n\n// Similarly, function elements in tuples can have different signatures.\nlet funTuple = ( squareIt, BMICalculator )\n\n// Functions can be mixed with integers, strings, and other types in\n// a tuple. Identifier num was declared previously.\n//let num = 10\nlet moreMixedTuple = ( num, &quot;two&quot;, 3.3, squareIt )\n</code></pre><p>To verify that a function name stored in a tuple does in fact evaluate to a function, the following example uses the <code>fst</code> and <code>snd</code> operators to extract the first and second elements from tuple <code>funAndArgTuple</code>. The first element in the tuple is <code>squareIt</code> and the second element is <code>num</code>. Identifier <code>num</code> is bound in a previous example to integer 10, a valid argument for the <code>squareIt</code> function. The second expression applies the first element in the tuple to the second element in the tuple: <code>squareIt num</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// You can pull a function out of a tuple and apply it. Both squareIt and num\n// were defined previously.\nlet funAndArgTuple = (squareIt, num)\n\n// The following expression applies squareIt to num, returns 100, and\n// then displays 100.\nSystem.Console.WriteLine((fst funAndArgTuple)(snd funAndArgTuple))\n</code></pre><p>Similarly, just as identifier <code>num</code> and integer 10 can be used interchangeably, so can identifier <code>squareIt</code> and lambda expression <code>fun n -&gt; n * n</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Make a list of values instead of identifiers.\nlet funAndArgTuple2 = ((fun n -&gt; n * n), 10)\n\n// The following expression applies a squaring function to 10, returns\n// 100, and then displays 100.\nSystem.Console.WriteLine((fst funAndArgTuple2)(snd funAndArgTuple2))\n</code></pre><h2 id=\"pass-the-value-as-an-argument\">Pass the Value as an Argument</h2>\n<p>If a value has first-class status in a language, you can pass it as an argument to a function. For example, it is common to pass integers and strings as arguments. The following code shows integers and strings passed as arguments in F#.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// An integer is passed to squareIt. Both squareIt and num are defined in\n// previous examples.\n//let num = 10\n//let squareIt = fun n -&gt; n * n\nSystem.Console.WriteLine(squareIt num)\n\n// String.\n// Function repeatString concatenates a string with itself.\nlet repeatString = fun s -&gt; s + s\n\n// A string is passed to repeatString. HelloHello is returned and displayed.\nlet greeting = &quot;Hello&quot;\nSystem.Console.WriteLine(repeatString greeting)\n</code></pre><p>If functions have first-class status, you must be able to pass them as arguments in the same way. Remember that this is the first characteristic of higher-order functions.</p>\n<p>In the following example, function <code>applyIt</code> has two parameters, <code>op</code> and <code>arg</code>. If you send in a function that has one parameter for <code>op</code> and an appropriate argument for the function to <code>arg</code>, the function returns the result of applying <code>op</code> to <code>arg</code>. In the following example, both the function argument and the integer argument are sent in the same way, by using their names.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Define the function, again using lambda expression syntax.\nlet applyIt = fun op arg -&gt; op arg\n\n// Send squareIt for the function, op, and num for the argument you want to\n// apply squareIt to, arg. Both squareIt and num are defined in previous\n// examples. The result returned and displayed is 100.\nSystem.Console.WriteLine(applyIt squareIt num)\n\n// The following expression shows the concise syntax for the previous function\n// definition.\nlet applyIt2 op arg = op arg\n// The following line also displays 100.\nSystem.Console.WriteLine(applyIt2 squareIt num)\n</code></pre><p>The ability to send a function as an argument to another function underlies common abstractions in functional programming languages, such as map or filter operations. A map operation, for example, is a higher-order function that captures the computation shared by functions that step through a list, do something to each element, and then return a list of the results. You might want to increment each element in a list of integers, or to square each element, or to change each element in a list of strings to uppercase. The error-prone part of the computation is the recursive process that steps through the list and builds a list of the results to return. That part is captured in the mapping function. All you have to write for a particular application is the function that you want to apply to each list element individually (adding, squaring, changing case). That function is sent as an argument to the mapping function, just as <code>squareIt</code> is sent to <code>applyIt</code> in the previous example.</p>\n<p>F# provides map methods for most collection types, including <a href=\"../language-reference/lists\" data-linktype=\"relative-path\">lists</a>, <a href=\"../language-reference/arrays\" data-linktype=\"relative-path\">arrays</a>, and <a href=\"../language-reference/sequences\" data-linktype=\"relative-path\">sequences</a>. The following examples use lists. The syntax is <code>List.map &lt;the function&gt; &lt;the list&gt;</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// List integerList was defined previously:\n//let integerList = [ 1; 2; 3; 4; 5; 6; 7 ]\n\n// You can send the function argument by name, if an appropriate function\n// is available. The following expression uses squareIt.\nlet squareAll = List.map squareIt integerList\n\n// The following line displays [1; 4; 9; 16; 25; 36; 49]\nprintfn &quot;%A&quot; squareAll\n\n// Or you can define the action to apply to each list element inline.\n// For example, no function that tests for even integers has been defined,\n// so the following expression defines the appropriate function inline.\n// The function returns true if n is even; otherwise it returns false.\nlet evenOrNot = List.map (fun n -&gt; n % 2 = 0) integerList\n\n// The following line displays [false; true; false; true; false; true; false]\nprintfn &quot;%A&quot; evenOrNot\n</code></pre><p>For more information, see <a href=\"../language-reference/lists\" data-linktype=\"relative-path\">Lists</a>.</p>\n<h2 id=\"return-the-value-from-a-function-call\">Return the Value from a Function Call</h2>\n<p>Finally, if a function has first-class status in a language, you must be able to return it as the value of a function call, just as you return other types, such as integers and strings.</p>\n<p>The following function calls return integers and display them.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Function doubleIt is defined in a previous example.\n//let doubleIt = fun n -&gt; 2 * n\nSystem.Console.WriteLine(doubleIt 3)\nSystem.Console.WriteLine(squareIt 4)\n</code></pre><p>The following function call returns a string.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// str is defined in a previous section.\n//let str = &quot;F#&quot;\nlet lowercase = str.ToLower()\n</code></pre><p>The following function call, declared inline, returns a Boolean value. The value displayed is <code>True</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">System.Console.WriteLine((fun n -&gt; n % 2 = 1) 15)\n</code></pre><p>The ability to return a function as the value of a function call is the second characteristic of higher-order functions. In the following example, <code>checkFor</code> is defined to be a function that takes one argument, <code>item</code>, and returns a new function as its value. The returned function takes a list as its argument, <code>lst</code>, and searches for <code>item</code> in <code>lst</code>. If <code>item</code> is present, the function returns <code>true</code>. If <code>item</code> is not present, the function returns <code>false</code>. As in the previous section, the following code uses a provided list function, <a href=\"https://msdn.microsoft.com/library/15a3ebd5-98f0-44c0-8220-7dedec3e68a8\" data-linktype=\"external\">List.exists</a>, to search the list.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let checkFor item =\n    let functionToReturn = fun lst -&gt;\n                           List.exists (fun a -&gt; a = item) lst\n    functionToReturn\n</code></pre><p>The following code uses <code>checkFor</code> to create a new function that takes one argument, a list, and searches for 7 in the list.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// integerList and stringList were defined earlier.\n//let integerList = [ 1; 2; 3; 4; 5; 6; 7 ]\n//let stringList = [ &quot;one&quot;; &quot;two&quot;; &quot;three&quot; ]\n\n// The returned function is given the name checkFor7.\nlet checkFor7 = checkFor 7\n\n// The result displayed when checkFor7 is applied to integerList is True.\nSystem.Console.WriteLine(checkFor7 integerList)\n\n// The following code repeats the process for &quot;seven&quot; in stringList.\nlet checkForSeven = checkFor &quot;seven&quot;\n\n// The result displayed is False.\nSystem.Console.WriteLine(checkForSeven stringList)\n</code></pre><p>The following example uses the first-class status of functions in F# to declare a function, <code>compose</code>, that returns a composition of two function arguments.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Function compose takes two arguments. Each argument is a function\n// that takes one argument of the same type. The following declaration\n// uses lambda expresson syntax.\nlet compose =\n    fun op1 op2 -&gt;\n        fun n -&gt;\n            op1 (op2 n)\n\n// To clarify what you are returning, use a nested let expression:\nlet compose2 =\n    fun op1 op2 -&gt;\n        // Use a let expression to build the function that will be returned.\n        let funToReturn = fun n -&gt;\n                            op1 (op2 n)\n        // Then just return it.\n        funToReturn\n\n// Or, integrating the more concise syntax:\nlet compose3 op1 op2 =\n    let funToReturn = fun n -&gt;\n                        op1 (op2 n)\n    funToReturn\n</code></pre><div class=\"NOTE\"><h5>Note</h5><p>For an even shorter version, see the following section, &quot;Curried Functions.&quot;</p>\n</div>\n<p>The following code sends two functions as arguments to <code>compose</code>, both of which take a single argument of the same type. The return value is a new function that is a composition of the two function arguments.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Functions squareIt and doubleIt were defined in a previous example.\nlet doubleAndSquare = compose squareIt doubleIt\n// The following expression doubles 3, squares 6, and returns and\n// displays 36.\nSystem.Console.WriteLine(doubleAndSquare 3)\n\nlet squareAndDouble = compose doubleIt squareIt\n// The following expression squares 3, doubles 9, returns 18, and\n// then displays 18.\nSystem.Console.WriteLine(squareAndDouble 3)\n</code></pre><div class=\"NOTE\"><h5>Note</h5><p>F# provides two operators, <code>&lt;&lt;</code> and <code>&gt;&gt;</code>, that compose functions. For example, <code>let squareAndDouble2 = doubleIt &lt;&lt; squareIt</code> is equivalent to <code>let squareAndDouble = compose doubleIt squareIt</code> in the previous example.</p>\n</div>\n<p>The following example of returning a function as the value of a function call creates a simple guessing game. To create a game, call <code>makeGame</code> with the value that you want someone to guess sent in for <code>target</code>. The return value from function <code>makeGame</code> is a function that takes one argument (the guess) and reports whether the guess is correct.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let makeGame target =\n    // Build a lambda expression that is the function that plays the game.\n    let game = fun guess -&gt;\n                   if guess = target then\n                      System.Console.WriteLine(&quot;You win!&quot;)\n                   else\n                      System.Console.WriteLine(&quot;Wrong. Try again.&quot;)\n    // Now just return it.\n    game\n</code></pre><p>The following code calls <code>makeGame</code>, sending the value <code>7</code> for <code>target</code>. Identifier <code>playGame</code> is bound to the returned lambda expression. Therefore, <code>playGame</code> is a function that takes as its one argument a value for <code>guess</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let playGame = makeGame 7\n// Send in some guesses.\nplayGame 2\nplayGame 9\nplayGame 7\n\n// Output:\n// Wrong. Try again.\n// Wrong. Try again.\n// You win!\n\n// The following game specifies a character instead of an integer for target.\nlet alphaGame = makeGame &#39;q&#39;\nalphaGame &#39;c&#39;\nalphaGame &#39;r&#39;\nalphaGame &#39;j&#39;\nalphaGame &#39;q&#39;\n\n// Output:\n// Wrong. Try again.\n// Wrong. Try again.\n// Wrong. Try again.\n// You win!\n</code></pre><h2 id=\"curried-functions\">Curried Functions</h2>\n<p>Many of the examples in the previous section can be written more concisely by taking advantage of the implicit <em>currying</em> in F# function declarations. Currying is a process that transforms a function that has more than one parameter into a series of embedded functions, each of which has a single parameter. In F#, functions that have more than one parameter are inherently curried. For example, <code>compose</code> from the previous section can be written as shown in the following concise style, with three parameters.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let compose4 op1 op2 n = op1 (op2 n)\n</code></pre><p>However, the result is a function of one parameter that returns a function of one parameter that in turn returns another function of one parameter, as shown in <code>compose4curried</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let compose4curried =\n    fun op1 -&gt;\n        fun op2 -&gt;\n            fun n -&gt; op1 (op2 n)\n</code></pre><p>You can access this function in several ways. Each of the following examples returns and displays 18. You can replace <code>compose4</code> with <code>compose4curried</code> in any of the examples.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Access one layer at a time.\nSystem.Console.WriteLine(((compose4 doubleIt) squareIt) 3)\n\n// Access as in the original compose examples, sending arguments for\n// op1 and op2, then applying the resulting function to a value.\nSystem.Console.WriteLine((compose4 doubleIt squareIt) 3)\n\n// Access by sending all three arguments at the same time.\nSystem.Console.WriteLine(compose4 doubleIt squareIt 3)\n</code></pre><p>To verify that the function still works as it did before, try the original test cases again.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let doubleAndSquare4 = compose4 squareIt doubleIt\n// The following expression returns and displays 36.\nSystem.Console.WriteLine(doubleAndSquare4 3)\n\nlet squareAndDouble4 = compose4 doubleIt squareIt\n// The following expression returns and displays 18.\nSystem.Console.WriteLine(squareAndDouble4 3)\n</code></pre><div class=\"NOTE\"><h5>Note</h5><p>You can restrict currying by enclosing parameters in tuples. For more information, see &quot;Parameter Patterns&quot; in <a href=\"../language-reference/parameters-and-arguments\" data-linktype=\"relative-path\">Parameters and Arguments</a>.</p>\n</div>\n<p>The following example uses implicit currying to write a shorter version of <code>makeGame</code>. The details of how <code>makeGame</code> constructs and returns the <code>game</code> function are less explicit in this format, but you can verify by using the original test cases that the result is the same.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let makeGame2 target guess =\n    if guess = target then\n       System.Console.WriteLine(&quot;You win!&quot;)\n    else\n       System.Console.WriteLine(&quot;Wrong. Try again.&quot;)\n\nlet playGame2 = makeGame2 7\nplayGame2 2\nplayGame2 9\nplayGame2 7\n\nlet alphaGame2 = makeGame2 &#39;q&#39;\nalphaGame2 &#39;c&#39;\nalphaGame2 &#39;r&#39;\nalphaGame2 &#39;j&#39;\nalphaGame2 &#39;q&#39;\n</code></pre><p>For more information about currying, see &quot;Partial Application of Arguments&quot; in <a href=\"../language-reference/functions/index\" data-linktype=\"relative-path\">Functions</a>.</p>\n<h2 id=\"identifier-and-function-definition-are-interchangeable\">Identifier and Function Definition Are Interchangeable</h2>\n<p>The variable name <code>num</code> in the previous examples evaluates to the integer 10, and it is no surprise that where <code>num</code> is valid, 10 is also valid. The same is true of function identifiers and their values: anywhere the name of the function can be used, the lambda expression to which it is bound can be used.</p>\n<p>The following example defines a <code>Boolean</code> function called <code>isNegative</code>, and then uses the name of the function and the definition of the function interchangeably. The next three examples all return and display <code>False</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let isNegative = fun n -&gt; n &lt; 0\n\n// This example uses the names of the function argument and the integer\n// argument. Identifier num is defined in a previous example.\n//let num = 10\nSystem.Console.WriteLine(applyIt isNegative num)\n\n// This example substitutes the value that num is bound to for num, and the\n// value that isNegative is bound to for isNegative.\nSystem.Console.WriteLine(applyIt (fun n -&gt; n &lt; 0) 10)\n</code></pre><p>To take it one step further, substitute the value that <code>applyIt</code> is bound to for <code>applyIt</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">System.Console.WriteLine((fun op arg -&gt; op arg) (fun n -&gt; n &lt; 0)  10)\n</code></pre><h2 id=\"functions-are-first-class-values-in-f\">Functions Are First-Class Values in F#</h2>\n<p>The examples in the previous sections demonstrate that functions in F# satisfy the criteria for being first-class values in F#:</p>\n<ul>\n<li>You can bind an identifier to a function definition.</li>\n</ul>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let squareIt = fun n -&gt; n * n\n</code></pre><ul>\n<li><p>You can store a function in a data structure.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let funTuple2 = ( BMICalculator, fun n -&gt; n * n )\n</code></pre></li>\n<li><p>You can pass a function as an argument.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let increments = List.map (fun n -&gt; n + 1) [ 1; 2; 3; 4; 5; 6; 7 ]\n</code></pre></li>\n<li><p>You can return a function as the value of a function call.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let checkFor item =\n    let functionToReturn = fun lst -&gt;\n                           List.exists (fun a -&gt; a = item) lst\n    functionToReturn\n</code></pre></li>\n</ul>\n<p>For more information about F#, see the <a href=\"../language-reference/index\" data-linktype=\"relative-path\">F# Language Reference</a>.</p>\n<h2 id=\"example\">Example</h2>\n<h3 id=\"description\">Description</h3>\n<p>The following code contains all the examples in this topic.</p>\n<h3 id=\"code\">Code</h3>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// ** GIVE THE VALUE A NAME **\n\n\n// Integer and string.\nlet num = 10\nlet str = &quot;F#&quot;\n\n\n\nlet squareIt = fun n -&gt; n * n\n\n\n\nlet squareIt2 n = n * n\n\n\n\n// ** STORE THE VALUE IN A DATA STRUCTURE **\n\n\n// Lists.\n\n// Storing integers and strings.\nlet integerList = [ 1; 2; 3; 4; 5; 6; 7 ]\nlet stringList = [ &quot;one&quot;; &quot;two&quot;; &quot;three&quot; ]\n\n// You cannot mix types in a list. The following declaration causes a\n// type-mismatch compiler error.\n//let failedList = [ 5; &quot;six&quot; ]\n\n// In F#, functions can be stored in a list, as long as the functions\n// have the same signature.\n\n// Function doubleIt has the same signature as squareIt, declared previously.\n//let squareIt = fun n -&gt; n * n\nlet doubleIt = fun n -&gt; 2 * n\n\n// Functions squareIt and doubleIt can be stored together in a list.\nlet funList = [ squareIt; doubleIt ]\n\n// Function squareIt cannot be stored in a list together with a function\n// that has a different signature, such as the following body mass\n// index (BMI) calculator.\nlet BMICalculator = fun ht wt -&gt;\n                    (float wt / float (squareIt ht)) * 703.0\n\n// The following expression causes a type-mismatch compiler error.\n//let failedFunList = [ squareIt; BMICalculator ]\n\n\n// Tuples.\n\n// Integers and strings.\nlet integerTuple = ( 1, -7 )\nlet stringTuple = ( &quot;one&quot;, &quot;two&quot;, &quot;three&quot; )\n\n// A tuple does not require its elements to be of the same type.\nlet mixedTuple = ( 1, &quot;two&quot;, 3.3 )\n\n// Similarly, function elements in tuples can have different signatures.\nlet funTuple = ( squareIt, BMICalculator )\n\n// Functions can be mixed with integers, strings, and other types in\n// a tuple. Identifier num was declared previously.\n//let num = 10\nlet moreMixedTuple = ( num, &quot;two&quot;, 3.3, squareIt )\n\n\n\n// You can pull a function out of a tuple and apply it. Both squareIt and num\n// were defined previously.\nlet funAndArgTuple = (squareIt, num)\n\n// The following expression applies squareIt to num, returns 100, and\n// then displays 100.\nSystem.Console.WriteLine((fst funAndArgTuple)(snd funAndArgTuple))\n\n\n\n// Make a list of values instead of identifiers.\nlet funAndArgTuple2 = ((fun n -&gt; n * n), 10)\n\n// The following expression applies a squaring function to 10, returns\n// 100, and then displays 100.\nSystem.Console.WriteLine((fst funAndArgTuple2)(snd funAndArgTuple2))\n\n\n\n// ** PASS THE VALUE AS AN ARGUMENT **\n\n\n// An integer is passed to squareIt. Both squareIt and num are defined in\n// previous examples.\n//let num = 10\n//let squareIt = fun n -&gt; n * n\nSystem.Console.WriteLine(squareIt num)\n\n// String.\n// Function repeatString concatenates a string with itself.\nlet repeatString = fun s -&gt; s + s\n\n// A string is passed to repeatString. HelloHello is returned and displayed.\nlet greeting = &quot;Hello&quot;\nSystem.Console.WriteLine(repeatString greeting)\n\n\n\n// Define the function, again using lambda expression syntax.\nlet applyIt = fun op arg -&gt; op arg\n\n// Send squareIt for the function, op, and num for the argument you want to\n// apply squareIt to, arg. Both squareIt and num are defined in previous\n// examples. The result returned and displayed is 100.\nSystem.Console.WriteLine(applyIt squareIt num)\n\n// The following expression shows the concise syntax for the previous function\n// definition.\nlet applyIt2 op arg = op arg\n// The following line also displays 100.\nSystem.Console.WriteLine(applyIt2 squareIt num)\n\n\n\n// List integerList was defined previously:\n//let integerList = [ 1; 2; 3; 4; 5; 6; 7 ]\n\n// You can send the function argument by name, if an appropriate function\n// is available. The following expression uses squareIt.\nlet squareAll = List.map squareIt integerList\n\n// The following line displays [1; 4; 9; 16; 25; 36; 49]\nprintfn &quot;%A&quot; squareAll\n\n// Or you can define the action to apply to each list element inline.\n// For example, no function that tests for even integers has been defined,\n// so the following expression defines the appropriate function inline.\n// The function returns true if n is even; otherwise it returns false.\nlet evenOrNot = List.map (fun n -&gt; n % 2 = 0) integerList\n\n// The following line displays [false; true; false; true; false; true; false]\nprintfn &quot;%A&quot; evenOrNot\n\n\n\n// ** RETURN THE VALUE FROM A FUNCTION CALL **\n\n\n// Function doubleIt is defined in a previous example.\n//let doubleIt = fun n -&gt; 2 * n\nSystem.Console.WriteLine(doubleIt 3)\nSystem.Console.WriteLine(squareIt 4)\n\n\n// The following function call returns a string:\n\n// str is defined in a previous section.\n//let str = &quot;F#&quot;\nlet lowercase = str.ToLower()\n\n\n\nSystem.Console.WriteLine((fun n -&gt; n % 2 = 1) 15)\n\n\n\nlet checkFor item =\n    let functionToReturn = fun lst -&gt;\n                           List.exists (fun a -&gt; a = item) lst\n    functionToReturn\n\n\n\n// integerList and stringList were defined earlier.\n//let integerList = [ 1; 2; 3; 4; 5; 6; 7 ]\n//let stringList = [ &quot;one&quot;; &quot;two&quot;; &quot;three&quot; ]\n\n// The returned function is given the name checkFor7.\nlet checkFor7 = checkFor 7\n\n// The result displayed when checkFor7 is applied to integerList is True.\nSystem.Console.WriteLine(checkFor7 integerList)\n\n// The following code repeats the process for &quot;seven&quot; in stringList.\nlet checkForSeven = checkFor &quot;seven&quot;\n\n// The result displayed is False.\nSystem.Console.WriteLine(checkForSeven stringList)\n\n\n\n// Function compose takes two arguments. Each argument is a function\n// that takes one argument of the same type. The following declaration\n// uses lambda expresson syntax.\nlet compose =\n    fun op1 op2 -&gt;\n        fun n -&gt;\n            op1 (op2 n)\n\n// To clarify what you are returning, use a nested let expression:\nlet compose2 =\n    fun op1 op2 -&gt;\n        // Use a let expression to build the function that will be returned.\n        let funToReturn = fun n -&gt;\n                            op1 (op2 n)\n        // Then just return it.\n        funToReturn\n\n// Or, integrating the more concise syntax:\nlet compose3 op1 op2 =\n    let funToReturn = fun n -&gt;\n                        op1 (op2 n)\n    funToReturn\n\n\n\n// Functions squareIt and doubleIt were defined in a previous example.\nlet doubleAndSquare = compose squareIt doubleIt\n// The following expression doubles 3, squares 6, and returns and\n// displays 36.\nSystem.Console.WriteLine(doubleAndSquare 3)\n\nlet squareAndDouble = compose doubleIt squareIt\n// The following expression squares 3, doubles 9, returns 18, and\n// then displays 18.\nSystem.Console.WriteLine(squareAndDouble 3)\n\n\n\nlet makeGame target =\n    // Build a lambda expression that is the function that plays the game.\n    let game = fun guess -&gt;\n                   if guess = target then\n                      System.Console.WriteLine(&quot;You win!&quot;)\n                   else\n                      System.Console.WriteLine(&quot;Wrong. Try again.&quot;)\n    // Now just return it.\n    game\n\n\n\nlet playGame = makeGame 7\n// Send in some guesses.\nplayGame 2\nplayGame 9\nplayGame 7\n\n// Output:\n// Wrong. Try again.\n// Wrong. Try again.\n// You win!\n\n// The following game specifies a character instead of an integer for target.\nlet alphaGame = makeGame &#39;q&#39;\nalphaGame &#39;c&#39;\nalphaGame &#39;r&#39;\nalphaGame &#39;j&#39;\nalphaGame &#39;q&#39;\n\n// Output:\n// Wrong. Try again.\n// Wrong. Try again.\n// Wrong. Try again.\n// You win!\n\n\n\n// ** CURRIED FUNCTIONS **\n\n\nlet compose4 op1 op2 n = op1 (op2 n)\n\n\n\nlet compose4curried =\n    fun op1 -&gt;\n        fun op2 -&gt;\n            fun n -&gt; op1 (op2 n)\n\n\n\n// Access one layer at a time.\nSystem.Console.WriteLine(((compose4 doubleIt) squareIt) 3)\n\n// Access as in the original compose examples, sending arguments for\n// op1 and op2, then applying the resulting function to a value.\nSystem.Console.WriteLine((compose4 doubleIt squareIt) 3)\n\n// Access by sending all three arguments at the same time.\nSystem.Console.WriteLine(compose4 doubleIt squareIt 3)\n\n\n\nlet doubleAndSquare4 = compose4 squareIt doubleIt\n// The following expression returns and displays 36.\nSystem.Console.WriteLine(doubleAndSquare4 3)\n\nlet squareAndDouble4 = compose4 doubleIt squareIt\n// The following expression returns and displays 18.\nSystem.Console.WriteLine(squareAndDouble4 3)\n\n\n\nlet makeGame2 target guess =\n    if guess = target then\n       System.Console.WriteLine(&quot;You win!&quot;)\n    else\n       System.Console.WriteLine(&quot;Wrong. Try again.&quot;)\n\nlet playGame2 = makeGame2 7\nplayGame2 2\nplayGame2 9\nplayGame2 7\n\nlet alphaGame2 = makeGame2 &#39;q&#39;\nalphaGame2 &#39;c&#39;\nalphaGame2 &#39;r&#39;\nalphaGame2 &#39;j&#39;\nalphaGame2 &#39;q&#39;\n\n\n\n// ** IDENTIFIER AND FUNCTION DEFINITION ARE INTERCHANGEABLE **\n\n\nlet isNegative = fun n -&gt; n &lt; 0\n\n// This example uses the names of the function argument and the integer\n// argument. Identifier num is defined in a previous example.\n//let num = 10\nSystem.Console.WriteLine(applyIt isNegative num)\n\n// This example substitutes the value that num is bound to for num, and the\n// value that isNegative is bound to for isNegative.\nSystem.Console.WriteLine(applyIt (fun n -&gt; n &lt; 0) 10)\n\n\n\nSystem.Console.WriteLine((fun op arg -&gt; op arg) (fun n -&gt; n &lt; 0)  10)\n\n\n\n// ** FUNCTIONS ARE FIRST-CLASS VALUES IN F# **\n\n//let squareIt = fun n -&gt; n * n\n\n\nlet funTuple2 = ( BMICalculator, fun n -&gt; n * n )\n\n\n\nlet increments = List.map (fun n -&gt; n + 1) [ 1; 2; 3; 4; 5; 6; 7 ]\n\n\n//let checkFor item =\n//    let functionToReturn = fun lst -&gt;\n//                           List.exists (fun a -&gt; a = item) lst\n//    functionToReturn\n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p><a href=\"../language-reference/lists\" data-linktype=\"relative-path\">Lists</a></p>\n<p><a href=\"../language-reference/tuples\" data-linktype=\"relative-path\">Tuples</a></p>\n<p><a href=\"../language-reference/functions/index\" data-linktype=\"relative-path\">Functions</a></p>\n<p><a href=\"../language-reference/functions/let-bindings\" data-linktype=\"relative-path\"><code>let</code> Bindings</a></p>\n<p><a href=\"../language-reference/functions/lambda-expressions-the-fun-keyword\" data-linktype=\"relative-path\">Lambda Expressions: The <code>fun</code> Keyword</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"6b76b93b-a141-40f4-976c-7f0c558d6d09\">\r\n<meta name=\"description\" content=\"Functions as First-Class Values (F#)\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming\">\r\n<meta name=\"ms.topic\" content=\"language-reference\">\r\n<meta name=\"ms.date\" content=\"05/16/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/introduction-to-functional-programming/functions-as-first-class-values.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/introduction-to-functional-programming/functions-as-first-class-values.md\">\r\n<meta name=\"document_id\" content=\"a27a44ac-95de-d684-aa66-a69a03ee52fd\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Functions as First-Class Values (F#) | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"6b76b93b-a141-40f4-976c-7f0c558d6d09","description":"Functions as First-Class Values (F#)","keywords":"visual f#, f#, functional programming","ms.topic":"language-reference","ms.date":"05/16/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Carl Patenaude Poulin","author_email":"carl.patenaudepoulin@mail.mcgill.ca","committer_name":"Phillip Carter","comitter_email":"phillip.carter@outlook.com","message":"clarify wording of \"Functions as First-Class Values\" (#1290)","commit_sha":"cb70a728281019a2d8dad13fdeb095f95134b1a1","commit_date":"2016-11-29 18:59:48 -0800"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Move snippets to snippets folder, now with some F# (#904)","commit_sha":"37fe2b89d590509e8eb14342da988f15862a9e2b","commit_date":"2016-08-13 16:40:56 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize F# snippets (#903)","commit_sha":"6ea1cf8f3779532a9ed8fbdac32592fbb809443c","commit_date":"2016-08-13 15:14:41 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"F# Docs: Update intro, move files, rename language reference for better URLS (#902)","commit_sha":"70a10b9c3e21291c96d927d13f8710d9e0738d4c","commit_date":"2016-08-13 11:22:39 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Add Visual F# Conceptual Content (#900)","commit_sha":"c27bed7dbad6b24c55734fcab0333bd3a1de85d6","commit_date":"2016-08-12 17:06:05 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/lilred","display_name":"Carl Patenaude Poulin","id":"1834919"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/introduction-to-functional-programming/functions-as-first-class-values.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/introduction-to-functional-programming/functions-as-first-class-values.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/introduction-to-functional-programming/functions-as-first-class-values.md","document_id":"a27a44ac-95de-d684-aa66-a69a03ee52fd","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/fsharp/introduction-to-functional-programming/functions-as-first-class-values","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Functions as First-Class Values (F#)","_op_displayDate":"2016-5-16","_op_displayDate_source":"2016-05-16T00:00:00Z","_op_wordCount":4442,"_op_rawTitle":"<h1 id=\"functions-as-first-class-values\" sourcefile=\"docs/fsharp/introduction-to-functional-programming/functions-as-first-class-values.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Functions as First-Class Values</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/fsharp/introduction-to-functional-programming/functions-as-first-class-values","fileRelativePath":"articles/fsharp/introduction-to-functional-programming/functions-as-first-class-values.html"},"themesRelativePathToOutputRoot":"_themes/"}