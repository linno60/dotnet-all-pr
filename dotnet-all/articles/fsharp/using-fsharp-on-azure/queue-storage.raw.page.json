{"content":"<div><div class=\"content\">\n<p>Azure Queue storage provides cloud messaging between application components. In designing applications for scale, application components are often decoupled, so that they can scale independently. Queue storage delivers asynchronous messaging for communication between application components, whether they are running in the cloud, on the desktop, on an on-premises server, or on a mobile device. Queue storage also supports managing asynchronous tasks and building process work flows.</p>\n<h3 id=\"about-this-tutorial\">About this tutorial</h3>\n<p>This tutorial shows how to write F# code for some common tasks using Azure Queue storage. Tasks covered include creating and deleting queues and adding, reading, and deleting queue messages.</p>\n<p>For a conceptual overview of queue storage, please see <a href=\"https://docs.microsoft.com/azure/storage/storage-dotnet-how-to-use-queues\" data-linktype=\"external\">the .NET guide for queue storage</a>.</p>\n<h2 id=\"prerequisites\">Prerequisites</h2>\n<p>To use this guide, you must first <a href=\"https://docs.microsoft.com/azure/storage/storage-create-storage-account\" data-linktype=\"external\">create an Azure storage account</a>.\nYou&#39;ll also need your storage access key for this account.</p>\n<h2 id=\"create-an-f-script-and-start-f-interactive\">Create an F# Script and Start F# Interactive</h2>\n<p>The samples in this article can be used in either an F# application or an F# script. To create an F# script, create a file with the <code>.fsx</code> extension, for example <code>queues.fsx</code>, in your F# development environment.</p>\n<p>Next, use a <a href=\"package-management\" data-linktype=\"relative-path\">package manager</a> such as <a href=\"https://fsprojects.github.io/Paket/\" data-linktype=\"external\">Paket</a> or <a href=\"https://www.nuget.org/\" data-linktype=\"external\">NuGet</a> to install the <code>WindowsAzure.Storage</code> package and reference <code>WindowsAzure.Storage.dll</code> in your script using a <code>#r</code> directive.</p>\n<h3 id=\"add-namespace-declarations\">Add namespace declarations</h3>\n<p>Add the following <code>open</code> statements to the top of the <code>queues.fsx</code> file:</p>\n<pre><code class=\"lang-fsharp\" name=\"QueueStorage\">open Microsoft.Azure // Namespace for CloudConfigurationManager \nopen Microsoft.WindowsAzure.Storage // Namespace for CloudStorageAccount\nopen Microsoft.WindowsAzure.Storage.Queue // Namespace for Queue storage types\n</code></pre><h3 id=\"get-your-connection-string\">Get your connection string</h3>\n<p>You&#39;ll need an Azure Storage connection string for this tutorial. For more information about connection strings, see <a href=\"https://docs.microsoft.com/azure/storage/storage-configure-connection-string\" data-linktype=\"external\">Configure Storage Connection Strings</a>.</p>\n<p>For the tutorial, you&#39;ll enter your connection string in your script, like this:</p>\n<pre><code class=\"lang-fsharp\" name=\"QueueStorage\">let storageConnString = &quot;...&quot; // fill this in from your storage account\n</code></pre><p>However, this is <strong>not recommended</strong> for real projects. Your storage account key is similar to the root password for your storage account. Always be careful to protect your storage account key. Avoid distributing it to other users, hard-coding it, or saving it in a plain-text file that is accessible to others. You can regenerate your key using the Azure Portal if you believe it may have been compromised.</p>\n<p>For real applications, the best way to maintain your storage connection string is in a configuration file. To fetch the connection string from a configuration file, you can do this:</p>\n<pre><code class=\"lang-fsharp\" name=\"QueueStorage\">// Parse the connection string and return a reference to the storage account.\nlet storageConnString = \n    CloudConfigurationManager.GetSetting(&quot;StorageConnectionString&quot;)\n</code></pre><p>Using Azure Configuration Manager is optional. You can also use an API such as the .NET Framework&#39;s <code>ConfigurationManager</code> type.</p>\n<h3 id=\"parse-the-connection-string\">Parse the connection string</h3>\n<p>To parse the connection string, use:</p>\n<pre><code class=\"lang-fsharp\" name=\"QueueStorage\">// Parse the connection string and return a reference to the storage account.\nlet storageAccount = CloudStorageAccount.Parse(storageConnString)\n</code></pre><p>This will return a <code>CloudStorageAccount</code>.</p>\n<h3 id=\"create-the-queue-service-client\">Create the Queue service client</h3>\n<p>The <code>CloudQueueClient</code> class enables you to retrieve queues stored in Queue storage. Here&#39;s one way to create the service client:</p>\n<pre><code class=\"lang-fsharp\" name=\"QueueStorage\">let queueClient = storageAccount.CreateCloudQueueClient()\n</code></pre><p>Now you are ready to write code that reads data from and writes data to Queue storage.</p>\n<h2 id=\"create-a-queue\">Create a queue</h2>\n<p>This example shows how to create a queue if it doesn&#39;t already exist:</p>\n<pre><code class=\"lang-fsharp\" name=\"QueueStorage\">// Retrieve a reference to a container.\nlet queue = queueClient.GetQueueReference(&quot;myqueue&quot;)\n\n// Create the queue if it doesn&#39;t already exist\nqueue.CreateIfNotExists()\n</code></pre><h2 id=\"insert-a-message-into-a-queue\">Insert a message into a queue</h2>\n<p>To insert a message into an existing queue, first create a new\n<code>CloudQueueMessage</code>. Next, call the <code>AddMessage</code> method. A\n<code>CloudQueueMessage</code> can be created from either a string (in UTF-8\nformat) or a <code>byte</code> array, like this:</p>\n<pre><code class=\"lang-fsharp\" name=\"QueueStorage\">// Create a message and add it to the queue.\nlet message = new CloudQueueMessage(&quot;Hello, World&quot;)\nqueue.AddMessage(message)\n</code></pre><h2 id=\"peek-at-the-next-message\">Peek at the next message</h2>\n<p>You can peek at the message in the front of a queue, without removing it\nfrom the queue, by calling the <code>PeekMessage</code> method.</p>\n<pre><code class=\"lang-fsharp\" name=\"QueueStorage\">// Peek at the next message.\nlet peekedMessage = queue.PeekMessage()\nlet msgAsString = peekedMessage.AsString\n</code></pre><h2 id=\"get-the-next-message-for-processing\">Get the next message for processing</h2>\n<p>You can retrieve the message at the front of a queue for processing by calling the <code>GetMessage</code> method.</p>\n<pre><code class=\"lang-fsharp\" name=\"QueueStorage\">// Get the next message. Successful processing must be indicated via DeleteMessage later.\nlet retrieved = queue.GetMessage()\n</code></pre><p>You later indicate successful processing of the message by using <code>DeleteMessage</code>.</p>\n<h2 id=\"change-the-contents-of-a-queued-message\">Change the contents of a queued message</h2>\n<p>You can change the contents of a retrieved message in-place in the queue. If the\nmessage represents a work task, you could use this feature to update the\nstatus of the work task. The following code updates the queue message\nwith new contents, and sets the visibility timeout to extend another 60\nseconds. This saves the state of work associated with the message, and\ngives the client another minute to continue working on the message. You\ncould use this technique to track multi-step workflows on queue\nmessages, without having to start over from the beginning if a\nprocessing step fails due to hardware or software failure. Typically,\nyou would keep a retry count as well, and if the message is retried more\nthan some number of times, you would delete it. This protects against a message\nthat triggers an application error each time it is processed.</p>\n<pre><code class=\"lang-fsharp\" name=\"QueueStorage\">// Update the message contents and set a new timeout.\nretrieved.SetMessageContent(&quot;Updated contents.&quot;)\nqueue.UpdateMessage(retrieved,\n    TimeSpan.FromSeconds(60.0),\n    MessageUpdateFields.Content ||| MessageUpdateFields.Visibility)\n</code></pre><h2 id=\"de-queue-the-next-message\">De-queue the next message</h2>\n<p>Your code de-queues a message from a queue in two steps. When you call\n<code>GetMessage</code>, you get the next message in a queue. A message returned\nfrom <code>GetMessage</code> becomes invisible to any other code reading messages\nfrom this queue. By default, this message stays invisible for 30\nseconds. To finish removing the message from the queue, you must also\ncall <code>DeleteMessage</code>. This two-step process of removing a message\nassures that if your code fails to process a message due to hardware or\nsoftware failure, another instance of your code can get the same message\nand try again. Your code calls <code>DeleteMessage</code> right after the message\nhas been processed.</p>\n<pre><code class=\"lang-fsharp\" name=\"QueueStorage\">// Process the message in less than 30 seconds, and then delete the message.\nqueue.DeleteMessage(retrieved)\n</code></pre><h2 id=\"use-async-workflows-with-common-queue-storage-apis\">Use Async workflows with common Queue storage APIs</h2>\n<p>This example shows how to use an async workflow with common Queue storage APIs.</p>\n<pre><code class=\"lang-fsharp\" name=\"QueueStorage\">async {\n    let! exists = queue.CreateIfNotExistsAsync() |&gt; Async.AwaitTask\n\n    let! retrieved = queue.GetMessageAsync() |&gt; Async.AwaitTask\n\n    // ... process the message here ...\n\n    // Now indicate successful processing:\n    do! queue.DeleteMessageAsync(retrieved) |&gt; Async.AwaitTask\n}\n</code></pre><h2 id=\"additional-options-for-de-queuing-messages\">Additional options for de-queuing messages</h2>\n<p>There are two ways you can customize message retrieval from a queue.\nFirst, you can get a batch of messages (up to 32). Second, you can set a\nlonger or shorter invisibility timeout, allowing your code more or less\ntime to fully process each message. The following code example uses\n<code>GetMessages</code> to get 20 messages in one call and then processes\neach message. It also sets the invisibility timeout to five minutes for\neach message. Note that the 5 minutes starts for all messages at the same\ntime, so after 5 minutes have passed since the call to <code>GetMessages</code>, any \nmessages which have not been deleted will become visible again.</p>\n<pre><code class=\"lang-fsharp\" name=\"QueueStorage\">for msg in queue.GetMessages(20, Nullable(TimeSpan.FromMinutes(5.))) do\n        // Process the message here.\n        queue.DeleteMessage(msg)\n</code></pre><h2 id=\"get-the-queue-length\">Get the queue length</h2>\n<p>You can get an estimate of the number of messages in a queue. The <code>FetchAttributes</code> method asks the Queue service to retrieve the queue attributes, including the message count. The <code>ApproximateMessageCount</code> property returns the last value retrieved by the <code>FetchAttributes</code> method, without calling the Queue service.</p>\n<pre><code class=\"lang-fsharp\" name=\"QueueStorage\">queue.FetchAttributes()\nlet count = queue.ApproximateMessageCount.GetValueOrDefault()\n</code></pre><h2 id=\"delete-a-queue\">Delete a queue</h2>\n<p>To delete a queue and all the messages contained in it, call the\n<code>Delete</code> method on the queue object.</p>\n<pre><code class=\"lang-fsharp\" name=\"QueueStorage\">// Delete the queue.\nqueue.Delete()\n</code></pre><h2 id=\"next-steps\">Next steps</h2>\n<p>Now that you&#39;ve learned the basics of Queue storage, follow these links\nto learn about more complex storage tasks.</p>\n<ul>\n<li><a href=\"http://go.microsoft.com/fwlink/?LinkID=390731&amp;clcid=0x409\" data-linktype=\"external\">Storage Client Library for .NET reference</a></li>\n<li><a href=\"https://github.com/fsprojects/AzureStorageTypeProvider\" data-linktype=\"external\">Azure Storage Type Provider</a></li>\n<li><a href=\"http://blogs.msdn.com/b/windowsazurestorage/\" data-linktype=\"external\">Azure Storage Team Blog</a></li>\n<li><a href=\"http://msdn.microsoft.com/library/azure/ee758697.aspx\" data-linktype=\"external\">Configuring Connection Strings</a></li>\n<li><a href=\"http://msdn.microsoft.com/library/azure/dd179355\" data-linktype=\"external\">REST API reference</a></li>\n</ul>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"sylvanc\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"70dc554c-8f4d-42a7-8e2a-6438657d012a\">\r\n<meta name=\"description\" content=\"Azure Queues provide reliable, asynchronous messaging between application components. Cloud messaging enables your application components to scale independently.\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming, .NET, .NET Core, Azure\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"09/20/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/using-fsharp-on-azure/queue-storage.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/using-fsharp-on-azure/queue-storage.md\">\r\n<meta name=\"document_id\" content=\"b1d13774-3afb-000e-95b9-971b9a0c21a7\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"sylvanc","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Get started with Azure Queue storage using F# | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"70dc554c-8f4d-42a7-8e2a-6438657d012a","description":"Azure Queues provide reliable, asynchronous messaging between application components. Cloud messaging enables your application components to scale independently.","keywords":"visual f#, f#, functional programming, .NET, .NET Core, Azure","ms.topic":"article","ms.date":"09/20/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Absolute urls and other fixes (#1281)","commit_sha":"f7dffe4885b331cec8d37f3cc5c9163f69c3b4c9","commit_date":"2016-11-22 12:57:26 -0800"},{"author_name":"Sylvan Clebsch","author_email":"sylvan.clebsch@gmail.com","committer_name":"Phillip Carter","comitter_email":"phillip.carter@outlook.com","message":"F# Azure storage docs (#1079)","commit_sha":"d1d0aa55980c280485fcf6c4b5e4507b034c65fc","commit_date":"2016-10-11 22:43:31 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/sylvanc","display_name":"Sylvan Clebsch","id":"2785007"},"contributors":[{"profile_url":"https://github.com/sylvanc","display_name":"Sylvan Clebsch"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/using-fsharp-on-azure/queue-storage.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/using-fsharp-on-azure/queue-storage.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/using-fsharp-on-azure/queue-storage.md","document_id":"b1d13774-3afb-000e-95b9-971b9a0c21a7","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/using-fsharp-on-azure/queue-storage","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Get started with Azure Queue storage using F#","_op_displayDate":"2016-9-20","_op_displayDate_source":"2016-09-20T00:00:00Z","_op_wordCount":1292,"_op_rawTitle":"<h1 id=\"get-started-with-azure-queue-storage-using-f\" sourcefile=\"docs/fsharp/using-fsharp-on-azure/queue-storage.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Get started with Azure Queue storage using F#</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/using-fsharp-on-azure/queue-storage","fileRelativePath":"articles/fsharp/using-fsharp-on-azure/queue-storage.html"},"themesRelativePathToOutputRoot":"_themes/"}