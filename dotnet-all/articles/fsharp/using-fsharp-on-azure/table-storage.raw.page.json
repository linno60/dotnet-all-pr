{"content":"<div><div class=\"content\">\n<p>Azure Table storage is a service that stores structured NoSQL data in the cloud. Table storage is a key/attribute store with a schemaless design. Because Table storage is schemaless, it&#39;s easy to adapt your data as the needs of your application evolve. Access to data is fast and cost-effective for all kinds of applications. Table storage is typically significantly lower in cost than traditional SQL for similar volumes of data.</p>\n<p>You can use Table storage to store flexible datasets, such as user data for web applications, address books, device information, and any other type of metadata that your service requires. You can store any number of entities in a table, and a storage account may contain any number of tables, up to the capacity limit of the storage account.</p>\n<h3 id=\"about-this-tutorial\">About this tutorial</h3>\n<p>This tutorial shows how to write F# code to do some common tasks using Azure Table storage, including creating and deleting a table and inserting, updating, deleting, and querying table data.</p>\n<p>For a conceptual overview of table storage, please see <a href=\"https://docs.microsoft.com/azure/storage/storage-dotnet-how-to-use-tables\" data-linktype=\"external\">the .NET guide for table storage</a></p>\n<h2 id=\"prerequisites\">Prerequisites</h2>\n<p>To use this guide, you must first <a href=\"https://docs.microsoft.com/azure/storage/storage-create-storage-account\" data-linktype=\"external\">create an Azure storage account</a>.\nYou&#39;ll also need your storage access key for this account.</p>\n<h2 id=\"create-an-f-script-and-start-f-interactive\">Create an F# Script and Start F# Interactive</h2>\n<p>The samples in this article can be used in either an F# application or an F# script. To create an F# script, create a file with the <code>.fsx</code> extension, for example <code>tables.fsx</code>, in your F# development environment.</p>\n<p>Next, use a <a href=\"package-management\" data-linktype=\"relative-path\">package manager</a> such as <a href=\"https://fsprojects.github.io/Paket/\" data-linktype=\"external\">Paket</a> or <a href=\"https://www.nuget.org/\" data-linktype=\"external\">NuGet</a> to install the <code>WindowsAzure.Storage</code> package and reference <code>WindowsAzure.Storage.dll</code> in your script using a <code>#r</code> directive.</p>\n<h3 id=\"add-namespace-declarations\">Add namespace declarations</h3>\n<p>Add the following <code>open</code> statements to the top of the <code>tables.fsx</code> file:</p>\n<pre><code class=\"lang-fsharp\" name=\"TableStorage\">open System\nopen System.IO\nopen Microsoft.Azure // Namespace for CloudConfigurationManager\nopen Microsoft.WindowsAzure.Storage // Namespace for CloudStorageAccount\nopen Microsoft.WindowsAzure.Storage.Table // Namespace for Table storage types\n</code></pre><h3 id=\"get-your-connection-string\">Get your connection string</h3>\n<p>You&#39;ll need an Azure Storage connection string for this tutorial. For more information about connection strings, see <a href=\"https://docs.microsoft.com/azure/storage/storage-configure-connection-string\" data-linktype=\"external\">Configure Storage Connection Strings</a>.</p>\n<p>For the tutorial, you&#39;ll enter your connection string in your script, like this:</p>\n<pre><code class=\"lang-fsharp\" name=\"TableStorage\">let storageConnString = &quot;...&quot; // fill this in from your storage account\n</code></pre><p>However, this is <strong>not recommended</strong> for real projects. Your storage account key is similar to the root password for your storage account. Always be careful to protect your storage account key. Avoid distributing it to other users, hard-coding it, or saving it in a plain-text file that is accessible to others. You can regenerate your key using the Azure Portal if you believe it may have been compromised.</p>\n<p>For real applications, the best way to maintain your storage connection string is in a configuration file. To fetch the connection string from a configuration file, you can do this:</p>\n<pre><code class=\"lang-fsharp\" name=\"TableStorage\">// Parse the connection string and return a reference to the storage account.\nlet storageConnString = \n    CloudConfigurationManager.GetSetting(&quot;StorageConnectionString&quot;)\n</code></pre><p>Using Azure Configuration Manager is optional. You can also use an API such as the .NET Framework&#39;s <code>ConfigurationManager</code> type.</p>\n<h3 id=\"parse-the-connection-string\">Parse the connection string</h3>\n<p>To parse the connection string, use:</p>\n<pre><code class=\"lang-fsharp\" name=\"TableStorage\">// Parse the connection string and return a reference to the storage account.\nlet storageAccount = CloudStorageAccount.Parse(storageConnString)\n</code></pre><p>This will return a <code>CloudStorageAccount</code>.</p>\n<h3 id=\"create-the-table-service-client\">Create the Table service client</h3>\n<p>The <code>CloudTableClient</code> class enables you to retrieve tables and entities stored in Table storage. Here&#39;s one way to create the service client:</p>\n<pre><code class=\"lang-fsharp\" name=\"TableStorage\">// Create the table client.\nlet tableClient = storageAccount.CreateCloudTableClient()\n</code></pre><p>Now you are ready to write code that reads data from and writes data to Table storage.</p>\n<h2 id=\"create-a-table\">Create a table</h2>\n<p>This example shows how to create a table if it does not already exist:</p>\n<pre><code class=\"lang-fsharp\" name=\"TableStorage\">// Retrieve a reference to the table.\nlet table = tableClient.GetTableReference(&quot;people&quot;)\n\n// Create the table if it doesn&#39;t exist.\ntable.CreateIfNotExists()\n</code></pre><h2 id=\"add-an-entity-to-a-table\">Add an entity to a table</h2>\n<p>An entity has to have a type that inherits from <code>TableEntity</code>. You can extend <code>TableEntity</code> in any way you like, but your type <em>must</em> have a parameter-less constructor. Only properties that have both <code>get</code> and <code>set</code> will be stored in your Azure Table.</p>\n<p>An entity&#39;s partition and row key uniquely identify the entity in the table. Entities with the same partition key can be queried faster than those with different partition keys, but using diverse partition keys allows for greater scalability of parallel operations.</p>\n<p>Here&#39;s an example of a <code>Customer</code> that uses the <code>lastName</code> as the partition key and the <code>firstName</code> as the row key.</p>\n<pre><code class=\"lang-fsharp\" name=\"TableStorage\">type Customer(firstName, lastName, email: string, phone: string) =\n    inherit TableEntity(partitionKey=lastName, rowKey=firstName)\n    new() = Customer(null, null, null, null)\n    member val Email = email with get, set\n    member val PhoneNumber = phone with get, set\n\nlet customer = \n    Customer(&quot;Walter&quot;, &quot;Harp&quot;, &quot;Walter@contoso.com&quot;, &quot;425-555-0101&quot;)\n</code></pre><p>Now we&#39;ll add our <code>Customer</code> to the table. To do so, you create a <code>TableOperation</code> that will execute on the table. In this case, you create an <code>Insert</code> operation.</p>\n<pre><code class=\"lang-fsharp\" name=\"TableStorage\">let insertOp = TableOperation.Insert(customer)\ntable.Execute(insertOp)\n</code></pre><h2 id=\"insert-a-batch-of-entities\">Insert a batch of entities</h2>\n<p>You can insert a batch of entities into a table using a single write operation. Batch operations allow you to combine operations into a single execution, but they have some restrictions:</p>\n<ul>\n<li>You can perform updates, deletes, and inserts in the same batch operation.</li>\n<li>A batch operation can include up to 100 entities.</li>\n<li>All entities in a batch operation must have the same partition key.</li>\n<li>While it is possible to perform a query in a batch operation, it must be the only operation in the batch.</li>\n</ul>\n<p>Here&#39;s some code that combines two inserts into a batch operation:</p>\n<pre><code class=\"lang-fsharp\" name=\"TableStorage\">let customer1 =\n    Customer(&quot;Jeff&quot;, &quot;Smith&quot;, &quot;Jeff@contoso.com&quot;, &quot;425-555-0102&quot;)\n\nlet customer2 =\n    Customer(&quot;Ben&quot;, &quot;Smith&quot;, &quot;Ben@contoso.com&quot;, &quot;425-555-0103&quot;)\n\nlet batchOp = TableBatchOperation()\nbatchOp.Insert(customer1)\nbatchOp.Insert(customer2)\ntable.ExecuteBatch(batchOp)\n</code></pre><h2 id=\"retrieve-all-entities-in-a-partition\">Retrieve all entities in a partition</h2>\n<p>To query a table for all entities in a partition, use a <code>TableQuery</code> object. Here, you filter for entities where &quot;Buster&quot; is the partition key.</p>\n<pre><code class=\"lang-fsharp\" name=\"TableStorage\">let query =\n    TableQuery&lt;Customer&gt;().Where(\n        TableQuery.GenerateFilterCondition(\n            &quot;PartitionKey&quot;, QueryComparisons.Equal, &quot;Smith&quot;))\n</code></pre><p>You now print the results:</p>\n<pre><code class=\"lang-fsharp\" name=\"TableStorage\">for customer in result do \n    printfn &quot;customer: %A %A&quot; customer.RowKey customer.PartitionKey\n</code></pre><h2 id=\"retrieve-a-range-of-entities-in-a-partition\">Retrieve a range of entities in a partition</h2>\n<p>If you don&#39;t want to query all the entities in a partition, you can specify a range by combining the partition key filter with a row key filter. Here, you use two filters to get all entities in the &quot;Buster&quot; partition where the row key (first name) starts with a letter earlier than &quot;M&quot; in the alphabet.</p>\n<pre><code class=\"lang-fsharp\" name=\"TableStorage\">let range =\n    TableQuery&lt;Customer&gt;().Where(\n        TableQuery.CombineFilters(\n            TableQuery.GenerateFilterCondition(\n                &quot;PartitionKey&quot;, QueryComparisons.Equal, &quot;Smith&quot;),\n            TableOperators.And,\n            TableQuery.GenerateFilterCondition(\n                &quot;RowKey&quot;, QueryComparisons.LessThan, &quot;M&quot;)))\n\nlet rangeResult = table.ExecuteQuery(query)\n</code></pre><p>You now print the results:</p>\n<pre><code class=\"lang-fsharp\" name=\"TableStorage\">for customer in rangeResult do \n    printfn &quot;customer: %A %A&quot; customer.RowKey customer.PartitionKey\n</code></pre><h2 id=\"retrieve-a-single-entity\">Retrieve a single entity</h2>\n<p>You can write a query to retrieve a single, specific entity. Here, you use a <code>TableOperation</code> to specify the customer &quot;Larry Buster&quot;. Instead of a collection, you get back a <code>Customer</code>. Specifying both the partition key and the row key in a query is the fastest way to retrieve a single entity from the Table service.</p>\n<pre><code class=\"lang-fsharp\" name=\"TableStorage\">let retrieveOp = TableOperation.Retrieve&lt;Customer&gt;(&quot;Smith&quot;, &quot;Ben&quot;)\n\nlet retrieveResult = table.Execute(retrieveOp)\n</code></pre><p>You now print the results:</p>\n<pre><code class=\"lang-fsharp\" name=\"TableStorage\">// Show the result\nlet retrieveCustomer = retrieveResult.Result :?&gt; Customer\nprintfn &quot;customer: %A %A&quot; retrieveCustomer.RowKey retrieveCustomer.PartitionKey\n</code></pre><h2 id=\"replace-an-entity\">Replace an entity</h2>\n<p>To update an entity, retrieve it from the Table service, modify the entity object, and then save the changes back to the Table service using a <code>Replace</code> operation. This causes the entity to be fully replaced on the server, unless the entity on the server has changed since it was retrieved, in which case the operation will fail. This failure is to prevent your application from inadvertently overwriting changes from other sources.</p>\n<pre><code class=\"lang-fsharp\" name=\"TableStorage\">try\n    let customer = retrieveResult.Result :?&gt; Customer\n    customer.PhoneNumber &lt;- &quot;425-555-0103&quot;\n    let replaceOp = TableOperation.Replace(customer)\n    table.Execute(replaceOp) |&gt; ignore\n    Console.WriteLine(&quot;Update succeeeded&quot;)\nwith e -&gt;\n    Console.WriteLine(&quot;Update failed&quot;)\n</code></pre><h2 id=\"insert-or-replace-an-entity\">Insert-or-replace an entity</h2>\n<p>Sometimes, you don&#39;t know if the entity exists in the table or not. And if it does, the current values stored in it are no longer needed. You can use <code>InsertOrReplace</code> to create the entity, or replace it if it exists, regardless of its state.</p>\n<pre><code class=\"lang-fsharp\" name=\"TableStorage\">try\n    customer.PhoneNumber &lt;- &quot;425-555-0104&quot;\n    let replaceOp = TableOperation.InsertOrReplace(customer)\n    table.Execute(replaceOp) |&gt; ignore\n    Console.WriteLine(&quot;Update succeeeded&quot;)\nwith e -&gt;\n    Console.WriteLine(&quot;Update failed&quot;)\n</code></pre><h2 id=\"query-a-subset-of-entity-properties\">Query a subset of entity properties</h2>\n<p>A table query can retrieve just a few properties from an entity instead of all of them. This technique, called projection, can improve query performance, especially for large entities. Here, you return only email addresses using <code>DynamicTableEntity</code> and <code>EntityResolver</code>. Note that projection is not supported on the local storage emulator, so this code runs only when you&#39;re using an account on the Table service.</p>\n<pre><code class=\"lang-fsharp\" name=\"TableStorage\">// Define the query, and select only the Email property.\nlet projectionQ = TableQuery&lt;DynamicTableEntity&gt;().Select [|&quot;Email&quot;|]\n\n// Define an entity resolver to work with the entity after retrieval.\nlet resolver = EntityResolver&lt;string&gt;(fun pk rk ts props etag -&gt;\n    if props.ContainsKey(&quot;Email&quot;) then\n        props.[&quot;Email&quot;].StringValue\n    else\n        null\n    )\n\nlet resolvedResults = table.ExecuteQuery(projectionQ, resolver, null, null)\n</code></pre><h2 id=\"retrieve-entities-in-pages-asynchronously\">Retrieve entities in pages asynchronously</h2>\n<p>If you are reading a large number of entities, and you want to process them as they are retrieved rather than waiting for them all to return, you can use a segmented query. Here, you return results in pages by using an async workflow so that execution is not blocked while you&#39;re waiting for a large set of results to return.</p>\n<pre><code class=\"lang-fsharp\" name=\"TableStorage\">let tableQ = TableQuery&lt;Customer&gt;()\n\nlet asyncQuery = \n    let rec loop (cont: TableContinuationToken) = async {\n        let! ct = Async.CancellationToken\n        let! result = table.ExecuteQuerySegmentedAsync(tableQ, cont, ct) |&gt; Async.AwaitTask\n\n        // ...process the result here...\n        \n        // Continue to the next segment\n        match result.ContinuationToken with\n        | null -&gt; ()\n        | cont -&gt; return! loop cont \n    }\n    loop null\n</code></pre><p>You now execute this computation synchronously:</p>\n<pre><code class=\"lang-fsharp\" name=\"TableStorage\">let asyncResults = asyncQuery |&gt; Async.RunSynchronously\n</code></pre><h2 id=\"delete-an-entity\">Delete an entity</h2>\n<p>You can delete an entity after you have retrieved it. As with updating an entity, this will fail if the entity has changed since you retrieved it.</p>\n<pre><code class=\"lang-fsharp\" name=\"TableStorage\">let deleteOp = TableOperation.Delete(customer)\ntable.Execute(deleteOp)\n</code></pre><h2 id=\"delete-a-table\">Delete a table</h2>\n<p>You can delete a table from a storage account. A table that has been deleted will be unavailable to be re-created for a period of time following the deletion.</p>\n<pre><code class=\"lang-fsharp\" name=\"TableStorage\">table.DeleteIfExists()\n</code></pre><h2 id=\"next-steps\">Next steps</h2>\n<p>Now that you&#39;ve learned the basics of Table storage, follow these links\nto learn about more complex storage tasks:</p>\n<ul>\n<li><a href=\"http://go.microsoft.com/fwlink/?LinkID=390731&amp;clcid=0x409\" data-linktype=\"external\">Storage Client Library for .NET reference</a></li>\n<li><a href=\"http://fsprojects.github.io/AzureStorageTypeProvider/\" data-linktype=\"external\">Azure Storage Type Provider</a></li>\n<li><a href=\"http://blogs.msdn.com/b/windowsazurestorage/\" data-linktype=\"external\">Azure Storage Team Blog</a></li>\n<li><a href=\"http://msdn.microsoft.com/library/azure/ee758697.aspx\" data-linktype=\"external\">Configuring Connection Strings</a></li>\n<li><a href=\"https://azure.microsoft.com/documentation/samples/storage-table-dotnet-getting-started/\" data-linktype=\"external\">Getting Started with Azure Table Storage in .NET</a></li>\n</ul>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"sylvanc\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"9e5d6cea-a98c-461e-a5cc-75f1d154eafd\">\r\n<meta name=\"description\" content=\"Store structured data in the cloud using Azure Table storage, a NoSQL data store.\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming, .NET, .NET Core, Azure\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"09/20/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/using-fsharp-on-azure/table-storage.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/using-fsharp-on-azure/table-storage.md\">\r\n<meta name=\"document_id\" content=\"e52309bc-4a4e-f625-3a13-7de8c904022d\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"sylvanc","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","title":"Get started with Azure Table storage using F# | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"9e5d6cea-a98c-461e-a5cc-75f1d154eafd","description":"Store structured data in the cloud using Azure Table storage, a NoSQL data store.","keywords":"visual f#, f#, functional programming, .NET, .NET Core, Azure","ms.topic":"article","ms.date":"09/20/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Absolute urls and other fixes (#1281)","commit_sha":"f7dffe4885b331cec8d37f3cc5c9163f69c3b4c9","commit_date":"2016-11-22 12:57:26 -0800"},{"author_name":"Sylvan Clebsch","author_email":"sylvan.clebsch@gmail.com","committer_name":"Phillip Carter","comitter_email":"phillip.carter@outlook.com","message":"F# Azure storage docs (#1079)","commit_sha":"d1d0aa55980c280485fcf6c4b5e4507b034c65fc","commit_date":"2016-10-11 22:43:31 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/sylvanc","display_name":"Sylvan Clebsch","id":"2785007"},"contributors":[{"profile_url":"https://github.com/sylvanc","display_name":"Sylvan Clebsch"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/using-fsharp-on-azure/table-storage.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/using-fsharp-on-azure/table-storage.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/using-fsharp-on-azure/table-storage.md","document_id":"e52309bc-4a4e-f625-3a13-7de8c904022d","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/using-fsharp-on-azure/table-storage","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Get started with Azure Table storage using F#","_op_displayDate":"2016-9-20","_op_displayDate_source":"2016-09-20T00:00:00Z","_op_wordCount":1697,"_op_rawTitle":"<h1 id=\"get-started-with-azure-table-storage-using-f\" sourcefile=\"docs/fsharp/using-fsharp-on-azure/table-storage.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Get started with Azure Table storage using F#</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/using-fsharp-on-azure/table-storage","fileRelativePath":"articles/fsharp/using-fsharp-on-azure/table-storage.html"},"themesRelativePathToOutputRoot":"_themes/"}