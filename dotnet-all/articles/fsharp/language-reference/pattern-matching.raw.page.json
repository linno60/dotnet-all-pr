{"content":"<div><div class=\"content\">\n<p>Patterns are rules for transforming input data. They are used throughout the F# language to compare data with a logical structure or structures, decompose data into constituent parts, or extract information from data in various ways.</p>\n<h2 id=\"remarks\">Remarks</h2>\n<p>Patterns are used in many language constructs, such as the <code>match</code> expression. They are used when you are processing arguments for functions in <code>let</code> bindings, lambda expressions, and in the exception handlers associated with the <code>try...with</code> expression. For more information, see <a href=\"match-expressions\" data-linktype=\"relative-path\">Match Expressions</a>, <a href=\"functions/let-bindings\" data-linktype=\"relative-path\">let Bindings</a>, <a href=\"functions/lambda-expressions-the-fun-keyword\" data-linktype=\"relative-path\">Lambda Expressions: The <code>fun</code> Keyword</a>, and <a href=\"exception-handling/the-try-with-expression\" data-linktype=\"relative-path\">Exceptions: The <code>try...with</code> Expression</a>.</p>\n<p>For example, in the <code>match</code> expression, the <em>pattern</em> is what follows the pipe symbol.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">match expression with\n| pattern [ when condition ] -&gt; result-expression\n...\n</code></pre><p>Each pattern acts as a rule for transforming input in some way. In the <code>match</code> expression, each pattern is examined in turn to see if the input data is compatible with the pattern. If a match is found, the result expression is executed. If a match is not found, the next pattern rule is tested. The optional when <em>condition</em> part is explained in <a href=\"match-expressions\" data-linktype=\"relative-path\">Match Expressions</a>.</p>\n<p>Supported patterns are shown in the following table. At run time, the input is tested against each of the following patterns in the order listed in the table, and patterns are applied recursively, from first to last as they appear in your code, and from left to right for the patterns on each line.</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Description</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Constant pattern</td>\n<td>Any numeric, character, or string literal, an enumeration constant, or a defined literal identifier</td>\n<td><code>1.0</code>, <code>&quot;test&quot;</code>, <code>30</code>, <code>Color.Red</code></td>\n</tr>\n<tr>\n<td>Identifier pattern</td>\n<td>A case value of a discriminated union, an exception label, or an active pattern case</td>\n<td><code>Some(x)</code><br><br><code>Failure(msg)</code></td>\n</tr>\n<tr>\n<td>Variable pattern</td>\n<td><em>identifier</em></td>\n<td><code>a</code></td>\n</tr>\n<tr>\n<td><code>as</code> pattern</td>\n<td><em>pattern</em> as <em>identifier</em></td>\n<td><code>(a, b) as tuple1</code></td>\n</tr>\n<tr>\n<td>OR pattern</td>\n<td><em>pattern1</em> &#124; <em>pattern2</em></td>\n<td><code>([h] &#124; [h; _])</code></td>\n</tr>\n<tr>\n<td>AND pattern</td>\n<td><em>pattern1</em> &amp; <em>pattern2</em></td>\n<td><code>(a, b) &amp; (_, &quot;test&quot;)</code></td>\n</tr>\n<tr>\n<td>Cons pattern</td>\n<td><em>identifier</em> :: <em>list-identifier</em></td>\n<td><code>h :: t</code></td>\n</tr>\n<tr>\n<td>List pattern</td>\n<td>[ <em>pattern_1</em>; ... ; <em>pattern_n</em> ]</td>\n<td><code>[ a; b; c ]</code></td>\n</tr>\n<tr>\n<td>Array pattern</td>\n<td>[&#124; <em>pattern_1</em>; ..; <em>pattern_n</em> &#124;]</td>\n<td><code>[&#124; a; b; c &#124;]</code></td>\n</tr>\n<tr>\n<td>Parenthesized pattern</td>\n<td>( <em>pattern</em> )</td>\n<td><code>( a )</code></td>\n</tr>\n<tr>\n<td>Tuple pattern</td>\n<td>( <em>pattern_1</em>, ... , <em>pattern_n</em> )</td>\n<td><code>( a, b )</code></td>\n</tr>\n<tr>\n<td>Record pattern</td>\n<td>{ <em>identifier1</em> = <em>pattern_1</em>; ... ; <em>identifier_n</em> = <em>pattern_n</em> }</td>\n<td><code>{ Name = name; }</code></td>\n</tr>\n<tr>\n<td>Wildcard pattern</td>\n<td>_</td>\n<td><code>_</code></td>\n</tr>\n<tr>\n<td>Pattern together with type annotation</td>\n<td><em>pattern</em> : <em>type</em></td>\n<td><code>a : int</code></td>\n</tr>\n<tr>\n<td>Type test pattern</td>\n<td>:? <em>type</em> [ as <em>identifier</em> ]</td>\n<td><code>:? System.DateTime as dt</code></td>\n</tr>\n<tr>\n<td>Null pattern</td>\n<td>null</td>\n<td><code>null</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"constant-patterns\">Constant Patterns</h2>\n<p>Constant patterns are numeric, character, and string literals, enumeration constants (with the enumeration type name included). A <code>match</code> expression that has only constant patterns can be compared to a case statement in other languages. The input is compared with the literal value and the pattern matches if the values are equal. The type of the literal must be compatible with the type of the input.</p>\n<p>The following example demonstrates the use of literal patterns, and also uses a variable pattern and an OR pattern.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">[&lt;Literal&gt;]\nlet Three = 3\n\nlet filter123 x =\n    match x with\n    // The following line contains literal patterns combined with an OR pattern.\n    | 1 | 2 | Three -&gt; printfn &quot;Found 1, 2, or 3!&quot;\n    // The following line contains a variable pattern.\n    | var1 -&gt; printfn &quot;%d&quot; var1\n\nfor x in 1..10 do filter123 x\n</code></pre><p>Another example of a literal pattern is a pattern based on enumeration constants. You must specify the enumeration type name when you use enumeration constants.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type Color =\n    | Red = 0\n    | Green = 1\n    | Blue = 2\n\nlet printColorName (color:Color) =\n    match color with\n    | Color.Red -&gt; printfn &quot;Red&quot;\n    | Color.Green -&gt; printfn &quot;Green&quot;\n    | Color.Blue -&gt; printfn &quot;Blue&quot;\n    | _ -&gt; ()\n\nprintColorName Color.Red\nprintColorName Color.Green\nprintColorName Color.Blue\n</code></pre><h2 id=\"identifier-patterns\">Identifier Patterns</h2>\n<p>If the pattern is a string of characters that forms a valid identifier, the form of the identifier determines how the pattern is matched. If the identifier is longer than a single character and starts with an uppercase character, the compiler tries to make a match to the identifier pattern. The identifier for this pattern could be a value marked with the Literal attribute, a discriminated union case, an exception identifier, or an active pattern case. If no matching identifier is found, the match fails and the next pattern rule, the variable pattern, is compared to the input.</p>\n<p>Discriminated union patterns can be simple named cases or they can have a value, or a tuple containing multiple values. If there is a value, you must specify an identifier for the value. In the case of a tuple, you must supply a tuple pattern with an identifier for each element of the tuple or an identifier with a field name for one or more named union fields. See the code examples in this section for examples.</p>\n<p>The <code>option</code> type is a discriminated union that has two cases, <code>Some</code> and <code>None</code>. One case (<code>Some</code>) has a value, but the other (<code>None</code>) is just a named case. Therefore, <code>Some</code> needs to have a variable for the value associated with the <code>Some</code> case, but <code>None</code> must appear by itself. In the following code, the variable <code>var1</code> is given the value that is obtained by matching to the <code>Some</code> case.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let printOption (data : int option) =\n    match data with\n    | Some var1  -&gt; printfn &quot;%d&quot; var1\n    | None -&gt; ()\n</code></pre><p>In the following example, the <code>PersonName</code> discriminated union contains a mixture of strings and characters that represent possible forms of names. The cases of the discriminated union are <code>FirstOnly</code>, <code>LastOnly</code>, and <code>FirstLast</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type PersonName =\n    | FirstOnly of string\n    | LastOnly of string\n    | FirstLast of string * string\n\nlet constructQuery personName =\n    match personName with\n    | FirstOnly(firstName) -&gt; printf &quot;May I call you %s?&quot; firstName\n    | LastOnly(lastName) -&gt; printf &quot;Are you Mr. or Ms. %s?&quot; lastName\n    | FirstLast(firstName, lastName) -&gt; printf &quot;Are you %s %s?&quot; firstName lastName\n</code></pre><p>For discriminated unions that have named fields, you use the equals sign (=) to extract the value of a named field. For example, consider a discriminated union with a declaration like the following.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">type Shape =\n    | Rectangle of height : float * width : float\n    | Circle of radius : float\n</code></pre><p>You can use the named fields in a pattern matching expression as follows.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let matchShape shape =\n    match shape with\n    | Rectangle(height = h) -&gt; printfn &quot;Rectangle with length %f&quot; h\n    | Circle(r) -&gt; printfn &quot;Circle with radius %f&quot; r\n</code></pre><p>The use of the named field is optional, so in the previous example, both <code>Circle(r)</code> and <code>Circle(radius = r)</code> have the same effect.</p>\n<p>When you specify multiple fields, use the semicolon (;) as a separator.</p>\n<pre class=\"loading\"><code>match shape with\n| Rectangle(height = h; width = w) -&gt; printfn &quot;Rectangle with height %f and width %f&quot; h w\n| _ -&gt; ()\n</code></pre><p>Active patterns enable you to define more complex custom pattern matching. For more information about active patterns, see <a href=\"active-patterns\" data-linktype=\"relative-path\">Active Patterns</a>.</p>\n<p>The case in which the identifier is an exception is used in pattern matching in the context of exception handlers. For information about pattern matching in exception handling, see <a href=\"exception-handling/the-try-with-expression\" data-linktype=\"relative-path\">Exceptions: The <code>try...with</code> Expression</a>.</p>\n<h2 id=\"variable-patterns\">Variable Patterns</h2>\n<p>The variable pattern assigns the value being matched to a variable name, which is then available for use in the execution expression to the right of the <code>-&gt;</code> symbol. A variable pattern alone matches any input, but variable patterns often appear within other patterns, therefore enabling more complex structures such as tuples and arrays to be decomposed into variables.</p>\n<p>The following example demonstrates a variable pattern within a tuple pattern.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let function1 x =\n    match x with\n    | (var1, var2) when var1 &gt; var2 -&gt; printfn &quot;%d is greater than %d&quot; var1 var2\n    | (var1, var2) when var1 &lt; var2 -&gt; printfn &quot;%d is less than %d&quot; var1 var2\n    | (var1, var2) -&gt; printfn &quot;%d equals %d&quot; var1 var2\n\nfunction1 (1,2)\nfunction1 (2, 1)\nfunction1 (0, 0)\n</code></pre><h2 id=\"as-pattern\">as Pattern</h2>\n<p>The <code>as</code> pattern is a pattern that has an <code>as</code> clause appended to it. The <code>as</code> clause binds the matched value to a name that can be used in the execution expression of a <code>match</code> expression, or, in the case where this pattern is used in a <code>let</code> binding, the name is added as a binding to the local scope.</p>\n<p>The following example uses an <code>as</code> pattern.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let (var1, var2) as tuple1 = (1, 2)\nprintfn &quot;%d %d %A&quot; var1 var2 tuple1\n</code></pre><h2 id=\"or-pattern\">OR Pattern</h2>\n<p>The OR pattern is used when input data can match multiple patterns, and you want to execute the same code as a result. The types of both sides of the OR pattern must be compatible.</p>\n<p>The following example demonstrates the OR pattern.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let detectZeroOR point =\n    match point with\n    | (0, 0) | (0, _) | (_, 0) -&gt; printfn &quot;Zero found.&quot;\n    | _ -&gt; printfn &quot;Both nonzero.&quot;\ndetectZeroOR (0, 0)\ndetectZeroOR (1, 0)\ndetectZeroOR (0, 10)\ndetectZeroOR (10, 15)\n</code></pre><h2 id=\"and-pattern\">AND Pattern</h2>\n<p>The AND pattern requires that the input match two patterns. The types of both sides of the AND pattern must be compatible.</p>\n<p>The following example is like <code>detectZeroTuple</code> shown in the <a href=\"https://msdn.microsoft.com/library/#tuple\" data-linktype=\"external\">Tuple Pattern</a> section later in this topic, but here both <code>var1</code> and <code>var2</code> are obtained as values by using the AND pattern.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let detectZeroAND point =\n    match point with\n    | (0, 0) -&gt; printfn &quot;Both values zero.&quot;\n    | (var1, var2) &amp; (0, _) -&gt; printfn &quot;First value is 0 in (%d, %d)&quot; var1 var2\n    | (var1, var2)  &amp; (_, 0) -&gt; printfn &quot;Second value is 0 in (%d, %d)&quot; var1 var2\n    | _ -&gt; printfn &quot;Both nonzero.&quot;\ndetectZeroAND (0, 0)\ndetectZeroAND (1, 0)\ndetectZeroAND (0, 10)\ndetectZeroAND (10, 15)\n</code></pre><h2 id=\"cons-pattern\">Cons Pattern</h2>\n<p>The cons pattern is used to decompose a list into the first element, the <em>head</em>, and a list that contains the remaining elements, the <em>tail</em>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let list1 = [ 1; 2; 3; 4 ]\n\n// This example uses a cons pattern and a list pattern.\nlet rec printList l =\n    match l with\n    | head :: tail -&gt; printf &quot;%d &quot; head; printList tail\n    | [] -&gt; printfn &quot;&quot;\n\nprintList list1\n</code></pre><h2 id=\"list-pattern\">List Pattern</h2>\n<p>The list pattern enables lists to be decomposed into a number of elements. The list pattern itself can match only lists of a specific number of elements.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// This example uses a list pattern.\nlet listLength list =\n    match list with\n    | [] -&gt; 0\n    | [ _ ] -&gt; 1\n    | [ _; _ ] -&gt; 2\n    | [ _; _; _ ] -&gt; 3\n    | _ -&gt; List.length list\n\nprintfn &quot;%d&quot; (listLength [ 1 ])\nprintfn &quot;%d&quot; (listLength [ 1; 1 ])\nprintfn &quot;%d&quot; (listLength [ 1; 1; 1; ])\nprintfn &quot;%d&quot; (listLength [ ] )\n</code></pre><h2 id=\"array-pattern\">Array Pattern</h2>\n<p>The array pattern resembles the list pattern and can be used to decompose arrays of a specific length.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// This example uses array patterns.\nlet vectorLength vec =\n    match vec with\n    | [| var1 |] -&gt; var1\n    | [| var1; var2 |] -&gt; sqrt (var1*var1 + var2*var2)\n    | [| var1; var2; var3 |] -&gt; sqrt (var1*var1 + var2*var2 + var3*var3)\n    | _ -&gt; failwith &quot;vectorLength called with an unsupported array size of %d.&quot; (vec.Length)\n\nprintfn &quot;%f&quot; (vectorLength [| 1. |])\nprintfn &quot;%f&quot; (vectorLength [| 1.; 1. |])\nprintfn &quot;%f&quot; (vectorLength [| 1.; 1.; 1.; |])\nprintfn &quot;%f&quot; (vectorLength [| |] )\n</code></pre><h2 id=\"parenthesized-pattern\">Parenthesized Pattern</h2>\n<p>Parentheses can be grouped around patterns to achieve the desired associativity. In the following example, parentheses are used to control associativity between an AND pattern and a cons pattern.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let countValues list value =\n    let rec checkList list acc =\n       match list with\n       | (elem1 &amp; head) :: tail when elem1 = value -&gt; checkList tail (acc + 1)\n       | head :: tail -&gt; checkList tail acc\n       | [] -&gt; acc\n    checkList list 0\n\nlet result = countValues [ for x in -10..10 -&gt; x*x - 4 ] 0\nprintfn &quot;%d&quot; result\n</code></pre><h2 id=\"tuple-pattern\">Tuple Pattern</h2>\n<p>The tuple pattern matches input in tuple form and enables the tuple to be decomposed into its constituent elements by using pattern matching variables for each position in the tuple.</p>\n<p>The following example demonstrates the tuple pattern and also uses literal patterns, variable patterns, and the wildcard pattern.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let detectZeroTuple point =\n    match point with\n    | (0, 0) -&gt; printfn &quot;Both values zero.&quot;\n    | (0, var2) -&gt; printfn &quot;First value is 0 in (0, %d)&quot; var2\n    | (var1, 0) -&gt; printfn &quot;Second value is 0 in (%d, 0)&quot; var1\n    | _ -&gt; printfn &quot;Both nonzero.&quot;\ndetectZeroTuple (0, 0)\ndetectZeroTuple (1, 0)\ndetectZeroTuple (0, 10)\ndetectZeroTuple (10, 15)\n</code></pre><h2 id=\"record-pattern\">Record Pattern</h2>\n<p>The record pattern is used to decompose records to extract the values of fields. The pattern does not have to reference all fields of the record; any omitted fields just do not participate in matching and are not extracted.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// This example uses a record pattern.\n\ntype MyRecord = { Name: string; ID: int }\n\nlet IsMatchByName record1 (name: string) =\n    match record1 with\n    | { MyRecord.Name = nameFound; MyRecord.ID = _; } when nameFound = name -&gt; true\n    | _ -&gt; false\n\nlet recordX = { Name = &quot;Parker&quot;; ID = 10 }\nlet isMatched1 = IsMatchByName recordX &quot;Parker&quot;\nlet isMatched2 = IsMatchByName recordX &quot;Hartono&quot;\n</code></pre><h2 id=\"wildcard-pattern\">Wildcard Pattern</h2>\n<p>The wildcard pattern is represented by the underscore (<code>_</code>) character and matches any input, just like the variable pattern, except that the input is discarded instead of assigned to a variable. The wildcard pattern is often used within other patterns as a placeholder for values that are not needed in the expression to the right of the <code>-&gt;</code> symbol. The wildcard pattern is also frequently used at the end of a list of patterns to match any unmatched input. The wildcard pattern is demonstrated in many code examples in this topic. See the preceding code for one example.</p>\n<h2 id=\"patterns-that-have-type-annotations\">Patterns That Have Type Annotations</h2>\n<p>Patterns can have type annotations. These behave like other type annotations and guide inference like other type annotations. Parentheses are required around type annotations in patterns. The following code shows a pattern that has a type annotation.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let detect1 x =\n    match x with\n    | 1 -&gt; printfn &quot;Found a 1!&quot;\n    | (var1 : int) -&gt; printfn &quot;%d&quot; var1\ndetect1 0\ndetect1 1\n</code></pre><h2 id=\"type-test-pattern\">Type Test Pattern</h2>\n<p>The type test pattern is used to match the input against a type. If the input type is a match to (or a derived type of) the type specified in the pattern, the match succeeds.</p>\n<p>The following example demonstrates the type test pattern.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">open System.Windows.Forms\n\nlet RegisterControl(control:Control) =\n    match control with\n    | :? Button as button -&gt; button.Text &lt;- &quot;Registered.&quot;\n    | :? CheckBox as checkbox -&gt; checkbox.Text &lt;- &quot;Registered.&quot;\n    | _ -&gt; ()\n</code></pre><h2 id=\"null-pattern\">Null Pattern</h2>\n<p>The null pattern matches the null value that can appear when you are working with types that allow a null value. Null patterns are frequently used when interoperating with .NET Framework code. For example, the return value of a .NET API might be the input to a <code>match</code> expression. You can control program flow based on whether the return value is null, and also on other characteristics of the returned value. You can use the null pattern to prevent null values from propagating to the rest of your program.</p>\n<p>The following example uses the null pattern and the variable pattern.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let ReadFromFile (reader : System.IO.StreamReader) =\n    match reader.ReadLine() with\n    | null -&gt; printfn &quot;\\n&quot;; false\n    | line -&gt; printfn &quot;%s&quot; line; true\n\nlet fs = System.IO.File.Open(&quot;..\\..\\Program.fs&quot;, System.IO.FileMode.Open)\nlet sr = new System.IO.StreamReader(fs)\nwhile ReadFromFile(sr) = true do ()\nsr.Close()\n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p><a href=\"match-expressions\" data-linktype=\"relative-path\">Match Expressions</a></p>\n<p><a href=\"active-patterns\" data-linktype=\"relative-path\">Active Patterns</a></p>\n<p><a href=\"index\" data-linktype=\"relative-path\">F# Language Reference</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"5562ee98-e2f1-4dcd-8e2f-16ae27baaade\">\r\n<meta name=\"description\" content=\"Pattern Matching (F#)\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming\">\r\n<meta name=\"ms.topic\" content=\"language-reference\">\r\n<meta name=\"ms.date\" content=\"05/16/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/pattern-matching.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/pattern-matching.md\">\r\n<meta name=\"document_id\" content=\"c7d74372-b127-2d09-c09d-d70771248c4e\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Pattern Matching (F#) | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"5562ee98-e2f1-4dcd-8e2f-16ae27baaade","description":"Pattern Matching (F#)","keywords":"visual f#, f#, functional programming","ms.topic":"language-reference","ms.date":"05/16/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Marcio Rinaldi","author_email":"me@marciorinaldi.com","committer_name":"Phillip Carter","comitter_email":"phillip.carter@outlook.com","message":"Fix formatting issues (#978)","commit_sha":"7d0327581c1fa471b46cdceccf548d085b00d4ea","commit_date":"2016-08-30 07:53:25 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Move snippets to snippets folder, now with some F# (#904)","commit_sha":"37fe2b89d590509e8eb14342da988f15862a9e2b","commit_date":"2016-08-13 16:40:56 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize F# snippets (#903)","commit_sha":"6ea1cf8f3779532a9ed8fbdac32592fbb809443c","commit_date":"2016-08-13 15:14:41 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"F# Docs: Update intro, move files, rename language reference for better URLS (#902)","commit_sha":"70a10b9c3e21291c96d927d13f8710d9e0738d4c","commit_date":"2016-08-13 11:22:39 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/mrinaldi","display_name":"Marcio Rinaldi","id":"1226112"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/pattern-matching.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/pattern-matching.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/language-reference/pattern-matching.md","document_id":"c7d74372-b127-2d09-c09d-d70771248c4e","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/pattern-matching","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Pattern Matching (F#)","_op_displayDate":"2016-5-16","_op_displayDate_source":"2016-05-16T00:00:00Z","_op_wordCount":2518,"_op_rawTitle":"<h1 id=\"pattern-matching\" sourcefile=\"docs/fsharp/language-reference/pattern-matching.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Pattern Matching</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/pattern-matching","fileRelativePath":"articles/fsharp/language-reference/pattern-matching.html"},"themesRelativePathToOutputRoot":"_themes/"}