{"content":"<div><div class=\"content\">\n<p>Inheritance is used to model the &quot;is-a&quot; relationship, or subtyping, in object-oriented programming.</p>\n<h2 id=\"specifying-inheritance-relationships\">Specifying Inheritance Relationships</h2>\n<p>You specify inheritance relationships by using the <code>inherit</code> keyword in a class declaration. The basic syntactical form is shown in the following example.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">type MyDerived(...) =\n    inherit MyBase(...)\n</code></pre><p>A class can have at most one direct base class. If you do not specify a base class by using the <code>inherit</code> keyword, the class implicitly inherits from <code>System.Object</code>.</p>\n<h2 id=\"inherited-members\">Inherited Members</h2>\n<p>If a class inherits from another class, the methods and members of the base class are available to users of the derived class as if they were direct members of the derived class.</p>\n<p>Any let bindings and constructor parameters are private to a class and, therefore, cannot be accessed from derived classes.</p>\n<p>The keyword <code>base</code> is available in derived classes and refers to the base class instance. It is used like the self-identifier.</p>\n<h2 id=\"virtual-methods-and-overrides\">Virtual Methods and Overrides</h2>\n<p>Virtual methods (and properties) work somewhat differently in F# as compared to other .NET languages. To declare a new virtual member, you use the <code>abstract</code> keyword. You do this regardless of whether you provide a default implementation for that method. Thus a complete definition of a virtual method in a base class follows this pattern:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">abstract member [method-name] : [type]\n\ndefault [self-identifier].[method-name] [argument-list] = [method-body]\n</code></pre><p>And in a derived class, an override of this virtual method follows this pattern:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">override [self-identifier].[method-name] [argument-list] = [method-body]\n</code></pre><p>If you omit the default implementation in the base class, the base class becomes an abstract class.</p>\n<p>The following code example illustrates the declaration of a new virtual method <code>function1</code> in a base class and how to override it in a derived class.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type MyClassBase1() =\n   let mutable z = 0\n   abstract member function1 : int -&gt; int\n   default u.function1(a : int) = z &lt;- z + a; z\n\ntype MyClassDerived1() =\n   inherit MyClassBase1()\n   override u.function1(a: int) = a + 1\n</code></pre><h2 id=\"constructors-and-inheritance\">Constructors and Inheritance</h2>\n<p>The constructor for the base class must be called in the derived class. The arguments for the base class constructor appear in the argument list in the <code>inherit</code> clause. The values that are used must be determined from the arguments supplied to the derived class constructor.</p>\n<p>The following code shows a base class and a derived class, where the derived class calls the base class constructor in the inherit clause:</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type MyClassBase2(x: int) =\n   let mutable z = x * x\n   do for i in 1..z do printf &quot;%d &quot; i\n\n\ntype MyClassDerived2(y: int) =\n   inherit MyClassBase2(y * 2)\n   do for i in 1..y do printf &quot;%d &quot; i\n</code></pre><p>In the case of multiple constructors, the following code can be used. The first line of the derived class constructors is the <code>inherit</code> clause, and the fields appear as explicit fields that are declared with the <code>val</code> keyword. For more information, see <a href=\"members/explicit-fields-the-val-keyword\" data-linktype=\"relative-path\">Explicit Fields: The <code>val</code> Keyword</a>.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">type BaseClass =\n    val string1 : string\n    new (str) = { string1 = str }\n    new () = { string1 = &quot;&quot; }\n\ntype DerivedClass =\n    inherit BaseClass\n\n    val string2 : string\n    new (str1, str2) = { inherit BaseClass(str1); string2 = str2 }\n    new (str2) = { inherit BaseClass(); string2 = str2 }\n\nlet obj1 = DerivedClass(&quot;A&quot;, &quot;B&quot;)\nlet obj2 = DerivedClass(&quot;A&quot;)\n</code></pre><h2 id=\"alternatives-to-inheritance\">Alternatives to Inheritance</h2>\n<p>In cases where a minor modification of a type is required, consider using an object expression as an alternative to inheritance. The following example illustrates the use of an object expression as an alternative to creating a new derived type:</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">open System\n\nlet object1 = { new Object() with\n      override this.ToString() = &quot;This overrides object.ToString()&quot;\n      }\n\nprintfn &quot;%s&quot; (object1.ToString())\n</code></pre><p>For more information about object expressions, see <a href=\"object-expressions\" data-linktype=\"relative-path\">Object Expressions</a>.</p>\n<p>When you are creating object hierarchies, consider using a discriminated union instead of inheritance. Discriminated unions can also model varied behavior of different objects that share a common overall type. A single discriminated union can often eliminate the need for a number of derived classes that are minor variations of each other. For information about discriminated unions, see <a href=\"discriminated-unions\" data-linktype=\"relative-path\">Discriminated Unions</a>.</p>\n<h2 id=\"see-also\">See Also</h2>\n<p><a href=\"object-expressions\" data-linktype=\"relative-path\">Object Expressions</a></p>\n<p><a href=\"index\" data-linktype=\"relative-path\">F# Language Reference</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc.json\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"b38ab2f6-7ba7-4839-8eff-e6bd6cfd2b2f\">\r\n<meta name=\"description\" content=\"Inheritance (F#)\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming\">\r\n<meta name=\"ms.topic\" content=\"language-reference\">\r\n<meta name=\"ms.date\" content=\"05/16/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-21 01:42 AM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/inheritance.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/fsharp/language-reference/inheritance.md\">\r\n<meta name=\"document_id\" content=\"c5bd6023-3983-632f-a449-7e3130ab2989\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Inheritance (F#) | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"b38ab2f6-7ba7-4839-8eff-e6bd6cfd2b2f","description":"Inheritance (F#)","keywords":"visual f#, f#, functional programming","ms.topic":"language-reference","ms.date":"05/16/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Move snippets to snippets folder, now with some F# (#904)","commit_sha":"37fe2b89d590509e8eb14342da988f15862a9e2b","commit_date":"2016-08-13 16:40:56 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize F# snippets (#903)","commit_sha":"6ea1cf8f3779532a9ed8fbdac32592fbb809443c","commit_date":"2016-08-13 15:14:41 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"F# Docs: Update intro, move files, rename language reference for better URLS (#902)","commit_sha":"70a10b9c3e21291c96d927d13f8710d9e0738d4c","commit_date":"2016-08-13 11:22:39 -0700"}],"updated_at":"2017-03-21 01:42 AM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"3/21/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/inheritance.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/fsharp/language-reference/inheritance.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/language-reference/inheritance.md","document_id":"c5bd6023-3983-632f-a449-7e3130ab2989","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/fsharp/language-reference/inheritance","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Inheritance (F#)","_op_displayDate":"2016-5-16","_op_displayDate_source":"2016-05-16T00:00:00Z","_op_wordCount":670,"_op_rawTitle":"<h1 id=\"inheritance\" sourcefile=\"docs/fsharp/language-reference/inheritance.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Inheritance</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/fsharp/language-reference/inheritance","fileRelativePath":"articles/fsharp/language-reference/inheritance.html"},"themesRelativePathToOutputRoot":"_themes/"}