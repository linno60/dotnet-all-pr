{"content":"<div><div class=\"content\">\n<div class=\"NOTE\"><h5>Note</h5><p>The API reference link will take you to MSDN.  The docs.microsoft.com API reference is not complete.</p>\n</div>\n<p>This topic describes <em>code quotations</em>, a language feature that enables you to generate and work with F# code expressions programmatically. This feature lets you generate an abstract syntax tree that represents F# code. The abstract syntax tree can then be traversed and processed according to the needs of your application. For example, you can use the tree to generate F# code or generate code in some other language.</p>\n<h2 id=\"quoted-expressions\">Quoted Expressions</h2>\n<p>A <em>quoted expression</em> is an F# expression in your code that is delimited in such a way that it is not compiled as part of your program, but instead is compiled into an object that represents an F# expression. You can mark a quoted expression in one of two ways: either with type information or without type information. If you want to include type information, you use the symbols <code>&lt;@</code> and <code>@&gt;</code> to delimit the quoted expression. If you do not need type information, you use the symbols <code>&lt;@@</code> and <code>@@&gt;</code>. The following code shows typed and untyped quotations.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">open Microsoft.FSharp.Quotations\n// A typed code quotation.\nlet expr : Expr&lt;int&gt; = &lt;@ 1 + 1 @&gt;\n// An untyped code quotation.\nlet expr2 : Expr = &lt;@@ 1 + 1 @@&gt;\n</code></pre><p>Traversing a large expression tree is faster if you do not include type information. The resulting type of an expression quoted with the typed symbols is <code>Expr&lt;&#39;T&gt;</code>, where the type parameter has the type of the expression as determined by the F# compiler&#39;s type inference algorithm. When you use code quotations without type information, the type of the quoted expression is the non-generic type <a href=\"https://msdn.microsoft.com/library/ed6a2caf-69d4-45c2-ab97-e9b3be9bce65\" data-linktype=\"external\">Expr</a>. You can call the <a href=\"https://msdn.microsoft.com/library/47fb94f1-e77f-4c68-aabc-2b0ba40d59c2\" data-linktype=\"external\">Raw</a> property on the typed <code>Expr</code> class to obtain the untyped <code>Expr</code> object.</p>\n<p>There are a variety of static methods that allow you to generate F# expression objects programmatically in the <code>Expr</code> class without using quoted expressions.</p>\n<p>Note that a code quotation must include a complete expression. For a <code>let</code> binding, for example, you need both the definition of the bound name and an additional expression that uses the binding. In verbose syntax, this is an expression that follows the <code>in</code> keyword. At the top-level in a module, this is just the next expression in the module, but in a quotation, it is explicitly required.</p>\n<p>Therefore, the following expression is not valid.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">// Not valid:\n// &lt;@ let f x = x + 1 @&gt;\n</code></pre><p>But the following expressions are valid.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Valid:\n&lt;@ let f x = x + 10 in f 20 @&gt;\n// Valid:\n&lt;@\n    let f x = x + 10\n    f 20\n@&gt;\n</code></pre><p>To use code quotations, you must add an import declaration (by using the <code>open</code> keyword) that opens the <a href=\"https://msdn.microsoft.com/library/e9ce8a3a-e00c-4190-bad5-cce52ee089b2\" data-linktype=\"external\">Microsoft.FSharp.Quotations</a> namespace.</p>\n<p>The F# PowerPack provides support for evaluating and executing F# expression objects.</p>\n<h2 id=\"expr-type\">Expr Type</h2>\n<p>An instance of the <code>Expr</code> type represents an F# expression. Both the generic and the non-generic <code>Expr</code> types are documented in the F# library documentation. For more information, see <a href=\"https://msdn.microsoft.com/visualfsharpdocs/conceptual/microsoft.fsharp.quotations-namespace-%5bfsharp%5d\" data-linktype=\"external\">Microsoft.FSharp.Quotations Namespace</a> and <a href=\"https://msdn.microsoft.com/visualfsharpdocs/conceptual/quotations.expr-class-%5bfsharp%5d\" data-linktype=\"external\">Quotations.Expr Class</a>.</p>\n<h2 id=\"splicing-operators\">Splicing Operators</h2>\n<p>Splicing enables you to combine literal code quotations with expressions that you have created programmatically or from another code quotation. The <code>%</code> and <code>%%</code> operators enable you to add an F# expression object into a code quotation. You use the <code>%</code> operator to insert a typed expression object into a typed quotation; you use the <code>%%</code> operator to insert an untyped expression object into an untyped quotation. Both operators are unary prefix operators. Thus if <code>expr</code> is an untyped expression of type <code>Expr</code>, the following code is valid.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">&lt;@@ 1 + %%expr @@&gt;\n</code></pre><p>And if <code>expr</code> is a typed quotation of type <code>Expr&lt;int&gt;</code>, the following code is valid.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">&lt;@ 1 + %expr @&gt;\n</code></pre><h2 id=\"example\">Example</h2>\n<h3 id=\"description\">Description</h3>\n<p>The following example illustrates the use of code quotations to put F# code into an expression object and then print the F# code that represents the expression. A function <code>println</code> is defined that contains a recursive function <code>print</code> that displays an F# expression object (of type <code>Expr</code>) in a friendly format. There are several active patterns in the <a href=\"https://msdn.microsoft.com/library/093944a9-c752-403a-8983-5fcd5dbf92a4\" data-linktype=\"external\">Microsoft.FSharp.Quotations.Patterns</a> and <a href=\"https://msdn.microsoft.com/library/d2434a6e-ae7b-4f3d-b567-c162938bc9cd\" data-linktype=\"external\">Microsoft.FSharp.Quotations.DerivedPatterns</a> modules that can be used to analyze expression objects. This example does not include all the possible patterns that might appear in an F# expression. Any unrecognized pattern triggers a match to the wildcard pattern (<code>_</code>) and is rendered by using the <code>ToString</code> method, which, on the <code>Expr</code> type, lets you know the active pattern to add to your match expression.</p>\n<h3 id=\"code\">Code</h3>\n<pre><code class=\"lang-fsharp\" name=\"Main\">module Print\nopen Microsoft.FSharp.Quotations\nopen Microsoft.FSharp.Quotations.Patterns\nopen Microsoft.FSharp.Quotations.DerivedPatterns\n\nlet println expr =\n    let rec print expr =\n        match expr with\n        | Application(expr1, expr2) -&gt;\n            // Function application.\n            print expr1\n            printf &quot; &quot;\n            print expr2\n        | SpecificCall &lt;@@ (+) @@&gt; (_, _, exprList) -&gt;\n            // Matches a call to (+). Must appear before Call pattern.\n            print exprList.Head\n            printf &quot; + &quot;\n            print exprList.Tail.Head\n        | Call(exprOpt, methodInfo, exprList) -&gt;\n            // Method or module function call.\n            match exprOpt with\n            | Some expr -&gt; print expr\n            | None -&gt; printf &quot;%s&quot; methodInfo.DeclaringType.Name\n            printf &quot;.%s(&quot; methodInfo.Name\n            if (exprList.IsEmpty) then printf &quot;)&quot; else\n            print exprList.Head\n            for expr in exprList.Tail do\n                printf &quot;,&quot;\n                print expr\n            printf &quot;)&quot;\n        | Int32(n) -&gt;\n            printf &quot;%d&quot; n\n        | Lambda(param, body) -&gt;\n            // Lambda expression.\n            printf &quot;fun (%s:%s) -&gt; &quot; param.Name (param.Type.ToString())\n            print body\n        | Let(var, expr1, expr2) -&gt;\n            // Let binding.\n            if (var.IsMutable) then\n                printf &quot;let mutable %s = &quot; var.Name\n            else\n                printf &quot;let %s = &quot; var.Name\n            print expr1\n            printf &quot; in &quot;\n            print expr2\n        | PropertyGet(_, propOrValInfo, _) -&gt;\n            printf &quot;%s&quot; propOrValInfo.Name\n        | String(str) -&gt;\n            printf &quot;%s&quot; str\n        | Value(value, typ) -&gt;\n            printf &quot;%s&quot; (value.ToString())\n        | Var(var) -&gt;\n            printf &quot;%s&quot; var.Name\n        | _ -&gt; printf &quot;%s&quot; (expr.ToString())\n    print expr\n    printfn &quot;&quot;\n\n\nlet a = 2\n\n// exprLambda has type &quot;(int -&gt; int)&quot;.\nlet exprLambda = &lt;@ fun x -&gt; x + 1 @&gt;\n// exprCall has type unit.\nlet exprCall = &lt;@ a + 1 @&gt;\n\nprintln exprLambda\nprintln exprCall\nprintln &lt;@@ let f x = x + 10 in f 10 @@&gt;\n</code></pre><h3 id=\"output\">Output</h3>\n<pre class=\"loading\"><code class=\"lang-fsharp\">fun (x:System.Int32) -&gt; x + 1\na + 1\nlet f = fun (x:System.Int32) -&gt; x + 10 in f 10\n</code></pre><h2 id=\"example-1\">Example</h2>\n<h3 id=\"description-1\">Description</h3>\n<p>You can also use the three active patterns in the <a href=\"https://msdn.microsoft.com/library/7685150e-2432-4d39-9338-57292eff18de\" data-linktype=\"external\">ExprShape module</a> to traverse expression trees with fewer active patterns. These active patterns can be useful when you want to traverse a tree but you do not need all the information in most of the nodes. When you use these patterns, any F# expression matches one of the following three patterns: <code>ShapeVar</code> if the expression is a variable, <code>ShapeLambda</code> if the expression is a lambda expression, or <code>ShapeCombination</code> if the expression is anything else. If you traverse an expression tree by using the active patterns as in the previous code example, you have to use many more patterns to handle all possible F# expression types, and your code will be more complex. For more information, see <a href=\"https://msdn.microsoft.com/visualfsharpdocs/conceptual/exprshape.shapevarhshapelambdahshapecombination-active-pattern-%5bfsharp%5d\" data-linktype=\"external\">ExprShape.ShapeVar&#124;ShapeLambda&#124;ShapeCombination Active Pattern</a>.</p>\n<p>The following code example can be used as a basis for more complex traversals. In this code, an expression tree is created for an expression that involves a function call, <code>add</code>. The <a href=\"https://msdn.microsoft.com/library/05a77b21-20fe-4b9a-8e07-aa999538198d\" data-linktype=\"external\">SpecificCall</a> active pattern is used to detect any call to <code>add</code> in the expression tree. This active pattern assigns the arguments of the call to the <code>exprList</code> value. In this case, there are only two, so these are pulled out and the function is called recursively on the arguments. The results are inserted into a code quotation that represents a call to <code>mul</code> by using the splice operator (<code>%%</code>). The <code>println</code> function from the previous example is used to display the results.</p>\n<p>The code in the other active pattern branches just regenerates the same expression tree, so the only change in the resulting expression is the change from <code>add</code> to <code>mul</code>.</p>\n<h3 id=\"code-1\">Code</h3>\n<pre><code class=\"lang-fsharp\" name=\"Main\">module Module1\nopen Print\nopen Microsoft.FSharp.Quotations\nopen Microsoft.FSharp.Quotations.DerivedPatterns\nopen Microsoft.FSharp.Quotations.ExprShape\n\nlet add x y = x + y\nlet mul x y = x * y\n\nlet rec substituteExpr expression =\n    match expression with\n    | SpecificCall &lt;@@ add @@&gt; (_, _, exprList) -&gt;\n        let lhs = substituteExpr exprList.Head\n        let rhs = substituteExpr exprList.Tail.Head\n        &lt;@@ mul %%lhs %%rhs @@&gt;\n    | ShapeVar var -&gt; Expr.Var var\n    | ShapeLambda (var, expr) -&gt; Expr.Lambda (var, substituteExpr expr)\n    | ShapeCombination(shapeComboObject, exprList) -&gt;\n        RebuildShapeCombination(shapeComboObject, List.map substituteExpr exprList)\n\nlet expr1 = &lt;@@ 1 + (add 2 (add 3 4)) @@&gt;\nprintln expr1\nlet expr2 = substituteExpr expr1\nprintln expr2\n</code></pre><h3 id=\"output-1\">Output</h3>\n<pre class=\"loading\"><code class=\"lang-fsharp\">1 + Module1.add(2,Module1.add(3,4))\n1 + Module1.mul(2,Module1.mul(3,4))\n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p><a href=\"index\" data-linktype=\"relative-path\">F# Language Reference</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"4559e659-2b04-48bd-8a0b-8527920eec95\">\r\n<meta name=\"description\" content=\"Code Quotations (F#)\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming\">\r\n<meta name=\"ms.topic\" content=\"language-reference\">\r\n<meta name=\"ms.date\" content=\"05/16/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/code-quotations.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/code-quotations.md\">\r\n<meta name=\"document_id\" content=\"bf09a724-589d-bce7-2849-c72696a4bbc2\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Code Quotations (F#) | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"4559e659-2b04-48bd-8a0b-8527920eec95","description":"Code Quotations (F#)","keywords":"visual f#, f#, functional programming","ms.topic":"language-reference","ms.date":"05/16/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"fixed absolute and msdn links (#1001)","commit_sha":"de0dab146fc811e895dc32f98f877db5e757f82b","commit_date":"2016-09-06 10:59:39 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Move snippets to snippets folder, now with some F# (#904)","commit_sha":"37fe2b89d590509e8eb14342da988f15862a9e2b","commit_date":"2016-08-13 16:40:56 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize F# snippets (#903)","commit_sha":"6ea1cf8f3779532a9ed8fbdac32592fbb809443c","commit_date":"2016-08-13 15:14:41 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"F# Docs: Update intro, move files, rename language reference for better URLS (#902)","commit_sha":"70a10b9c3e21291c96d927d13f8710d9e0738d4c","commit_date":"2016-08-13 11:22:39 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/code-quotations.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/code-quotations.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/language-reference/code-quotations.md","document_id":"bf09a724-589d-bce7-2849-c72696a4bbc2","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/fsharp/language-reference/code-quotations","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Code Quotations (F#)","_op_displayDate":"2016-5-16","_op_displayDate_source":"2016-05-16T00:00:00Z","_op_wordCount":1416,"_op_rawTitle":"<h1 id=\"code-quotations\" sourcefile=\"docs/fsharp/language-reference/code-quotations.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Code Quotations</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/fsharp/language-reference/code-quotations","fileRelativePath":"articles/fsharp/language-reference/code-quotations.html"},"themesRelativePathToOutputRoot":"_themes/"}