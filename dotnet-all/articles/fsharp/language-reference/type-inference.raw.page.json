{"content":"<div><div class=\"content\">\n<p>This topic describes how the F# compiler infers the types of values, variables, parameters and return values.</p>\n<h2 id=\"type-inference-in-general\">Type Inference in General</h2>\n<p>The idea of type inference is that you do not have to specify the types of F# constructs except when the compiler cannot conclusively deduce the type. Omitting explicit type information does not mean that F# is a dynamically typed language or that values in F# are weakly typed. F# is a statically typed language, which means that the compiler deduces an exact type for each construct during compilation. If there is not enough information for the compiler to deduce the types of each construct, you must supply additional type information, typically by adding explicit type annotations somewhere in the code.</p>\n<h2 id=\"inference-of-parameter-and-return-types\">Inference of Parameter and Return Types</h2>\n<p>In a parameter list, you do not have to specify the type of each parameter. And yet, F# is a statically typed language, and therefore every value and expression has a definite type at compile time. For those types that you do not specify explicitly, the compiler infers the type based on the context. If the type is not otherwise specified, it is inferred to be generic. If the code uses a value inconsistently, in such a way that there is no single inferred type that satisfies all the uses of a value, the compiler reports an error.</p>\n<p>The return type of a function is determined by the type of the last expression in the function.</p>\n<p>For example, in the following code, the parameter types <code>a</code> and <code>b</code> and the return type are all inferred to be <code>int</code> because the literal <code>100</code> is of type <code>int</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let f a b = a + b + 100\n</code></pre><p>You can influence type inference by changing the literals. If you make the <code>100</code> a <code>uint32</code> by appending the suffix <code>u</code>, the types of <code>a</code>, <code>b</code>, and the return value are inferred to be <code>uint32</code>.</p>\n<p>You can also influence type inference by using other constructs that imply restrictions on the type, such as functions and methods that work with only a particular type.</p>\n<p>Also, you can apply explicit type annotations to function or method parameters or to variables in expressions, as shown in the following examples. Errors result if conflicts occur between different constraints.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Type annotations on a parameter.\nlet addu1 (x : uint32) y =\n    x + y\n\n// Type annotations on an expression.\nlet addu2 x y =\n    (x : uint32) + y\n</code></pre><p>You can also explicitly specify the return value of a function by providing a type annotation after all the parameters.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let addu1 x y : uint32 =\n   x + y\n</code></pre><p>A common case where a type annotation is useful on a parameter is when the parameter is an object type and you want to use a member.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let replace(str: string) =\n    str.Replace(&quot;A&quot;, &quot;a&quot;)\n</code></pre><h2 id=\"automatic-generalization\">Automatic Generalization</h2>\n<p>If the function code is not dependent on the type of a parameter, the compiler considers the parameter to be generic. This is called <em>automatic generalization</em>, and it can be a powerful aid to writing generic code without increasing complexity.</p>\n<p>For example, the following function combines two parameters of any type into a tuple.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let makeTuple a b = (a, b)\n</code></pre><p>The type is inferred to be</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">&#39;a -&gt; &#39;b -&gt; &#39;a * &#39;b\n</code></pre><h2 id=\"additional-information\">Additional Information</h2>\n<p>Type inference is described in more detail in the F# Language Specification.</p>\n<h2 id=\"see-also\">See Also</h2>\n<p><a href=\"generics/automatic-generalization\" data-linktype=\"relative-path\">Automatic Generalization</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet/toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"2d5fa4b1-732a-4d71-a62d-07f7ee79fe06\">\r\n<meta name=\"description\" content=\"Type Inference (F#)\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming\">\r\n<meta name=\"ms.topic\" content=\"language-reference\">\r\n<meta name=\"ms.date\" content=\"05/16/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/type-inference.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/type-inference.md\">\r\n<meta name=\"document_id\" content=\"8425721f-c4af-4e58-1b5a-af474f5a04f2\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Type Inference (F#) | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"2d5fa4b1-732a-4d71-a62d-07f7ee79fe06","description":"Type Inference (F#)","keywords":"visual f#, f#, functional programming","ms.topic":"language-reference","ms.date":"05/16/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Move snippets to snippets folder, now with some F# (#904)","commit_sha":"37fe2b89d590509e8eb14342da988f15862a9e2b","commit_date":"2016-08-13 16:40:56 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize F# snippets (#903)","commit_sha":"6ea1cf8f3779532a9ed8fbdac32592fbb809443c","commit_date":"2016-08-13 15:14:41 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"F# Docs: Update intro, move files, rename language reference for better URLS (#902)","commit_sha":"70a10b9c3e21291c96d927d13f8710d9e0738d4c","commit_date":"2016-08-13 11:22:39 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/type-inference.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/type-inference.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/language-reference/type-inference.md","document_id":"8425721f-c4af-4e58-1b5a-af474f5a04f2","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/type-inference","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Type Inference (F#)","_op_displayDate":"2016-5-16","_op_displayDate_source":"2016-05-16T00:00:00Z","_op_wordCount":564,"_op_rawTitle":"<h1 id=\"type-inference\" sourcefile=\"docs/fsharp/language-reference/type-inference.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Type Inference</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/type-inference","fileRelativePath":"articles/fsharp/language-reference/type-inference.html"},"themesRelativePathToOutputRoot":"_themes/"}