{"content":"<div><div class=\"content\">\n<p>In the context of the F# language, a <em>module</em> is a grouping of F# code, such as values, types, and function values, in an F# program. Grouping code in modules helps keep related code together and helps avoid name conflicts in your program.</p>\n<h2 id=\"syntax\">Syntax</h2>\n<pre class=\"loading\"><code class=\"lang-fsharp\">// Top-level module declaration.\nmodule [accessibility-modifier] [qualified-namespace.]module-name\ndeclarations\n// Local module declaration.\nmodule [accessibility-modifier] module-name =\n    declarations\n</code></pre><h2 id=\"remarks\">Remarks</h2>\n<p>An F# module is a grouping of F# code constructs such as types, values, function values, and code in <code>do</code> bindings. It is implemented as a common language runtime (CLR) class that has only static members. There are two types of module declarations, depending on whether the whole file is included in the module: a top-level module declaration and a local module declaration. A top-level module declaration includes the whole file in the module. A top-level module declaration can appear only as the first declaration in a file.</p>\n<p>In the syntax for the top-level module declaration, the optional <em>qualified-namespace</em> is the sequence of nested namespace names that contains the module. The qualified namespace does not have to be previously declared.</p>\n<p>You do not have to indent declarations in a top-level module. You do have to indent all declarations in local modules. In a local module declaration, only the declarations that are indented under that module declaration are part of the module.</p>\n<p>If a code file does not begin with a top-level module declaration or a namespace declaration, the whole contents of the file, including any local modules, becomes part of an implicitly created top-level module that has the same name as the file, without the extension, with the first letter converted to uppercase. For example, consider the following file.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// In the file program.fs.\nlet x = 40\n</code></pre><p>This file would be compiled as if it were written in this manner:</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">module Program\nlet x = 40\n</code></pre><p>If you have multiple modules in a file, you must use a local module declaration for each module. If an enclosing namespace is declared, these modules are part of the enclosing namespace. If an enclosing namespace is not declared, the modules become part of the implicitly created top-level module. The following code example shows a code file that contains multiple modules. The compiler implicitly creates a top-level module named <code>Multiplemodules</code>, and <code>MyModule1</code> and <code>MyModule2</code> are nested in that top-level module.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// In the file multiplemodules.fs.\n// MyModule1\nmodule MyModule1 =\n    // Indent all program elements within modules that are declared with an equal sign.\n    let module1Value = 100\n\n    let module1Function x =\n        x + 10\n\n// MyModule2\nmodule MyModule2 =\n\n    let module2Value = 121\n\n    // Use a qualified name to access the function.\n    // from MyModule1.\n    let module2Function x =\n        x * (MyModule1.module1Function module2Value)\n</code></pre><p>If you have multiple files in a project or in a single compilation, or if you are building a library, you must include a namespace declaration or module declaration at the top of the file. The F# compiler only determines a module name implicitly when there is only one file in a project or compilation command line, and you are creating an application.</p>\n<p>The <em>accessibility-modifier</em> can be one of the following: <code>public</code>, <code>private</code>, <code>internal</code>. For more information, see <a href=\"access-control\" data-linktype=\"relative-path\">Access Control</a>. The default is public.</p>\n<h2 id=\"referencing-code-in-modules\">Referencing Code in Modules</h2>\n<p>When you reference functions, types, and values from another module, you must either use a qualified name or open the module. If you use a qualified name, you must specify the namespaces, the module, and the identifier for the program element you want. You separate each part of the qualified path with a dot (.), as follows.</p>\n<p><code>Namespace1.Namespace2.ModuleName.Identifier</code></p>\n<p>You can open the module or one or more of the namespaces to simplify the code. For more information about opening namespaces and modules, see <a href=\"import-declarations-the-open-keyword\" data-linktype=\"relative-path\">Import Declarations: The <code>open</code> Keyword</a>.</p>\n<p>The following code example shows a top-level module that contains all the code up to the end of the file.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">module Arithmetic\n\nlet add x y =\n    x + y\n\nlet sub x y =\n    x - y\n</code></pre><p>To use this code from another file in the same project, you either use qualified names or you open the module before you use the functions, as shown in the following examples.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Fully qualify the function name.\nlet result1 = Arithmetic.add 5 9\n// Open the module.\nopen Arithmetic\nlet result2 = add 5 9\n</code></pre><h2 id=\"nested-modules\">Nested Modules</h2>\n<p>Modules can be nested. Inner modules must be indented as far as outer module declarations to indicate that they are inner modules, not new modules. For example, compare the following two examples. Module <code>Z</code> is an inner module in the following code.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">module Y =\n    let x = 1\n\n    module Z =\n        let z = 5\n</code></pre><p>But module <code>Z</code> is a sibling to module <code>Y</code> in the following code.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">module Y =\n    let x = 1\n\nmodule Z =\n    let z = 5\n</code></pre><p>Module <code>Z</code> is also a sibling module in the following code, because it is not indented as far as other declarations in module <code>Y</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">module Y =\n        let x = 1\n\n    module Z =\n        let z = 5\n</code></pre><p>Finally, if the outer module has no declarations and is followed immediately by another module declaration, the new module declaration is assumed to be an inner module, but the compiler will warn you if the second module definition is not indented farther than the first.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// This code produces a warning, but treats Z as a inner module.\nmodule Y =\nmodule Z =\n    let z = 5\n</code></pre><p>To eliminate the warning, indent the inner module.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">module Y =\n    module Z =\n        let z = 5\n</code></pre><p>If you want all the code in a file to be in a single outer module and you want inner modules, the outer module does not require the equal sign, and the declarations, including any inner module declarations, that will go in the outer module do not have to be indented. Declarations inside the inner module declarations do have to be indented. The following code shows this case.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// The top-level module declaration can be omitted if the file is named\n// TopLevel.fs or topLevel.fs, and the file is the only file in an\n// application.\nmodule TopLevel\n\nlet topLevelX = 5\n\nmodule Inner1 =\n    let inner1X = 1\nmodule Inner2 =\n    let inner2X = 5\n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p><a href=\"index\" data-linktype=\"relative-path\">F# Language Reference</a></p>\n<p><a href=\"namespaces\" data-linktype=\"relative-path\">Namespaces</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"46de2d18-da51-40fa-a262-92edecada79d\">\r\n<meta name=\"description\" content=\"Modules (F#)\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming\">\r\n<meta name=\"ms.topic\" content=\"language-reference\">\r\n<meta name=\"ms.date\" content=\"05/16/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-21 01:42 AM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/modules.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/fsharp/language-reference/modules.md\">\r\n<meta name=\"document_id\" content=\"ddbb72a8-bdf5-91cd-c51c-a22c9aa70530\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Modules (F#) | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"46de2d18-da51-40fa-a262-92edecada79d","description":"Modules (F#)","keywords":"visual f#, f#, functional programming","ms.topic":"language-reference","ms.date":"05/16/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Petr Onderka","author_email":"gsvick@gmail.com","committer_name":"Phillip Carter","comitter_email":"phillip.carter@outlook.com","message":"Added missing newline (#1023)","commit_sha":"aa7cf569a9cde78bdb582c675ca88dbf68df1911","commit_date":"2016-09-14 13:24:37 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Move snippets to snippets folder, now with some F# (#904)","commit_sha":"37fe2b89d590509e8eb14342da988f15862a9e2b","commit_date":"2016-08-13 16:40:56 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize F# snippets (#903)","commit_sha":"6ea1cf8f3779532a9ed8fbdac32592fbb809443c","commit_date":"2016-08-13 15:14:41 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"F# Docs: Update intro, move files, rename language reference for better URLS (#902)","commit_sha":"70a10b9c3e21291c96d927d13f8710d9e0738d4c","commit_date":"2016-08-13 11:22:39 -0700"}],"updated_at":"2017-03-21 01:42 AM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/svick","display_name":"Petr Onderka","id":"287848"}],"update_at":"3/21/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/modules.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/fsharp/language-reference/modules.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/language-reference/modules.md","document_id":"ddbb72a8-bdf5-91cd-c51c-a22c9aa70530","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/fsharp/language-reference/modules","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Modules (F#)","_op_displayDate":"2016-5-16","_op_displayDate_source":"2016-05-16T00:00:00Z","_op_wordCount":1053,"_op_rawTitle":"<h1 id=\"modules\" sourcefile=\"docs/fsharp/language-reference/modules.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Modules</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/fsharp/language-reference/modules","fileRelativePath":"articles/fsharp/language-reference/modules.html"},"themesRelativePathToOutputRoot":"_themes/"}