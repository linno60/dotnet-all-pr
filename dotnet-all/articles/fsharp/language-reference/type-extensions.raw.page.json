{"content":"<div><div class=\"content\">\n<p>Type extensions let you add new members to a previously defined object type.</p>\n<h2 id=\"syntax\">Syntax</h2>\n<pre class=\"loading\"><code class=\"lang-fsharp\">// Intrinsic extension.\ntype typename with\n    member self-identifier.member-name =\n        body\n    ...\n[ end ]\n\n// Optional extension.\ntype typename with\n    member self-identifier.member-name =\n        body\n    ...\n[ end ]\n</code></pre><h2 id=\"remarks\">Remarks</h2>\n<p>There are two forms of type extensions that have slightly different syntax and behavior. An <em>intrinsic extension</em> is an extension that appears in the same namespace or module, in the same source file, and in the same assembly (DLL or executable file) as the type being extended. An <em>optional extension</em> is an extension that appears outside the original module, namespace, or assembly of the type being extended. Intrinsic extensions appear on the type when the type is examined by reflection, but optional extensions do not. Optional extensions must be in modules, and they are only in scope when the module that contains the extension is open.</p>\n<p>In the previous syntax, <em>typename</em> represents the type that is being extended. Any type that can be accessed can be extended, but the type name must be an actual type name, not a type abbreviation. You can define multiple members in one type extension. The <em>self-identifier</em> represents the instance of the object being invoked, just as in ordinary members.</p>\n<p>The <code>end</code> keyword is optional in lightweight syntax.</p>\n<p>Members defined in type extensions can be used just like other members on a class type. Like other members, they can be static or instance members. These methods are also known as <em>extension methods</em>; properties are known as <em>extension properties</em>, and so on. Optional extension members are compiled to static members for which the object instance is passed implicitly as the first parameter. However, they act as if they were instance members or static members according to how they are declared. Implicit extension members are included as members of the type and can be used without restriction.</p>\n<p>Extension methods cannot be virtual or abstract methods. They can overload other methods of the same name, but the compiler gives preference to non-extension methods in the case of an ambiguous call.</p>\n<p>If multiple intrinsic type extensions exist for one type, all members must be unique. For optional type extensions, members in different type extensions to the same type can have the same names. Ambiguity errors occur only if client code opens two different scopes that define the same member names.</p>\n<p>In the following example, a type in a module has an intrinsic type extension. To client code outside the module, the type extension appears as a regular member of the type in all respects.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">module MyModule1 =\n\n    // Define a type.\n    type MyClass() =\n      member this.F() = 100\n\n    // Define type extension.\n    type MyClass with\n       member this.G() = 200\n\nmodule MyModule2 =\n   let function1 (obj1: MyModule1.MyClass) =\n      // Call an ordinary method.\n      printfn &quot;%d&quot; (obj1.F())\n      // Call the extension method.\n      printfn &quot;%d&quot; (obj1.G())\n</code></pre><p>You can use intrinsic type extensions to separate the definition of a type into sections. This can be useful in managing large type definitions, for example, to keep compiler-generated code and authored code separate or to group together code created by different people or associated with different functionality.</p>\n<p>In the following example, an optional type extension extends the <code>System.Int32</code> type with an extension method <code>FromString</code> that calls the static member <code>Parse</code>. The <code>testFromString</code> method demonstrates that the new member is called just like any instance member.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Define a new member method FromString on the type Int32.\ntype System.Int32 with\n    member this.FromString( s : string ) =\n       System.Int32.Parse(s)\n\nlet testFromString str =\n    let mutable i = 0\n    // Use the extension method.\n    i &lt;- i.FromString(str)\n    printfn &quot;%d&quot; i\n\ntestFromString &quot;500&quot;\n</code></pre><p>The new instance member will appear like any other method of the <code>Int32</code> type in IntelliSense, but only when the module that contains the extension is open or otherwise in scope.</p>\n<h2 id=\"generic-extension-methods\">Generic Extension Methods</h2>\n<p>Before F# 3.1, the F# compiler didn&#39;t support the use of C#-style extension methods with a generic type variable, array type, tuple type, or an F# function type as the “this” parameter. F# 3.1 supports the use of these extension members.</p>\n<p>For example, in F# 3.1 code, you can use extension methods with signatures that resemble the following syntax in C#:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">static member Method&lt;T&gt;(this T input, T other)\n</code></pre><p>This approach is particularly useful when the generic type parameter is constrained. Further, you can now declare extension members like this in F# code and define an additional, semantically rich set of extension methods. In F#, you usually define extension members as the following example shows:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">open System.Collections.Generic\n\ntype IEnumerable&lt;&#39;T&gt; with\n    /// Repeat each element of the sequence n times\n    member xs.RepeatElements(n: int) =\n        seq { for x in xs do for i in 1 .. n do yield x }\n</code></pre><p>However, for a generic type, the type variable may not be constrained. You can now declare a C#-style extension member in F# to work around this limitation. When you combine this kind of declaration with the inline feature of F#, you can present generic algorithms as extension members.</p>\n<p>Consider the following declaration:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">[&lt;Extension&gt;]\ntype ExtraCSharpStyleExtensionMethodsInFSharp () =\n    [&lt;Extension&gt;]\n    static member inline Sum(xs: IEnumerable&lt;&#39;T&gt;) = Seq.sum xs\n</code></pre><p>By using this declaration, you can write code that resembles the following sample.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let listOfIntegers = [ 1 .. 100 ]\nlet listOfBigIntegers = [ 1I to 100I ]\nlet sum1 = listOfIntegers.Sum()\nlet sum2 = listOfBigIntegers.Sum()\n</code></pre><p>In this code, the same generic arithmetic code is applied to lists of two types without overloading, by defining a single extension member.</p>\n<h2 id=\"see-also\">See Also</h2>\n<p><a href=\"index\" data-linktype=\"relative-path\">F# Language Reference</a></p>\n<p><a href=\"members/index\" data-linktype=\"relative-path\">Members</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"c9d7ce27-f5ad-4766-b9e9-34187da5bc24\">\r\n<meta name=\"description\" content=\"Type Extensions (F#)\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming\">\r\n<meta name=\"ms.topic\" content=\"language-reference\">\r\n<meta name=\"ms.date\" content=\"05/16/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-21 01:42 AM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/type-extensions.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/fsharp/language-reference/type-extensions.md\">\r\n<meta name=\"document_id\" content=\"2d7d45ef-1fe2-e5a5-d158-4b34cf10a197\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Type Extensions (F#) | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"c9d7ce27-f5ad-4766-b9e9-34187da5bc24","description":"Type Extensions (F#)","keywords":"visual f#, f#, functional programming","ms.topic":"language-reference","ms.date":"05/16/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Don Syme","author_email":"dsyme@users.noreply.github.com","committer_name":"Phillip Carter","comitter_email":"phillip.carter@outlook.com","message":"Fix extension docs (#1178)","commit_sha":"be15ceda3d0c64b9e08fc16a38a12ad7df9cbf05","commit_date":"2016-10-27 08:53:43 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Move snippets to snippets folder, now with some F# (#904)","commit_sha":"37fe2b89d590509e8eb14342da988f15862a9e2b","commit_date":"2016-08-13 16:40:56 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize F# snippets (#903)","commit_sha":"6ea1cf8f3779532a9ed8fbdac32592fbb809443c","commit_date":"2016-08-13 15:14:41 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"F# Docs: Update intro, move files, rename language reference for better URLS (#902)","commit_sha":"70a10b9c3e21291c96d927d13f8710d9e0738d4c","commit_date":"2016-08-13 11:22:39 -0700"}],"updated_at":"2017-03-21 01:42 AM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/dsyme","display_name":"Don Syme","id":"7204669"}],"update_at":"3/21/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/type-extensions.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/fsharp/language-reference/type-extensions.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/language-reference/type-extensions.md","document_id":"2d7d45ef-1fe2-e5a5-d158-4b34cf10a197","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/fsharp/language-reference/type-extensions","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Type Extensions (F#)","_op_displayDate":"2016-5-16","_op_displayDate_source":"2016-05-16T00:00:00Z","_op_wordCount":907,"_op_rawTitle":"<h1 id=\"type-extensions\" sourcefile=\"docs/fsharp/language-reference/type-extensions.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Type Extensions</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/fsharp/language-reference/type-extensions","fileRelativePath":"articles/fsharp/language-reference/type-extensions.html"},"themesRelativePathToOutputRoot":"_themes/"}