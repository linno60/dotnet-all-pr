{"content":"<div><div class=\"content\">\n<p>This topic describes how to overload arithmetic operators in a class or record type, and at the global level.</p>\n<h2 id=\"syntax\">Syntax</h2>\n<pre class=\"loading\"><code class=\"lang-fsharp\">// Overloading an operator as a class or record member.\nstatic member (operator-symbols) (parameter-list) =\n    method-body\n// Overloading an operator at the global level\nlet [inline] (operator-symbols) parameter-list = function-body\n</code></pre><h2 id=\"remarks\">Remarks</h2>\n<p>In the previous syntax, the <em>operator-symbol</em> is one of <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>=</code>, and so on. The <em>parameter-list</em> specifies the operands in the order they appear in the usual syntax for that operator. The <em>method-body</em> constructs the resulting value.</p>\n<p>Operator overloads for operators must be static. Operator overloads for unary operators, such as <code>+</code> and <code>-</code>, must use a tilde (<code>~</code>) in the <em>operator-symbol</em> to indicate that the operator is a unary operator and not a binary operator, as shown in the following declaration.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">static member (~-) (v : Vector)\n</code></pre><p>The following code illustrates a vector class that has just two operators, one for unary minus and one for multiplication by a scalar. In the example, two overloads for scalar multiplication are needed because the operator must work regardless of the order in which the vector and scalar appear.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type Vector(x: float, y : float) =\n   member this.x = x\n   member this.y = y\n   static member (~-) (v : Vector) =\n     Vector(-1.0 * v.x, -1.0 * v.y)\n   static member (*) (v : Vector, a) =\n     Vector(a * v.x, a * v.y)\n   static member (*) (a, v: Vector) =\n     Vector(a * v.x, a * v.y)\n   override this.ToString() =\n     this.x.ToString() + &quot; &quot; + this.y.ToString()\n\nlet v1 = Vector(1.0, 2.0)\n\nlet v2 = v1 * 2.0\nlet v3 = 2.0 * v1\n\nlet v4 = - v2\n\nprintfn &quot;%s&quot; (v1.ToString())\nprintfn &quot;%s&quot; (v2.ToString())\nprintfn &quot;%s&quot; (v3.ToString())\nprintfn &quot;%s&quot; (v4.ToString())\n</code></pre><h2 id=\"creating-new-operators\">Creating New Operators</h2>\n<p>You can overload all the standard operators, but you can also create new operators out of sequences of certain characters. Allowed operator characters are <code>!</code>, <code>%</code>, <code>&amp;</code>, <code>*</code>, <code>+</code>, <code>-</code>, <code>.</code>, <code>/</code>, <code>&lt;</code>, <code>=</code>, <code>&gt;</code>, <code>?</code>, <code>@</code>, <code>^</code>, <code>|</code>, and <code>~</code>. The <code>~</code> character has the special meaning of making an operator unary, and is not part of the operator character sequence. Not all operators can be made unary.</p>\n<p>Depending on the exact character sequence you use, your operator will have a certain precedence and associativity. Associativity can be either left to right or right to left and is used whenever operators of the same level of precedence appear in sequence without parentheses.</p>\n<p>The operator character <code>.</code> does not affect precedence, so that, for example, if you want to define your own version of multiplication that has the same precedence and associativity as ordinary multiplication, you could create operators such as <code>.*</code>.</p>\n<p>Only the operators <code>?</code> and <code>?&lt;-</code> may start with <code>?.</code></p>\n<p>A table that shows the precedence of all operators in F# can be found in <a href=\"symbol-and-operator-reference/index\" data-linktype=\"relative-path\">Symbol and Operator Reference</a>.</p>\n<h2 id=\"overloaded-operator-names\">Overloaded Operator Names</h2>\n<p>When the F# compiler compiles an operator expression, it generates a method that has a compiler-generated name for that operator. This is the name that appears in the Microsoft intermediate language (MSIL) for the method, and also in reflection and IntelliSense. You do not normally need to use these names in F# code.</p>\n<p>The following table shows the standard operators and their corresponding generated names.</p>\n<table>\n<thead>\n<tr>\n<th>Operator</th>\n<th>Generated name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>[]</code></td>\n<td><code>op_Nil</code></td>\n</tr>\n<tr>\n<td><code>::</code></td>\n<td><code>op_Cons</code></td>\n</tr>\n<tr>\n<td><code>+</code></td>\n<td><code>op_Addition</code></td>\n</tr>\n<tr>\n<td><code>-</code></td>\n<td><code>op_Subtraction</code></td>\n</tr>\n<tr>\n<td><code>*</code></td>\n<td><code>op_Multiply</code></td>\n</tr>\n<tr>\n<td><code>/</code></td>\n<td><code>op_Division</code></td>\n</tr>\n<tr>\n<td><code>@</code></td>\n<td><code>op_Append</code></td>\n</tr>\n<tr>\n<td><code>^</code></td>\n<td><code>op_Concatenate</code></td>\n</tr>\n<tr>\n<td><code>%</code></td>\n<td><code>op_Modulus</code></td>\n</tr>\n<tr>\n<td><code>&amp;&amp;&amp;</code></td>\n<td><code>op_BitwiseAnd</code></td>\n</tr>\n<tr>\n<td><code>&#124;&#124;&#124;</code></td>\n<td><code>op_BitwiseOr</code></td>\n</tr>\n<tr>\n<td><code>^^^</code></td>\n<td><code>op_ExclusiveOr</code></td>\n</tr>\n<tr>\n<td><code>&lt;&lt;&lt;</code></td>\n<td><code>op_LeftShift</code></td>\n</tr>\n<tr>\n<td><code>~~~</code></td>\n<td><code>op_LogicalNot</code></td>\n</tr>\n<tr>\n<td><code>&gt;&gt;&gt;</code></td>\n<td><code>op_RightShift</code></td>\n</tr>\n<tr>\n<td><code>~+</code></td>\n<td><code>op_UnaryPlus</code></td>\n</tr>\n<tr>\n<td><code>~-</code></td>\n<td><code>op_UnaryNegation</code></td>\n</tr>\n<tr>\n<td><code>=</code></td>\n<td><code>op_Equality</code></td>\n</tr>\n<tr>\n<td><code>&lt;=</code></td>\n<td><code>op_LessThanOrEqual</code></td>\n</tr>\n<tr>\n<td><code>&gt;=</code></td>\n<td><code>op_GreaterThanOrEqual</code></td>\n</tr>\n<tr>\n<td><code>&lt;</code></td>\n<td><code>op_LessThan</code></td>\n</tr>\n<tr>\n<td><code>&gt;</code></td>\n<td><code>op_GreaterThan</code></td>\n</tr>\n<tr>\n<td><code>?</code></td>\n<td><code>op_Dynamic</code></td>\n</tr>\n<tr>\n<td><code>?&lt;-</code></td>\n<td><code>op_DynamicAssignment</code></td>\n</tr>\n<tr>\n<td><code>&#124;&gt;</code></td>\n<td><code>op_PipeRight</code></td>\n</tr>\n<tr>\n<td><code>&lt;&#124;</code></td>\n<td><code>op_PipeLeft</code></td>\n</tr>\n<tr>\n<td><code>!</code></td>\n<td><code>op_Dereference</code></td>\n</tr>\n<tr>\n<td><code>&gt;&gt;</code></td>\n<td><code>op_ComposeRight</code></td>\n</tr>\n<tr>\n<td><code>&lt;&lt;</code></td>\n<td><code>op_ComposeLeft</code></td>\n</tr>\n<tr>\n<td><code>&lt;@ @&gt;</code></td>\n<td><code>op_Quotation</code></td>\n</tr>\n<tr>\n<td><code>&lt;@@ @@&gt;</code></td>\n<td><code>op_QuotationUntyped</code></td>\n</tr>\n<tr>\n<td><code>+=</code></td>\n<td><code>op_AdditionAssignment</code></td>\n</tr>\n<tr>\n<td><code>-=</code></td>\n<td><code>op_SubtractionAssignment</code></td>\n</tr>\n<tr>\n<td><code>*=</code></td>\n<td><code>op_MultiplyAssignment</code></td>\n</tr>\n<tr>\n<td><code>/=</code></td>\n<td><code>op_DivisionAssignment</code></td>\n</tr>\n<tr>\n<td><code>..</code></td>\n<td><code>op_Range</code></td>\n</tr>\n<tr>\n<td><code>.. ..</code></td>\n<td><code>op_RangeStep</code></td>\n</tr>\n</tbody>\n</table>\n<p>Other combinations of operator characters that are not listed here can be used as operators and have names that are made up by concatenating names for the individual characters from the following table. For example, +! becomes <code>op_PlusBang</code>.</p>\n<table>\n<thead>\n<tr>\n<th>Operator character</th>\n<th>Name</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&gt;</code></td>\n<td><code>Greater</code></td>\n</tr>\n<tr>\n<td><code>&lt;</code></td>\n<td><code>Less</code></td>\n</tr>\n<tr>\n<td><code>+</code></td>\n<td><code>Plus</code></td>\n</tr>\n<tr>\n<td><code>-</code></td>\n<td><code>Minus</code></td>\n</tr>\n<tr>\n<td><code>*</code></td>\n<td><code>Multiply</code></td>\n</tr>\n<tr>\n<td><code>/</code></td>\n<td><code>Divide</code></td>\n</tr>\n<tr>\n<td><code>=</code></td>\n<td><code>Equals</code></td>\n</tr>\n<tr>\n<td><code>~</code></td>\n<td><code>Twiddle</code></td>\n</tr>\n<tr>\n<td><code>%</code></td>\n<td><code>Percent</code></td>\n</tr>\n<tr>\n<td><code>.</code></td>\n<td><code>Dot</code></td>\n</tr>\n<tr>\n<td><code>&amp;</code></td>\n<td><code>Amp</code></td>\n</tr>\n<tr>\n<td><code>&#124;</code></td>\n<td><code>Bar</code></td>\n</tr>\n<tr>\n<td><code>@</code></td>\n<td><code>At</code></td>\n</tr>\n<tr>\n<td><code>^</code></td>\n<td><code>Hat</code></td>\n</tr>\n<tr>\n<td><code>!</code></td>\n<td><code>Bang</code></td>\n</tr>\n<tr>\n<td><code>?</code></td>\n<td><code>Qmark</code></td>\n</tr>\n<tr>\n<td><code>(</code></td>\n<td><code>LParen</code></td>\n</tr>\n<tr>\n<td><code>,</code></td>\n<td><code>Comma</code></td>\n</tr>\n<tr>\n<td><code>)</code></td>\n<td><code>RParen</code></td>\n</tr>\n<tr>\n<td><code>[</code></td>\n<td><code>LBrack</code></td>\n</tr>\n<tr>\n<td><code>]</code></td>\n<td><code>RBrack</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"prefix-and-infix-operators\">Prefix and Infix Operators</h2>\n<p><em>Prefix</em> operators are expected to be placed in front of an operand or operands, much like a function. <em>Infix</em> operators are expected to be placed between the two operands.</p>\n<p>Only certain operators can be used as prefix operators. Some operators are always prefix operators, others can be infix or prefix, and the rest are always infix operators. Operators that begin with <code>!</code>, except <code>!=</code>, and the operator <code>~</code>, or repeated sequences of<code>~</code>, are always prefix operators. The operators <code>+</code>, <code>-</code>, <code>+.</code>, <code>-.</code>, <code>&amp;</code>, <code>&amp;&amp;</code>, <code>%</code>, and <code>%%</code> can be prefix operators or infix operators. You distinguish the prefix version of these operators from the infix version by adding a <code>~</code> at the beginning of a prefix operator when it is defined. The <code>~</code> is not used when you use the operator, only when it is defined.</p>\n<h2 id=\"example\">Example</h2>\n<p>The following code illustrates the use of operator overloading to implement a fraction type. A fraction is represented by a numerator and a denominator. The function <code>hcf</code> is used to determine the highest common factor, which is used to reduce fractions.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Determine the highest common factor between\n// two positive integers, a helper for reducing\n// fractions.\nlet rec hcf a b =\n  if a = 0u then b\n  elif a&lt;b then hcf a (b - a)\n  else hcf (a - b) b\n\n// type Fraction: represents a positive fraction\n// (positive rational number).\ntype Fraction =\n   {\n      // n: Numerator of fraction.\n      n : uint32\n      // d: Denominator of fraction.\n      d : uint32\n   }\n\n   // Produce a string representation. If the\n   // denominator is &quot;1&quot;, do not display it.\n   override this.ToString() =\n      if (this.d = 1u)\n        then this.n.ToString()\n        else this.n.ToString() + &quot;/&quot; + this.d.ToString()\n\n   // Add two fractions.\n   static member (+) (f1 : Fraction, f2 : Fraction) =\n      let nTemp = f1.n * f2.d + f2.n * f1.d\n      let dTemp = f1.d * f2.d\n      let hcfTemp = hcf nTemp dTemp\n      { n = nTemp / hcfTemp; d = dTemp / hcfTemp }\n\n   // Adds a fraction and a positive integer.\n   static member (+) (f1: Fraction, i : uint32) =\n      let nTemp = f1.n + i * f1.d\n      let dTemp = f1.d\n      let hcfTemp = hcf nTemp dTemp\n      { n = nTemp / hcfTemp; d = dTemp / hcfTemp }\n\n   // Adds a positive integer and a fraction.\n   static member (+) (i : uint32, f2: Fraction) =\n      let nTemp = f2.n + i * f2.d\n      let dTemp = f2.d\n      let hcfTemp = hcf nTemp dTemp\n      { n = nTemp / hcfTemp; d = dTemp / hcfTemp }\n\n   // Subtract one fraction from another.\n   static member (-) (f1 : Fraction, f2 : Fraction) =\n      if (f2.n * f1.d &gt; f1.n * f2.d)\n        then failwith &quot;This operation results in a negative number, which is not supported.&quot;\n      let nTemp = f1.n * f2.d - f2.n * f1.d\n      let dTemp = f1.d * f2.d\n      let hcfTemp = hcf nTemp dTemp\n      { n = nTemp / hcfTemp; d = dTemp / hcfTemp }\n\n   // Multiply two fractions.\n   static member (*) (f1 : Fraction, f2 : Fraction) =\n      let nTemp = f1.n * f2.n\n      let dTemp = f1.d * f2.d\n      let hcfTemp = hcf nTemp dTemp\n      { n = nTemp / hcfTemp; d = dTemp / hcfTemp }\n\n   // Divide two fractions.\n   static member (/) (f1 : Fraction, f2 : Fraction) =\n      let nTemp = f1.n * f2.d\n      let dTemp = f2.n * f1.d\n      let hcfTemp = hcf nTemp dTemp\n      { n = nTemp / hcfTemp; d = dTemp / hcfTemp }\n\n   // A full set of operators can be quite lengthy. For example,\n   // consider operators that support other integral data types,\n   // with fractions, on the left side and the right side for each.\n   // Also consider implementing unary operators.\n\nlet fraction1 = { n = 3u; d = 4u }\nlet fraction2 = { n = 1u; d = 2u }\nlet result1 = fraction1 + fraction2\nlet result2 = fraction1 - fraction2\nlet result3 = fraction1 * fraction2\nlet result4 = fraction1 / fraction2\nlet result5 = fraction1 + 1u\nprintfn &quot;%s + %s = %s&quot; (fraction1.ToString()) (fraction2.ToString()) (result1.ToString())\nprintfn &quot;%s - %s = %s&quot; (fraction1.ToString()) (fraction2.ToString()) (result2.ToString())\nprintfn &quot;%s * %s = %s&quot; (fraction1.ToString()) (fraction2.ToString()) (result3.ToString())\nprintfn &quot;%s / %s = %s&quot; (fraction1.ToString()) (fraction2.ToString()) (result4.ToString())\nprintfn &quot;%s + 1 = %s&quot; (fraction1.ToString()) (result5.ToString())\n</code></pre><p><strong>Output:</strong></p>\n<pre class=\"loading\"><code>3/4 + 1/2 = 5/4\n3/4 - 1/2 = 1/4\n3/4 * 1/2 = 3/8\n3/4 / 1/2 = 3/2\n3/4 + 1 = 7/4\n</code></pre><h2 id=\"operators-at-the-global-level\">Operators at the Global Level</h2>\n<p>You can also define operators at the global level. The following code defines an operator <code>+?</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let inline (+?) (x: int) (y: int) = x + 2*y\nprintf &quot;%d&quot; (10 +? 1)\n</code></pre><p>The output of the above code is <code>12</code>.</p>\n<p>You can redefine the regular arithmetic operators in this manner because the scoping rules for F# dictate that newly defined operators take precedence over the built-in operators.</p>\n<p>The keyword <code>inline</code> is often used with global operators, which are often small functions that are best integrated into the calling code. Making operator functions inline also enables them to work with statically resolved type parameters to produce statically resolved generic code. For more information, see <a href=\"functions/inline-functions\" data-linktype=\"relative-path\">Inline Functions</a> and <a href=\"generics/statically-resolved-type-parameters\" data-linktype=\"relative-path\">Statically Resolved Type Parameters</a>.</p>\n<h2 id=\"see-also\">See Also</h2>\n<p><a href=\"members/index\" data-linktype=\"relative-path\">Members</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc.json\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"019277ed-f649-4fa5-ad43-097865f449d9\">\r\n<meta name=\"description\" content=\"Operator Overloading (F#)\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming\">\r\n<meta name=\"ms.topic\" content=\"language-reference\">\r\n<meta name=\"ms.date\" content=\"05/16/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-21 01:42 AM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/operator-overloading.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/fsharp/language-reference/operator-overloading.md\">\r\n<meta name=\"document_id\" content=\"4711905b-7c5a-2f23-2366-a3e110df6fec\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Operator Overloading (F#) | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"019277ed-f649-4fa5-ad43-097865f449d9","description":"Operator Overloading (F#)","keywords":"visual f#, f#, functional programming","ms.topic":"language-reference","ms.date":"05/16/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Jared Hester","author_email":"jared.hester@gmail.com","committer_name":"Phillip Carter","comitter_email":"phillip.carter@outlook.com","message":"custom operators using `?` (#1291)","commit_sha":"0761d4c1bd5c743d16d9217946d05a9f99879595","commit_date":"2016-11-29 19:00:22 -0800"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Move snippets to snippets folder, now with some F# (#904)","commit_sha":"37fe2b89d590509e8eb14342da988f15862a9e2b","commit_date":"2016-08-13 16:40:56 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize F# snippets (#903)","commit_sha":"6ea1cf8f3779532a9ed8fbdac32592fbb809443c","commit_date":"2016-08-13 15:14:41 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"F# Docs: Update intro, move files, rename language reference for better URLS (#902)","commit_sha":"70a10b9c3e21291c96d927d13f8710d9e0738d4c","commit_date":"2016-08-13 11:22:39 -0700"}],"updated_at":"2017-03-21 01:42 AM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/cloudRoutine","display_name":"Jared Hester","id":"680051"}],"update_at":"3/21/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/operator-overloading.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/fsharp/language-reference/operator-overloading.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/language-reference/operator-overloading.md","document_id":"4711905b-7c5a-2f23-2366-a3e110df6fec","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/fsharp/language-reference/operator-overloading","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Operator Overloading (F#)","_op_displayDate":"2016-5-16","_op_displayDate_source":"2016-05-16T00:00:00Z","_op_wordCount":1544,"_op_rawTitle":"<h1 id=\"operator-overloading\" sourcefile=\"docs/fsharp/language-reference/operator-overloading.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Operator Overloading</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/fsharp/language-reference/operator-overloading","fileRelativePath":"articles/fsharp/language-reference/operator-overloading.html"},"themesRelativePathToOutputRoot":"_themes/"}