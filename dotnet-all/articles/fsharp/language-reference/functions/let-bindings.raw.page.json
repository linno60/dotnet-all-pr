{"content":"<div><div class=\"content\">\n<p>A <em>binding</em> associates an identifier with a value or function. You use the <code>let</code> keyword to bind a name to a value or function.</p>\n<h2 id=\"syntax\">Syntax</h2>\n<pre class=\"loading\"><code class=\"lang-fsharp\">// Binding a value:\nlet identifier-or-pattern [: type] =expressionbody-expression\n// Binding a function value:\nlet identifier parameter-list [: return-type ] =expressionbody-expression\n</code></pre><h2 id=\"remarks\">Remarks</h2>\n<p>The <code>let</code> keyword is used in binding expressions to define values or function values for one or more names. The simplest form of the <code>let</code> expression binds a name to a simple value, as follows.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let i = 1\n</code></pre><p>If you separate the expression from the identifier by using a new line, you must indent each line of the expression, as in the following code.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let someVeryLongIdentifier =\n    // Note indentation below.\n    3 * 4 + 5 * 6\n</code></pre><p>Instead of just a name, a pattern that contains names can be specified, for example, a tuple, as shown in the following code.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let i, j, k = (1, 2, 3)\n</code></pre><p>The <em>body-expression</em> is the expression in which the names are used. The body expression appears on its own line, indented to line up exactly with the first character in the <code>let</code> keyword:</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let result =\n\n    let i, j, k = (1, 2, 3)\n\n    // Body expression:\n    i + 2*j + 3*k\n</code></pre><p>A <code>let</code> binding can appear at the module level, in the definition of a class type, or in local scopes, such as in a function definition. A <code>let</code> binding at the top level in a module or in a class type does not need to have a body expression, but at other scope levels, the body expression is required. The bound names are usable after the point of definition, but not at any point before the <code>let</code> binding appears, as is illustrated in the following code.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Error:\nprintfn &quot;%d&quot; x\nlet x = 100\n// OK:\nprintfn &quot;%d&quot; x\n</code></pre><h2 id=\"function-bindings\">Function Bindings</h2>\n<p>Function bindings follow the rules for value bindings, except that function bindings include the function name and the parameters, as shown in the following code.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let function1 a =\n    a + 1\n</code></pre><p>In general, parameters are patterns, such as a tuple pattern:</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let function2 (a, b) = a + b\n</code></pre><p>A <code>let</code> binding expression evaluates to the value of the last expression. Therefore, in the following code example, the value of <code>result</code> is computed from <code>100 * function3 (1, 2)</code>, which evaluates to <code>300</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let result =\n    let function3 (a, b) = a + b\n    100 * function3 (1, 2)\n</code></pre><p>For more information, see <a href=\"index\" data-linktype=\"relative-path\">Functions</a>.</p>\n<h2 id=\"type-annotations\">Type Annotations</h2>\n<p>You can specify types for parameters by including a colon (:) followed by a type name, all enclosed in parentheses. You can also specify the type of the return value by appending the colon and type after the last parameter. The full type annotations for <code>function1</code>, with integers as the parameter types, would be as follows.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let function1 (a: int) : int = a + 1\n</code></pre><p>When there are no explicit type parameters, type inference is used to determine the types of parameters of functions. This can include automatically generalizing the type of a parameter to be generic.</p>\n<p>For more information, see <a href=\"../generics/automatic-generalization\" data-linktype=\"relative-path\">Automatic Generalization</a> and <a href=\"../type-inference\" data-linktype=\"relative-path\">Type Inference</a>.</p>\n<h2 id=\"let-bindings-in-classes\">let Bindings in Classes</h2>\n<p>A <code>let</code> binding can appear in a class type but not in a structure or record type. To use a let binding in a class type, the class must have a primary constructor. Constructor parameters must appear after the type name in the class definition. A <code>let</code> binding in a class type defines private fields and members for that class type and, together with <code>do</code> bindings in the type, forms the code for the primary constructor for the type. The following code examples show a class <code>MyClass</code> with private fields <code>field1</code> and <code>field2</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type MyClass(a) =\n    let field1 = a\n    let field2 = &quot;text&quot;\n    do printfn &quot;%d %s&quot; field1 field2\n    member this.F input =\n        printfn &quot;Field1 %d Field2 %s Input %A&quot; field1 field2 input\n</code></pre><p>The scopes of <code>field1</code> and <code>field2</code> are limited to the type in which they are declared. For more information, see <a href=\"../members/let-bindings-in-classes\" data-linktype=\"relative-path\"><code>let</code> Bindings in Classes</a> and <a href=\"../classes\" data-linktype=\"relative-path\">Classes</a>.</p>\n<h2 id=\"type-parameters-in-let-bindings\">Type Parameters in let Bindings</h2>\n<p>A <code>let</code> binding at the module level, in a type, or in a computation expression can have explicit type parameters. A let binding in an expression, such as within a function definition, cannot have type parameters. For more information, see <a href=\"../generics/index\" data-linktype=\"relative-path\">Generics</a>.</p>\n<h2 id=\"attributes-on-let-bindings\">Attributes on let Bindings</h2>\n<p>Attributes can be applied to top-level <code>let</code> bindings in a module, as shown in the following code.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">[&lt;Obsolete&gt;]\nlet function1 x y = x + y\n</code></pre><h2 id=\"scope-and-accessibility-of-let-bindings\">Scope and Accessibility of Let Bindings</h2>\n<p>The scope of an entity declared with a let binding is limited to the portion of the containing scope (such as a function, module, file or class) after the binding appears. Therefore, it can be said that a let binding introduces a name into a scope. In a module, a let-bound value or function is accessible to clients of a module as long as the module is accessible, since the let bindings in a module are compiled into public functions of the module. By contrast, let bindings in a class are private to the class.</p>\n<p>Normally, functions in modules must be qualified by the name of the module when used by client code. For example, if a module <code>Module1</code> has a function <code>function1</code>, users would specify <code>Module1.function1</code> to refer to the function.</p>\n<p>Users of a module may use an import declaration to make the functions within that module available for use without being qualified by the module name. In the example just mentioned, users of the module can in that case open the module by using the import declaration open <code>Module1</code> and thereafter refer to <code>function1</code> directly.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">module Module1 =\n    let function1 x = x + 1.0\n\nmodule Module2 =\n    let function2 x =\n        Module1.function1 x\n\nopen Module1\n\nlet function3 x =\n    function1 x\n</code></pre><p>Some modules have the attribute <a href=\"https://msdn.microsoft.com/library/8b9b6ade-0471-4413-ac5d-638cd0de5f15\" data-linktype=\"external\">RequireQualifiedAccess</a>, which means that the functions that they expose must be qualified with the name of the module. For example, the F# List module has this attribute.</p>\n<p>For more information on modules and access control, see <a href=\"../modules\" data-linktype=\"relative-path\">Modules</a> and <a href=\"../access-control\" data-linktype=\"relative-path\">Access Control</a>.</p>\n<h2 id=\"see-also\">See Also</h2>\n<p><a href=\"index\" data-linktype=\"relative-path\">Functions</a></p>\n<p><a href=\"../members/let-bindings-in-classes\" data-linktype=\"relative-path\"><code>let</code> Bindings in Classes</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"bee69edc-d5ae-46bd-8b56-f02d97725d0d\">\r\n<meta name=\"description\" content=\"let Bindings (F#)\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming\">\r\n<meta name=\"ms.topic\" content=\"language-reference\">\r\n<meta name=\"ms.date\" content=\"05/16/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/functions/let-bindings.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/functions/let-bindings.md\">\r\n<meta name=\"document_id\" content=\"dd36c271-b9d6-156d-1df9-6d347431658d\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../../toc2.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","title":"let Bindings (F#) | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"bee69edc-d5ae-46bd-8b56-f02d97725d0d","description":"let Bindings (F#)","keywords":"visual f#, f#, functional programming","ms.topic":"language-reference","ms.date":"05/16/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Move snippets to snippets folder, now with some F# (#904)","commit_sha":"37fe2b89d590509e8eb14342da988f15862a9e2b","commit_date":"2016-08-13 16:40:56 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize F# snippets (#903)","commit_sha":"6ea1cf8f3779532a9ed8fbdac32592fbb809443c","commit_date":"2016-08-13 15:14:41 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"F# Docs: Update intro, move files, rename language reference for better URLS (#902)","commit_sha":"70a10b9c3e21291c96d927d13f8710d9e0738d4c","commit_date":"2016-08-13 11:22:39 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/functions/let-bindings.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/functions/let-bindings.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/language-reference/functions/let-bindings.md","document_id":"dd36c271-b9d6-156d-1df9-6d347431658d","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/let-bindings","toc_asset_id":"articles/toc.json","toc_rel":"../../../toc.json","_op_ogTitle":"let Bindings (F#)","_op_displayDate":"2016-5-16","_op_displayDate_source":"2016-05-16T00:00:00Z","_op_wordCount":1021,"_op_rawTitle":"<h1 id=\"let-bindings\" sourcefile=\"docs/fsharp/language-reference/functions/let-bindings.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">let Bindings</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/let-bindings","fileRelativePath":"articles/fsharp/language-reference/functions/let-bindings.html"},"themesRelativePathToOutputRoot":"_themes/"}