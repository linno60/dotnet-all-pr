{"content":"<div><div class=\"content\">\n<p><em>Interfaces</em> specify sets of related members that other classes implement.</p>\n<h2 id=\"syntax\">Syntax</h2>\n<pre class=\"loading\"><code class=\"lang-fsharp\">// Interface declaration:\n[ attributes ]\ntype interface-name =\n    [ interface ]     [ inherit base-interface-name ...]\n    abstract member1 : [ argument-types1 -&gt; ] return-type1\n    abstract member2 : [ argument-types2 -&gt; ] return-type2\n    ...\n[ end ]\n\n// Implementing, inside a class type definition:\ninterface interface-name with\n    member self-identifier.member1argument-list = method-body1\n    member self-identifier.member2argument-list = method-body2\n\n// Implementing, by using an object expression:\n[ attributes ]\nlet class-name (argument-list) =\n    { new interface-name with\n        member self-identifier.member1argument-list = method-body1\n        member self-identifier.member2argument-list = method-body2\n        [ base-interface-definitions ]\n    }\n    member-list\n</code></pre><h2 id=\"remarks\">Remarks</h2>\n<p>Interface declarations resemble class declarations except that no members are implemented. Instead, all the members are abstract, as indicated by the keyword <code>abstract</code>. You do not provide a method body for abstract methods. However, you can provide a default implementation by also including a separate definition of the member as a method together with the <code>default</code> keyword. Doing so is equivalent to creating a virtual method in a base class in other .NET languages. Such a virtual method can be overridden in classes that implement the interface.</p>\n<p>You can optionally give each method parameter a name using normal F# syntax:</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type ISprintable =\n    abstract member Print : format:string -&gt; unit\n</code></pre><p>In the above <code>ISprintable</code> example, the <code>Print</code> method has a single parameter of the type <code>string</code> with the name <code>format</code>.</p>\n<p>There are two ways to implement interfaces: by using object expressions, and by using class types. In either case, the class type or object expression provides method bodies for abstract methods of the interface. Implementations are specific to each type that implements the interface. Therefore, interface methods on different types might be different from each other.</p>\n<p>The keywords <code>interface</code> and <code>end</code>, which mark the start and end of the definition, are optional when you use lightweight syntax. If you do not use these keywords, the compiler attempts to infer whether the type is a class or an interface by analyzing the constructs that you use. If you define a member or use other class syntax, the type is interpreted as a class.</p>\n<p>The .NET coding style is to begin all interfaces with a capital <code>I</code>.</p>\n<h2 id=\"implementing-interfaces-by-using-class-types\">Implementing Interfaces by Using Class Types</h2>\n<p>You can implement one or more interfaces in a class type by using the <code>interface</code> keyword, the name of the interface, and the <code>with</code> keyword, followed by the interface member definitions, as shown in the following code.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type IPrintable =\n   abstract member Print : unit -&gt; unit\n\ntype SomeClass1(x: int, y: float) =\n   interface IPrintable with\n      member this.Print() = printfn &quot;%d %f&quot; x y\n</code></pre><p>Interface implementations are inherited, so any derived classes do not need to reimplement them.</p>\n<h2 id=\"calling-interface-methods\">Calling Interface Methods</h2>\n<p>Interface methods can be called only through the interface, not through any object of the type that implements the interface. Thus, you might have to upcast to the interface type by using the <code>:&gt;</code> operator or the <code>upcast</code> operator in order to call these methods.</p>\n<p>To call the interface method when you have an object of type <code>SomeClass</code>, you must upcast the object to the interface type, as shown in the following code.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let x1 = new SomeClass1(1, 2.0)\n(x1 :&gt; IPrintable).Print()\n</code></pre><p>An alternative is to declare a method on the object that upcasts and calls the interface method, as in the following example.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type SomeClass2(x: int, y: float) =\n   member this.Print() = (this :&gt; IPrintable).Print()\n   interface IPrintable with\n      member this.Print() = printfn &quot;%d %f&quot; x y\n\nlet x2 = new SomeClass2(1, 2.0)\nx2.Print()\n</code></pre><h2 id=\"implementing-interfaces-by-using-object-expressions\">Implementing Interfaces by Using Object Expressions</h2>\n<p>Object expressions provide a short way to implement an interface. They are useful when you do not have to create a named type, and you just want an object that supports the interface methods, without any additional methods. An object expression is illustrated in the following code.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let makePrintable(x: int, y: float) =\n    { new IPrintable with\n              member this.Print() = printfn &quot;%d %f&quot; x y }\nlet x3 = makePrintable(1, 2.0)\nx3.Print()\n</code></pre><h2 id=\"interface-inheritance\">Interface Inheritance</h2>\n<p>Interfaces can inherit from one or more base interfaces.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type Interface1 =\n    abstract member Method1 : int -&gt; int\n\ntype Interface2 =\n    abstract member Method2 : int -&gt; int\n\ntype Interface3 =\n    inherit Interface1\n    inherit Interface2\n    abstract member Method3 : int -&gt; int\n\ntype MyClass() =\n    interface Interface3 with\n        member this.Method1(n) = 2 * n\n        member this.Method2(n) = n + 100\n        member this.Method3(n) = n / 10\n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p><a href=\"index\" data-linktype=\"relative-path\">F# Language Reference</a></p>\n<p><a href=\"object-expressions\" data-linktype=\"relative-path\">Object Expressions</a></p>\n<p><a href=\"classes\" data-linktype=\"relative-path\">Classes</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"3a082459-17d4-45cf-9153-0b7550a154ec\">\r\n<meta name=\"description\" content=\"Interfaces (F#)\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming\">\r\n<meta name=\"ms.topic\" content=\"language-reference\">\r\n<meta name=\"ms.date\" content=\"05/16/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/interfaces.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/interfaces.md\">\r\n<meta name=\"document_id\" content=\"409f92b7-b9ad-f83f-5470-e39202b2000a\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Interfaces (F#) | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"3a082459-17d4-45cf-9153-0b7550a154ec","description":"Interfaces (F#)","keywords":"visual f#, f#, functional programming","ms.topic":"language-reference","ms.date":"05/16/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Move snippets to snippets folder, now with some F# (#904)","commit_sha":"37fe2b89d590509e8eb14342da988f15862a9e2b","commit_date":"2016-08-13 16:40:56 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize F# snippets (#903)","commit_sha":"6ea1cf8f3779532a9ed8fbdac32592fbb809443c","commit_date":"2016-08-13 15:14:41 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"F# Docs: Update intro, move files, rename language reference for better URLS (#902)","commit_sha":"70a10b9c3e21291c96d927d13f8710d9e0738d4c","commit_date":"2016-08-13 11:22:39 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/interfaces.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/interfaces.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/language-reference/interfaces.md","document_id":"409f92b7-b9ad-f83f-5470-e39202b2000a","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/fsharp/language-reference/interfaces","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Interfaces (F#)","_op_displayDate":"2016-5-16","_op_displayDate_source":"2016-05-16T00:00:00Z","_op_wordCount":714,"_op_rawTitle":"<h1 id=\"interfaces\" sourcefile=\"docs/fsharp/language-reference/interfaces.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Interfaces</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/fsharp/language-reference/interfaces","fileRelativePath":"articles/fsharp/language-reference/interfaces.html"},"themesRelativePathToOutputRoot":"_themes/"}