{"content":"<div><div class=\"content\">\n<div class=\"NOTE\"><h5>Note</h5><p>The API reference links in this article will take you to MSDN.  The docs.microsoft.com API reference is not complete.</p>\n</div>\n<p>A list in F# is an ordered, immutable series of elements of the same type. To perform basic operations on lists, use the functions in the <a href=\"https://msdn.microsoft.com/library/a2264ba3-2d45-40dd-9040-4f7aa2ad9788\" data-linktype=\"external\">List module</a>.</p>\n<h2 id=\"creating-and-initializing-lists\">Creating and Initializing Lists</h2>\n<p>You can define a list by explicitly listing out the elements, separated by semicolons and enclosed in square brackets, as shown in the following line of code.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let list123 = [ 1; 2; 3 ]\n</code></pre><p>You can also put line breaks between elements, in which case the semicolons are optional. The latter syntax can result in more readable code when the element initialization expressions are longer, or when you want to include a comment for each element.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let list123 = [\n    1\n    2\n    3 ]\n</code></pre><p>Normally, all list elements must be the same type. An exception is that a list in which the elements are specified to be a base type can have elements that are derived types. Thus the following is acceptable, because both <code>Button</code> and <code>CheckBox</code> derive from <code>Control</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let myControlList : Control list = [ new Button(); new CheckBox() ]\n</code></pre><p>You can also define list elements by using a range indicated by integers separated by the range operator (<code>..</code>), as shown in the following code.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let list1 = [ 1 .. 10 ]\n</code></pre><p>An empty list is specified by a pair of square brackets with nothing in between them.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// An empty list.\nlet listEmpty = []\n</code></pre><p>You can also use a sequence expression to create a list. See <a href=\"sequences#sequence-expressions\" data-linktype=\"relative-path\">Sequence Expressions</a> for more information. For example, the following code creates a list of squares of integers from 1 to 10.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let listOfSquares = [ for i in 1 .. 10 -&gt; i*i ]\n</code></pre><h2 id=\"operators-for-working-with-lists\">Operators for Working with Lists</h2>\n<p>You can attach elements to a list by using the <code>::</code> (cons) operator. If <code>list1</code> is <code>[2; 3; 4]</code>, the following code creates <code>list2</code> as <code>[100; 2; 3; 4]</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let list2 = 100 :: list1\n</code></pre><p>You can concatenate lists that have compatible types by using the <code>@</code> operator, as in the following code. If <code>list1</code> is <code>[2; 3; 4]</code> and <code>list2</code> is <code>[100; 2; 3; 4 ]</code>, this code creates <code>list3</code> as <code>[2; 3; 4; 100; 2; 3; 4]</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let list3 = list1 @ list2\n</code></pre><p>Functions for performing operations on lists are available in the <a href=\"https://msdn.microsoft.com/library/a2264ba3-2d45-40dd-9040-4f7aa2ad9788\" data-linktype=\"external\">List module</a>.</p>\n<p>Because lists in F# are immutable, any modifying operations generate new lists instead of modifying existing lists.</p>\n<p>Lists in F# are implemented as singly linked lists, which means that operations that access only the head of the list are O(1), and element access is O(<em>n</em>).</p>\n<h2 id=\"properties\">Properties</h2>\n<p>The list type supports the following properties:</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/5f9414fd-6bdb-470a-8b72-40016db30740\" data-linktype=\"external\">Head</a></td>\n<td><code>&#39;T</code></td>\n<td>The first element.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/44406ecb-1918-4d32-b32a-ca1f69840386\" data-linktype=\"external\">Empty</a></td>\n<td><code>&#39;T list</code></td>\n<td>A static property that returns an empty list of the appropriate type.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/3ba087b2-2fc2-406d-b10a-cff6a19322da\" data-linktype=\"external\">IsEmpty</a></td>\n<td><code>bool</code></td>\n<td><code>true</code> if the list has no elements.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/bdb2553a-0e54-4ff8-baed-ab1aac8f5dae\" data-linktype=\"external\">Item</a></td>\n<td><code>&#39;T</code></td>\n<td>The element at the specified index (zero-based).</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/25f715c8-9daa-4c4d-a6c7-26772f9dab4d\" data-linktype=\"external\">Length</a></td>\n<td><code>int</code></td>\n<td>The number of elements.</td>\n</tr>\n<tr>\n<td><a href=\"https://msdn.microsoft.com/library/2a6f8eb9-dc32-41aa-8b62-2baffaface91\" data-linktype=\"external\">Tail</a></td>\n<td><code>&#39;T list</code></td>\n<td>The list without the first element.</td>\n</tr>\n</tbody>\n</table>\n<p>Following are some examples of using these properties.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let list1 = [ 1; 2; 3 ]\n\n// Properties\nprintfn &quot;list1.IsEmpty is %b&quot; (list1.IsEmpty)\nprintfn &quot;list1.Length is %d&quot; (list1.Length)\nprintfn &quot;list1.Head is %d&quot; (list1.Head)\nprintfn &quot;list1.Tail.Head is %d&quot; (list1.Tail.Head)\nprintfn &quot;list1.Tail.Tail.Head is %d&quot; (list1.Tail.Tail.Head)\nprintfn &quot;list1.Item(1) is %d&quot; (list1.Item(1))\n</code></pre><h2 id=\"using-lists\">Using Lists</h2>\n<p>Programming with lists enables you to perform complex operations with a small amount of code. This section describes common operations on lists that are important to functional programming.</p>\n<h3 id=\"recursion-with-lists\">Recursion with Lists</h3>\n<p>Lists are uniquely suited to recursive programming techniques. Consider an operation that must be performed on every element of a list. You can do this recursively by operating on the head of the list and then passing the tail of the list, which is a smaller list that consists of the original list without the first element, back again to the next level of recursion.</p>\n<p>To write such a recursive function, you use the cons operator (<code>::</code>) in pattern matching, which enables you to separate the head of a list from the tail.</p>\n<p>The following code example shows how to use pattern matching to implement a recursive function that performs operations on a list.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let rec sum list =\n   match list with\n   | head :: tail -&gt; head + sum tail\n   | [] -&gt; 0\n</code></pre><p>The previous code works well for small lists, but for larger lists, it could overflow the stack. The following code improves on this code by using an accumulator argument, a standard technique for working with recursive functions. The use of the accumulator argument makes the function tail recursive, which saves stack space.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let sum list =\n   let rec loop list acc =\n       match list with\n       | head :: tail -&gt; loop tail (acc + head)\n       | [] -&gt; acc\n   loop list 0\n</code></pre><p>The function <code>RemoveAllMultiples</code> is a recursive function that takes two lists. The first list contains the numbers whose multiples will be removed, and the second list is the list from which to remove the numbers. The code in the following example uses this recursive function to eliminate all the non-prime numbers from a list, leaving a list of prime numbers as the result.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let IsPrimeMultipleTest n x =\n   x = n || x % n &lt;&gt; 0\n\nlet rec RemoveAllMultiples listn listx =\n   match listn with\n   | head :: tail -&gt; RemoveAllMultiples tail (List.filter (IsPrimeMultipleTest head) listx)\n   | [] -&gt; listx\n\n\nlet GetPrimesUpTo n =\n    let max = int (sqrt (float n))\n    RemoveAllMultiples [ 2 .. max ] [ 1 .. n ]\n\nprintfn &quot;Primes Up To %d:\\n %A&quot; 100 (GetPrimesUpTo 100)\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>Primes Up To 100:\n[2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47; 53; 59; 61; 67; 71; 73; 79; 83; 89; 97]\n</code></pre><h2 id=\"module-functions\">Module Functions</h2>\n<p>The <a href=\"https://msdn.microsoft.com/library/a2264ba3-2d45-40dd-9040-4f7aa2ad9788\" data-linktype=\"external\">List module</a> provides functions that access the elements of a list. The head element is the fastest and easiest to access. Use the property <a href=\"https://msdn.microsoft.com/library/5f9414fd-6bdb-470a-8b72-40016db30740\" data-linktype=\"external\">Head</a> or the module function <a href=\"https://msdn.microsoft.com/library/22514cc5-0511-498b-a2cc-837b688a6da2\" data-linktype=\"external\">List.head</a>. You can access the tail of a list by using the <a href=\"https://msdn.microsoft.com/library/2a6f8eb9-dc32-41aa-8b62-2baffaface91\" data-linktype=\"external\">Tail</a> property or the <a href=\"https://msdn.microsoft.com/library/da0a0638-4420-4571-84b6-d09ae601f601\" data-linktype=\"external\">List.tail</a> function. To find an element by index, use the <a href=\"https://msdn.microsoft.com/library/1f717d57-89be-4007-a971-9cf5a28d83b1\" data-linktype=\"external\">List.nth</a> function. <code>List.nth</code> traverses the list. Therefore, it is O(<em>n</em>). If your code uses <code>List.nth</code> frequently, you might want to consider using an array instead of a list. Element access in arrays is O(1).</p>\n<h3 id=\"boolean-operations-on-lists\">Boolean Operations on Lists</h3>\n<p>The <a href=\"https://msdn.microsoft.com/library/a7941d44-9e92-427c-b806-c378f4558107\" data-linktype=\"external\">List.isEmpty</a> function determines whether a list has any elements.</p>\n<p>The <a href=\"https://msdn.microsoft.com/library/15a3ebd5-98f0-44c0-8220-7dedec3e68a8\" data-linktype=\"external\">List.exists</a> function applies a Boolean test to elements of a list and returns <code>true</code> if any element satisfies the test. <a href=\"https://msdn.microsoft.com/library/7532b39e-3f4f-4534-a60b-d7721dc6fa7e\" data-linktype=\"external\">List.exists2</a> is similar but operates on successive pairs of elements in two lists.</p>\n<p>The following code demonstrates the use of <code>List.exists</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Use List.exists to determine whether there is an element of a list satisfies a given Boolean expression.\n// containsNumber returns true if any of the elements of the supplied list match\n// the supplied number.\nlet containsNumber number list = List.exists (fun elem -&gt; elem = number) list\nlet list0to3 = [0 .. 3]\nprintfn &quot;For list %A, contains zero is %b&quot; list0to3 (containsNumber 0 list0to3)\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>For list [0; 1; 2; 3], contains zero is true\n</code></pre><p>The following example demonstrates the use of <code>List.exists2</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Use List.exists2 to compare elements in two lists.\n// isEqualElement returns true if any elements at the same position in two supplied\n// lists match.\nlet isEqualElement list1 list2 = List.exists2 (fun elem1 elem2 -&gt; elem1 = elem2) list1 list2\nlet list1to5 = [ 1 .. 5 ]\nlet list5to1 = [ 5 .. -1 .. 1 ]\nif (isEqualElement list1to5 list5to1) then\n    printfn &quot;Lists %A and %A have at least one equal element at the same position.&quot; list1to5 list5to1\nelse\n    printfn &quot;Lists %A and %A do not have an equal element at the same position.&quot; list1to5 list5to1\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>Lists [1; 2; 3; 4; 5] and [5; 4; 3; 2; 1] have at least one equal element at the same position.\n</code></pre><p>You can use <a href=\"https://msdn.microsoft.com/library/e11a5233-d612-40ac-833b-d5cf496900b7\" data-linktype=\"external\">List.forall</a> if you want to test whether all the elements of a list meet a condition.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let isAllZeroes list = List.forall (fun elem -&gt; elem = 0.0) list\nprintfn &quot;%b&quot; (isAllZeroes [0.0; 0.0])\nprintfn &quot;%b&quot; (isAllZeroes [0.0; 1.0])\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>true\nfalse\n</code></pre><p>Similarly, <a href=\"https://msdn.microsoft.com/library/bb611f02-8277-48f5-9af3-6194ae27d07e\" data-linktype=\"external\">List.forall2</a> determines whether all elements in the corresponding positions in two lists satisfy a Boolean expression that involves each pair of elements.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let listEqual list1 list2 = List.forall2 (fun elem1 elem2 -&gt; elem1 = elem2) list1 list2\nprintfn &quot;%b&quot; (listEqual [0; 1; 2] [0; 1; 2])\nprintfn &quot;%b&quot; (listEqual [0; 0; 0] [0; 1; 0])\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>true\nfalse\n</code></pre><h3 id=\"sort-operations-on-lists\">Sort Operations on Lists</h3>\n<p>The <a href=\"https://msdn.microsoft.com/library/17f1030e-aa7e-41dd-94ea-72cb6c04fd3d\" data-linktype=\"external\">List.sort</a>, <a href=\"https://msdn.microsoft.com/library/955bfc5f-ad9c-4f2d-a7ab-91e43eb21359\" data-linktype=\"external\">List.sortBy</a>, and <a href=\"https://msdn.microsoft.com/library/1d806a54-9166-4198-906d-15101f7916c7\" data-linktype=\"external\">List.sortWith</a> functions sort lists. The sorting function determines which of these three functions to use. <code>List.sort</code> uses default generic comparison. Generic comparison uses global operators based on the generic compare function to compare values. It works efficiently with a wide variety of element types, such as simple numeric types, tuples, records, discriminated unions, lists, arrays, and any type that implements <code>System.IComparable</code>. For types that implement <code>System.IComparable</code>, generic comparison uses the <code>System.IComparable.CompareTo()</code> function. Generic comparison also works with strings, but uses a culture-independent sorting order. Generic comparison should not be used on unsupported types, such as function types. Also, the performance of the default generic comparison is best for small structured types; for larger structured types that need to be compared and sorted frequently, consider implementing <code>System.IComparable</code> and providing an efficient implementation of the <code>System.IComparable.CompareTo()</code> method.</p>\n<p><code>List.sortBy</code> takes a function that returns a value that is used as the sort criterion, and <code>List.sortWith</code> takes a comparison function as an argument. These latter two functions are useful when you are working with types that do not support comparison, or when the comparison requires more complex comparison semantics, as in the case of culture-aware strings.</p>\n<p>The following example demonstrates the use of <code>List.sort</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let sortedList1 = List.sort [1; 4; 8; -2; 5]\nprintfn &quot;%A&quot; sortedList1\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>[-2; 1; 4; 5; 8]\n</code></pre><p>The following example demonstrates the use of <code>List.sortBy</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let sortedList2 = List.sortBy (fun elem -&gt; abs elem) [1; 4; 8; -2; 5]\nprintfn &quot;%A&quot; sortedList2\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>[1; -2; 4; 5; 8]\n</code></pre><p>The next example demonstrates the use of <code>List.sortWith</code>. In this example, the custom comparison function <code>compareWidgets</code> is used to first compare one field of a custom type, and then another when the values of the first field are equal.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type Widget = { ID: int; Rev: int }\n\nlet compareWidgets widget1 widget2 =\n   if widget1.ID &lt; widget2.ID then -1 else\n   if widget1.ID &gt; widget2.ID then 1 else\n   if widget1.Rev &lt; widget2.Rev then -1 else\n   if widget1.Rev &gt; widget2.Rev then 1 else\n   0\n\nlet listToCompare = [\n    { ID = 92; Rev = 1 }\n    { ID = 110; Rev = 1 }\n    { ID = 100; Rev = 5 }\n    { ID = 100; Rev = 2 }\n    { ID = 92; Rev = 1 }\n    ]\n\nlet sortedWidgetList = List.sortWith compareWidgets listToCompare\nprintfn &quot;%A&quot; sortedWidgetList\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>[{ID = 92;\nRev = 1;}; {ID = 92;\nRev = 1;}; {ID = 100;\nRev = 2;}; {ID = 100;\nRev = 5;}; {ID = 110;\nRev = 1;}]\n</code></pre><h3 id=\"search-operations-on-lists\">Search Operations on Lists</h3>\n<p>Numerous search operations are supported for lists. The simplest, <a href=\"https://msdn.microsoft.com/library/0594593e-9c75-44c1-8f5a-a37b2e561c06\" data-linktype=\"external\">List.find</a>, enables you to find the first element that matches a given condition.</p>\n<p>The following code example demonstrates the use of <code>List.find</code> to find the first number that is divisible by 5 in a list.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let isDivisibleBy number elem = elem % number = 0\nlet result = List.find (isDivisibleBy 5) [ 1 .. 100 ]\nprintfn &quot;%d &quot; result\n</code></pre><p>The result is 5.</p>\n<p>If the elements must be transformed first, call <a href=\"https://msdn.microsoft.com/library/0430b515-7fe4-49a1-a616-d2286d8b08b2\" data-linktype=\"external\">List.pick</a>, which takes a function that returns an option, and looks for the first option value that is <code>Some(x)</code>. Instead of returning the element, <code>List.pick</code> returns the result <code>x</code>. If no matching element is found, <code>List.pick</code> throws <code>System.Collections.Generic.KeyNotFoundException</code>. The following code shows the use of <code>List.pick</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let valuesList = [ (&quot;a&quot;, 1); (&quot;b&quot;, 2); (&quot;c&quot;, 3) ]\n\nlet resultPick = List.pick (fun elem -&gt;\n                    match elem with\n                    | (value, 2) -&gt; Some value\n                    | _ -&gt; None) valuesList\nprintfn &quot;%A&quot; resultPick\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>&quot;b&quot;\n</code></pre><p>Another group of search operations, <a href=\"https://msdn.microsoft.com/library/37f4532e-9fd0-4802-8bbd-e1aa2380287d\" data-linktype=\"external\">List.tryFind</a> and related functions, return an option value. The <code>List.tryFind</code> function returns the first element of a list that satisfies a condition if such an element exists, but the option value <code>None</code> if not. The variation <a href=\"https://msdn.microsoft.com/library/5e31968c-c3d3-43d2-859a-0526825895ec\" data-linktype=\"external\">List.tryFindIndex</a> returns the index of the element, if one is found, rather than the element itself. These functions are illustrated in the following code.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let list1d = [1; 3; 7; 9; 11; 13; 15; 19; 22; 29; 36]\nlet isEven x = x % 2 = 0\nmatch List.tryFind isEven list1d with\n| Some value -&gt; printfn &quot;The first even value is %d.&quot; value\n| None -&gt; printfn &quot;There is no even value in the list.&quot;\n\nmatch List.tryFindIndex isEven list1d with\n| Some value -&gt; printfn &quot;The first even value is at position %d.&quot; value\n| None -&gt; printfn &quot;There is no even value in the list.&quot;\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>The first even value is 22.\nThe first even value is at position 8.\n</code></pre><h3 id=\"arithmetic-operations-on-lists\">Arithmetic Operations on Lists</h3>\n<p>Common arithmetic operations such as sum and average are built into the <a href=\"https://msdn.microsoft.com/library/a2264ba3-2d45-40dd-9040-4f7aa2ad9788\" data-linktype=\"external\">List module</a>. To work with <a href=\"https://msdn.microsoft.com/library/54d47fe3-5ecf-4883-beb5-e915342a17f9\" data-linktype=\"external\">List.sum</a>, the list element type must support the <code>+</code> operator and have a zero value. All built-in arithmetic types satisfy these conditions. To work with <a href=\"https://msdn.microsoft.com/library/2b9a627b-106d-4548-8c4c-ab5058b8f8e1\" data-linktype=\"external\">List.average</a>, the element type must support division without a remainder, which excludes integral types but allows for floating point types. The <a href=\"https://msdn.microsoft.com/library/b7623389-0fe1-4762-9c67-51079903ab7d\" data-linktype=\"external\">List.sumBy</a> and <a href=\"https://msdn.microsoft.com/library/936cc9ec-62af-464d-8726-7999c2f48403\" data-linktype=\"external\">List.averageBy</a> functions take a function as a parameter, and this function&#39;s results are used to calculate the values for the sum or average.</p>\n<p>The following code demonstrates the use of <code>List.sum</code>, <code>List.sumBy</code>, and <code>List.average</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Compute the sum of the first 10 integers by using List.sum.\nlet sum1 = List.sum [1 .. 10]\n\n// Compute the sum of the squares of the elements of a list by using List.sumBy.\nlet sum2 = List.sumBy (fun elem -&gt; elem*elem) [1 .. 10]\n\n// Compute the average of the elements of a list by using List.average.\nlet avg1 = List.average [0.0; 1.0; 1.0; 2.0]\n\nprintfn &quot;%f&quot; avg1\n</code></pre><p>The output is <code>1.000000</code>.</p>\n<p>The following code shows the use of <code>List.averageBy</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let avg2 = List.averageBy (fun elem -&gt; float elem) [1 .. 10]\nprintfn &quot;%f&quot; avg2\n</code></pre><p>The output is <code>5.5</code>.</p>\n<h3 id=\"lists-and-tuples\">Lists and Tuples</h3>\n<p>Lists that contain tuples can be manipulated by zip and unzip functions. These functions combine two lists of single values into one list of tuples or separate one list of tuples into two lists of single values. The simplest <a href=\"https://msdn.microsoft.com/library/3028d790-8f48-4c94-bf08-b058bec3689c\" data-linktype=\"external\">List.zip</a> function takes two lists of single elements and produces a single list of tuple pairs. Another version, <a href=\"https://msdn.microsoft.com/library/003cc28e-0de3-4d99-89ed-cb19028e3c5b\" data-linktype=\"external\">List.zip3</a>, takes three lists of single elements and produces a single list of tuples that have three elements. The following code example demonstrates the use of <code>List.zip</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let list1 = [ 1; 2; 3 ]\nlet list2 = [ -1; -2; -3 ]\nlet listZip = List.zip list1 list2\nprintfn &quot;%A&quot; listZip\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>[(1, -1); (2, -2); (3; -3)]\n</code></pre><p>The following code example demonstrates the use of <code>List.zip3</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let list3 = [ 0; 0; 0]\nlet listZip3 = List.zip3 list1 list2 list3\nprintfn &quot;%A&quot; listZip3\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>[(1, -1, 0); (2, -2, 0); (3, -3, 0)]\n</code></pre><p>The corresponding unzip versions, <a href=\"https://msdn.microsoft.com/library/639db80c-41b5-45bb-a6b4-1eaa04d61d21\" data-linktype=\"external\">List.unzip</a> and <a href=\"https://msdn.microsoft.com/library/43078c77-32ec-4342-85b3-c31ccf984db4\" data-linktype=\"external\">List.unzip3</a>, take lists of tuples and return lists in a tuple, where the first list contains all the elements that were first in each tuple, and the second list contains the second element of each tuple, and so on.</p>\n<p>The following code example demonstrates the use of <a href=\"https://msdn.microsoft.com/library/639db80c-41b5-45bb-a6b4-1eaa04d61d21\" data-linktype=\"external\">List.unzip</a>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let lists = List.unzip [(1,2); (3,4)]\nprintfn &quot;%A&quot; lists\nprintfn &quot;%A %A&quot; (fst lists) (snd lists)\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>([1; 3], [2; 4])\n[1; 3] [2; 4]\n</code></pre><p>The following code example demonstrates the use of <a href=\"https://msdn.microsoft.com/library/43078c77-32ec-4342-85b3-c31ccf984db4\" data-linktype=\"external\">List.unzip3</a>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let listsUnzip3 = List.unzip3 [(1,2,3); (4,5,6)]\nprintfn &quot;%A&quot; listsUnzip3\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>([1; 4], [2; 5], [3; 6])\n</code></pre><h3 id=\"operating-on-list-elements\">Operating on List Elements</h3>\n<p>F# supports a variety of operations on list elements. The simplest is <a href=\"https://msdn.microsoft.com/library/f778d075-81a9-4994-af60-cddcc53a201f\" data-linktype=\"external\">List.iter</a>, which enables you to call a function on every element of a list. Variations include <a href=\"https://msdn.microsoft.com/library/ea3b7761-916c-4016-9bd8-651124c98b40\" data-linktype=\"external\">List.iter2</a>, which enables you to perform an operation on elements of two lists, <a href=\"https://msdn.microsoft.com/library/6dd21ae6-5c00-41cd-8306-821e513d8f60\" data-linktype=\"external\">List.iteri</a>, which is like <code>List.iter</code> except that the index of each element is passed as an argument to the function that is called for each element, and <a href=\"https://msdn.microsoft.com/library/9658d740-9be5-4bf7-b663-c8ab2b3e196c\" data-linktype=\"external\">List.iteri2</a>, which is a combination of the functionality of <code>List.iter2</code> and <code>List.iteri</code>. The following code example illustrates these functions.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let list1 = [1; 2; 3]\nlet list2 = [4; 5; 6]\nList.iter (fun x -&gt; printfn &quot;List.iter: element is %d&quot; x) list1\nList.iteri(fun i x -&gt; printfn &quot;List.iteri: element %d is %d&quot; i x) list1\nList.iter2 (fun x y -&gt; printfn &quot;List.iter2: elements are %d %d&quot; x y) list1 list2\nList.iteri2 (fun i x y -&gt;\n                printfn &quot;List.iteri2: element %d of list1 is %d element %d of list2 is %d&quot;\n                  i x i y)\n            list1 list2\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>List.iter: element is 1\nList.iter: element is 2\nList.iter: element is 3\nList.iteri: element 0 is 1\nList.iteri: element 1 is 2\nList.iteri: element 2 is 3\nList.iter2: elements are 1 4\nList.iter2: elements are 2 5\nList.iter2: elements are 3 6\nList.iteri2: element 0 of list1 is 1; element 0 of list2 is 4\nList.iteri2: element 1 of list1 is 2; element 1 of list2 is 5\nList.iteri2: element 2 of list1 is 3; element 2 of list2 is 6\n</code></pre><p>Another frequently used function that transforms list elements is <a href=\"https://msdn.microsoft.com/library/c6b49c99-d4f3-4ba3-b1d0-85a312683dc6\" data-linktype=\"external\">List.map</a>, which enables you to apply a function to each element of a list and put all the results into a new list. <a href=\"https://msdn.microsoft.com/library/5f48cce7-6eaf-4e54-8996-2b04d3c31e57\" data-linktype=\"external\">List.map2</a> and <a href=\"https://msdn.microsoft.com/library/dd9fb190-6980-4537-be96-5645a64908f8\" data-linktype=\"external\">List.map3</a> are variations that take multiple lists. You can also use <a href=\"https://msdn.microsoft.com/library/284b9234-3d26-409b-b328-ac79638d9e14\" data-linktype=\"external\">List.mapi</a> and <a href=\"https://msdn.microsoft.com/library/680643af-233c-40a3-82f2-43d5af27ec49\" data-linktype=\"external\">List.mapi2</a>, if, in addition to the element, the function needs to be passed the index of each element. The only difference between <code>List.mapi2</code> and <code>List.mapi</code> is that <code>List.mapi2</code> works with two lists. The following example illustrates <a href=\"https://msdn.microsoft.com/library/c6b49c99-d4f3-4ba3-b1d0-85a312683dc6\" data-linktype=\"external\">List.map</a>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let list1 = [1; 2; 3]\nlet newList = List.map (fun x -&gt; x + 1) list1\nprintfn &quot;%A&quot; newList\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>[2; 3; 4]\n</code></pre><p>The following example shows the use of <code>List.map2</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let list1 = [1; 2; 3]\nlet list2 = [4; 5; 6]\nlet sumList = List.map2 (fun x y -&gt; x + y) list1 list2\nprintfn &quot;%A&quot; sumList\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>[5; 7; 9]\n</code></pre><p>The following example shows the use of <code>List.map3</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let newList2 = List.map3 (fun x y z -&gt; x + y + z) list1 list2 [2; 3; 4]\nprintfn &quot;%A&quot; newList2\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>[7; 10; 13]\n</code></pre><p>The following example shows the use of <code>List.mapi</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let newListAddIndex = List.mapi (fun i x -&gt; x + i) list1\nprintfn &quot;%A&quot; newListAddIndex\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>[1; 3; 5]\n</code></pre><p>The following example shows the use of <code>List.mapi2</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let listAddTimesIndex = List.mapi2 (fun i x y -&gt; (x + y) * i) list1 list2\nprintfn &quot;%A&quot; listAddTimesIndex\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>[0; 7; 18]\n</code></pre><p><a href=\"https://msdn.microsoft.com/library/cd08bbc7-a3b9-40ab-8c20-4e85ec84664f\" data-linktype=\"external\">List.collect</a> is like <code>List.map</code>, except that each element produces a list and all these lists are concatenated into a final list. In the following code, each element of the list generates three numbers. These are all collected into one list.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let collectList = List.collect (fun x -&gt; [for i in 1..3 -&gt; x * i]) list1\nprintfn &quot;%A&quot; collectList\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>[1; 2; 3; 2; 4; 6; 3; 6; 9]\n</code></pre><p>You can also use <a href=\"https://msdn.microsoft.com/library/11a8c926-547b-44dd-bbae-98d44f3dd248\" data-linktype=\"external\">List.filter</a>, which takes a Boolean condition and produces a new list that consists only of elements that satisfy the given condition.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let evenOnlyList = List.filter (fun x -&gt; x % 2 = 0) [1; 2; 3; 4; 5; 6]\n</code></pre><p>The resulting list is <code>[2; 4; 6]</code>.</p>\n<p>A combination of map and filter, <a href=\"https://msdn.microsoft.com/library/2e21d3fb-ce35-4824-8a57-c4404616093d\" data-linktype=\"external\">List.choose</a> enables you to transform and select elements at the same time. <code>List.choose</code> applies a function that returns an option to each element of a list, and returns a new list of the results for elements when the function returns the option value <code>Some</code>.</p>\n<p>The following code demonstrates the use of <code>List.choose</code> to select capitalized words out of a list of words.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let listWords = [ &quot;and&quot;; &quot;Rome&quot;; &quot;Bob&quot;; &quot;apple&quot;; &quot;zebra&quot; ]\nlet isCapitalized (string1:string) = System.Char.IsUpper string1.[0]\nlet results = List.choose (fun elem -&gt;\n    match elem with\n    | elem when isCapitalized elem -&gt; Some(elem + &quot;&#39;s&quot;)\n    | _ -&gt; None) listWords\nprintfn &quot;%A&quot; results\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>[&quot;Rome&#39;s&quot;; &quot;Bob&#39;s&quot;]\n</code></pre><h3 id=\"operating-on-multiple-lists\">Operating on Multiple Lists</h3>\n<p>Lists can be joined together. To join two lists into one, use <a href=\"https://msdn.microsoft.com/library/2954da80-3f4a-4a4b-9371-794645c03426\" data-linktype=\"external\">List.append</a>. To join more than two lists, use <a href=\"https://msdn.microsoft.com/library/c5afd433-8764-4ea8-a6a8-937fb4d77c4c\" data-linktype=\"external\">List.concat</a>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let list1to10 = List.append [1; 2; 3] [4; 5; 6; 7; 8; 9; 10]\nlet listResult = List.concat [ [1; 2; 3]; [4; 5; 6]; [7; 8; 9] ]\nList.iter (fun elem -&gt; printf &quot;%d &quot; elem) list1to10\nprintfn &quot;&quot;\nList.iter (fun elem -&gt; printf &quot;%d &quot; elem) listResult\n</code></pre><h3 id=\"fold-and-scan-operations\">Fold and Scan Operations</h3>\n<p>Some list operations involve interdependencies between all of the list elements. The fold and scan operations are like <code>List.iter</code> and <code>List.map</code> in that you invoke a function on each element, but these operations provide an additional parameter called the <em>accumulator</em> that carries information through the computation.</p>\n<p>Use <code>List.fold</code> to perform a calculation on a list.</p>\n<p>The following code example demonstrates the use of <a href=\"https://msdn.microsoft.com/library/c272779e-bae7-4983-8d7f-16b345bb33a0\" data-linktype=\"external\">List.fold</a> to perform various operations.</p>\n<p>The list is traversed; the accumulator <code>acc</code> is a value that is passed along as the calculation proceeds. The first argument takes the accumulator and the list element, and returns the interim result of the calculation for that list element. The second argument is the initial value of the accumulator.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let sumList list = List.fold (fun acc elem -&gt; acc + elem) 0 list\nprintfn &quot;Sum of the elements of list %A is %d.&quot; [ 1 .. 3 ] (sumList [ 1 .. 3 ])\n\n// The following example computes the average of a list.\nlet averageList list = (List.fold (fun acc elem -&gt; acc + float elem) 0.0 list / float list.Length)\n\n// The following example computes the standard deviation of a list.\n// The standard deviation is computed by taking the square root of the\n// sum of the variances, which are the differences between each value\n// and the average.\nlet stdDevList list =\n    let avg = averageList list\n    sqrt (List.fold (fun acc elem -&gt; acc + (float elem - avg) ** 2.0 ) 0.0 list / float list.Length)\n\nlet testList listTest =\n    printfn &quot;List %A average: %f stddev: %f&quot; listTest (averageList listTest) (stdDevList listTest)\n\ntestList [1; 1; 1]\ntestList [1; 2; 1]\ntestList [1; 2; 3]\n\n// List.fold is the same as to List.iter when the accumulator is not used.\nlet printList list = List.fold (fun acc elem -&gt; printfn &quot;%A&quot; elem) () list\nprintList [0.0; 1.0; 2.5; 5.1 ]\n\n// The following example uses List.fold to reverse a list.\n// The accumulator starts out as the empty list, and the function uses the cons operator\n// to add each successive element to the head of the accumulator list, resulting in a\n// reversed form of the list.\nlet reverseList list = List.fold (fun acc elem -&gt; elem::acc) [] list\nprintfn &quot;%A&quot; (reverseList [1 .. 10])\n</code></pre><p>The versions of these functions that have a digit in the function name operate on more than one list. For example, <a href=\"https://msdn.microsoft.com/library/6cfcd043-a65d-4423-805a-2ab234cb5343\" data-linktype=\"external\">List.fold2</a> performs computations on two lists.</p>\n<p>The following example demonstrates the use of <code>List.fold2</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Use List.fold2 to perform computations over two lists (of equal size) at the same time.\n// Example: Sum the greater element at each list position.\nlet sumGreatest list1 list2 = List.fold2 (fun acc elem1 elem2 -&gt;\n                                              acc + max elem1 elem2) 0 list1 list2\n\nlet sum = sumGreatest [1; 2; 3] [3; 2; 1]\nprintfn &quot;The sum of the greater of each pair of elements in the two lists is %d.&quot; sum\n</code></pre><p><code>List.fold</code> and <a href=\"https://msdn.microsoft.com/library/21f636db-885c-4a72-970e-e3841f33a1b8\" data-linktype=\"external\">List.scan</a> differ in that <code>List.fold</code> returns the final value of the extra parameter, but <code>List.scan</code> returns the list of the intermediate values (along with the final value) of the extra parameter.</p>\n<p>Each of these functions includes a reverse variation, for example, <a href=\"https://msdn.microsoft.com/library/b9a58e66-efe1-445f-a90c-ac9ffb9d40c7\" data-linktype=\"external\">List.foldBack</a>, which differs in the order in which the list is traversed and the order of the arguments. Also, <code>List.fold</code> and <code>List.foldBack</code> have variations, <a href=\"https://msdn.microsoft.com/library/6cfcd043-a65d-4423-805a-2ab234cb5343\" data-linktype=\"external\">List.fold2</a> and <a href=\"https://msdn.microsoft.com/library/56371d3e-5271-4183-9e8c-15a02eda9aa2\" data-linktype=\"external\">List.foldBack2</a>, that take two lists of equal length. The function that executes on each element can use corresponding elements of both lists to perform some action. The element types of the two lists can be different, as in the following example, in which one list contains transaction amounts for a bank account, and the other list contains the type of transaction: deposit or withdrawal.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Discriminated union type that encodes the transaction type.\ntype Transaction =\n    | Deposit\n    | Withdrawal\n\nlet transactionTypes = [Deposit; Deposit; Withdrawal]\nlet transactionAmounts = [100.00; 1000.00; 95.00 ]\nlet initialBalance = 200.00\n\n// Use fold2 to perform a calculation on the list to update the account balance.\nlet endingBalance = List.fold2 (fun acc elem1 elem2 -&gt;\n                                match elem1 with\n                                | Deposit -&gt; acc + elem2\n                                | Withdrawal -&gt; acc - elem2)\n                                initialBalance\n                                transactionTypes\n                                transactionAmounts\nprintfn &quot;%f&quot; endingBalance\n</code></pre><p>For a calculation like summation, <code>List.fold</code> and <code>List.foldBack</code> have the same effect because the result does not depend on the order of traversal. In the following example, <code>List.foldBack</code> is used to add the elements in a list.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let sumListBack list = List.foldBack (fun acc elem -&gt; acc + elem) list 0\nprintfn &quot;%d&quot; (sumListBack [1; 2; 3])\n\n// For a calculation in which the order of traversal is important, fold and foldBack have different\n// results. For example, replacing fold with foldBack in the listReverse function\n// produces a function that copies the list, rather than reversing it.\nlet copyList list = List.foldBack (fun elem acc -&gt; elem::acc) list []\nprintfn &quot;%A&quot; (copyList [1 .. 10])\n</code></pre><p>The following example returns to the bank account example. This time a new transaction type is added: an interest calculation. The ending balance now depends on the order of transactions.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type Transaction2 =\n    | Deposit\n    | Withdrawal\n    | Interest\n\nlet transactionTypes2 = [Deposit; Deposit; Withdrawal; Interest]\nlet transactionAmounts2 = [100.00; 1000.00; 95.00; 0.05 / 12.0 ]\nlet initialBalance2 = 200.00\n\n// Because fold2 processes the lists by starting at the head element,\n// the interest is calculated last, on the balance of 1205.00.\nlet endingBalance2 = List.fold2 (fun acc elem1 elem2 -&gt;\n                                match elem1 with\n                                | Deposit -&gt; acc + elem2\n                                | Withdrawal -&gt; acc - elem2\n                                | Interest -&gt; acc * (1.0 + elem2))\n                                initialBalance2\n                                transactionTypes2\n                                transactionAmounts2\nprintfn &quot;%f&quot; endingBalance2\n\n\n// Because foldBack2 processes the lists by starting at end of the list,\n// the interest is calculated first, on the balance of only 200.00.\nlet endingBalance3 = List.foldBack2 (fun elem1 elem2 acc -&gt;\n                                match elem1 with\n                                | Deposit -&gt; acc + elem2\n                                | Withdrawal -&gt; acc - elem2\n                                | Interest -&gt; acc * (1.0 + elem2))\n                                transactionTypes2\n                                transactionAmounts2\n                                initialBalance2\nprintfn &quot;%f&quot; endingBalance3\n</code></pre><p>The function <a href=\"https://msdn.microsoft.com/library/048e1f95-691b-49cb-bb99-fb85f68f3d8b\" data-linktype=\"external\">List.reduce</a> is somewhat like <code>List.fold</code> and <code>List.scan</code>, except that instead of passing around a separate accumulator, <code>List.reduce</code> takes a function that takes two arguments of the element type instead of just one, and one of those arguments acts as the accumulator, meaning that it stores the intermediate result of the computation. <code>List.reduce</code> starts by operating on the first two list elements, and then uses the result of the operation along with the next element. Because there is not a separate accumulator that has its own type, <code>List.reduce</code> can be used in place of <code>List.fold</code> only when the accumulator and the element type have the same type. The following code demonstrates the use of <code>List.reduce</code>. <code>List.reduce</code> throws an exception if the list provided has no elements.</p>\n<p>In the following code, the first call to the lambda expression is given the arguments 2 and 4, and returns 6, and the next call is given the arguments 6 and 10, so the result is 16.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let sumAList list =\n    try\n        List.reduce (fun acc elem -&gt; acc + elem) list\n    with\n       | :? System.ArgumentException as exc -&gt; 0\n\nlet resultSum = sumAList [2; 4; 10]\nprintfn &quot;%d &quot; resultSum\n</code></pre><h3 id=\"converting-between-lists-and-other-collection-types\">Converting Between Lists and Other Collection Types</h3>\n<p>The <code>List</code> module provides functions for converting to and from both sequences and arrays. To convert to or from a sequence, use <a href=\"https://msdn.microsoft.com/library/7024be4b-ee70-43cc-8d0a-e6564a4ff7c0\" data-linktype=\"external\">List.toSeq</a> or <a href=\"https://msdn.microsoft.com/library/74ab9289-4a59-4433-92eb-3f662d7f7db0\" data-linktype=\"external\">List.ofSeq</a>. To convert to or from an array, use <a href=\"https://msdn.microsoft.com/library/ac87dd82-a0cd-40b3-b1fa-dd3168134547\" data-linktype=\"external\">List.toArray</a> or <a href=\"https://msdn.microsoft.com/library/f4bddc26-8c8f-4307-a6d7-a49dceb97032\" data-linktype=\"external\">List.ofArray</a>.</p>\n<h3 id=\"additional-operations\">Additional Operations</h3>\n<p>For information about additional operations on lists, see the library reference topic <a href=\"https://msdn.microsoft.com/visualfsharpdocs/conceptual/collections.list-module-%5bfsharp%5d\" data-linktype=\"external\">Collections.List Module</a>.</p>\n<h2 id=\"see-also\">See Also</h2>\n<p><a href=\"index\" data-linktype=\"relative-path\">F# Language Reference</a></p>\n<p><a href=\"fsharp-types\" data-linktype=\"relative-path\">F# Types</a></p>\n<p><a href=\"sequences\" data-linktype=\"relative-path\">Sequences</a></p>\n<p><a href=\"arrays\" data-linktype=\"relative-path\">Arrays</a></p>\n<p><a href=\"options\" data-linktype=\"relative-path\">Options</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"a1a6075f-064d-4aee-8222-2b59ff16cc12\">\r\n<meta name=\"description\" content=\"Lists (F#)\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming\">\r\n<meta name=\"ms.topic\" content=\"language-reference\">\r\n<meta name=\"ms.date\" content=\"05/16/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/lists.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/lists.md\">\r\n<meta name=\"document_id\" content=\"0fe8ead8-1585-9a6e-0723-9a898100c823\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","title":"Lists (F#) | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"a1a6075f-064d-4aee-8222-2b59ff16cc12","description":"Lists (F#)","keywords":"visual f#, f#, functional programming","ms.topic":"language-reference","ms.date":"05/16/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Remove redundant sequence expression (#1105)","commit_sha":"2d3b535d217ac7a819762871872fa5e03002e863","commit_date":"2016-10-03 16:08:47 -0700"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"fixed absolute and msdn links (#1001)","commit_sha":"de0dab146fc811e895dc32f98f877db5e757f82b","commit_date":"2016-09-06 10:59:39 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Move snippets to snippets folder, now with some F# (#904)","commit_sha":"37fe2b89d590509e8eb14342da988f15862a9e2b","commit_date":"2016-08-13 16:40:56 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize F# snippets (#903)","commit_sha":"6ea1cf8f3779532a9ed8fbdac32592fbb809443c","commit_date":"2016-08-13 15:14:41 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"F# Docs: Update intro, move files, rename language reference for better URLS (#902)","commit_sha":"70a10b9c3e21291c96d927d13f8710d9e0738d4c","commit_date":"2016-08-13 11:22:39 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/lists.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/lists.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/language-reference/lists.md","document_id":"0fe8ead8-1585-9a6e-0723-9a898100c823","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/lists","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Lists (F#)","_op_displayDate":"2016-5-16","_op_displayDate_source":"2016-05-16T00:00:00Z","_op_wordCount":4722,"_op_rawTitle":"<h1 id=\"lists\" sourcefile=\"docs/fsharp/language-reference/lists.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Lists</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/lists","fileRelativePath":"articles/fsharp/language-reference/lists.html"},"themesRelativePathToOutputRoot":"_themes/"}