{"content":"<div><div class=\"content\">\n<div class=\"NOTE\"><h5>Note</h5><p>The API reference links in this article will take you to MSDN.  The docs.microsoft.com API reference is not complete.</p>\n</div>\n<p>A <em>sequence</em> is a logical series of elements all of one type. Sequences are particularly useful when you have a large, ordered collection of data but do not necessarily expect to use all the elements. Individual sequence elements are computed only as required, so a sequence can provide better performance than a list in situations in which not all the elements are used. Sequences are represented by the <code>seq&lt;&#39;T&gt;</code> type, which is an alias for <code>System.Collections.Generic.IEnumerable</code>. Therefore, any .NET Framework type that implements <code>System.IEnumerable</code> can be used as a sequence. The <a href=\"https://msdn.microsoft.com/library/54e8f059-ca52-4632-9ae9-49685ee9b684\" data-linktype=\"external\">Seq module</a> provides support for manipulations involving sequences.</p>\n<h2 id=\"sequence-expressions\">Sequence Expressions</h2>\n<p>A <em>sequence expression</em> is an expression that evaluates to a sequence. Sequence expressions can take a number of forms. The simplest form specifies a range. For example, <code>seq { 1 .. 5 }</code> creates a sequence that contains five elements, including the endpoints 1 and 5. You can also specify an increment (or decrement) between two double periods. For example, the following code creates the sequence of multiples of 10.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Sequence that has an increment.\nseq { 0 .. 10 .. 100 }\n</code></pre><p>Sequence expressions are made up of F# expressions that produce values of the sequence. They can use the <code>yield</code> keyword to produce values that become part of the sequence.</p>\n<p>Following is an example.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">seq { for i in 1 .. 10 do yield i * i }\n</code></pre><p>You can use the <code>-&gt;</code> operator instead of <code>yield</code>, in which case you can omit the <code>do</code> keyword, as shown in the following example.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">seq { for i in 1 .. 10 -&gt; i * i }\n</code></pre><p>The following code generates a list of coordinate pairs along with an index into an array that represents the grid.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let (height, width) = (10, 10)\nseq { for row in 0 .. width - 1 do\n         for col in 0 .. height - 1 do\n           yield (row, col, row*width + col)\n    }\n</code></pre><p>An <code>if</code> expression used in a sequence is a filter. For example, to generate a sequence of only prime numbers, assuming that you have a function <code>isprime</code> of type <code>int -&gt; bool</code>, construct the sequence as follows.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">seq { for n in 1 .. 100 do if isprime n then yield n }\n</code></pre><p>When you use <code>yield</code> or <code>-&gt;</code> in an iteration, each iteration is expected to generate a single element of the sequence. If each iteration produces a sequence of elements, use <code>yield!</code>. In that case, the elements generated on each iteration are concatenated to produce the final sequence.</p>\n<p>You can combine multiple expressions together in a sequence expression. The elements generated by each expression are concatenated together. For an example, see the &quot;Examples&quot; section of this topic.</p>\n<h2 id=\"examples\">Examples</h2>\n<p>The first example uses a sequence expression that contains an iteration, a filter, and a yield to generate an array. This code prints a sequence of prime numbers between 1 and 100 to the console.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Recursive isprime function.\nlet isprime n =\n    let rec check i =\n        i &gt; n/2 || (n % i &lt;&gt; 0 &amp;&amp; check (i + 1))\n    check 2\n\nlet aSequence = seq { for n in 1..100 do if isprime n then yield n }\nfor x in aSequence do\n    printfn &quot;%d&quot; x\n</code></pre><p>The following code uses <code>yield</code> to create a multiplication table that consists of tuples of three elements, each consisting of two factors and the product.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let multiplicationTable =\n  seq { for i in 1..9 do\n            for j in 1..9 do\n               yield (i, j, i*j) }\n</code></pre><p>The following example demonstrates the use of <code>yield!</code> to combine individual sequences into a single final sequence. In this case, the sequences for each subtree in a binary tree are concatenated in a recursive function to produce the final sequence.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Yield the values of a binary tree in a sequence.\ntype Tree&lt;&#39;a&gt; =\n   | Tree of &#39;a * Tree&lt;&#39;a&gt; * Tree&lt;&#39;a&gt;\n   | Leaf of &#39;a\n\n// inorder : Tree&lt;&#39;a&gt; -&gt; seq&lt;&#39;a&gt;\nlet rec inorder tree =\n    seq {\n      match tree with\n          | Tree(x, left, right) -&gt;\n               yield! inorder left\n               yield x\n               yield! inorder right\n          | Leaf x -&gt; yield x\n    }\n\nlet mytree = Tree(6, Tree(2, Leaf(1), Leaf(3)), Leaf(9))\nlet seq1 = inorder mytree\nprintfn &quot;%A&quot; seq1\n</code></pre><h2 id=\"using-sequences\">Using Sequences</h2>\n<p>Sequences support many of the same functions as <a href=\"lists\" data-linktype=\"relative-path\">lists</a>. Sequences also support operations such as grouping and counting by using key-generating functions. Sequences also support more diverse functions for extracting subsequences.</p>\n<p>Many data types, such as lists, arrays, sets, and maps are implicitly sequences because they are enumerable collections. A function that takes a sequence as an argument works with any of the common F# data types, in addition to any .NET Framework data type that implements <code>System.Collections.Generic.IEnumerable&lt;&#39;T&gt;</code>. Contrast this to a function that takes a list as an argument, which can only take lists. The type <code>seq&lt;&#39;T&gt;</code> is a type abbreviation for <code>IEnumerable&lt;&#39;T&gt;</code>. This means that any type that implements the generic <code>System.Collections.Generic.IEnumerable&lt;&#39;T&gt;</code>, which includes arrays, lists, sets, and maps in F#, and also most .NET Framework collection types, is compatible with the <code>seq</code> type and can be used wherever a sequence is expected.</p>\n<h2 id=\"module-functions\">Module Functions</h2>\n<p>The <a href=\"https://msdn.microsoft.com/library/54e8f059-ca52-4632-9ae9-49685ee9b684\" data-linktype=\"external\">Seq module</a> in the <a href=\"https://msdn.microsoft.com/library/24f64e5f-5030-47d0-9759-8d3e398ed13f\" data-linktype=\"external\">Microsoft.FSharp.Collections namespace</a> contains functions for working with sequences. These functions work with lists, arrays, maps, and sets as well, because all of those types are enumerable, and therefore can be treated as sequences.</p>\n<h2 id=\"creating-sequences\">Creating Sequences</h2>\n<p>You can create sequences by using sequence expressions, as described previously, or by using certain functions.</p>\n<p>You can create an empty sequence by using <a href=\"https://msdn.microsoft.com/library/3c7f1c69-6117-4782-b2da-0e04d6854f59\" data-linktype=\"external\">Seq.empty</a>, or you can create a sequence of just one specified element by using <a href=\"https://msdn.microsoft.com/library/9b8cc460-a282-4ec5-b29a-630ab17e9de7\" data-linktype=\"external\">Seq.singleton</a>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let seqEmpty = Seq.empty\nlet seqOne = Seq.singleton 10\n</code></pre><p>You can use <a href=\"https://msdn.microsoft.com/library/059de69d-812c-4f8e-be86-88aa72101576\" data-linktype=\"external\">Seq.init</a> to create a sequence for which the elements are created by using a function that you provide. You also provide a size for the sequence. This function is just like <a href=\"https://msdn.microsoft.com/library/dd38c096-0ea8-4858-be6b-794b90418b83\" data-linktype=\"external\">List.init</a>, except that the elements are not created until you iterate through the sequence. The following code illustrates the use of <code>Seq.init</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let seqFirst5MultiplesOf10 = Seq.init 5 (fun n -&gt; n * 10)\nSeq.iter (fun elem -&gt; printf &quot;%d &quot; elem) seqFirst5MultiplesOf10\n</code></pre><p>The output is</p>\n<pre class=\"loading\"><code>0 10 20 30 40\n</code></pre><p>By using <a href=\"https://msdn.microsoft.com/library/299cd4d9-be72-4511-aac8-089e1ddaac99\" data-linktype=\"external\">Seq.ofArray</a> and <a href=\"https://msdn.microsoft.com/visualfsharpdocs/conceptual/seq.oflist%5b%27t%5d-function-%5bfsharp%5d\" data-linktype=\"external\">Seq.ofList&#60;&#39;T&#62; Function</a>, you can create sequences from arrays and lists. However, you can also convert arrays and lists to sequences by using a cast operator. Both techniques are shown in the following code.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Convert an array to a sequence by using a cast.\nlet seqFromArray1 = [| 1 .. 10 |] :&gt; seq&lt;int&gt;\n// Convert an array to a sequence by using Seq.ofArray.\nlet seqFromArray2 = [| 1 .. 10 |] |&gt; Seq.ofArray\n</code></pre><p>By using <a href=\"https://msdn.microsoft.com/library/1d087db3-a8b2-41dd-8ddc-227544529334\" data-linktype=\"external\">Seq.cast</a>, you can create a sequence from a weakly typed collection, such as those defined in <code>System.Collections</code>. Such weakly typed collections have the element type <code>System.Object</code> and are enumerated by using the non-generic <code>System.Collections.Generic.IEnumerable&amp;#96;1</code> type. The following code illustrates the use of <code>Seq.cast</code> to convert an <code>System.Collections.ArrayList</code> into a sequence.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">open System\nlet mutable arrayList1 = new System.Collections.ArrayList(10)\nfor i in 1 .. 10 do arrayList1.Add(10) |&gt; ignore\nlet seqCast : seq&lt;int&gt; = Seq.cast arrayList1\n</code></pre><p>You can define infinite sequences by using the <a href=\"https://msdn.microsoft.com/library/d1804e53-da92-48ec-8d6e-57eaf4c62bef\" data-linktype=\"external\">Seq.initInfinite</a> function. For such a sequence, you provide a function that generates each element from the index of the element. Infinite sequences are possible because of lazy evaluation; elements are created as needed by calling the function that you specify. The following code example produces an infinite sequence of floating point numbers, in this case the alternating series of reciprocals of squares of successive integers.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let seqInfinite = Seq.initInfinite (fun index -&gt;\n    let n = float( index + 1 )\n    1.0 / (n * n * (if ((index + 1) % 2 = 0) then 1.0 else -1.0)))\nprintfn &quot;%A&quot; seqInfinite\n</code></pre><p><a href=\"https://msdn.microsoft.com/library/7d9232fc-742e-42bc-bdf7-6f130f0eff21\" data-linktype=\"external\">Seq.unfold</a> generates a sequence from a computation function that takes a state and transforms it to produce each subsequent element in the sequence. The state is just a value that is used to compute each element, and can change as each element is computed. The second argument to <code>Seq.unfold</code> is the initial value that is used to start the sequence. <code>Seq.unfold</code> uses an option type for the state, which enables you to terminate the sequence by returning the <code>None</code> value. The following code shows two examples of sequences, <code>seq1</code> and <code>fib</code>, that are generated by an <code>unfold</code> operation. The first, <code>seq1</code>, is just a simple sequence with numbers up to 100. The second, <code>fib</code>, uses <code>unfold</code> to compute the Fibonacci sequence. Because each element in the Fibonacci sequence is the sum of the previous two Fibonacci numbers, the state value is a tuple that consists of the previous two numbers in the sequence. The initial value is <code>(1,1)</code>, the first two numbers in the sequence.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let seq1 = Seq.unfold (fun state -&gt; if (state &gt; 20) then None else Some(state, state + 1)) 0\nprintfn &quot;The sequence seq1 contains numbers from 0 to 20.&quot;\nfor x in seq1 do printf &quot;%d &quot; x\nlet fib = Seq.unfold (fun state -&gt;\n    if (snd state &gt; 1000) then None\n    else Some(fst state + snd state, (snd state, fst state + snd state))) (1,1)\nprintfn &quot;\\nThe sequence fib contains Fibonacci numbers.&quot;\nfor x in fib do printf &quot;%d &quot; x\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>The sequence seq1 contains numbers from 0 to 20.\n\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n\nThe sequence fib contains Fibonacci numbers.\n\n2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597\n</code></pre><p>The following code is an example that uses many of the sequence module functions described here to generate and compute the values of infinite sequences. The code might take a few minutes to run.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// infiniteSequences.fs\n// generateInfiniteSequence generates sequences of floating point\n// numbers. The sequences generated are computed from the fDenominator\n// function, which has the type (int -&gt; float) and computes the\n// denominator of each term in the sequence from the index of that\n// term. The isAlternating parameter is true if the sequence has\n// alternating signs.\nlet generateInfiniteSequence fDenominator isAlternating =\n    if (isAlternating) then\n        Seq.initInfinite (fun index -&gt; 1.0 /(fDenominator index) * (if (index % 2 = 0) then -1.0 else 1.0))\n    else\n        Seq.initInfinite (fun index -&gt; 1.0 /(fDenominator index))\n\n// The harmonic series is the series of reciprocals of whole numbers.\nlet harmonicSeries = generateInfiniteSequence (fun index -&gt; float index) false\n// The harmonic alternating series is like the harmonic series\n// except that it has alternating signs.\nlet harmonicAlternatingSeries = generateInfiniteSequence (fun index -&gt; float index) true\n// This is the series of reciprocals of the odd numbers.\nlet oddNumberSeries = generateInfiniteSequence (fun index -&gt; float (2 * index - 1)) true\n// This is the series of recipocals of the squares.\nlet squaresSeries = generateInfiniteSequence (fun index -&gt; float (index * index)) false\n\n// This function sums a sequence, up to the specified number of terms.\nlet sumSeq length sequence =\n    Seq.unfold (fun state -&gt;\n        let subtotal = snd state + Seq.nth (fst state + 1) sequence\n        if (fst state &gt;= length) then None\n        else Some(subtotal,(fst state + 1, subtotal))) (0, 0.0)\n\n// This function sums an infinite sequence up to a given value\n// for the difference (epsilon) between subsequent terms,\n// up to a maximum number of terms, whichever is reached first.\nlet infiniteSum infiniteSeq epsilon maxIteration =\n    infiniteSeq\n    |&gt; sumSeq maxIteration\n    |&gt; Seq.pairwise\n    |&gt; Seq.takeWhile (fun elem -&gt; abs (snd elem - fst elem) &gt; epsilon)\n    |&gt; List.ofSeq\n    |&gt; List.rev\n    |&gt; List.head\n    |&gt; snd\n\n// Compute the sums for three sequences that converge, and compare\n// the sums to the expected theoretical values.\nlet result1 = infiniteSum harmonicAlternatingSeries 0.00001 100000\nprintfn &quot;Result: %f  ln2: %f&quot; result1 (log 2.0)\n\nlet pi = Math.PI\nlet result2 = infiniteSum oddNumberSeries 0.00001 10000\nprintfn &quot;Result: %f pi/4: %f&quot; result2 (pi/4.0)\n\n// Because this is not an alternating series, a much smaller epsilon\n// value and more terms are needed to obtain an accurate result.\nlet result3 = infiniteSum squaresSeries 0.0000001 1000000\nprintfn &quot;Result: %f pi*pi/6: %f&quot; result3 (pi*pi/6.0)\n</code></pre><h2 id=\"searching-and-finding-elements\">Searching and Finding Elements</h2>\n<p>Sequences support functionality available with lists: <a href=\"https://msdn.microsoft.com/library/428c97bf-599d-4c39-a5b9-f8717c198ad1\" data-linktype=\"external\">Seq.exists</a>, <a href=\"https://msdn.microsoft.com/library/efdf14a4-27f7-4dc1-9281-52639e66d565\" data-linktype=\"external\">Seq.exists2</a>, <a href=\"https://msdn.microsoft.com/library/02c21ecd-97e5-4e99-a4c1-b4d0b730b7d8\" data-linktype=\"external\">Seq.find</a>, <a href=\"https://msdn.microsoft.com/library/96dfe86b-df15-4d92-8316-7cd6055e09f3\" data-linktype=\"external\">Seq.findIndex</a>, <a href=\"https://msdn.microsoft.com/library/a87bc771-55f7-43f9-94f9-33d8f9bf325d\" data-linktype=\"external\">Seq.pick</a>, <a href=\"https://msdn.microsoft.com/library/ac43c6f5-4dc7-4e9a-a222-00b5736aee47\" data-linktype=\"external\">Seq.tryFind</a>, and <a href=\"https://msdn.microsoft.com/library/c357b221-edf6-4f68-bf40-82a3156d945a\" data-linktype=\"external\">Seq.tryFindIndex</a>. The versions of these functions that are available for sequences evaluate the sequence only up to the element that is being searched for. For examples, see <a href=\"https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d\" data-linktype=\"external\">Lists</a>.</p>\n<h2 id=\"obtaining-subsequences\">Obtaining Subsequences</h2>\n<p><a href=\"https://msdn.microsoft.com/library/7f2e9850-a660-460c-9831-3bbff5613770\" data-linktype=\"external\">Seq.filter</a> and <a href=\"https://msdn.microsoft.com/library/63b83b06-4b24-4239-bf69-a2c12d891395\" data-linktype=\"external\">Seq.choose</a> are like the corresponding functions that are available for lists, except that the filtering and choosing does not occur until the sequence elements are evaluated.</p>\n<p><a href=\"https://msdn.microsoft.com/library/1892dfeb-308e-45e2-857a-3c3405d02244\" data-linktype=\"external\">Seq.truncate</a> creates a sequence from another sequence, but limits the sequence to a specified number of elements. <a href=\"https://msdn.microsoft.com/library/6e75f701-640b-4c4a-9d63-4313fc090596\" data-linktype=\"external\">Seq.take</a> creates a new sequence that contains only a specified number of elements from the start of a sequence. If there are fewer elements in the sequence than you specify to take, <code>Seq.take</code> throws a <code>System.InvalidOperationException</code>. The difference between <code>Seq.take</code> and <code>Seq.truncate</code> is that <code>Seq.truncate</code> does not produce an error if the number of elements is fewer than the number you specify.</p>\n<p>The following code shows the behavior of and differences between <code>Seq.truncate</code> and <code>Seq.take</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let mySeq = seq { for i in 1 .. 10 -&gt; i*i }\nlet truncatedSeq = Seq.truncate 5 mySeq\nlet takenSeq = Seq.take 5 mySeq\n\nlet truncatedSeq2 = Seq.truncate 20 mySeq\nlet takenSeq2 = Seq.take 20 mySeq\n\nlet printSeq seq1 = Seq.iter (printf &quot;%A &quot;) seq1; printfn &quot;&quot;\n\n// Up to this point, the sequences are not evaluated.\n// The following code causes the sequences to be evaluated.\ntruncatedSeq |&gt; printSeq\ntruncatedSeq2 |&gt; printSeq\ntakenSeq |&gt; printSeq\n// The following line produces a run-time error (in printSeq):\ntakenSeq2 |&gt; printSeq\n</code></pre><p>The output, before the error occurs, is as follows.</p>\n<pre class=\"loading\"><code>1 4 9 16 25 \n1 4 9 16 25 36 49 64 81 100 \n1 4 9 16 25 \n1 4 9 16 25 36 49 64 81 100\n</code></pre><p>By using <a href=\"https://msdn.microsoft.com/library/19eea4ce-66e0-4353-b015-72eb03421d92\" data-linktype=\"external\">Seq.takeWhile</a>, you can specify a predicate function (a Boolean function) and create a sequence from another sequence made up of those elements of the original sequence for which the predicate is <code>true</code>, but stop before the first element for which the predicate returns <code>false</code>. <a href=\"https://msdn.microsoft.com/library/b4eb3f08-8594-4d17-8180-852c6c688bf1\" data-linktype=\"external\">Seq.skip</a> returns a sequence that skips a specified number of the first elements of another sequence and returns the remaining elements. <a href=\"https://msdn.microsoft.com/library/fb729021-2a3c-430f-83c3-0b37526f1a16\" data-linktype=\"external\">Seq.skipWhile</a> returns a sequence that skips the first elements of another sequence as long as the predicate returns <code>true</code>, and then returns the remaining elements, starting with the first element for which the predicate returns <code>false</code>.</p>\n<p>The following code example illustrates the behavior of and differences between <code>Seq.takeWhile</code>, <code>Seq.skip</code>, and <code>Seq.skipWhile</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// takeWhile\nlet mySeqLessThan10 = Seq.takeWhile (fun elem -&gt; elem &lt; 10) mySeq\nmySeqLessThan10 |&gt; printSeq\n\n// skip\nlet mySeqSkipFirst5 = Seq.skip 5 mySeq\nmySeqSkipFirst5 |&gt; printSeq\n\n// skipWhile\nlet mySeqSkipWhileLessThan10 = Seq.skipWhile (fun elem -&gt; elem &lt; 10) mySeq\nmySeqSkipWhileLessThan10 |&gt; printSeq\n</code></pre><p>The output is as follows.</p>\n<pre class=\"loading\"><code>1 4 9 \n36 49 64 81 100 \n16 25 36 49 64 81 100\n</code></pre><h2 id=\"transforming-sequences\">Transforming Sequences</h2>\n<p><a href=\"https://msdn.microsoft.com/library/210dcf26-4e24-4d83-af6d-a8288b2ae4b1\" data-linktype=\"external\">Seq.pairwise</a> creates a new sequence in which successive elements of the input sequence are grouped into tuples.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let printSeq seq1 = Seq.iter (printf &quot;%A &quot;) seq1; printfn &quot;&quot;\nlet seqPairwise = Seq.pairwise (seq { for i in 1 .. 10 -&gt; i*i })\nprintSeq seqPairwise\n\nprintfn &quot;&quot;\nlet seqDelta = Seq.map (fun elem -&gt; snd elem - fst elem) seqPairwise\nprintSeq seqDelta\n</code></pre><p><a href=\"https://msdn.microsoft.com/library/8b565b8f-d645-4dba-be22-099075fe4744\" data-linktype=\"external\">Seq.windowed</a> is like <code>Seq.pairwise</code>, except that instead of producing a sequence of tuples, it produces a sequence of arrays that contain copies of adjacent elements (a <em>window</em>) from the sequence. You specify the number of adjacent elements you want in each array.</p>\n<p>The following code example demonstrates the use of <code>Seq.windowed</code>. In this case the number of elements in the window is 3. The example uses <code>printSeq</code>, which is defined in the previous code example.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let seqNumbers = [ 1.0; 1.5; 2.0; 1.5; 1.0; 1.5 ] :&gt; seq&lt;float&gt;\nlet seqWindows = Seq.windowed 3 seqNumbers\nlet seqMovingAverage = Seq.map Array.average seqWindows\nprintfn &quot;Initial sequence: &quot;\nprintSeq seqNumbers\nprintfn &quot;\\nWindows of length 3: &quot;\nprintSeq seqWindows\nprintfn &quot;\\nMoving average: &quot;\nprintSeq seqMovingAverage\n</code></pre><p>The output is as follows.</p>\n<p>Initial sequence:</p>\n<pre class=\"loading\"><code>1.0 1.5 2.0 1.5 1.0 1.5 \n\nWindows of length 3: \n[|1.0; 1.5; 2.0|] [|1.5; 2.0; 1.5|] [|2.0; 1.5; 1.0|] [|1.5; 1.0; 1.5|] \n\nMoving average: \n1.5 1.666666667 1.5 1.333333333\n</code></pre><h2 id=\"operations-with-multiple-sequences\">Operations with Multiple Sequences</h2>\n<p><a href=\"https://msdn.microsoft.com/library/0a5df8bf-0d48-44ce-bff4-e8ef1df5bca4\" data-linktype=\"external\">Seq.zip</a> and <a href=\"https://msdn.microsoft.com/library/ef13bebb-22ae-4eb9-873b-87dd29154d16\" data-linktype=\"external\">Seq.zip3</a> take two or three sequences and produce a sequence of tuples. These functions are like the corresponding functions available for <a href=\"https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d\" data-linktype=\"external\">lists</a>. There is no corresponding functionality to separate one sequence into two or more sequences. If you need this functionality for a sequence, convert the sequence to a list and use <a href=\"https://msdn.microsoft.com/library/639db80c-41b5-45bb-a6b4-1eaa04d61d21\" data-linktype=\"external\">List.unzip</a>.</p>\n<h2 id=\"sorting-comparing-and-grouping\">Sorting, Comparing, and Grouping</h2>\n<p>The sorting functions supported for lists also work with sequences. This includes <a href=\"https://msdn.microsoft.com/library/327ea595-e77c-4529-b61e-8c6cbf5ec92e\" data-linktype=\"external\">Seq.sort</a> and <a href=\"https://msdn.microsoft.com/library/4f8b4fb9-bf20-49d9-b4ee-dcc906c8208f\" data-linktype=\"external\">Seq.sortBy</a>. These functions iterate through the whole sequence.</p>\n<p>You compare two sequences by using the <a href=\"https://msdn.microsoft.com/library/5a740135-0b3a-4545-816f-8f91cc31290f\" data-linktype=\"external\">Seq.compareWith</a> function. The function compares successive elements in turn, and stops when it encounters the first unequal pair. Any additional elements do not contribute to the comparison.</p>\n<p>The following code shows the use of <code>Seq.compareWith</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let sequence1 = seq { 1 .. 10 }\nlet sequence2 = seq { 10 .. -1 .. 1 }\n\n// Compare two sequences element by element.\nlet compareSequences = Seq.compareWith (fun elem1 elem2 -&gt;\n    if elem1 &gt; elem2 then 1\n    elif elem1 &lt; elem2 then -1\n    else 0)\n\nlet compareResult1 = compareSequences sequence1 sequence2\nmatch compareResult1 with\n| 1 -&gt; printfn &quot;Sequence1 is greater than sequence2.&quot;\n| -1 -&gt; printfn &quot;Sequence1 is less than sequence2.&quot;\n| 0 -&gt; printfn &quot;Sequence1 is equal to sequence2.&quot;\n| _ -&gt; failwith(&quot;Invalid comparison result.&quot;)\n</code></pre><p>In the previous code, only the first element is computed and examined, and the result is -1.</p>\n<p><a href=\"https://msdn.microsoft.com/library/721702a5-150e-4fe8-81cd-ffbf8476cc1f\" data-linktype=\"external\">Seq.countBy</a> takes a function that generates a value called a <em>key</em> for each element. A key is generated for each element by calling this function on each element. <code>Seq.countBy</code> then returns a sequence that contains the key values, and a count of the number of elements that generated each value of the key.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let mySeq1 = seq { 1.. 100 }\nlet printSeq seq1 = Seq.iter (printf &quot;%A &quot;) seq1; printfn &quot;&quot;\nlet seqResult = Seq.countBy (fun elem -&gt; if elem % 3 = 0 then 0\n                                         elif elem % 3 = 1 then 1\n                                         else 2) mySeq1\n\nprintSeq seqResult\n</code></pre><p>The output is as follows.</p>\n<pre class=\"loading\"><code>(1, 34) (2, 33) (0, 33)\n</code></pre><p>The previous output shows that there were 34 elements of the original sequence that produced the key 1, 33 values that produced the key 2, and 33 values that produced the key 0.</p>\n<p>You can group elements of a sequence by calling <a href=\"https://msdn.microsoft.com/library/d46a04df-1a42-40cc-a368-058c9c5806fd\" data-linktype=\"external\">Seq.groupBy</a>. <code>Seq.groupBy</code> takes a sequence and a function that generates a key from an element. The function is executed on each element of the sequence. <code>Seq.groupBy</code> returns a sequence of tuples, where the first element of each tuple is the key and the second is a sequence of elements that produce that key.</p>\n<p>The following code example shows the use of <code>Seq.groupBy</code> to partition the sequence of numbers from 1 to 100 into three groups that have the distinct key values 0, 1, and 2.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let sequence = seq { 1 .. 100 }\nlet printSeq seq1 = Seq.iter (printf &quot;%A &quot;) seq1; printfn &quot;&quot;\nlet sequences3 = Seq.groupBy (fun index -&gt;\n                                if (index % 3 = 0) then 0\n                                  elif (index % 3 = 1) then 1\n                                  else 2) sequence\nsequences3 |&gt; printSeq\n</code></pre><p>The output is as follows.</p>\n<pre class=\"loading\"><code>(1, seq [1; 4; 7; 10; ...]) (2, seq [2; 5; 8; 11; ...]) (0, seq [3; 6; 9; 12; ...])\n</code></pre><p>You can create a sequence that eliminates duplicate elements by calling <a href=\"https://msdn.microsoft.com/library/99d01014-7e0e-4e7b-9d0a-41a61d93f401\" data-linktype=\"external\">Seq.distinct</a>. Or you can use <a href=\"https://msdn.microsoft.com/library/9293293b-9420-49c8-848f-401a9cd49b75\" data-linktype=\"external\">Seq.distinctBy</a>, which takes a key-generating function to be called on each element. The resulting sequence contains elements of the original sequence that have unique keys; later elements that produce a duplicate key to an earlier element are discarded.</p>\n<p>The following code example illustrates the use of <code>Seq.distinct</code>. <code>Seq.distinct</code> is demonstrated by generating sequences that represent binary numbers, and then showing that the only distinct elements are 0 and 1.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let binary n =\n    let rec generateBinary n =\n        if (n / 2 = 0) then [n]\n        else (n % 2) :: generateBinary (n / 2)\n    generateBinary n |&gt; List.rev |&gt; Seq.ofList\n\nprintfn &quot;%A&quot; (binary 1024)\n\nlet resultSequence = Seq.distinct (binary 1024)\nprintfn &quot;%A&quot; resultSequence\n</code></pre><p>The following code demonstrates <code>Seq.distinctBy</code> by starting with a sequence that contains negative and positive numbers and using the absolute value function as the key-generating function. The resulting sequence is missing all the positive numbers that correspond to the negative numbers in the sequence, because the negative numbers appear earlier in the sequence and therefore are selected instead of the positive numbers that have the same absolute value, or key.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let inputSequence = { -5 .. 10 }\nlet printSeq seq1 = Seq.iter (printf &quot;%A &quot;) seq1; printfn &quot;&quot;\nprintfn &quot;Original sequence: &quot;\nprintSeq inputSequence\nprintfn &quot;\\nSequence with distinct absolute values: &quot;\nlet seqDistinctAbsoluteValue = Seq.distinctBy (fun elem -&gt; abs elem) inputSequence\nseqDistinctAbsoluteValue |&gt; printSeq\n</code></pre><h2 id=\"readonly-and-cached-sequences\">Readonly and Cached Sequences</h2>\n<p><a href=\"https://msdn.microsoft.com/library/88059cb4-3bb0-4126-9448-fbcd48fe13a7\" data-linktype=\"external\">Seq.readonly</a> creates a read-only copy of a sequence. <code>Seq.readonly</code> is useful when you have a read-write collection, such as an array, and you do not want to modify the original collection. This function can be used to preserve data encapsulation. In the following code example, a type that contains an array is created. A property exposes the array, but instead of returning an array, it returns a sequence that is created from the array by using <code>Seq.readonly</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type ArrayContainer(start, finish) =\n    let internalArray = [| start .. finish |]\n    member this.RangeSeq = Seq.readonly internalArray\n    member this.RangeArray = internalArray\n\nlet newArray = new ArrayContainer(1, 10)\nlet rangeSeq = newArray.RangeSeq\nlet rangeArray = newArray.RangeArray\n// These lines produce an error:\n//let myArray = rangeSeq :&gt; int array\n//myArray.[0] &lt;- 0\n// The following line does not produce an error.\n// It does not preserve encapsulation.\nrangeArray.[0] &lt;- 0\n</code></pre><p><a href=\"https://msdn.microsoft.com/library/d197f9cc-08bf-4986-9869-246e72ca73f0\" data-linktype=\"external\">Seq.cache</a> creates a stored version of a sequence. Use <code>Seq.cache</code> to avoid reevaluation of a sequence, or when you have multiple threads that use a sequence, but you must make sure that each element is acted upon only one time. When you have a sequence that is being used by multiple threads, you can have one thread that enumerates and computes the values for the original sequence, and remaining threads can use the cached sequence.</p>\n<h2 id=\"performing-computations-on-sequences\">Performing Computations on Sequences</h2>\n<p>Simple arithmetic operations are like those of lists, such as <a href=\"https://msdn.microsoft.com/library/609d793b-c70f-4e36-9ab4-d928056d65b8\" data-linktype=\"external\">Seq.average</a>, <a href=\"https://msdn.microsoft.com/library/01208515-4880-4358-91f5-af34f66dc77a\" data-linktype=\"external\">Seq.sum</a>, <a href=\"https://msdn.microsoft.com/library/47c855c1-2dbd-415a-885e-b909d9d3e4f8\" data-linktype=\"external\">Seq.averageBy</a>, <a href=\"https://msdn.microsoft.com/library/68cca78c-94ed-4a45-9b8d-34d2c5f2b1b1\" data-linktype=\"external\">Seq.sumBy</a>, and so on.</p>\n<p><a href=\"https://msdn.microsoft.com/library/30c4c95a-9563-4c96-bbe1-f7aacfd026e3\" data-linktype=\"external\">Seq.fold</a>, <a href=\"https://msdn.microsoft.com/library/a2ad4f64-ac69-47d2-92f0-7173d9dfeae9\" data-linktype=\"external\">Seq.reduce</a>, and <a href=\"https://msdn.microsoft.com/library/7e2d23e9-f153-4411-a884-b6d415ff627e\" data-linktype=\"external\">Seq.scan</a> are like the corresponding functions that are available for lists. Sequences support a subset of the full variations of these functions that lists support. For more information and examples, see <a href=\"lists\" data-linktype=\"relative-path\">Lists</a>.</p>\n<h2 id=\"see-also\">See Also</h2>\n<p><a href=\"index\" data-linktype=\"relative-path\">F# Language Reference</a></p>\n<p><a href=\"fsharp-types\" data-linktype=\"relative-path\">F# Types</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-all/api/toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"23dc7d75-cd26-4df2-9be3-9d1aba5c4443\">\r\n<meta name=\"description\" content=\"Sequences (F#)\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming\">\r\n<meta name=\"ms.topic\" content=\"language-reference\">\r\n<meta name=\"ms.date\" content=\"05/16/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/sequences.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/sequences.md\">\r\n<meta name=\"document_id\" content=\"96f41ffa-c1ee-db52-d072-0d306470b5c0\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Sequences (F#) | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"23dc7d75-cd26-4df2-9be3-9d1aba5c4443","description":"Sequences (F#)","keywords":"visual f#, f#, functional programming","ms.topic":"language-reference","ms.date":"05/16/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"fixed absolute and msdn links (#1001)","commit_sha":"de0dab146fc811e895dc32f98f877db5e757f82b","commit_date":"2016-09-06 10:59:39 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Move snippets to snippets folder, now with some F# (#904)","commit_sha":"37fe2b89d590509e8eb14342da988f15862a9e2b","commit_date":"2016-08-13 16:40:56 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize F# snippets (#903)","commit_sha":"6ea1cf8f3779532a9ed8fbdac32592fbb809443c","commit_date":"2016-08-13 15:14:41 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"F# Docs: Update intro, move files, rename language reference for better URLS (#902)","commit_sha":"70a10b9c3e21291c96d927d13f8710d9e0738d4c","commit_date":"2016-08-13 11:22:39 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/sequences.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/sequences.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/language-reference/sequences.md","document_id":"96f41ffa-c1ee-db52-d072-0d306470b5c0","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/fsharp/language-reference/sequences","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Sequences (F#)","_op_displayDate":"2016-5-16","_op_displayDate_source":"2016-05-16T00:00:00Z","_op_wordCount":3788,"_op_rawTitle":"<h1 id=\"sequences\" sourcefile=\"docs/fsharp/language-reference/sequences.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Sequences</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/fsharp/language-reference/sequences","fileRelativePath":"articles/fsharp/language-reference/sequences.html"},"themesRelativePathToOutputRoot":"_themes/"}