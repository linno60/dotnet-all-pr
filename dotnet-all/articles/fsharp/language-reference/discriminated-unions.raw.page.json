{"content":"<div><div class=\"content\">\n<div class=\"NOTE\"><h5>Note</h5><p>The following article does not cover using the <code>struct</code> attribute for Records yet, which is an F# 4.1 feature.  It will be documented here.</p>\n</div>\n<p>Discriminated unions provide support for values that can be one of a number of named cases, possibly each with different values and types. Discriminated unions are useful for heterogeneous data; data that can have special cases, including valid and error cases; data that varies in type from one instance to another; and as an alternative for small object hierarchies. In addition, recursive discriminated unions are used to represent tree data structures.</p>\n<h2 id=\"syntax\">Syntax</h2>\n<pre class=\"loading\"><code class=\"lang-fsharp\">type type-name =\n    | case-identifier1 [of [ fieldname1 : ] type1 [ * [ fieldname2 : ] type2 ...]\n    | case-identifier2 [of [fieldname3 : ]type3 [ * [ fieldname4 : ]type4 ...]\n...\n</code></pre><h2 id=\"remarks\">Remarks</h2>\n<p>Discriminated unions are similar to union types in other languages, but there are differences. As with a union type in C++ or a variant type in Visual Basic, the data stored in the value is not fixed; it can be one of several distinct options. Unlike unions in these other languages, however, each of the possible options is given a <em>case identifier</em>. The case identifiers are names for the various possible types of values that objects of this type could be; the values are optional. If values are not present, the case is equivalent to an enumeration case. If values are present, each value can either be a single value of a specified type, or a tuple that aggregates multiple fields of the same or different types. As of F# 3.1, you can give an individual field a name, but the name is optional, even if other fields in the same case are named.</p>\n<p>For example, consider the following declaration of a Shape type.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">type Shape =\n    | Rectangle of width : float * length : float\n    | Circle of radius : float\n    | Prism of width : float * float * height : float\n</code></pre><p>The preceding code declares a discriminated union Shape, which can have values of any of three cases: Rectangle, Circle, and Prism. Each case has a different set of fields. The Rectangle case has two named fields, both of type <code>float</code>, that have the names width and length. The Circle case has just one named field, radius. The Prism case has three fields, two of which (width and height) are named fields. Unnamed fields are referred to as anonymous fields.</p>\n<p>You construct objects by providing values for the named and anonymous fields according to the following examples.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let rect = Rectangle(length = 1.3, width = 10.0)\nlet circ = Circle (1.0)\nlet prism = Prism(5., 2.0, height = 3.0)\n</code></pre><p>This code shows that you can either use the named fields in the initialization, or you can rely on the ordering of the fields in the declaration and just provide the values for each field in turn. The constructor call for <code>rect</code> in the previous code uses the named fields, but the constructor call for <code>circ</code> uses the ordering. You can mix the ordered fields and named fields, as in the construction of <code>prism</code>.</p>\n<p>The <code>option</code> type is a simple discriminated union in the F# core library. The <code>option</code> type is declared as follows.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">// The option type is a discriminated union.\ntype Option&lt;&#39;a&gt; =\n    | Some of &#39;a\n    | None\n</code></pre><p>The previous code specifies that the type <code>Option</code> is a discriminated union that has two cases, <code>Some</code> and <code>None</code>. The <code>Some</code> case has an associated value that consists of one anonymous field whose type is represented by the type parameter <code>&#39;a</code>. The <code>None</code> case has no associated value. Thus the <code>option</code> type specifies a generic type that either has a value of some type or no value. The type <code>Option</code> also has a lowercase type alias, <code>option</code>, that is more commonly used.</p>\n<p>The case identifiers can be used as constructors for the discriminated union type. For example, the following code is used to create values of the <code>option</code> type.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let myOption1 = Some(10.0)\nlet myOption2 = Some(&quot;string&quot;)\nlet myOption3 = None\n</code></pre><p>The case identifiers are also used in pattern matching expressions. In a pattern matching expression, identifiers are provided for the values associated with the individual cases. For example, in the following code, <code>x</code> is the identifier given the value that is associated with the <code>Some</code> case of the <code>option</code> type.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let printValue opt =\n    match opt with\n    | Some x -&gt; printfn &quot;%A&quot; x\n    | None -&gt; printfn &quot;No value.&quot;\n</code></pre><p>In pattern matching expressions, you can use named fields to specify discriminated union matches. For the Shape type that was declared previously, you can use the named fields as the following code shows to extract the values of the fields.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let getShapeHeight shape =\n    match shape with\n    | Rectangle(height = h) -&gt; h\n    | Circle(radius = r) -&gt; 2. * r\n    | Prism(height = h) -&gt; h\n</code></pre><p>Normally, the case identifiers can be used without qualifying them with the name of the union. If you want the name to always be qualified with the name of the union, you can apply the <a href=\"https://msdn.microsoft.com/library/8b9b6ade-0471-4413-ac5d-638cd0de5f15\" data-linktype=\"external\">RequireQualifiedAccess</a> attribute to the union type definition.</p>\n<h2 id=\"using-discriminated-unions-instead-of-object-hierarchies\">Using Discriminated Unions Instead of Object Hierarchies</h2>\n<p>You can often use a discriminated union as a simpler alternative to a small object hierarchy. For example, the following discriminated union could be used instead of a <code>Shape</code> base class that has derived types for circle, square, and so on.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type Shape =\n  // The value here is the radius.\n| Circle of float\n  // The value here is the side length.\n| EquilateralTriangle of double\n  // The value here is the side length.\n| Square of double\n  // The values here are the height and width.\n| Rectangle of double * double\n</code></pre><p>Instead of a virtual method to compute an area or perimeter, as you would use in an object-oriented implementation, you can use pattern matching to branch to appropriate formulas to compute these quantities. In the following example, different formulas are used to compute the area, depending on the shape.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let pi = 3.141592654\n\nlet area myShape =\n    match myShape with\n    | Circle radius -&gt; pi * radius * radius\n    | EquilateralTriangle s -&gt; (sqrt 3.0) / 4.0 * s * s\n    | Square s -&gt; s * s\n    | Rectangle (h, w) -&gt; h * w\n\nlet radius = 15.0\nlet myCircle = Circle(radius)\nprintfn &quot;Area of circle that has radius %f: %f&quot; radius (area myCircle)\n\nlet squareSide = 10.0\nlet mySquare = Square(squareSide)\nprintfn &quot;Area of square that has side %f: %f&quot; squareSide (area mySquare)\n\nlet height, width = 5.0, 10.0\nlet myRectangle = Rectangle(height, width)\nprintfn &quot;Area of rectangle that has height %f and width %f is %f&quot; height width (area myRectangle)\n</code></pre><p>The output is as follows:</p>\n<pre class=\"loading\"><code>Area of circle that has radius 15.000000: 706.858347\nArea of square that has side 10.000000: 100.000000\nArea of rectangle that has height 5.000000 and width 10.000000 is 50.000000\n</code></pre><h2 id=\"using-discriminated-unions-for-tree-data-structures\">Using Discriminated Unions for Tree Data Structures</h2>\n<p>Discriminated unions can be recursive, meaning that the union itself can be included in the type of one or more cases. Recursive discriminated unions can be used to create tree structures, which are used to model expressions in programming languages. In the following code, a recursive discriminated union is used to create a binary tree data structure. The union consists of two cases, <code>Node</code>, which is a node with an integer value and left and right subtrees, and <code>Tip</code>, which terminates the tree.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type Tree =\n    | Tip\n    | Node of int * Tree * Tree\n\nlet rec sumTree tree =\n    match tree with\n    | Tip -&gt; 0\n    | Node(value, left, right) -&gt;\n        value + sumTree(left) + sumTree(right)\nlet myTree = Node(0, Node(1, Node(2, Tip, Tip), Node(3, Tip, Tip)), Node(4, Tip, Tip))\nlet resultSumTree = sumTree myTree\n</code></pre><p>In the previous code, <code>resultSumTree</code> has the value 10. The following illustration shows the tree structure for <code>myTree</code>.</p>\n<p><img src=\"../media/treestructurediagram.png\" alt=\"Tree structure for myTree\" data-linktype=\"relative-path\"></p>\n<p>Discriminated unions work well if the nodes in the tree are heterogeneous. In the following code, the type <code>Expression</code> represents the abstract syntax tree of an expression in a simple programming language that supports addition and multiplication of numbers and variables. Some of the union cases are not recursive and represent either numbers (<code>Number</code>) or variables (<code>Variable</code>). Other cases are recursive, and represent operations (<code>Add</code> and <code>Multiply</code>), where the operands are also expressions. The <code>Evaluate</code> function uses a match expression to recursively process the syntax tree.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type Expression =\n    | Number of int\n    | Add of Expression * Expression\n    | Multiply of Expression * Expression\n    | Variable of string\n\nlet rec Evaluate (env:Map&lt;string,int&gt;) exp =\n    match exp with\n    | Number n -&gt; n\n    | Add (x, y) -&gt; Evaluate env x + Evaluate env y\n    | Multiply (x, y) -&gt; Evaluate env x * Evaluate env y\n    | Variable id    -&gt; env.[id]\n\nlet environment = Map.ofList [ &quot;a&quot;, 1 ;\n                               &quot;b&quot;, 2 ;\n                               &quot;c&quot;, 3 ]\n\n// Create an expression tree that represents\n// the expression: a + 2 * b.\nlet expressionTree1 = Add(Variable &quot;a&quot;, Multiply(Number 2, Variable &quot;b&quot;))\n\n// Evaluate the expression a + 2 * b, given the\n// table of values for the variables.\nlet result = Evaluate environment expressionTree1\n</code></pre><p>When this code is executed, the value of <code>result</code> is 5.</p>\n<h2 id=\"see-also\">See Also</h2>\n<p><a href=\"index\" data-linktype=\"relative-path\">F# Language Reference</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet/toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"16e2a011-c785-48c8-859f-79df7f3a0e29\">\r\n<meta name=\"description\" content=\"Discriminated Unions (F#)\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming\">\r\n<meta name=\"ms.topic\" content=\"language-reference\">\r\n<meta name=\"ms.date\" content=\"05/16/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/0293858911fb719b743194ee52ec07a0ce47b82a/docs/fsharp/language-reference/discriminated-unions.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/discriminated-unions.md\">\r\n<meta name=\"document_id\" content=\"e42f861e-76cd-e7a8-8784-50ccc16aeff9\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Discriminated Unions (F#) | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"16e2a011-c785-48c8-859f-79df7f3a0e29","description":"Discriminated Unions (F#)","keywords":"visual f#, f#, functional programming","ms.topic":"language-reference","ms.date":"05/16/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Sam Grönblom","author_email":"sgronblo@gmail.com","committer_name":"Phillip Carter","comitter_email":"phillip.carter@outlook.com","message":"Fix broken sentence in discriminated-unions.md (#1322)","commit_sha":"0293858911fb719b743194ee52ec07a0ce47b82a","commit_date":"2016-12-11 19:28:18 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Tour of F# (#908)","commit_sha":"b07269aaa2cc042b1843207d7a31437034833cc6","commit_date":"2016-08-18 12:48:30 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Move snippets to snippets folder, now with some F# (#904)","commit_sha":"37fe2b89d590509e8eb14342da988f15862a9e2b","commit_date":"2016-08-13 16:40:56 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize F# snippets (#903)","commit_sha":"6ea1cf8f3779532a9ed8fbdac32592fbb809443c","commit_date":"2016-08-13 15:14:41 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"F# Docs: Update intro, move files, rename language reference for better URLS (#902)","commit_sha":"70a10b9c3e21291c96d927d13f8710d9e0738d4c","commit_date":"2016-08-13 11:22:39 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/sgronblo","display_name":"Sam Grönblom","id":"320449"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/0293858911fb719b743194ee52ec07a0ce47b82a/docs/fsharp/language-reference/discriminated-unions.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/discriminated-unions.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/language-reference/discriminated-unions.md","document_id":"e42f861e-76cd-e7a8-8784-50ccc16aeff9","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/discriminated-unions","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Discriminated Unions (F#)","_op_displayDate":"2016-5-16","_op_displayDate_source":"2016-05-16T00:00:00Z","_op_wordCount":1522,"_op_rawTitle":"<h1 id=\"discriminated-unions\" sourcefile=\"docs/fsharp/language-reference/discriminated-unions.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Discriminated Unions</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/discriminated-unions","fileRelativePath":"articles/fsharp/language-reference/discriminated-unions.html"},"themesRelativePathToOutputRoot":"_themes/"}