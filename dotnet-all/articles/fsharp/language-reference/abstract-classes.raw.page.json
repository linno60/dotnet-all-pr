{"content":"<div><div class=\"content\">\n<p><em>Abstract classes</em> are classes that leave some or all members unimplemented, so that implementations can be provided by derived classes.</p>\n<h2 id=\"syntax\">Syntax</h2>\n<pre class=\"loading\"><code class=\"lang-fsharp\">// Abstract class syntax.\n[&lt;AbstractClass&gt;]\ntype [ accessibility-modifier ] abstract-class-name =\n[ inherit base-class-or-interface-name ]\n[ abstract-member-declarations-and-member-definitions ]\n\n// Abstract member syntax.\nabstract member member-name : type-signature\n</code></pre><h2 id=\"remarks\">Remarks</h2>\n<p>In object-oriented programming, an abstract class is used as a base class of a hierarchy, and represents common functionality of a diverse set of object types. As the name &quot;abstract&quot; implies, abstract classes often do not correspond directly onto concrete entities in the problem domain. However, they do represent what many different concrete entities have in common.</p>\n<p>Abstract classes must have the <code>AbstractClass</code> attribute. They can have implemented and unimplemented members. The use of the term <em>abstract</em> when applied to a class is the same as in other .NET languages; however, the use of the term <em>abstract</em> when applied to methods (and properties) is a little different in F# from its use in other .NET languages. In F#, when a method is marked with the <code>abstract</code> keyword, this indicates that a member has an entry, known as a <em>virtual dispatch slot</em>, in the internal table of virtual functions for that type. In other words, the method is virtual, although the <code>virtual</code> keyword is not used in the F# language. The keyword <code>abstract</code> is used on virtual methods regardless of whether the method is implemented. The declaration of a virtual dispatch slot is separate from the definition of a method for that dispatch slot. Therefore, the F# equivalent of a virtual method declaration and definition in another .NET language is a combination of both an abstract method declaration and a separate definition, with either the <code>default</code> keyword or the <code>override</code> keyword. For more information and examples, see <a href=\"members/methods\" data-linktype=\"relative-path\">Methods</a>.</p>\n<p>A class is considered abstract only if there are abstract methods that are declared but not defined. Therefore, classes that have abstract methods are not necessarily abstract classes. Unless a class has undefined abstract methods, do not use the <strong>AbstractClass</strong> attribute.</p>\n<p>In the previous syntax, <em>accessibility-modifier</em> can be <code>public</code>, <code>private</code> or <code>internal</code>. For more information, see <a href=\"access-control\" data-linktype=\"relative-path\">Access Control</a>.</p>\n<p>As with other types, abstract classes can have a base class and one or more base interfaces. Each base class or interface appears on a separate line together with the <code>inherit</code> keyword.</p>\n<p>The type definition of an abstract class can contain fully defined members, but it can also contain abstract members. The syntax for abstract members is shown separately in the previous syntax. In this syntax, the <em>type signature</em> of a member is a list that contains the parameter types in order and the return types, separated by <code>-&gt;</code> tokens and/or <code>*</code> tokens as appropriate for curried and tupled parameters. The syntax for abstract member type signatures is the same as that used in signature files and that shown by IntelliSense in the Visual Studio Code Editor.</p>\n<p>The following code illustrates an abstract class Shape, which has two non-abstract derived classes, Square and Circle. The example shows how to use abstract classes, methods, and properties. In the example, the abstract class Shape represents the common elements of the concrete entities circle and square. The common features of all shapes (in a two-dimensional coordinate system) are abstracted out into the Shape class: the position on the grid, an angle of rotation, and the area and perimeter properties. These can be overridden, except for position, the behavior of which individual shapes cannot change.</p>\n<p>The rotation method can be overridden, as in the Circle class, which is rotation invariant because of its symmetry. So in the Circle class, the rotation method is replaced by a method that does nothing.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// An abstract class that has some methods and properties defined\n// and some left abstract.\n[&lt;AbstractClass&gt;]\ntype Shape2D(x0 : float, y0 : float) =\n    let mutable x, y = x0, y0\n    let mutable rotAngle = 0.0\n\n    // These properties are not declared abstract. They\n    // cannot be overriden.\n    member this.CenterX with get() = x and set xval = x &lt;- xval\n    member this.CenterY with get() = y and set yval = y &lt;- yval\n\n    // These properties are abstract, and no default implementation\n    // is provided. Non-abstract derived classes must implement these.\n    abstract Area : float with get\n    abstract Perimeter : float  with get\n    abstract Name : string with get\n\n    // This method is not declared abstract. It cannot be\n    // overriden.\n    member this.Move dx dy =\n       x &lt;- x + dx\n       y &lt;- y + dy\n\n    // An abstract method that is given a default implementation\n    // is equivalent to a virtual method in other .NET languages.\n    // Rotate changes the internal angle of rotation of the square.\n    // Angle is assumed to be in degrees.\n    abstract member Rotate: float -&gt; unit\n    default this.Rotate(angle) = rotAngle &lt;- rotAngle + angle\n\ntype Square(x, y, sideLengthIn) =\n    inherit Shape2D(x, y)\n    member this.SideLength = sideLengthIn\n    override this.Area = this.SideLength * this.SideLength\n    override this.Perimeter = this.SideLength * 4.\n    override this.Name = &quot;Square&quot;\n\ntype Circle(x, y, radius) =\n    inherit Shape2D(x, y)\n    let PI = 3.141592654\n    member this.Radius = radius\n    override this.Area = PI * this.Radius * this.Radius\n    override this.Perimeter = 2. * PI * this.Radius\n    // Rotating a circle does nothing, so use the wildcard\n    // character to discard the unused argument and\n    // evaluate to unit.\n    override this.Rotate(_) = ()\n    override this.Name = &quot;Circle&quot;\n\nlet square1 = new Square(0.0, 0.0, 10.0)\nlet circle1 = new Circle(0.0, 0.0, 5.0)\ncircle1.CenterX &lt;- 1.0\ncircle1.CenterY &lt;- -2.0\nsquare1.Move -1.0 2.0\nsquare1.Rotate 45.0\ncircle1.Rotate 45.0\nprintfn &quot;Perimeter of square with side length %f is %f, %f&quot;\n        (square1.SideLength) (square1.Area) (square1.Perimeter)\nprintfn &quot;Circumference of circle with radius %f is %f, %f&quot;\n        (circle1.Radius) (circle1.Area) (circle1.Perimeter)\n\nlet shapeList : list&lt;Shape2D&gt; = [ (square1 :&gt; Shape2D);\n                                  (circle1 :&gt; Shape2D) ]\nList.iter (fun (elem : Shape2D) -&gt;\n              printfn &quot;Area of %s: %f&quot; (elem.Name) (elem.Area))\n          shapeList\n</code></pre><p><strong>Output:</strong></p>\n<pre class=\"loading\"><code>Perimeter of square with side length 10.000000 is 40.000000\nCircumference of circle with radius 5.000000 is 31.415927\nArea of Square: 100.000000\nArea of Circle: 78.539816\n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p><a href=\"classes\" data-linktype=\"relative-path\">Classes</a></p>\n<p><a href=\"members/index\" data-linktype=\"relative-path\">Members</a></p>\n<p><a href=\"members/methods\" data-linktype=\"relative-path\">Methods</a></p>\n<p><a href=\"members/properties\" data-linktype=\"relative-path\">Properties</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"a3dcc335-433b-4672-ac2d-ae6b11b816f3\">\r\n<meta name=\"description\" content=\"Abstract Classes (F#)\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming\">\r\n<meta name=\"ms.topic\" content=\"language-reference\">\r\n<meta name=\"ms.date\" content=\"05/16/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/abstract-classes.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/abstract-classes.md\">\r\n<meta name=\"document_id\" content=\"6535ae16-f3f2-5f5e-443c-76469514b1ba\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Abstract Classes (F#) | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"a3dcc335-433b-4672-ac2d-ae6b11b816f3","description":"Abstract Classes (F#)","keywords":"visual f#, f#, functional programming","ms.topic":"language-reference","ms.date":"05/16/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Move snippets to snippets folder, now with some F# (#904)","commit_sha":"37fe2b89d590509e8eb14342da988f15862a9e2b","commit_date":"2016-08-13 16:40:56 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize F# snippets (#903)","commit_sha":"6ea1cf8f3779532a9ed8fbdac32592fbb809443c","commit_date":"2016-08-13 15:14:41 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"F# Docs: Update intro, move files, rename language reference for better URLS (#902)","commit_sha":"70a10b9c3e21291c96d927d13f8710d9e0738d4c","commit_date":"2016-08-13 11:22:39 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/abstract-classes.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/abstract-classes.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/language-reference/abstract-classes.md","document_id":"6535ae16-f3f2-5f5e-443c-76469514b1ba","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/abstract-classes","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Abstract Classes (F#)","_op_displayDate":"2016-5-16","_op_displayDate_source":"2016-05-16T00:00:00Z","_op_wordCount":988,"_op_rawTitle":"<h1 id=\"abstract-classes\" sourcefile=\"docs/fsharp/language-reference/abstract-classes.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Abstract Classes</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/abstract-classes","fileRelativePath":"articles/fsharp/language-reference/abstract-classes.html"},"themesRelativePathToOutputRoot":"_themes/"}