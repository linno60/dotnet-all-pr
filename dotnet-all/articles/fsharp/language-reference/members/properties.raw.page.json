{"content":"<div><div class=\"content\">\n<p><em>Properties</em> are members that represent values associated with an object.</p>\n<h2 id=\"syntax\">Syntax</h2>\n<pre class=\"loading\"><code class=\"lang-fsharp\">// Property that has both get and set defined.\n[ attributes ]\n[ static ] member [accessibility-modifier] [self-identifier.]PropertyName\nwith [accessibility-modifier] get() =\n    get-function-body\nand [accessibility-modifier] set parameter =\n    set-function-body\n\n// Alternative syntax for a property that has get and set.\n[ attributes-for-get ]\n[ static ] member [accessibility-modifier-for-get] [self-identifier.]PropertyName =\n    get-function-body\n[ attributes-for-set ]\n[ static ] member [accessibility-modifier-for-set] [self-identifier.]PropertyName\nwith set parameter =\n    set-function-body\n\n// Property that has get only.\n[ attributes ]\n[ static ] member [accessibility-modifier] [self-identifier.]PropertyName =\n    get-function-body\n\n// Alternative syntax for property that has get only.\n[ attributes ]\n[ static ] member [accessibility-modifier] [self-identifier.]PropertyName\nwith get() =\n    get-function-body\n\n// Property that has set only.\n[ attributes ]\n[ static ] member [accessibility-modifier] [self-identifier.]PropertyName\nwith set parameter =\n    set-function-body\n\n// Automatically implemented properties.\n[ attributes ]\n[ static ] member val [accessibility-modifier] PropertyName = initialization-expression [ with get, set ]\n</code></pre><h2 id=\"remarks\">Remarks</h2>\n<p>Properties represent the &quot;has a&quot; relationship in object-oriented programming, representing data that is associated with object instances or, for static properties, with the type.</p>\n<p>You can declare properties in two ways, depending on whether you want to explicitly specify the underlying value (also called the backing store) for the property, or if you want to allow the compiler to automatically generate the backing store for you. Generally, you should use the more explicit way if the property has a non-trivial implementation and the automatic way when the property is just a simple wrapper for a value or variable. To declare a property explicitly, use the <code>member</code> keyword. This declarative syntax is followed by the syntax that specifies the <code>get</code> and <code>set</code> methods, also named <em>accessors</em>. The various forms of the explicit syntax shown in the syntax section are used for read/write, read-only, and write-only properties. For read-only properties, you define only a <code>get</code> method; for write-only properties, define only a <code>set</code> method. Note that when a property has both <code>get</code> and <code>set</code> accessors, the alternative syntax enables you to specify attributes and accessibility modifiers that are different for each accessor, as is shown in the following code.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// A read-only property.\nmember this.MyReadOnlyProperty = myInternalValue\n// A write-only property.\nmember this.MyWriteOnlyProperty with set (value) = myInternalValue &lt;- value\n// A read-write property.\nmember this.MyReadWriteProperty\n    with get () = myInternalValue\n    and set (value) = myInternalValue &lt;- value\n</code></pre><p>For read/write properties, which have both a <code>get</code> and <code>set</code> method, the order of <code>get</code> and <code>set</code> can be reversed. Alternatively, you can provide the syntax shown for <code>get</code> only and the syntax shown for <code>set</code> only instead of using the combined syntax. Doing this makes it easier to comment out the individual <code>get</code> or <code>set</code> method, if that is something you might need to do. This alternative to using the combined syntax is shown in the following code.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">member this.MyReadWriteProperty with get () = myInternalValue\nmember this.MyReadWriteProperty with set (value) = myInternalValue &lt;- value\n</code></pre><p>Private values that hold the data for properties are called <em>backing stores</em>. To have the compiler create the backing store automatically, use the keywords <code>member val</code>, omit the self-identifier, then provide an expression to initialize the property. If the property is to be mutable, include <code>with get, set</code>. For example, the following class type includes two automatically implemented properties. <code>Property1</code> is read-only and is initialized to the argument provided to the primary constructor, and <code>Property2</code> is a settable property initialized to an empty string:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">type MyClass(property1 : int) =\nmember val Property1 = property1\nmember val Property2 = &quot;&quot; with get, set\n</code></pre><p>Automatically implemented properties are part of the initialization of a type, so they must be included before any other member definitions, just like <code>let</code> bindings and <code>do</code> bindings in a type definition. Note that the expression that initializes an automatically implemented property is only evaluated upon initialization, and not every time the property is accessed. This behavior is in contrast to the behavior of an explicitly implemented property. What this effectively means is that the code to initialize these properties is added to the constructor of a class. Consider the following code that shows this difference:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">type MyClass() =\n    let random  = new System.Random()\n    member val AutoProperty = random.Next() with get, set\n    member this.ExplicitProperty = random.Next()\n\nlet class1 = new MyClass()\n\nprintfn &quot;class1.AutoProperty = %d&quot; class1.AutoProperty\nprintfn &quot;class1.AutoProperty = %d&quot; class1.AutoProperty\nprintfn &quot;class1.ExplicitProperty = %d&quot; class1.ExplicitProperty\nprintfn &quot;class1.ExplicitProperty = %d&quot; class1.ExplicitProperty\n</code></pre><p><strong>Output</strong></p>\n<pre class=\"loading\"><code>class1.AutoProperty = 1853799794\nclass1.AutoProperty = 1853799794\nclass1.ExplicitProperty = 978922705\nclass1.ExplicitProperty = 1131210765\n</code></pre><p>The output of the preceding code shows that the value of AutoProperty is unchanged when called repeatedly, whereas the ExplicitProperty changes each time it is called. This demonstrates that the expression for an automatically implemented property is not evaluated each time, as is the getter method for the explicit property.</p>\n<div class=\"WARNING\"><h5>Warning</h5><p>There are some libraries, such as the Entity Framework (<code>System.Data.Entity</code>) that perform custom operations in base class constructors that don&#39;t work well with the initialization of automatically implemented properties. In those cases, try using explicit properties.</p>\n</div>\n<p>Properties can be members of classes, structures, discriminated unions, records, interfaces, and type extensions and can also be defined in object expressions.</p>\n<p>Attributes can be applied to properties. To apply an attribute to a property, write the attribute on a separate line before the property. For more information, see <a href=\"../attributes\" data-linktype=\"relative-path\">Attributes</a>.</p>\n<p>By default, properties are public. Accessibility modifiers can also be applied to properties. To apply an accessibility modifier, add it immediately before the name of the property if it is meant to apply to both the <code>get</code> and <code>set</code> methods; add it before the <code>get</code> and <code>set</code> keywords if different accessibility is required for each accessor. The <em>accessibility-modifier</em> can be one of the following: <code>public</code>, <code>private</code>, <code>internal</code>. For more information, see <a href=\"../access-control\" data-linktype=\"relative-path\">Access Control</a>.</p>\n<p>Property implementations are executed each time a property is accessed.</p>\n<h2 id=\"static-and-instance-properties\">Static and Instance Properties</h2>\n<p>Properties can be static or instance properties. Static properties can be invoked without an instance and are used for values associated with the type, not with individual objects. For static properties, omit the self-identifier. The self-identifier is required for instance properties.</p>\n<p>The following static property definition is based on a scenario in which you have a static field <code>myStaticValue</code> that is the backing store for the property.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">static member MyStaticProperty\n    with get() = myStaticValue\n    and set(value) = myStaticValue &lt;- value\n</code></pre><p>Properties can also be array-like, in which case they are called <em>indexed properties</em>. For more information, see <a href=\"indexed-properties\" data-linktype=\"relative-path\">Indexed Properties</a>.</p>\n<h2 id=\"type-annotation-for-properties\">Type Annotation for Properties</h2>\n<p>In many cases, the compiler has enough information to infer the type of a property from the type of the backing store, but you can set the type explicitly by adding a type annotation.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// To apply a type annotation to a property that does not have an explicit\n// get or set, apply the type annotation directly to the property.\nmember this.MyProperty1 : int = myInternalValue\n// If there is a get or set, apply the type annotation to the get or set method.\nmember this.MyProperty2 with get() : int = myInternalValue\n</code></pre><h2 id=\"using-property-set-accessors\">Using Property set Accessors</h2>\n<p>You can set properties that provide <code>set</code> accessors by using the <code>&lt;-</code> operator.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Assume that the constructor argument sets the initial value of the\n// internal backing store.\nlet mutable myObject = new MyType(10)\nmyObject.MyProperty &lt;- 20\nprintfn &quot;%d&quot; (myObject.MyProperty)\n</code></pre><p>The output is <strong>20</strong>.</p>\n<h2 id=\"abstract-properties\">Abstract Properties</h2>\n<p>Properties can be abstract. As with methods, <code>abstract</code> just means that there is a virtual dispatch associated with the property. Abstract properties can be truly abstract, that is, without a definition in the same class. The class that contains such a property is therefore an abstract class. Alternatively, abstract can just mean that a property is virtual, and in that case, a definition must be present in the same class. Note that abstract properties must not be private, and if one accessor is abstract, the other must also be abstract. For more information about abstract classes, see <a href=\"../abstract-classes\" data-linktype=\"relative-path\">Abstract Classes</a>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// Abstract property in abstract class.\n// The property is an int type that has a get and\n// set method\n[&lt;AbstractClass&gt;]\ntype AbstractBase() =\n   abstract Property1 : int with get, set\n\n// Implementation of the abstract property\ntype Derived1() =\n   inherit AbstractBase()\n   let mutable value = 10\n   override this.Property1 with get() = value and set(v : int) = value &lt;- v\n\n// A type with a &quot;virtual&quot; property.\n type Base1() =\n   let mutable value = 10\n   abstract Property1 : int with get, set\n   default this.Property1 with get() = value and set(v : int) = value &lt;- v\n\n// A derived type that overrides the virtual property\ntype Derived2() =\n   inherit Base1()\n   let mutable value2 = 11\n   override this.Property1 with get() = value2 and set(v) = value2 &lt;- v\n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p><a href=\"index\" data-linktype=\"relative-path\">Members</a></p>\n<p><a href=\"methods\" data-linktype=\"relative-path\">Methods</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"98b363a5-ee6a-4b7b-b8ae-b244f2a0b316\">\r\n<meta name=\"description\" content=\"Properties (F#)\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming\">\r\n<meta name=\"ms.topic\" content=\"language-reference\">\r\n<meta name=\"ms.date\" content=\"05/16/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/members/properties.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/members/properties.md\">\r\n<meta name=\"document_id\" content=\"f3c2a0d0-f0f8-d9d2-3156-3c96126405d2\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../../toc2.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","title":"Properties (F#) | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"98b363a5-ee6a-4b7b-b8ae-b244f2a0b316","description":"Properties (F#)","keywords":"visual f#, f#, functional programming","ms.topic":"language-reference","ms.date":"05/16/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Move snippets to snippets folder, now with some F# (#904)","commit_sha":"37fe2b89d590509e8eb14342da988f15862a9e2b","commit_date":"2016-08-13 16:40:56 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize F# snippets (#903)","commit_sha":"6ea1cf8f3779532a9ed8fbdac32592fbb809443c","commit_date":"2016-08-13 15:14:41 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"F# Docs: Update intro, move files, rename language reference for better URLS (#902)","commit_sha":"70a10b9c3e21291c96d927d13f8710d9e0738d4c","commit_date":"2016-08-13 11:22:39 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/members/properties.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/members/properties.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/language-reference/members/properties.md","document_id":"f3c2a0d0-f0f8-d9d2-3156-3c96126405d2","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/properties","toc_asset_id":"articles/toc.json","toc_rel":"../../../toc.json","_op_ogTitle":"Properties (F#)","_op_displayDate":"2016-5-16","_op_displayDate_source":"2016-05-16T00:00:00Z","_op_wordCount":1408,"_op_rawTitle":"<h1 id=\"properties\" sourcefile=\"docs/fsharp/language-reference/members/properties.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Properties</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/properties","fileRelativePath":"articles/fsharp/language-reference/members/properties.html"},"themesRelativePathToOutputRoot":"_themes/"}