{"content":"<div><div class=\"content\">\n<p>A <em>method</em> is a function that is associated with a type. In object-oriented programming, methods are used to expose and implement the functionality and behavior of objects and types.</p>\n<h2 id=\"syntax\">Syntax</h2>\n<pre class=\"loading\"><code class=\"lang-fsharp\">// Instance method definition.\n[ attributes ]\nmember [inline] self-identifier.method-nameparameter-list [ : return-type ]=\n    method-body\n\n// Static method definition.\n[ attributes ]\nstatic member [inline] method-nameparameter-list [ : return-type ]=\n    method-body\n\n// Abstract method declaration or virtual dispatch slot.\n[ attributes ]\nabstract member self-identifier.method-name : type-signature\n\n// Virtual method declaration and default implementation.\n[ attributes ]\nabstract member [inline] self-identifier.method-name : type-signature\n[ attributes ]\ndefault member [inline] self-identifier.method-nameparameter-list[ : return-type ] =\n    method-body\n\n// Override of inherited virtual method.\n[ attributes ]\noverride member [inline] self-identifier.method-nameparameter-list [ : return-type ]=\n    method-body\n</code></pre><h2 id=\"remarks\">Remarks</h2>\n<p>In the previous syntax, you can see the various forms of method declarations and definitions. In longer method bodies, a line break follows the equal sign (=), and the whole method body is indented.</p>\n<p>Attributes can be applied to any method declaration. They precede the syntax for a method definition and are usually listed on a separate line. For more information, see <a href=\"../attributes\" data-linktype=\"relative-path\">Attributes</a>.</p>\n<p>Methods can be marked <code>inline</code>. For information about <code>inline</code>, see <a href=\"../functions/inline-functions\" data-linktype=\"relative-path\">Inline Functions</a>.</p>\n<p>Non-inline methods can be used recursively within the type; there is no need to explicitly use the <code>rec</code> keyword.</p>\n<h2 id=\"instance-methods\">Instance Methods</h2>\n<p>Instance methods are declared with the <code>member</code> keyword and a <em>self-identifier</em>, followed by a period (.) and the method name and parameters. As is the case for <code>let</code> bindings, the <em>parameter-list</em> can be a pattern. Typically, you enclose method parameters in parentheses in a tuple form, which is the way methods appear in F# when they are created in other .NET Framework languages. However, the curried form (parameters separated by spaces) is also common, and other patterns are supported also.</p>\n<p>The following example illustrates the definition and use of a non-abstract instance method.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type SomeType(factor0: int) =\n   let factor = factor0\n   member this.SomeMethod(a, b, c) =\n      (a + b + c) * factor\n\n   member this.SomeOtherMethod(a, b, c) =\n      this.SomeMethod(a, b, c) * factor\n</code></pre><p>Within instance methods, do not use the self identifier to access fields defined by using let bindings. Use the self identifier when accessing other members and properties.</p>\n<h2 id=\"static-methods\">Static Methods</h2>\n<p>The keyword <code>static</code> is used to specify that a method can be called without an instance and is not associated with an object instance. Otherwise, methods are instance methods.</p>\n<p>The example in the next section shows fields declared with the <code>let</code> keyword, property members declared with the <code>member</code> keyword, and a static method declared with the <code>static</code> keyword.</p>\n<p>The following example illustrates the definition and use of static methods. Assume that these method definitions are in the <code>SomeType</code> class in the previous section.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">static member SomeStaticMethod(a, b, c) =\n   (a + b + c)\n\nstatic member SomeOtherStaticMethod(a, b, c) =\n   SomeType.SomeStaticMethod(a, b, c) * 100\n</code></pre><h2 id=\"abstract-and-virtual-methods\">Abstract and Virtual Methods</h2>\n<p>The keyword <code>abstract</code> indicates that a method has a virtual dispatch slot and might not have a definition in the class. A <em>virtual dispatch slot</em> is an entry in an internally maintained table of functions that is used at run time to look up virtual function calls in an object-oriented type. The virtual dispatch mechanism is the mechanism that implements <em>polymorphism</em>, an important feature of object-oriented programming. A class that has at least one abstract method without a definition is an <em>abstract class</em>, which means that no instances can be created of that class. For more information about abstract classes, see <a href=\"../abstract-classes\" data-linktype=\"relative-path\">Abstract Classes</a>.</p>\n<p>Abstract method declarations do not include a method body. Instead, the name of the method is followed by a colon (:) and a type signature for the method. The type signature of a method is the same as that shown by IntelliSense when you pause the mouse pointer over a method name in the Visual Studio Code Editor, except without parameter names. Type signatures are also displayed by the interpreter, fsi.exe, when you are working interactively. The type signature of a method is formed by listing out the types of the parameters, followed by the return type, with appropriate separator symbols. Curried parameters are separated by <code>-&gt;</code> and tuple parameters are separated by <code>*</code>. The return value is always separated from the arguments by a <code>-&gt;</code> symbol. Parentheses can be used to group complex parameters, such as when a function type is a parameter, or to indicate when a tuple is treated as a single parameter rather than as two parameters.</p>\n<p>You can also give abstract methods default definitions by adding the definition to the class and using the <code>default</code> keyword, as shown in the syntax block in this topic. An abstract method that has a definition in the same class is equivalent to a virtual method in other .NET Framework languages. Whether or not a definition exists, the <code>abstract</code> keyword creates a new dispatch slot in the virtual function table for the class.</p>\n<p>Regardless of whether a base class implements its abstract methods, derived classes can provide implementations of abstract methods. To implement an abstract method in a derived class, define a method that has the same name and signature in the derived class, except use the <code>override</code> or <code>default</code> keyword, and provide the method body. The keywords <code>override</code> and <code>default</code> mean exactly the same thing. Use <code>override</code> if the new method overrides a base class implementation; use <code>default</code> when you create an implementation in the same class as the original abstract declaration. Do not use the <code>abstract</code> keyword on the method that implements the method that was declared abstract in the base class.</p>\n<p>The following example illustrates an abstract method <code>Rotate</code> that has a default implementation, the equivalent of a .NET Framework virtual method.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type Ellipse(a0 : float, b0 : float, theta0 : float) =\n    let mutable axis1 = a0\n    let mutable axis2 = b0\n    let mutable rotAngle = theta0\n    abstract member Rotate: float -&gt; unit\n    default this.Rotate(delta : float) = rotAngle &lt;- rotAngle + delta\n</code></pre><p>The following example illustrates a derived class that overrides a base class method. In this case, the override changes the behavior so that the method does nothing.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type Circle(radius : float) =\n    inherit Ellipse(radius, radius, 0.0)\n     // Circles are invariant to rotation, so do nothing.\n    override this.Rotate(_) = ()\n</code></pre><h2 id=\"overloaded-methods\">Overloaded Methods</h2>\n<p>Overloaded methods are methods that have identical names in a given type but that have different arguments. In F#, optional arguments are usually used instead of overloaded methods. However, overloaded methods are permitted in the language, provided that the arguments are in tuple form, not curried form.</p>\n<h2 id=\"example-properties-and-methods\">Example: Properties and Methods</h2>\n<p>The following example contains a type that has examples of fields, private functions, properties, and a static method.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type RectangleXY(x1 : float, y1: float, x2: float, y2: float) =\n    // Field definitions.\n    let height = y2 - y1\n    let width = x2 - x1\n    let area = height * width\n    // Private functions.\n    static let maxFloat (x: float) (y: float) =\n      if x &gt;= y then x else y\n    static let minFloat (x: float) (y: float) =\n      if x &lt;= y then x else y\n    // Properties.\n    // Here, &quot;this&quot; is used as the self identifier,\n    // but it can be any identifier.\n    member this.X1 = x1\n    member this.Y1 = y1\n    member this.X2 = x2\n    member this.Y2 = y2\n    // A static method.\n    static member intersection(rect1 : RectangleXY, rect2 : RectangleXY) =\n       let x1 = maxFloat rect1.X1 rect2.X1\n       let y1 = maxFloat rect1.Y1 rect2.Y1\n       let x2 = minFloat rect1.X2 rect2.X2\n       let y2 = minFloat rect1.Y2 rect2.Y2\n       let result : RectangleXY option =\n         if ( x2 &gt; x1 &amp;&amp; y2 &gt; y1) then\n           Some (RectangleXY(x1, y1, x2, y2))\n         else\n           None\n       result\n\n// Test code.\nlet testIntersection =\n    let r1 = RectangleXY(10.0, 10.0, 20.0, 20.0)\n    let r2 = RectangleXY(15.0, 15.0, 25.0, 25.0)\n    let r3 : RectangleXY option = RectangleXY.intersection(r1, r2)\n    match r3 with\n    | Some(r3) -&gt; printfn &quot;Intersection rectangle: %f %f %f %f&quot; r3.X1 r3.Y1 r3.X2 r3.Y2\n    | None -&gt; printfn &quot;No intersection found.&quot;\n\ntestIntersection\n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p><a href=\"index\" data-linktype=\"relative-path\">Members</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc1.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"1febab3b-c922-49c6-889f-c22db107710c\">\r\n<meta name=\"description\" content=\"Methods (F#)\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming\">\r\n<meta name=\"ms.topic\" content=\"language-reference\">\r\n<meta name=\"ms.date\" content=\"05/16/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/members/methods.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/members/methods.md\">\r\n<meta name=\"document_id\" content=\"976858e2-1215-2e8f-008e-90f35db2e6be\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../../toc1.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","title":"Methods (F#) | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"1febab3b-c922-49c6-889f-c22db107710c","description":"Methods (F#)","keywords":"visual f#, f#, functional programming","ms.topic":"language-reference","ms.date":"05/16/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Move snippets to snippets folder, now with some F# (#904)","commit_sha":"37fe2b89d590509e8eb14342da988f15862a9e2b","commit_date":"2016-08-13 16:40:56 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize F# snippets (#903)","commit_sha":"6ea1cf8f3779532a9ed8fbdac32592fbb809443c","commit_date":"2016-08-13 15:14:41 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"F# Docs: Update intro, move files, rename language reference for better URLS (#902)","commit_sha":"70a10b9c3e21291c96d927d13f8710d9e0738d4c","commit_date":"2016-08-13 11:22:39 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/members/methods.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/members/methods.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/language-reference/members/methods.md","document_id":"976858e2-1215-2e8f-008e-90f35db2e6be","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/methods","toc_asset_id":"articles/toc.json","toc_rel":"../../../toc.json","_op_ogTitle":"Methods (F#)","_op_displayDate":"2016-5-16","_op_displayDate_source":"2016-05-16T00:00:00Z","_op_wordCount":1294,"_op_rawTitle":"<h1 id=\"methods\" sourcefile=\"docs/fsharp/language-reference/members/methods.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Methods</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/methods","fileRelativePath":"articles/fsharp/language-reference/members/methods.html"},"themesRelativePathToOutputRoot":"_themes/"}