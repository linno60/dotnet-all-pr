{"content":"<div><div class=\"content\">\n<div class=\"NOTE\"><h5>Note</h5><p>The API reference links in this article will take you to MSDN.  The docs.microsoft.com API reference is not complete.</p>\n</div>\n<p>Events enable you to associate function calls with user actions and are important in GUI programming. Events can also be triggered by your applications or by the operating system.</p>\n<h2 id=\"handling-events\">Handling Events</h2>\n<p>When you use a GUI library like Windows Forms or Windows Presentation Foundation (WPF), much of the code in your application runs in response to events that are predefined by the library. These predefined events are members of GUI classes such as forms and controls. You can add custom behavior to a preexisting event, such as a button click, by referencing the specific named event of interest (for example, the <code>Click</code> event of the <code>Form</code> class) and invoking the <code>Add</code> method, as shown in the following code. If you run this from F# Interactive, omit the call to <code>System.Windows.Forms.Application.Run(System.Windows.Forms.Form)</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">open System.Windows.Forms\n\nlet form = new Form(Text=&quot;F# Windows Form&quot;,\n                    Visible = true,\n                    TopMost = true)\n\nform.Click.Add(fun evArgs -&gt; System.Console.Beep())\nApplication.Run(form)\n</code></pre><p>The type of the <code>Add</code> method is <code>(&#39;a -&gt; unit) -&gt; unit</code>. Therefore, the event handler method takes one parameter, typically the event arguments, and returns <code>unit</code>. The previous example shows the event handler as a lambda expression. The event handler can also be a function value, as in the following code example. The following code example also shows the use of the event handler parameters, which provide information specific to the type of event. For a <code>MouseMove</code> event, the system passes a <code>System.Windows.Forms.MouseEventArgs</code> object, which contains the <code>X</code> and <code>Y</code> position of the pointer.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">open System.Windows.Forms\n\nlet Beep evArgs =\n    System.Console.Beep( )\n\n\nlet form = new Form(Text = &quot;F# Windows Form&quot;,\n                    Visible = true,\n                    TopMost = true)\n\nlet MouseMoveEventHandler (evArgs : System.Windows.Forms.MouseEventArgs) =\n    form.Text &lt;- System.String.Format(&quot;{0},{1}&quot;, evArgs.X, evArgs.Y)\n\nform.Click.Add(Beep)\nform.MouseMove.Add(MouseMoveEventHandler)\nApplication.Run(form)\n</code></pre><h2 id=\"creating-custom-events\">Creating Custom Events</h2>\n<p>F# events are represented by the F# <a href=\"https://msdn.microsoft.com/library/f3b47c8a-4ee5-4ce8-9a72-ad305a17c4b9\" data-linktype=\"external\">Event</a> class, which implements the <a href=\"https://msdn.microsoft.com/library/8dbca0df-f8a1-40bd-8d50-aa26f6a8b862\" data-linktype=\"external\">IEvent</a> interface. <code>IEvent</code> is itself an interface that combines the functionality of two other interfaces, <code>System.IObservable&lt;&#39;T&gt;</code> and <a href=\"https://msdn.microsoft.com/library/3d849465-6b8e-4fc5-b36c-2941d734268a\" data-linktype=\"external\">IDelegateEvent</a>. Therefore, <code>Event</code>s have the equivalent functionality of delegates in other languages, plus the additional functionality from <code>IObservable</code>, which means that F# events support event filtering and using F# first-class functions and lambda expressions as event handlers. This functionality is provided in the <a href=\"https://msdn.microsoft.com/library/8b883baa-a460-4840-9baa-de8260351bc7\" data-linktype=\"external\">Event module</a>.</p>\n<p>To create an event on a class that acts just like any other .NET Framework event, add to the class a <code>let</code> binding that defines an <code>Event</code> as a field in a class. You can specify the desired event argument type as the type argument, or leave it blank and have the compiler infer the appropriate type. You also must define an event member that exposes the event as a CLI event. This member should have the <a href=\"https://msdn.microsoft.com/library/d359f1dd-ffa5-42fb-8808-b4c8131a0333\" data-linktype=\"external\">CLIEvent</a> attribute. It is declared like a property and its implementation is just a call to the <a href=\"https://msdn.microsoft.com/library/b0fdaad5-25e5-43d0-9c0c-ce37c4aeb68e\" data-linktype=\"external\">Publish</a> property of the event. Users of your class can use the <code>Add</code> method of the published event to add a handler. The argument for the <code>Add</code> method can be a lambda expression. You can use the <code>Trigger</code> property of the event to raise the event, passing the arguments to the handler function. The following code example illustrates this. In this example, the inferred type argument for the event is a tuple, which represents the arguments for the lambda expression.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">open System.Collections.Generic\n\ntype MyClassWithCLIEvent() =\n\n    let event1 = new Event&lt;_&gt;()\n\n    [&lt;CLIEvent&gt;]\n    member this.Event1 = event1.Publish\n\n    member this.TestEvent(arg) =\n        event1.Trigger(this, arg)\n\nlet classWithEvent = new MyClassWithCLIEvent()\nclassWithEvent.Event1.Add(fun (sender, arg) -&gt;\n        printfn &quot;Event1 occurred! Object data: %s&quot; arg)\n\nclassWithEvent.TestEvent(&quot;Hello World!&quot;)\n\nSystem.Console.ReadLine() |&gt; ignore\n</code></pre><p>The output is as follows.</p>\n<pre class=\"loading\"><code>Event1 occurred! Object data: Hello World!\n</code></pre><p>The additional functionality provided by the <code>Event</code> module is illustrated here. The following code example illustrates the basic use of <code>Event.create</code> to create an event and a trigger method, add two event handlers in the form of lambda expressions, and then trigger the event to execute both lambda expressions.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type MyType() =\n    let myEvent = new Event&lt;_&gt;()\n\n    member this.AddHandlers() =\n       Event.add (fun string1 -&gt; printfn &quot;%s&quot; string1) myEvent.Publish\n       Event.add (fun string1 -&gt; printfn &quot;Given a value: %s&quot; string1) myEvent.Publish\n\n    member this.Trigger(message) =\n       myEvent.Trigger(message)\n\nlet myMyType = MyType()\nmyMyType.AddHandlers()\nmyMyType.Trigger(&quot;Event occurred.&quot;)\n</code></pre><p>The output of the previous code is as follows.</p>\n<pre class=\"loading\"><code>Event occurred.\nGiven a value: Event occurred.\n</code></pre><h2 id=\"processing-event-streams\">Processing Event Streams</h2>\n<p>Instead of just adding an event handler for an event by using the <a href=\"https://msdn.microsoft.com/library/10670d3b-8d47-4f6e-b8df-ebc6f64ef4fd\" data-linktype=\"external\">Event.add</a> function, you can use the functions in the <code>Event</code> module to process streams of events in highly customized ways. To do this, you use the forward pipe (<code>|&gt;</code>) together with the event as the first value in a series of function calls, and the <code>Event</code> module functions as subsequent function calls.</p>\n<p>The following code example shows how to set up an event for which the handler is only called under certain conditions.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let form = new Form(Text = &quot;F# Windows Form&quot;,\n                    Visible = true,\n                    TopMost = true)\nform.MouseMove\n    |&gt; Event.filter ( fun evArgs -&gt; evArgs.X &gt; 100 &amp;&amp; evArgs.Y &gt; 100)\n    |&gt; Event.add ( fun evArgs -&gt;\n        form.BackColor &lt;- System.Drawing.Color.FromArgb(\n            evArgs.X, evArgs.Y, evArgs.X ^^^ evArgs.Y) )\n</code></pre><p>The <a href=\"https://msdn.microsoft.com/library/16b8610b-b30a-4df7-aa99-d9d352276227\" data-linktype=\"external\">Observable module</a> contains similar functions that operate on observable objects. Observable objects are similar to events but only actively subscribe to events if they themselves are being subscribed to.</p>\n<h2 id=\"implementing-an-interface-event\">Implementing an Interface Event</h2>\n<p>As you develop UI components, you often start by creating a new form or a new control that inherits from an existing form or control. Events are frequently defined on an interface, and, in that case, you must implement the interface to implement the event. The <code>System.ComponentModel.INotifyPropertyChanged</code> interface defines a single <code>System.ComponentModel.INotifyPropertyChanged.PropertyChanged</code> event. The following code illustrates how to implement the event that this inherited interface defined:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">module CustomForm\n\nopen System.Windows.Forms\nopen System.ComponentModel\n\ntype AppForm() as this =\n    inherit Form()\n\n    // Define the propertyChanged event.\n    let propertyChanged = Event&lt;PropertyChangedEventHandler, PropertyChangedEventArgs&gt;()\n    let mutable underlyingValue = &quot;text0&quot;\n\n    // Set up a click event to change the properties.\n    do\n        this.Click |&gt; Event.add(fun evArgs -&gt; this.Property1 &lt;- &quot;text2&quot;\n        this.Property2 &lt;- &quot;text3&quot;)\n\n    // This property does not have the property-changed event set.\n    member val Property1 : string = &quot;text&quot; with get, set\n\n    // This property has the property-changed event set.\n    member this.Property2\n        with get() = underlyingValue\n        and set(newValue) =\n            underlyingValue &lt;- newValue\n            propertyChanged.Trigger(this, new PropertyChangedEventArgs(&quot;Property2&quot;))\n\n    // Expose the PropertyChanged event as a first class .NET event.\n    [&lt;CLIEvent&gt;]\n    member this.PropertyChanged = propertyChanged.Publish\n\n\n    // Define the add and remove methods to implement this interface.\n    interface INotifyPropertyChanged with\n        member this.add_PropertyChanged(handler) = propertyChanged.Publish.AddHandler(handler)\n        member this.remove_PropertyChanged(handler) = propertyChanged.Publish.RemoveHandler(handler)\n\n    // This is the event-handler method.\n    member this.OnPropertyChanged(args : PropertyChangedEventArgs) =\n        let newProperty = this.GetType().GetProperty(args.PropertyName)\n        let newValue = newProperty.GetValue(this :&gt; obj) :?&gt; string\n        printfn &quot;Property %s changed its value to %s&quot; args.PropertyName newValue\n\n// Create a form, hook up the event handler, and start the application.\nlet appForm = new AppForm()\nlet inpc = appForm :&gt; INotifyPropertyChanged\ninpc.PropertyChanged.Add(appForm.OnPropertyChanged)\nApplication.Run(appForm)\n</code></pre><p>If you want to hook up the event in the constructor, the code is a bit more complicated because the event hookup must be in a <code>then</code> block in an additional constructor, as in the following example:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">module CustomForm\n\nopen System.Windows.Forms\nopen System.ComponentModel\n\n// Create a private constructor with a dummy argument so that the public\n// constructor can have no arguments.\ntype AppForm private (dummy) as this =\n    inherit Form()\n\n    // Define the propertyChanged event.\n    let propertyChanged = Event&lt;PropertyChangedEventHandler, PropertyChangedEventArgs&gt;()\n    let mutable underlyingValue = &quot;text0&quot;\n\n    // Set up a click event to change the properties.\n    do\n        this.Click |&gt; Event.add(fun evArgs -&gt; this.Property1 &lt;- &quot;text2&quot;\n        this.Property2 &lt;- &quot;text3&quot;)\n\n\n    // This property does not have the property changed event set.\n    member val Property1 : string = &quot;text&quot; with get, set\n\n    // This property has the property changed event set.\n    member this.Property2\n        with get() = underlyingValue\n        and set(newValue) =\n            underlyingValue &lt;- newValue\n            propertyChanged.Trigger(this, new PropertyChangedEventArgs(&quot;Property2&quot;))\n\n    [&lt;CLIEvent&gt;]\n    member this.PropertyChanged = propertyChanged.Publish\n\n    // Define the add and remove methods to implement this interface.\n    interface INotifyPropertyChanged with\n        member this.add_PropertyChanged(handler) = this.PropertyChanged.AddHandler(handler)\n        member this.remove_PropertyChanged(handler) = this.PropertyChanged.RemoveHandler(handler)\n\n    // This is the event handler method.\n    member this.OnPropertyChanged(args : PropertyChangedEventArgs) =\n        let newProperty = this.GetType().GetProperty(args.PropertyName)\n        let newValue = newProperty.GetValue(this :&gt; obj) :?&gt; string\n        printfn &quot;Property %s changed its value to %s&quot; args.PropertyName newValue\n\n    new() as this =\n        new AppForm(0)\n        then\n            let inpc = this :&gt; INotifyPropertyChanged\n            inpc.PropertyChanged.Add(this.OnPropertyChanged)\n\n\n// Create a form, hook up the event handler, and start the application.\nlet appForm = new AppForm()\nApplication.Run(appForm)\n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p><a href=\"index\" data-linktype=\"relative-path\">Members</a></p>\n<p><a href=\"https://msdn.microsoft.com/library/edzehd2t.aspx\" data-linktype=\"external\">Handling and Raising Events</a></p>\n<p><a href=\"../functions/lambda-expressions-the-fun-keyword\" data-linktype=\"relative-path\">Lambda Expressions: The <code>fun</code> Keyword</a></p>\n<p><a href=\"https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.event-module-%5bfsharp%5d\" data-linktype=\"external\">Control.Event Module</a></p>\n<p><a href=\"https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.event%5b%27t%5d-class-%5bfsharp%5d\" data-linktype=\"external\">Control.Event&#60;&#39;T&#62; Class</a></p>\n<p><a href=\"https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.event%5b%27delegate%2c%27args%5d-class-%5bfsharp%5d\" data-linktype=\"external\">Control.Event&#60;&#39;Delegate,&#39;Args&#62; Class</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"28b588f2-0c9e-4c0d-babf-901ed934638a\">\r\n<meta name=\"description\" content=\"Events (F#)\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming\">\r\n<meta name=\"ms.topic\" content=\"language-reference\">\r\n<meta name=\"ms.date\" content=\"05/16/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/members/events.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/members/events.md\">\r\n<meta name=\"document_id\" content=\"b1f929cc-103c-2a99-0022-bce2389daf5e\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../../toc2.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","title":"Events (F#) | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"28b588f2-0c9e-4c0d-babf-901ed934638a","description":"Events (F#)","keywords":"visual f#, f#, functional programming","ms.topic":"language-reference","ms.date":"05/16/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"fixed absolute and msdn links (#1001)","commit_sha":"de0dab146fc811e895dc32f98f877db5e757f82b","commit_date":"2016-09-06 10:59:39 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Move snippets to snippets folder, now with some F# (#904)","commit_sha":"37fe2b89d590509e8eb14342da988f15862a9e2b","commit_date":"2016-08-13 16:40:56 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize F# snippets (#903)","commit_sha":"6ea1cf8f3779532a9ed8fbdac32592fbb809443c","commit_date":"2016-08-13 15:14:41 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"F# Docs: Update intro, move files, rename language reference for better URLS (#902)","commit_sha":"70a10b9c3e21291c96d927d13f8710d9e0738d4c","commit_date":"2016-08-13 11:22:39 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/members/events.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/members/events.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/language-reference/members/events.md","document_id":"b1f929cc-103c-2a99-0022-bce2389daf5e","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/events","toc_asset_id":"articles/toc.json","toc_rel":"../../../toc.json","_op_ogTitle":"Events (F#)","_op_displayDate":"2016-5-16","_op_displayDate_source":"2016-05-16T00:00:00Z","_op_wordCount":1392,"_op_rawTitle":"<h1 id=\"events\" sourcefile=\"docs/fsharp/language-reference/members/events.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Events</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/events","fileRelativePath":"articles/fsharp/language-reference/members/events.html"},"themesRelativePathToOutputRoot":"_themes/"}