{"content":"<div><div class=\"content\">\n<div class=\"NOTE\"><h5>Note</h5><p>The following article does not cover using the <code>struct</code> attribute for Records yet, which is an F# 4.1 feature.  It will be documented here.</p>\n</div>\n<p>Records represent simple aggregates of named values, optionally with members.</p>\n<h2 id=\"syntax\">Syntax</h2>\n<pre class=\"loading\"><code class=\"lang-fsharp\">[ attributes ]\ntype [accessibility-modifier] typename = {\n    [ mutable ] label1 : type1;\n    [ mutable ] label2 : type2;\n    ...\n}\n    [ member-list ]\n</code></pre><h2 id=\"remarks\">Remarks</h2>\n<p>In the previous syntax, <em>typename</em> is the name of the record type, <em>label1</em> and <em>label2</em> are names of values, referred to as <em>labels</em>, and <em>type1</em> and <em>type2</em> are the types of these values. <em>member-list</em> is the optional list of members for the type.</p>\n<p>Following are some examples.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type Point = { x : float; y: float; z: float; }\ntype Customer = { First : string; Last: string; SSN: uint32; AccountNumber : uint32; }\n</code></pre><p>When each label is on a separate line, the semicolon is optional.</p>\n<p>You can set values in expressions known as <em>record expressions</em>. The compiler infers the type from the labels used (if the labels are sufficiently distinct from those of other record types). Braces ({ }) enclose the record expression. The following code shows a record expression that initializes a record with three float elements with labels <code>x</code>, <code>y</code> and <code>z</code>.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let mypoint = { x = 1.0; y = 1.0; z = -1.0; }\n</code></pre><p>Do not use the shortened form if there could be another type that also has the same labels.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type Point = { x : float; y: float; z: float; }\ntype Point3D = { x: float; y: float; z: float }\n// Ambiguity: Point or Point3D?\nlet mypoint3D = { x = 1.0; y = 1.0; z = 0.0; }\n</code></pre><p>The labels of the most recently declared type take precedence over those of the previously declared type, so in the preceding example, <code>mypoint3D</code> is inferred to be <code>Point3D</code>. You can explicitly specify the record type, as in the following code.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let myPoint1 = { Point.x = 1.0; y = 1.0; z = 0.0; }\n</code></pre><p>Methods can be defined for record types just as for class types.</p>\n<h2 id=\"creating-records-by-using-record-expressions\">Creating Records by Using Record Expressions</h2>\n<p>You can initialize records by using the labels that are defined in the record. An expression that does this is referred to as a <em>record expression</em>. Use braces to enclose the record expression and use the semicolon as a delimiter.</p>\n<p>The following example shows how to create a record.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type MyRecord = {\n    X: int;\n    Y: int;\n    Z: int\n    }\n\nlet myRecord1 = { X = 1; Y = 2; Z = 3; }\n</code></pre><p>The semicolons after the last field in the record expression and in the type definition are optional, regardless of whether the fields are all in one line.</p>\n<p>When you create a record, you must supply values for each field. You cannot refer to the values of other fields in the initialization expression for any field.</p>\n<p>In the following code, the type of <code>myRecord2</code> is inferred from the names of the fields. Optionally, you can specify the type name explicitly.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let myRecord2 = { MyRecord.X = 1; MyRecord.Y = 2; MyRecord.Z = 3 }\n</code></pre><p>Another form of record construction can be useful when you have to copy an existing record, and possibly change some of the field values. The following line of code illustrates this.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let myRecord3 = { myRecord2 with Y = 100; Z = 2 }\n</code></pre><p>This form of the record expression is called the <em>copy and update record expression</em>.</p>\n<p>Records are immutable by default; however, you can easily create modified records by using a copy and update expression. You can also explicitly specify a mutable field.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type Car = {\n    Make : string\n    Model : string\n    mutable Odometer : int\n    }\nlet myCar = { Make = &quot;Fabrikam&quot;; Model = &quot;Coupe&quot;; Odometer = 108112 }\nmyCar.Odometer &lt;- myCar.Odometer + 21\n</code></pre><p>Don&#39;t use the DefaultValue attribute with record fields. A better approach is to define default instances of records with fields that are initialized to default values and then use a copy and update record expression to set any fields that differ from the default values.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">// Rather than use [&lt;DefaultValue&gt;], define a default record.\ntype MyRecord =\n{\n    field1 : int\n    field2 : int\n}\n\nlet defaultRecord1 = { field1 = 0; field2 = 0 }\nlet defaultRecord2 = { field1 = 1; field2 = 25 }\n\n// Use the with keyword to populate only a few chosen fields\n// and leave the rest with default values.\nlet rr3 = { defaultRecord1 with field2 = 42 }\n</code></pre><h2 id=\"pattern-matching-with-records\">Pattern Matching with Records</h2>\n<p>Records can be used with pattern matching. You can specify some fields explicitly and provide variables for other fields that will be assigned when a match occurs. The following code example illustrates this.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type Point3D = { x: float; y: float; z: float }\nlet evaluatePoint (point: Point3D) =\n    match point with\n    | { x = 0.0; y = 0.0; z = 0.0 } -&gt; printfn &quot;Point is at the origin.&quot;\n    | { x = xVal; y = 0.0; z = 0.0 } -&gt; printfn &quot;Point is on the x-axis. Value is %f.&quot; xVal\n    | { x = 0.0; y = yVal; z = 0.0 } -&gt; printfn &quot;Point is on the y-axis. Value is %f.&quot; yVal\n    | { x = 0.0; y = 0.0; z = zVal } -&gt; printfn &quot;Point is on the z-axis. Value is %f.&quot; zVal\n    | { x = xVal; y = yVal; z = zVal } -&gt; printfn &quot;Point is at (%f, %f, %f).&quot; xVal yVal zVal\n\nevaluatePoint { x = 0.0; y = 0.0; z = 0.0 }\nevaluatePoint { x = 100.0; y = 0.0; z = 0.0 }\nevaluatePoint { x = 10.0; y = 0.0; z = -1.0 }\n</code></pre><p>The output of this code is as follows.</p>\n<pre class=\"loading\"><code>Point is at the origin.\nPoint is on the x-axis. Value is 100.000000.\nPoint is at (10.000000, 0.000000, -1.000000).\n</code></pre><h2 id=\"differences-between-records-and-classes\">Differences Between Records and Classes</h2>\n<p>Record fields differ from classes in that they are automatically exposed as properties, and they are used in the creation and copying of records. Record construction also differs from class construction. In a record type, you cannot define a constructor. Instead, the construction syntax described in this topic applies. Classes have no direct relationship between constructor parameters, fields, and properties.</p>\n<p>Like union and structure types, records have structural equality semantics. Classes have reference equality semantics. The following code example demonstrates this.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type RecordTest = { X: int; Y: int }\nlet record1 = { X = 1; Y = 2 }\nlet record2 = { X = 1; Y = 2 }\nif (record1 = record2) then\n    printfn &quot;The records are equal.&quot;\nelse\n    printfn &quot;The records are unequal.&quot;\n</code></pre><p>If you write the same code with classes, the two class objects would be unequal because the two values would represent two objects on the heap and only the addresses would be compared (unless the class type overrides the <code>System.Object.Equals</code> method).</p>\n<h2 id=\"see-also\">See Also</h2>\n<p><a href=\"fsharp-types\" data-linktype=\"relative-path\">F# Types</a></p>\n<p><a href=\"classes\" data-linktype=\"relative-path\">Classes</a></p>\n<p><a href=\"index\" data-linktype=\"relative-path\">F# Language Reference</a></p>\n<p><a href=\"pattern-matching\" data-linktype=\"relative-path\">Pattern Matching</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"3a3701ea-4308-4fa1-9b5c-b955c470f17a\">\r\n<meta name=\"description\" content=\"Records (F#)\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming\">\r\n<meta name=\"ms.topic\" content=\"language-reference\">\r\n<meta name=\"ms.date\" content=\"05/16/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/records.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/records.md\">\r\n<meta name=\"document_id\" content=\"fe9291d5-1b92-3951-86d1-6f7023a5e039\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Records (F#) | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"3a3701ea-4308-4fa1-9b5c-b955c470f17a","description":"Records (F#)","keywords":"visual f#, f#, functional programming","ms.topic":"language-reference","ms.date":"05/16/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Tour of F# (#908)","commit_sha":"b07269aaa2cc042b1843207d7a31437034833cc6","commit_date":"2016-08-18 12:48:30 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Move snippets to snippets folder, now with some F# (#904)","commit_sha":"37fe2b89d590509e8eb14342da988f15862a9e2b","commit_date":"2016-08-13 16:40:56 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize F# snippets (#903)","commit_sha":"6ea1cf8f3779532a9ed8fbdac32592fbb809443c","commit_date":"2016-08-13 15:14:41 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"F# Docs: Update intro, move files, rename language reference for better URLS (#902)","commit_sha":"70a10b9c3e21291c96d927d13f8710d9e0738d4c","commit_date":"2016-08-13 11:22:39 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/records.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/records.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/language-reference/records.md","document_id":"fe9291d5-1b92-3951-86d1-6f7023a5e039","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/records","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Records (F#)","_op_displayDate":"2016-5-16","_op_displayDate_source":"2016-05-16T00:00:00Z","_op_wordCount":1150,"_op_rawTitle":"<h1 id=\"records\" sourcefile=\"docs/fsharp/language-reference/records.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Records</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/records","fileRelativePath":"articles/fsharp/language-reference/records.html"},"themesRelativePathToOutputRoot":"_themes/"}