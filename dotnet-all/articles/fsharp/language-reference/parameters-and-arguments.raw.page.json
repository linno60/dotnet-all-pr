{"content":"<div><div class=\"content\">\n<p>This topic describes language support for defining parameters and passing arguments to functions, methods, and properties. It includes information about how to pass by reference, and how to define and use methods that can take a variable number of arguments.</p>\n<h2 id=\"parameters-and-arguments-1\">Parameters and Arguments</h2>\n<p>The term <em>parameter</em> is used to describe the names for values that are expected to be supplied. The term <em>argument</em> is used for the values provided for each parameter.</p>\n<p>Parameters can be specified in tuple or curried form, or in some combination of the two. You can pass arguments by using an explicit parameter name. Parameters of methods can be specified as optional and given a default value.</p>\n<h2 id=\"parameter-patterns\">Parameter Patterns</h2>\n<p>Parameters supplied to functions and methods are, in general, patterns separated by spaces. This means that, in principle, any of the patterns described in <a href=\"match-expressions\" data-linktype=\"relative-path\">Match Expressions</a> can be used in a parameter list for a function or member.</p>\n<p>Methods usually use the tuple form of passing arguments. This achieves a clearer result from the perspective of other .NET languages because the tuple form matches the way arguments are passed in .NET methods.</p>\n<p>The curried form is most often used with functions created by using <code>let</code> bindings.</p>\n<p>The following pseudocode shows examples of tuple and curried arguments.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">// Tuple form.\nmember this.SomeMethod(param1, param2) = ...\n// Curried form.\nlet function1 param1 param2 = ...\n</code></pre><p>Combined forms are possible when some arguments are in tuples and some are not.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let function2 param1 (param2a, param2b) param3 = ...\n</code></pre><p>Other patterns can also be used in parameter lists, but if the parameter pattern does not match all possible inputs, there might be an incomplete match at run time. The exception <code>MatchFailureException</code> is generated when the value of an argument does not match the patterns specified in the parameter list. The compiler issues a warning when a parameter pattern allows for incomplete matches. At least one other pattern is commonly useful for parameter lists, and that is the wildcard pattern. You use the wildcard pattern in a parameter list when you simply want to ignore any arguments that are supplied. The following code illustrates the use of the wildcard pattern in an argument list.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let makeList _ = [ for i in 1 .. 100 -&gt; i * i ]\n// The arguments 100 and 200 are ignored.\nlet list1 = makeList 100\nlet list2 = makeList 200\n</code></pre><p>The wildcard pattern can be useful whenever you do not need the arguments passed in, such as in the main entry point to a program, when you are not interested in the command-line arguments that are normally supplied as a string array, as in the following code.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">[&lt;EntryPoint&gt;]\nlet main _ =\n    printfn &quot;Entry point!&quot;\n    0\n</code></pre><p>Other patterns that are sometimes used in arguments are the <code>as</code> pattern, and identifier patterns associated with discriminated unions and active patterns. You can use the single-case discriminated union pattern as follows.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type Slice = Slice of int * int * string\n\nlet GetSubstring1 (Slice(p0, p1, text)) =\n    printfn &quot;Data begins at %d and ends at %d in string %s&quot; p0 p1 text\n    text.[p0..p1]\n\nlet substring = GetSubstring1 (Slice(0, 4, &quot;Et tu, Brute?&quot;))\nprintfn &quot;Substring: %s&quot; substring\n</code></pre><p>The output is as follows.</p>\n<pre class=\"loading\"><code>Data begins at 0 and ends at 4 in string Et tu, Brute?\nEt tu\n</code></pre><p>Active patterns can be useful as parameters, for example, when transforming an argument into a desired format, as in the following example:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">type Point = { x : float; y : float }\n\nlet (| Polar |) { x = x; y = y} =\n    ( sqrt (x*x + y*y), System.Math.Atan (y/ x) )\n\nlet radius (Polar(r, _)) = r\nlet angle (Polar(_, theta)) = theta\n</code></pre><p>You can use the <code>as</code> pattern to store a matched value as a local value, as is shown in the following line of code.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let GetSubstring2 (Slice(p0, p1, text) as s) = s\n</code></pre><p>Another pattern that is used occasionally is a function that leaves the last argument unnamed by providing, as the body of the function, a lambda expression that immediately performs a pattern match on the implicit argument. An example of this is the following line of code.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let isNil = function [] -&gt; true | _::_ -&gt; false\n</code></pre><p>This code defines a function that takes a generic list and returns <code>true</code> if the list is empty, and <code>false</code> otherwise. The use of such techniques can make code more difficult to read.</p>\n<p>Occasionally, patterns that involve incomplete matches are useful, for example, if you know that the lists in your program have only three elements, you might use a pattern like the following in a parameter list.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let sum [a; b; c;] = a + b + c\n</code></pre><p>The use of patterns that have incomplete matches is best reserved for quick prototyping and other temporary uses. The compiler will issue a warning for such code. Such patterns cannot cover the general case of all possible inputs and therefore are not suitable for component APIs.</p>\n<h2 id=\"named-arguments\">Named Arguments</h2>\n<p>Arguments for methods can be specified by position in a comma-separated argument list, or they can be passed to a method explicitly by providing the name, followed by an equal sign and the value to be passed in. If specified by providing the name, they can appear in a different order from that used in the declaration.</p>\n<p>Named arguments can make code more readable and more adaptable to certain types of changes in the API, such as a reordering of method parameters.</p>\n<p>Named arguments are allowed only for methods, not for <code>let</code>-bound functions, function values, or lambda expressions.</p>\n<p>The following code example demonstrates the use of named arguments.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type SpeedingTicket() =\n    member this.GetMPHOver(speed: int, limit: int) = speed - limit\n\nlet CalculateFine (ticket : SpeedingTicket) =\n    let delta = ticket.GetMPHOver(limit = 55, speed = 70)\n    if delta &lt; 20 then 50.0 else 100.0\n\nlet ticket1 : SpeedingTicket = SpeedingTicket()\nprintfn &quot;%f&quot; (CalculateFine ticket1)\n</code></pre><p>In a call to a class constructor, you can set the values of properties of the class by using a syntax similar to that of named arguments. The following example shows this syntax.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\"> type Account() =\n    let mutable balance = 0.0\n    let mutable number = 0\n    let mutable firstName = &quot;&quot;\n    let mutable lastName = &quot;&quot;\n    member this.AccountNumber\n       with get() = number\n       and set(value) = number &lt;- value\n    member this.FirstName\n       with get() = firstName\n       and set(value) = firstName &lt;- value\n    member this.LastName\n       with get() = lastName\n       and set(value) = lastName &lt;- value\n    member this.Balance\n       with get() = balance\n       and set(value) = balance &lt;- value\n    member this.Deposit(amount: float) = this.Balance &lt;- this.Balance + amount\n    member this.Withdraw(amount: float) = this.Balance &lt;- this.Balance - amount\n\n\nlet account1 = new Account(AccountNumber=8782108,\n                           FirstName=&quot;Darren&quot;, LastName=&quot;Parker&quot;,\n                           Balance=1543.33)\n</code></pre><p>For more information, see <a href=\"https://msdn.microsoft.com/library/2cd0ed07-d214-4125-8317-4f288af99f05\" data-linktype=\"external\">Constructors (F#)</a>.</p>\n<h2 id=\"optional-parameters\">Optional Parameters</h2>\n<p>You can specify an optional parameter for a method by using a question mark in front of the parameter name. Optional parameters are interpreted as the F# option type, so you can query them in the regular way that option types are queried, by using a <code>match</code> expression with <code>Some</code> and <code>None</code>. Optional parameters are permitted only on members, not on functions created by using <code>let</code> bindings.</p>\n<p>You can also use a function <code>defaultArg</code>, which sets a default value of an optional argument. The <code>defaultArg</code> function takes the optional parameter as the first argument and the default value as the second.</p>\n<p>The following example illustrates the use of optional parameters.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type DuplexType =\n    | Full\n    | Half\n\ntype Connection(?rate0 : int, ?duplex0 : DuplexType, ?parity0 : bool) =\n    let duplex = defaultArg duplex0 Full\n    let parity = defaultArg parity0 false\n    let mutable rate = match rate0 with\n                        | Some rate1 -&gt; rate1\n                        | None -&gt; match duplex with\n                                  | Full -&gt; 9600\n                                  | Half -&gt; 4800\n    do printfn &quot;Baud Rate: %d Duplex: %A Parity: %b&quot; rate duplex parity\n\nlet conn1 = Connection(duplex0 = Full)\nlet conn2 = Connection(duplex0 = Half)\nlet conn3 = Connection(300, Half, true)\n</code></pre><p>The output is as follows.</p>\n<pre class=\"loading\"><code>Baud Rate: 9600 Duplex: Full Parity: false\nBaud Rate: 4800 Duplex: Half Parity: false\nBaud Rate: 300 Duplex: Half Parity: true\n</code></pre><h2 id=\"passing-by-reference\">Passing by Reference</h2>\n<p>F# supports the <code>byref</code> keyword, which specifies that a parameter is passed by reference. This means that any changes to the value are retained after the execution of the function. Values provided to a <code>byref</code> parameter must be mutable. Alternatively, you can pass reference cells of the appropriate type.</p>\n<p>Passing by reference in .NET languages evolved as a way to return more than one value from a function. In F#, you can return a tuple for this purpose, or use a mutable reference cell as a parameter. The <code>byref</code> parameter is mainly provided for interoperability with .NET libraries.</p>\n<p>The following examples illustrate the use of the <code>byref</code> keyword. Note that when you use a reference cell as a parameter, you must create a reference cell as a named value and use that as the parameter, not just add the <code>ref</code> operator as shown in the first call to <code>Increment</code> in the following code. Because creating a reference cell creates a copy of the underlying value, the first call just increments a temporary value.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">type Incrementor(z) =\n    member this.Increment(i : int byref) =\n       i &lt;- i + z\n\nlet incrementor = new Incrementor(1)\nlet mutable x = 10\n// Not recommended: Does not actually increment the variable.\nincrementor.Increment(ref x)\n// Prints 10.\nprintfn &quot;%d&quot; x\n\nlet mutable y = 10\nincrementor.Increment(&amp;y)\n// Prints 11.\nprintfn &quot;%d&quot; y\n\nlet refInt = ref 10\nincrementor.Increment(refInt)\n// Prints 11.\nprintfn &quot;%d&quot; !refInt\n</code></pre><p>You can use a tuple as a return value to store any <code>out</code> parameters in .NET library methods. Alternatively, you can treat the <code>out</code> parameter as a <code>byref</code> parameter. The following code example illustrates both ways.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">// TryParse has a second parameter that is an out parameter\n// of type System.DateTime.\nlet (b, dt) = System.DateTime.TryParse(&quot;12-20-04 12:21:00&quot;)\n\nprintfn &quot;%b %A&quot; b dt\n\n// The same call, using an address of operator.\nlet mutable dt2 = System.DateTime.Now\nlet b2 = System.DateTime.TryParse(&quot;12-20-04 12:21:00&quot;, &amp;dt2)\n\nprintfn &quot;%b %A&quot; b2 dt2\n</code></pre><h2 id=\"parameter-arrays\">Parameter Arrays</h2>\n<p>Occasionally it is necessary to define a function that takes an arbitrary number of parameters of heterogeneous type. It would not be practical to create all the possible overloaded methods to account for all the types that could be used. The .NET platform provides support for such methods through the parameter array feature. A method that takes a parameter array in its signature can be provided with an arbitrary number of parameters. The parameters are put into an array. The type of the array elements determines the parameter types that can be passed to the function. If you define the parameter array with <code>System.Object</code> as the element type, then client code can pass values of any type.</p>\n<p>In F#, parameter arrays can only be defined in methods. They cannot be used in standalone functions or functions that are defined in modules.</p>\n<p>You define a parameter array by using the <code>ParamArray</code> attribute. The <code>ParamArray</code> attribute can only be applied to the last parameter.</p>\n<p>The following code illustrates both calling a .NET method that takes a parameter array and the definition of a type in F# that has a method that takes a parameter array.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">open System\n\ntype X() =\n    member this.F([&lt;ParamArray&gt;] args: Object[]) =\n        for arg in args do\n            printfn &quot;%A&quot; arg\n\n[&lt;EntryPoint&gt;]\nlet main _ =\n    // call a .NET method that takes a parameter array, passing values of various types\n    Console.WriteLine(&quot;a {0} {1} {2} {3} {4}&quot;, 1, 10.0, &quot;Hello world&quot;, 1u, true)\n\n    let xobj = new X()\n    // call an F# method that takes a parameter array, passing values of various types\n    xobj.F(&quot;a&quot;, 1, 10.0, &quot;Hello world&quot;, 1u, true)\n    0\n</code></pre><p>When run in a project, the output of the previous code is as follows:</p>\n<pre class=\"loading\"><code>a 1 10 Hello world 1 True\n&quot;a&quot;\n1\n10.0\n&quot;Hello world&quot;\n1u\ntrue\n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p><a href=\"members/index\" data-linktype=\"relative-path\">Members</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet/toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"9b37a5c4-9263-4513-822a-fbb0d1004254\">\r\n<meta name=\"description\" content=\"Parameters and Arguments (F#)\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming\">\r\n<meta name=\"ms.topic\" content=\"language-reference\">\r\n<meta name=\"ms.date\" content=\"05/16/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/parameters-and-arguments.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/parameters-and-arguments.md\">\r\n<meta name=\"document_id\" content=\"b3010c00-19e5-8ac1-0584-fd36eae1568b\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Parameters and Arguments (F#) | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"9b37a5c4-9263-4513-822a-fbb0d1004254","description":"Parameters and Arguments (F#)","keywords":"visual f#, f#, functional programming","ms.topic":"language-reference","ms.date":"05/16/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Move snippets to snippets folder, now with some F# (#904)","commit_sha":"37fe2b89d590509e8eb14342da988f15862a9e2b","commit_date":"2016-08-13 16:40:56 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize F# snippets (#903)","commit_sha":"6ea1cf8f3779532a9ed8fbdac32592fbb809443c","commit_date":"2016-08-13 15:14:41 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"F# Docs: Update intro, move files, rename language reference for better URLS (#902)","commit_sha":"70a10b9c3e21291c96d927d13f8710d9e0738d4c","commit_date":"2016-08-13 11:22:39 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/parameters-and-arguments.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/parameters-and-arguments.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/language-reference/parameters-and-arguments.md","document_id":"b3010c00-19e5-8ac1-0584-fd36eae1568b","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/parameters-and-arguments","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Parameters and Arguments (F#)","_op_displayDate":"2016-5-16","_op_displayDate_source":"2016-05-16T00:00:00Z","_op_wordCount":1961,"_op_rawTitle":"<h1 id=\"parameters-and-arguments\" sourcefile=\"docs/fsharp/language-reference/parameters-and-arguments.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Parameters and Arguments</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/parameters-and-arguments","fileRelativePath":"articles/fsharp/language-reference/parameters-and-arguments.html"},"themesRelativePathToOutputRoot":"_themes/"}