{"content":"<div><div class=\"content\">\n<p>A <em>flexible type annotation</em> indicates that a parameter, variable, or value has a type that is compatible with a specifed type, where compatibility is determined by position in an object-oriented hierarchy of classes or interfaces. Flexible types are useful specifically when the automatic conversion to types higher in the type hierarchy does not occur but you still want to enable your functionality to work with any type in the hierarchy or any type that implements an interface.</p>\n<h2 id=\"syntax\">Syntax</h2>\n<pre class=\"loading\"><code class=\"lang-fsharp\">#type\n</code></pre><h2 id=\"remarks\">Remarks</h2>\n<p>In the previous syntax, <em>type</em> represents a base type or an interface.</p>\n<p>A flexible type is equivalent to a generic type that has a constraint that limits the allowed types to types that are compatible with the base or interface type. That is, the following two lines of code are equivalent.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">#SomeType\n\n&#39;T when &#39;T :&gt; SomeType\n</code></pre><p>Flexible types are useful in several types of situations. For example, when you have a higher order function (a function that takes a function as an argument), it is often useful to have the function return a flexible type. In the following example, the use of a flexible type with a sequence argument in <code>iterate2</code> enables the higher order function to work with functions that generate sequences, arrays, lists, and any other enumerable type.</p>\n<p>Consider the following two functions, one of which returns a sequence, the other of which returns a flexible type.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let iterate1 (f : unit -&gt; seq&lt;int&gt;) =\n    for e in f() do printfn &quot;%d&quot; e\nlet iterate2 (f : unit -&gt; #seq&lt;int&gt;) =\n    for e in f() do printfn &quot;%d&quot; e\n\n// Passing a function that takes a list requires a cast.\niterate1 (fun () -&gt; [1] :&gt; seq&lt;int&gt;)\n\n// Passing a function that takes a list to the version that specifies a\n// flexible type as the return value is OK as is.\niterate2 (fun () -&gt; [1])\n</code></pre><p>As another example, consider the <a href=\"https://msdn.microsoft.com/library/2eeb69a9-fc2f-4b7d-8dee-101fa2b00712\" data-linktype=\"external\">Seq.concat</a> library function:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">val concat: sequences:seq&lt;#seq&lt;&#39;T&gt;&gt; -&gt; seq&lt;&#39;T&gt;\n</code></pre><p>You can pass any of the following enumerable sequences to this function:</p>\n<ul>\n<li>A list of lists</li>\n<li>A list of arrays</li>\n<li>An array of lists</li>\n<li>An array of sequences</li>\n<li>Any other combination of enumerable sequences</li>\n</ul>\n<p>The following code uses <code>Seq.concat</code> to demonstrate the scenarios that you can support by using flexible types.</p>\n<pre><code class=\"lang-fsharp\" name=\"Main\">let list1 = [1;2;3]\nlet list2 = [4;5;6]\nlet list3 = [7;8;9]\n\nlet concat1 = Seq.concat [ list1; list2; list3]\nprintfn &quot;%A&quot; concat1\n\nlet array1 = [|1;2;3|]\nlet array2 = [|4;5;6|]\nlet array3 = [|7;8;9|]\n\nlet concat2 = Seq.concat [ array1; array2; array3 ]\nprintfn &quot;%A&quot; concat2\n\nlet concat3 = Seq.concat [| list1; list2; list3 |]\nprintfn &quot;%A&quot; concat3\n\nlet concat4 = Seq.concat [| array1; array2; array3 |]\nprintfn &quot;%A&quot; concat4\n\nlet seq1 = { 1 .. 3 }\nlet seq2 = { 4 .. 6 }\nlet seq3 = { 7 .. 9 }\n\nlet concat5 = Seq.concat [| seq1; seq2; seq3 |]\n\nprintfn &quot;%A&quot; concat5\n</code></pre><p>The output is as follows.</p>\n<pre class=\"loading\"><code>seq [1; 2; 3; 4; ...]\nseq [1; 2; 3; 4; ...]\nseq [1; 2; 3; 4; ...]\nseq [1; 2; 3; 4; ...]\nseq [1; 2; 3; 4; ...]\n</code></pre><p>In F#, as in other object-oriented languages, there are contexts in which derived types or types that implement interfaces are automatically converted to a base type or interface type. These automatic conversions occur in direct arguments, but not when the type is in a subordinate position, as part of a more complex type such as a return type of a function type, or as a type argument. Thus, the flexible type notation is primarily useful when the type you are applying it to is part of a more complex type.</p>\n<h2 id=\"see-also\">See Also</h2>\n<p><a href=\"index\" data-linktype=\"relative-path\">F# Language Reference</a></p>\n<p><a href=\"generics/index\" data-linktype=\"relative-path\">Generics</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet/toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"c8b510f2-3405-4cc9-b55b-e47b35e2b15b\">\r\n<meta name=\"description\" content=\"Flexible Types (F#)\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming\">\r\n<meta name=\"ms.topic\" content=\"language-reference\">\r\n<meta name=\"ms.date\" content=\"05/16/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/flexible-types.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/flexible-types.md\">\r\n<meta name=\"document_id\" content=\"50fde395-4ec4-1a96-c3a4-387021ac5e5c\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Flexible Types (F#) | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"c8b510f2-3405-4cc9-b55b-e47b35e2b15b","description":"Flexible Types (F#)","keywords":"visual f#, f#, functional programming","ms.topic":"language-reference","ms.date":"05/16/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Move snippets to snippets folder, now with some F# (#904)","commit_sha":"37fe2b89d590509e8eb14342da988f15862a9e2b","commit_date":"2016-08-13 16:40:56 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize F# snippets (#903)","commit_sha":"6ea1cf8f3779532a9ed8fbdac32592fbb809443c","commit_date":"2016-08-13 15:14:41 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"F# Docs: Update intro, move files, rename language reference for better URLS (#902)","commit_sha":"70a10b9c3e21291c96d927d13f8710d9e0738d4c","commit_date":"2016-08-13 11:22:39 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/language-reference/flexible-types.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/language-reference/flexible-types.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/language-reference/flexible-types.md","document_id":"50fde395-4ec4-1a96-c3a4-387021ac5e5c","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/flexible-types","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Flexible Types (F#)","_op_displayDate":"2016-5-16","_op_displayDate_source":"2016-05-16T00:00:00Z","_op_wordCount":597,"_op_rawTitle":"<h1 id=\"flexible-types\" sourcefile=\"docs/fsharp/language-reference/flexible-types.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Flexible Types</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/flexible-types","fileRelativePath":"articles/fsharp/language-reference/flexible-types.html"},"themesRelativePathToOutputRoot":"_themes/"}