{"content":"<div><div class=\"content\">\n<div class=\"NOTE\"><h5>Note</h5><p>This guide was written for F# 3.0 and will be updated.  See <a href=\"http://fsharp.github.io/FSharp.Data/\" data-linktype=\"external\">FSharp.Data</a> for up-to-date, cross-platform type providers.</p>\n</div>\n<div class=\"NOTE\"><h5>Note</h5><p>The API reference links will take you to MSDN.  The docs.microsoft.com API reference is not complete.</p>\n</div>\n<p>This walkthrough explains how to use the SqlDataConnection (LINQ to SQL) type provider that is available in F# 3.0 to generate types for data in a SQL database when you have a live connection to a database. If you do not have a live connection to a database, but you do have a LINQ to SQL schema file (DBML file), see <a href=\"generating-fsharp-types-from-dbml\" data-linktype=\"relative-path\">Walkthrough: Generating F# Types from a DBML File</a>.</p>\n<p>This walkthrough illustrates the following tasks. These tasks must be performed in this order for the walkthrough to succeed:</p>\n<ul>\n<li><p>Preparing a test database</p>\n</li>\n<li><p>Creating the project</p>\n</li>\n<li><p>Setting up a type provider</p>\n</li>\n<li><p>Querying the data</p>\n</li>\n<li><p>Working with nullable fields</p>\n</li>\n<li><p>Calling a stored procedure</p>\n</li>\n<li><p>Updating the database</p>\n</li>\n<li><p>Executing Transact-SQL code</p>\n</li>\n<li><p>Using the full data context</p>\n</li>\n<li><p>Deleting data</p>\n</li>\n<li><p>Create a test database (as needed)</p>\n</li>\n</ul>\n<h2 id=\"preparing-a-test-database\">Preparing a Test Database</h2>\n<p>On a server that&#39;s running SQL Server, create a database for testing purposes. You can use the database create script at the bottom of this page in the section <a href=\"#creating-a-test-database\" data-linktype=\"self-bookmark\">Creating a test database</a> to do this.</p>\n<h4 id=\"to-prepare-a-test-database\">To prepare a test database</h4>\n<p>To run the MyDatabase Create Script, open the <strong>View</strong> menu, and then choose <strong>SQL Server Object Explorer</strong> or choose the Ctrl+\\, Ctrl+S keys. In <strong>SQL Server Object Explorer</strong> window, open the shortcut menu for the appropriate instance, choose <strong>New Query</strong>, copy the script at the bottom of this page, and then paste the script into the editor. To run the SQL script, choose the toolbar icon with the triangular symbol, or choose the Ctrl+Q keys. For more information about <strong>SQL Server Object Explorer</strong>, see <a href=\"http://go.microsoft.com/fwlink/?LinkId=237128\" data-linktype=\"external\">Connected Database Development</a>.</p>\n<h2 id=\"creating-the-project\">Creating the project</h2>\n<p>Next, you create an F# application project.</p>\n<h4 id=\"to-create-and-set-up-the-project\">To create and set up the project</h4>\n<ol>\n<li><p>Create a new F# Application project.</p>\n</li>\n<li><p>Add references to <a href=\"https://msdn.microsoft.com/library/a858f859-047a-44ab-945b-8731d7a0e6e3\" data-linktype=\"external\">FSharp.Data.TypeProviders</a>, as well as <code>System.Data</code>, and <code>System.Data.Linq</code>.</p>\n</li>\n<li><p>Open the appropriate namespaces by adding the following lines of code to the top of your F# code file Program.fs.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">open System\nopen System.Data\nopen System.Data.Linq\nopen Microsoft.FSharp.Data.TypeProviders\nopen Microsoft.FSharp.Linq\n</code></pre></li>\n<li><p>As with most F# programs, you can execute the code in this walkthrough as a compiled program, or you can run it interactively as a script. If you prefer to use scripts, open the shortcut menu for the project node, select <strong>Add New Item</strong>, add an F# script file, and add the code in each step to the script. You will need to add the following lines at the top of the file to load the assembly references.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">#r &quot;System.Data.dll&quot;\n#r &quot;FSharp.Data.TypeProviders.dll&quot;\n#r &quot;System.Data.Linq.dll&quot;\n</code></pre><p>You can then select each block of code as you add it and press Alt+Enter to run it in F# Interactive.</p>\n</li>\n</ol>\n<h2 id=\"setting-up-a-type-provider\">Setting up a type provider</h2>\n<p>In this step, you create a type provider for your database schema.</p>\n<h4 id=\"to-set-up-the-type-provider-from-a-direct-database-connection\">To set up the type provider from a direct database connection</h4>\n<p>There are two critical lines of code that you need in order to create the types that you can use to query a SQL database using the type provider. First, you instantiate the type provider. To do this, create what looks like a type abbreviation for a <code>SqlDataConnection</code> with a static generic parameter. <code>SqlDataConnection</code> is a SQL type provider, and should not be confused with <code>SqlConnection</code> type that is used in ADO.NET programming. If you have a database that you want to connect to, and have a connection string, use the following code to invoke the type provider. Substitute your own connection string for the example string given. For example, if your server is MYSERVER and the database instance is INSTANCE, the database name is MyDatabase, and you want to use Windows Authentication to access the database, then the connection string would be as given in the following example code.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">type dbSchema = SqlDataConnection&lt;&quot;Data Source=MYSERVER\\INSTANCE;Initial Catalog=MyDatabase;Integrated Security=SSPI;&quot;&gt;\nlet db = dbSchema.GetDataContext()\n\n// Enable the logging of database activity to the console.\ndb.DataContext.Log &lt;- System.Console.Out\n</code></pre><p>Now you have a type, <code>dbSchema</code>, which is a parent type that contains all the generated types that represent database tables. You also have an object, <code>db</code>, which has as its members all the tables in the database. The table names are properties, and the type of these properties is generated by the F# compiler. The types themselves appear as nested types under <code>dbSchema.ServiceTypes</code>. Therefore, any data retrieved for rows of these tables is an instance of the appropriate type that was generated for that table. The name of the type is <code>ServiceTypes.Table1</code>.</p>\n<p>To familiarize yourself with how the F# language interprets queries into SQL queries, review the line that sets the <code>Log</code> property on the data context.</p>\n<p>To further explore the types created by the type provider, add the following code.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let table1 = db.Table1\n</code></pre><p>Hover over <code>table1</code> to see its type. Its type is <code>System.Data.Linq.Table&lt;dbSchema.ServiceTypes.Table1&gt;</code> and the generic argument implies that the type of each row is the generated type, <code>dbSchema.ServiceTypes.Table1</code>. The compiler creates a similar type for each table in the database.</p>\n<h2 id=\"querying-the-data\">Querying the data</h2>\n<p>In this step, you write a query using F# query expressions.</p>\n<h4 id=\"to-query-the-data\">To query the data</h4>\n<ol>\n<li><p>Now create a query for that table in the database. Add the following code.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let query1 =\n  query {\n    for row in db.Table1 do\n    select row\n  }\nquery1 |&gt; Seq.iter (fun row -&gt; printfn &quot;%s %d&quot; row.Name row.TestData1)\n</code></pre><p>The appearance of the word <code>query</code> indicates that this is a query expression, a type of computation expression that generates a collection of results similar of a typical database query. If you hover over query, you will see that it is an instance of <a href=\"https://msdn.microsoft.com/visualfsharpdocs/conceptual/linq.querybuilder-class-%5bfsharp%5d\" data-linktype=\"external\">Linq.QueryBuilder Class</a>, a type that defines the query computation expression. If you hover over <code>query1</code>, you will see that it is an instance of <code>System.Linq.IQueryable</code>. As the name suggests, <code>System.Linq.IQueryable</code> represents data that may be queried, not the result of a query. A query is subject to lazy evaluation, which means that the database is only queried when the query is evaluated. The final line passes the query through <code>Seq.iter</code>. Queries are enumerable and may be iterated like sequences. For more information, see <a href=\"../../language-reference/query-expressions\" data-linktype=\"relative-path\">Query Expressions</a>.</p>\n</li>\n<li><p>Now add a query operator to the query. There are a number of query operators available that you can use to construct more complex queries. This example also shows that you can eliminate the query variable and use a pipeline operator instead.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">query {\n  for row in db.Table1 do\n  where (row.TestData1 &gt; 2)\n  select row\n} |&gt; Seq.iter (fun row -&gt; printfn &quot;%d %s&quot; row.TestData1 row.Name)\n</code></pre></li>\n<li><p>Add a more complex query with a join of two tables.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">query {\n  for row1 in db.Table1 do\n  join row2 in db.Table2 on (row1.Id = row2.Id)\n  select (row1, row2)\n} |&gt; Seq.iteri (fun index (row1, row2) -&gt;\n                if (index = 0) then printfn &quot;Table1.Id TestData1 TestData2 Name Table2.Id TestData1 TestData2 Name&quot;\n                printfn &quot;%d %d %f %s %d %d %f %s&quot; row1.Id row1.TestData1 row1.TestData2 row1.Name\n                  row2.Id (row2.TestData1.GetValueOrDefault()) (row2.TestData2.GetValueOrDefault()) row2.Name)\n</code></pre></li>\n<li><p>In real-world code, the parameters in your query are usually values or variables, not compile-time constants. Add the following code that wraps a query in a function that takes a parameter, and then calls that function with the value 10.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let findData param =\n  query {\n    for row in db.Table1 do\n    where (row.TestData1 = param)\n    select row\n  }\n\nfindData 10 |&gt; Seq.iter (fun row -&gt; printfn &quot;Found row: %d %d %f %s&quot; row.Id row.TestData1 row.TestData2 row.Name)\n</code></pre></li>\n</ol>\n<h2 id=\"working-with-nullable-fields\">Working with nullable fields</h2>\n<p>In databases, fields often allow null values. In the .NET type system, you cannot use the ordinary numerical data types for data that allows nulls because those types do not have null as a possible value. Therefore, these values are represented by instances of <code>System.Nullable</code> type. Instead of accessing the value of such fields directly with the name of the field, you need to add some extra steps. You can use the <code>System.Nullable.Value</code> property to access the underlying value of a nullable type. The <code>System.Nullable.Value</code> property throws an exception if the object is null rather than having a value. You can use the <code>System.Nullable.HasValue</code> Boolean method to determine if a value exists, or use <code>System.Nullable.GetValueOrDefault()</code> to ensure that you have an actual value in all cases. If you use <code>System.Nullable.GetValueOrDefault()</code> and there is a null in the database, then it is replaced with a value such as an empty string for string types, 0 for integral types or 0.0 for floating point types.</p>\n<p>When you need to perform equality tests or comparisons on nullable values in a <code>where</code> clause in a query, you can use the nullable operators found in the <a href=\"https://msdn.microsoft.com/visualfsharpdocs/conceptual/linq.nullableoperators-module-%5bfsharp%5d\" data-linktype=\"external\">Linq.NullableOperators Module</a>. These are like the regular comparison operators <code>=</code>, <code>&gt;</code>, <code>&lt;=</code>, and so on, except that a question mark appears on the left or right of the operator where the nullable values are. For example, the operator <code>&gt;?</code> is a greater-than operator with a nullable value on the right. The way these operators work is that if either side of the expression is null, the expression evaluates to <code>false</code>. In a <code>where</code> clause, this generally means that the rows that contain null fields are not selected and not returned in the query results.</p>\n<h4 id=\"to-work-with-nullable-fields\">To work with nullable fields</h4>\n<p>The following code shows working with nullable values; assume that <strong>TestData1</strong> is an integer field that allows nulls.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">query {\n  for row in db.Table2 do\n  where (row.TestData1.HasValue &amp;&amp; row.TestData1.Value &gt; 2)\n  select row\n} |&gt; Seq.iter (fun row -&gt; printfn &quot;%d %s&quot; row.TestData1.Value row.Name)\n\nquery {\n  for row in db.Table2 do\n  // Use a nullable operator ?&gt;\n  where (row.TestData1 ?&gt; 2)\n  select row\n} |&gt; Seq.iter (fun row -&gt; printfn &quot;%d %s&quot; (row.TestData1.GetValueOrDefault()) row.Name)\n</code></pre><h2 id=\"calling-a-stored-procedure\">Calling a stored procedure</h2>\n<p>Any stored procedures on the database can be called from F#. You must set the static parameter <code>StoredProcedures</code> to <code>true</code> in the type provider instantiation. The type provider <code>SqlDataConnection</code> contains several static methods that you can use to configure the types that are generated. For a complete description of these, see <a href=\"https://msdn.microsoft.com/visualfsharpdocs/conceptual/sqldataconnection-type-provider-%5bfsharp%5d\" data-linktype=\"external\">SqlDataConnection Type Provider</a>. A method on the data context type is generated for each stored procedure.</p>\n<h4 id=\"to-call-a-stored-procedure\">To call a stored procedure</h4>\n<p>If the stored procedures takes parameters that are nullable, you need to pass an appropriate <code>System.Nullable</code> value. The return value of a stored procedure method that returns a scalar or a table is <code>System.Data.Linq.ISingleResult</code>, which contains properties that enable you to access the returned data. The type argument for <code>System.Data.Linq.ISingleResult</code> depends on the specific procedure and is also one of the types that the type provider generates. For a stored procedure named <code>Procedure1</code>, the type is <code>Procedure1Result</code>. The type <code>Procedure1Result</code> contains the names of the columns in a returned table, or, for a stored procedure that returns a scalar value, it represents the return value.</p>\n<p>The following code assumes that there is a procedure <code>Procedure1</code> on the database that takes two nullable integers as parameters, runs a query that returns a column named <code>TestData1</code>, and returns an integer.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">type schema = SqlDataConnection&lt;&quot;Data Source=MYSERVER\\INSTANCE;Initial Catalog=MyDatabase;Integrated Security=SSPI;&quot;, StoredProcedures = true&gt;\n\nlet testdb = schema.GetDataContext()\n\nlet nullable value = new System.Nullable&lt;_&gt;(value)\n\nlet callProcedure1 a b =\n  let results = testdb.Procedure1(nullable a, nullable b)\n  for result in results do\n    printfn &quot;%d&quot; (result.TestData1.GetValueOrDefault())\n  results.ReturnValue :?&gt; int\n\nprintfn &quot;Return Value: %d&quot; (callProcedure1 10 20)\n</code></pre><h2 id=\"updating-the-database\">Updating the database</h2>\n<p>The LINQ DataContext type contains methods that make it easier to perform transacted database updates in a fully typed fashion with the generated types.</p>\n<h4 id=\"to-update-the-database\">To update the database</h4>\n<ol>\n<li><p>In the following code, several rows are added to the database. If you are only adding a row, you can use <code>System.Data.Linq.Table.InsertOnSubmit()</code> to specify the new row to add. If you are inserting multiple rows, you should put them into a collection and call <code>System.Data.Linq.Table.InsertAllOnSubmit(System.Collections.Generic.IEnumerable)</code>. When you call either of these methods, the database is not immediately changed. You must call <code>System.Data.Linq.DataContext.SubmitChanges</code> to actually commit the changes. By default, everything that you do before you call <code>System.Data.Linq.DataContext.SubmitChanges</code> is implicitly part of the same transaction.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let newRecord = new dbSchema.ServiceTypes.Table1(Id = 100,\n                                                 TestData1 = 35, \n                                                 TestData2 = 2.0,\n                                                 Name = &quot;Testing123&quot;)\n\nlet newValues =\n  [ for i in [1 .. 10] -&gt;\n    new dbSchema.ServiceTypes.Table3(Id = 700 + i,\n      Name = &quot;Testing&quot; + i.ToString(),\n      Data = i) ]\n\n// Insert the new data into the database.\ndb.Table1.InsertOnSubmit(newRecord)\ndb.Table3.InsertAllOnSubmit(newValues)\n\ntry\n  db.DataContext.SubmitChanges()\n  printfn &quot;Successfully inserted new rows.&quot;\nwith\n| exn -&gt; printfn &quot;Exception:\\n%s&quot; exn.Message\n</code></pre></li>\n<li><p>Now clean up the rows by calling a delete operation.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">// Now delete what was added.\ndb.Table1.DeleteOnSubmit(newRecord)\ndb.Table3.DeleteAllOnSubmit(newValues)\n\ntry\n  db.DataContext.SubmitChanges()\n  printfn &quot;Successfully deleted all pending rows.&quot;\nwith\n| exn -&gt; printfn &quot;Exception:\\n%s&quot; exn.Message\n</code></pre></li>\n</ol>\n<h2 id=\"executing-transact-sql-code\">Executing Transact-SQL code</h2>\n<p>You can also specify Transact-SQL directly by using the <code>System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])</code> method on the <code>DataContext</code> class.</p>\n<h4 id=\"to-execute-custom-sql-commands\">To execute custom SQL commands</h4>\n<p>The following code shows how to send SQL commands to insert a record into a table and also to delete a record from a table.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">try\n  db.DataContext.ExecuteCommand(&quot;INSERT INTO Table3 (Id, Name, Data) VALUES (102, &#39;Testing&#39;, 55)&quot;) |&gt; ignore\nwith\n| exn -&gt; printfn &quot;Exception:\\n%s&quot; exn.Message\n\ntry //AND Name = &#39;Testing&#39; AND Data = 55\n  db.DataContext.ExecuteCommand(&quot;DELETE FROM Table3 WHERE Id = 102 &quot;) |&gt; ignore\nwith\n| exn -&gt; printfn &quot;Exception:\\n%s&quot; exn.Message\n</code></pre><h2 id=\"using-the-full-data-context\">Using the full data context</h2>\n<p>In the previous examples, the <code>GetDataContext</code> method was used to get what is called the <em>simplified data context</em> for the database schema. The simplified data context is easier to use when you are constructing queries because there are not as many members available. Therefore, when you browse the properties in IntelliSense, you can focus on the database structure, such as the tables and stored procedures. However, there is a limit to what you can do with the simplified data context. A full data context that provides the ability to perform other actions. is also available This is located in the <code>ServiceTypes</code> and has the name of the <em>DataContext</em> static parameter if you provided it. If you did not provide it, the name of the data context type is generated for you by SqlMetal.exe based on the other input. The full data context inherits from <code>System.Data.Linq.DataContext</code> and exposes the members of its base class, including references to ADO.NET data types such as the <code>Connection</code> object, methods such as <code>System.Data.Linq.DataContext.ExecuteCommand(System.String,System.Object[])</code> and <code>System.Data.Linq.DataContext.ExecuteQuery(System.String,System.Object[])</code> that you can use to write queries in SQL, and also a means to work with transactions explicitly.</p>\n<h4 id=\"to-use-the-full-data-context\">To use the full data context</h4>\n<p>The following code demonstrates getting a full data context object and using it to execute commands directly against the database. In this case, two commands are executed as part of the same transaction.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let dbConnection = testdb.Connection\nlet fullContext = new dbSchema.ServiceTypes.MyDatabase(dbConnection)\n\ndbConnection.Open()\n\nlet transaction = dbConnection.BeginTransaction()\nfullContext.Transaction &lt;- transaction\n\ntry\n  let result1 = fullContext.ExecuteCommand(&quot;INSERT INTO Table3 (Id, Name, Data) VALUES (102, &#39;A&#39;, 55)&quot;)\n  printfn &quot;ExecuteCommand Result: %d&quot; result1\n  let result2 = fullContext.ExecuteCommand(&quot;INSERT INTO Table3 (Id, Name, Data) VALUES (103, &#39;B&#39;, -2)&quot;)\n  printfn &quot;ExecuteCommand Result: %d&quot; result2\n  if (result1 &lt;&gt; 1 || result2 &lt;&gt; 1) then\n    transaction.Rollback()\n    printfn &quot;Rolled back creation of two new rows.&quot;\n  else\n    transaction.Commit()\n  printfn &quot;Successfully committed two new rows.&quot;\nwith\n| exn -&gt;\n  transaction.Rollback()\n  printfn &quot;Rolled back creation of two new rows due to exception:\\n%s&quot; exn.Message\n\ndbConnection.Close()\n</code></pre><h2 id=\"deleting-data\">Deleting data</h2>\n<p>This step shows you how to delete rows from a data table.</p>\n<h4 id=\"to-delete-rows-from-the-database\">To delete rows from the database</h4>\n<p>Now, clean up any added rows by writing a function that deletes rows from a specified table, an instance of the <code>System.Data.Linq.Table</code> class. Then write a query to find all the rows that you want to delete, and pipe the results of the query into the <code>deleteRows</code> function. This code takes advantage of the ability to provide partial application of function arguments.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let deleteRowsFrom (table:Table&lt;_&gt;) rows =\n  table.DeleteAllOnSubmit(rows)\n\nquery {\n  for rows in db.Table3 do\n  where (rows.Id &gt; 10)\n  select rows\n} |&gt; deleteRowsFrom db.Table3\n\ndb.DataContext.SubmitChanges()\nprintfn &quot;Successfully deleted rows with Id greater than 10 in Table3.&quot;\n</code></pre><h2 id=\"creating-a-test-database\">Creating a test database</h2>\n<p>This section shows you how to set up the test database to use in this walkthrough.</p>\n<p>Note that if you alter the database in some way, you will have to reset the type provider. To reset the type provider, rebuild or clean the project that contains the type provider.</p>\n<h4 id=\"to-create-the-test-database\">To create the test database</h4>\n<ol>\n<li><p>In <strong>Server Explorer</strong>, open the shortcut menu for the <strong>Data Connections</strong> node, and choose <strong>Add Connection</strong>. The <strong>Add Connection</strong> dialog box appears.</p>\n</li>\n<li><p>In the <strong>Server name</strong> box, specify the name of an instance of SQL Server that you have administrative access to, or if you do not have access to a server, specify (localdb\\v11.0). SQL Express LocalDB provides a lightweight database server for development and testing on your machine. A new node is created in <strong>Server Explorer</strong> under <strong>Data Connections</strong>. For more information about LocalDB, see <a href=\"https://msdn.microsoft.com/library/ms233763.aspx\" data-linktype=\"external\">Walkthrough: Creating a Local Database File in Visual Studio</a>.</p>\n</li>\n<li><p>Open the shortcut menu for the new connection node, and select <strong>New Query</strong>.</p>\n</li>\n<li><p>Copy the following SQL script, paste it into the query editor, and then choose the <strong>Execute</strong> button on the toolbar or choose the Ctrl+Shift+E keys.</p>\n</li>\n</ol>\n<pre class=\"loading\"><code class=\"lang-sql\">SET ANSI_NULLS ON\nGO\nSET QUOTED_IDENTIFIER ON\nGO\n\nUSE [master];\nGO\n\nIF EXISTS (SELECT * FROM sys.databases WHERE name = &#39;MyDatabase&#39;)\n  DROP DATABASE MyDatabase;\nGO\n\n-- Create the MyDatabase database.\nCREATE DATABASE MyDatabase;\nGO\n\n-- Specify a simple recovery model \n-- to keep the log growth to a minimum.\nALTER DATABASE MyDatabase \nSET RECOVERY SIMPLE;\nGO\n\nUSE MyDatabase;\nGO\n\n-- Create the Table1 table.\nCREATE TABLE [dbo].[Table1] (\n  [Id]        INT        NOT NULL,\n  [TestData1] INT        NOT NULL,\n  [TestData2] FLOAT (53) NOT NULL,\n  [Name]      NTEXT      NOT NULL,\n  PRIMARY KEY CLUSTERED ([Id] ASC)\n);\n\n-- Create the Table2 table.\nCREATE TABLE [dbo].[Table2] (\n  [Id]        INT        NOT NULL,\n  [TestData1] INT        NULL,\n  [TestData2] FLOAT (53) NULL,\n  [Name]      NTEXT      NOT NULL,\n  PRIMARY KEY CLUSTERED ([Id] ASC)\n);\n\n\n-- Create the Table3 table.\nCREATE TABLE [dbo].[Table3] (\n  [Id]   INT           NOT NULL,\n  [Name] NVARCHAR (50) NOT NULL,\n  [Data] INT           NOT NULL,\n  PRIMARY KEY CLUSTERED ([Id] ASC)\n  );\nGO\n\nCREATE PROCEDURE [dbo].[Procedure1]\n  @param1 int = 0,\n  @param2 int\nAS\nSELECT TestData1 FROM Table1\nRETURN 0\nGO\n\nUSE MyDatabase\n\n-- Insert data into the Table1 table.\nINSERT INTO Table1 (Id, TestData1, TestData2, Name)\n  VALUES(1, 10, 5.5, &#39;Testing1&#39;);\nINSERT INTO Table1 (Id, TestData1, TestData2, Name)\n  VALUES(2, 20, -1.2, &#39;Testing2&#39;);\n\n-- Insert data into the Table2 table.\nINSERT INTO Table2 (Id, TestData1, TestData2, Name)\n  VALUES(1, 10, 5.5, &#39;Testing1&#39;);\nINSERT INTO Table2 (Id, TestData1, TestData2, Name)\n  VALUES(2, 20, -1.2, &#39;Testing2&#39;);\nINSERT INTO Table2 (Id, TestData1, TestData2, Name)\n  VALUES(3, NULL, NULL, &#39;Testing3&#39;);\n\n-- Insert data into the Table3 table.\nINSERT INTO Table3 (Id, Name, Data)\n  VALUES (1, &#39;Testing1&#39;, 10);\nINSERT INTO Table3 (Id, Name, Data)\n  VALUES (2, &#39;Testing2&#39;, 100);\n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p><a href=\"index\" data-linktype=\"relative-path\">Type Providers</a></p>\n<p><a href=\"https://msdn.microsoft.com/visualfsharpdocs/conceptual/sqldataconnection-type-provider-%5bfsharp%5d\" data-linktype=\"external\">SqlDataConnection Type Provider</a></p>\n<p><a href=\"generating-fsharp-types-from-dbml\" data-linktype=\"relative-path\">Walkthrough: Generating F# Types from a DBML File</a></p>\n<p><a href=\"../../language-reference/query-expressions\" data-linktype=\"relative-path\">Query Expressions</a></p>\n<p><a href=\"https://msdn.microsoft.com/library/bb386976\" data-linktype=\"external\">LINQ to SQL</a></p>\n<p><a href=\"https://msdn.microsoft.com/library/bb386987\" data-linktype=\"external\">SqlMetal.exe &#40;Code Generation Tool&#41;</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"1c413eb0-16a5-4c1a-9a4e-ad6877e645d6\">\r\n<meta name=\"description\" content=\"Walkthrough: Accessing a SQL Database by Using Type Providers (F#)\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming\">\r\n<meta name=\"ms.topic\" content=\"language-reference\">\r\n<meta name=\"ms.date\" content=\"05/16/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-21 01:42 AM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/tutorials/type-providers/accessing-a-sql-database.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/fsharp/tutorials/type-providers/accessing-a-sql-database.md\">\r\n<meta name=\"document_id\" content=\"a3bdece2-06c4-532f-ddb3-f0b1f04d012c\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../../toc2.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Walkthrough: Accessing a SQL Database by Using Type Providers (F#) | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"1c413eb0-16a5-4c1a-9a4e-ad6877e645d6","description":"Walkthrough: Accessing a SQL Database by Using Type Providers (F#)","keywords":"visual f#, f#, functional programming","ms.topic":"language-reference","ms.date":"05/16/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Petr Onderka","author_email":"gsvick@gmail.com","committer_name":"Phillip Carter","comitter_email":"phillip.carter@outlook.com","message":"Improved formatting of SQL Database Type Providers walkthrough (#1104)","commit_sha":"f999edc24f221caa177abbac3b704e401b50ddc1","commit_date":"2016-10-02 14:14:10 -0700"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"fixed absolute and msdn links (#1001)","commit_sha":"de0dab146fc811e895dc32f98f877db5e757f82b","commit_date":"2016-09-06 10:59:39 -0700"},{"author_name":"Petr Onderka","author_email":"gsvick@gmail.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"Improve titles of some F# articles (#1003)","commit_sha":"d18cfd736f1dbd61ab9e209de4aaa878a88162cd","commit_date":"2016-09-03 11:22:59 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"F# Docs: Update intro, move files, rename language reference for better URLS (#902)","commit_sha":"70a10b9c3e21291c96d927d13f8710d9e0738d4c","commit_date":"2016-08-13 11:22:39 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Add Visual F# Conceptual Content (#900)","commit_sha":"c27bed7dbad6b24c55734fcab0333bd3a1de85d6","commit_date":"2016-08-12 17:06:05 -0700"}],"updated_at":"2017-03-21 01:42 AM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/svick","display_name":"Petr Onderka","id":"287848"}],"update_at":"3/21/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/tutorials/type-providers/accessing-a-sql-database.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/fsharp/tutorials/type-providers/accessing-a-sql-database.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/tutorials/type-providers/accessing-a-sql-database.md","document_id":"a3bdece2-06c4-532f-ddb3-f0b1f04d012c","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/fsharp/tutorials/type-providers/accessing-a-sql-database","toc_asset_id":"articles/toc.json","toc_rel":"../../../toc.json","_op_ogTitle":"Walkthrough: Accessing a SQL Database by Using Type Providers (F#)","_op_displayDate":"2016-5-16","_op_displayDate_source":"2016-05-16T00:00:00Z","_op_wordCount":3096,"_op_rawTitle":"<h1 id=\"walkthrough-accessing-a-sql-database-by-using-type-providers\" sourcefile=\"docs/fsharp/tutorials/type-providers/accessing-a-sql-database.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Walkthrough: Accessing a SQL Database by Using Type Providers</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/fsharp/tutorials/type-providers/accessing-a-sql-database","fileRelativePath":"articles/fsharp/tutorials/type-providers/accessing-a-sql-database.html"},"themesRelativePathToOutputRoot":"_themes/"}