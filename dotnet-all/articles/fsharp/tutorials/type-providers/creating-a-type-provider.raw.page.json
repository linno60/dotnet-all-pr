{"content":"<div><div class=\"content\">\n<div class=\"NOTE\"><h5>Note</h5><p>This guide was written for F# 3.0 and will be updated.</p>\n</div>\n<p>The type provider mechanism in F# 3.0 is a significant part of its support for information rich programming. This tutorial explains how to create your own type providers by walking you through the development of several simple type providers to illustrate the basic concepts. For more information about the type provider mechanism in F#, see <a href=\"index\" data-linktype=\"relative-path\">Type Providers</a>.</p>\n<p>F# 3.0 contains several built-in type providers for commonly used Internet and enterprise data services. These type providers give simple and regular access to SQL relational databases and network-based OData and WSDL services. These providers also support the use of F# LINQ queries against these data sources.</p>\n<p>Where necessary, you can create custom type providers, or you can reference type providers that others have created. For example, your organization could have a data service that provides a large and growing number of named data sets, each with its own stable data schema. You can create a type provider that reads the schemas and presents the current data sets to the programmer in a strongly typed way.</p>\n<h2 id=\"before-you-start\">Before You Start</h2>\n<p>The type provider mechanism is primarily designed for injecting stable data and service information spaces into the F# programming experience.</p>\n<p>This mechanism isn’t designed for injecting information spaces whose schema changes during program execution in ways that are relevant to program logic. Also, the mechanism isn&#39;t designed for intra-language meta-programming, even though that domain contains some valid uses. You should use this mechanism only where necessary and where the development of a type provider yields very high value.</p>\n<p>You should avoid writing a type provider where a schema isn&#39;t available. Likewise, you should avoid writing a type provider where an ordinary (or even an existing) .NET library would suffice.</p>\n<p>Before you start, you might ask the following questions:</p>\n<ul>\n<li><p>Do you have a schema for your information source? If so, what’s the mapping into the F# and .NET type system?</p>\n</li>\n<li><p>Can you use an existing (dynamically typed) API as a starting point for your implementation?</p>\n</li>\n<li><p>Will you and your organization have enough uses of the type provider to make writing it worthwhile? Would a normal .NET library meet your needs?</p>\n</li>\n<li><p>How much will your schema change?</p>\n</li>\n<li><p>Will it change during coding?</p>\n</li>\n<li><p>Will it change between coding sessions?</p>\n</li>\n<li><p>Will it change during program execution?</p>\n</li>\n</ul>\n<p>Type providers are best suited to situations where the schema is stable at runtime and during the lifetime of compiled code.</p>\n<h2 id=\"a-simple-type-provider\">A Simple Type Provider</h2>\n<p>This sample is Samples.HelloWorldTypeProvider in the <code>SampleProviders\\Providers</code> directory of the <a href=\"http://go.microsoft.com/fwlink/?LinkId=236999\" data-linktype=\"external\">F# 3.0 Sample Pack</a> on the Codeplex website. The provider makes available a &quot;type space&quot; that contains 100 erased types, as the following code shows by using F# signature syntax and omitting the details for all except <code>Type1</code>. For more information about erased types, see <a href=\"https://msdn.microsoft.com/library/#BK_Erased\" data-linktype=\"external\">Details About Erased Provided Types</a> later in this topic.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">namespace Samples.HelloWorldTypeProvider\n\ntype Type1 =\n    /// This is a static property.\n    static member StaticProperty : string\n\n    /// This constructor takes no arguments.\n    new : unit -&gt; Type1\n\n    /// This constructor takes one argument.\n    new : data:string -&gt; Type1\n\n    /// This is an instance property.\n    member InstanceProperty : int\n\n    /// This is an instance method.\n    member InstanceMethod : x:int -&gt; char\n\n    /// This is an instance property.\n    nested type NestedType = \n        /// This is StaticProperty1 on NestedType.\n        static member StaticProperty1 : string\n        …\n        /// This is StaticProperty100 on NestedType.\n        static member StaticProperty100 : string\n\ntype Type2 =\n…\n…\n\ntype Type100 =\n…\n</code></pre><p>Note that the set of types and members provided is statically known. This example doesn&#39;t leverage the ability of providers to provide types that depend on a schema. The implementation of the type provider is outlined in the following code, and the details are covered in later sections of this topic.</p>\n<div class=\"WARNING\"><h5>Warning</h5><p>There may be some small naming differences between this code and the online samples.</p>\n</div>\n<pre class=\"loading\"><code class=\"lang-fsharp\">namespace Samples.FSharp.HelloWorldTypeProvider\n\nopen System\nopen System.Reflection\nopen Samples.FSharp.ProvidedTypes\nopen Microsoft.FSharp.Core.CompilerServices\nopen Microsoft.FSharp.Quotations\n\n// This type defines the type provider. When compiled to a DLL, it can be added\n// as a reference to an F# command-line compilation, script, or project.\n[&lt;TypeProvider&gt;]\ntype SampleTypeProvider(config: TypeProviderConfig) as this = \n\n// Inheriting from this type provides implementations of ITypeProvider \n// in terms of the provided types below.\ninherit TypeProviderForNamespaces()\n\nlet namespaceName = &quot;Samples.HelloWorldTypeProvider&quot;\nlet thisAssembly = Assembly.GetExecutingAssembly()\n\n// Make one provided type, called TypeN.\nlet makeOneProvidedType (n:int) = \n…\n// Now generate 100 types\nlet types = [ for i in 1 .. 100 -&gt; makeOneProvidedType i ] \n\n// And add them to the namespace\ndo this.AddNamespace(namespaceName, types)\n\n[&lt;assembly:TypeProviderAssembly&gt;] \ndo()\n</code></pre><p>To use this provider, open a separate instance of Visual Studio 2012, create an F# script, and then add a reference to the provider from your script by using #r as the following code shows:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">#r @&quot;.\\bin\\Debug\\Samples.HelloWorldTypeProvider.dll&quot;\n\nlet obj1 = Samples.HelloWorldTypeProvider.Type1(&quot;some data&quot;)\n\nlet obj2 = Samples.HelloWorldTypeProvider.Type1(&quot;some other data&quot;)\n\nobj1.InstanceProperty\nobj2.InstanceProperty\n\n[ for index in 0 .. obj1.InstanceProperty-1 -&gt; obj1.InstanceMethod(index) ]\n[ for index in 0 .. obj2.InstanceProperty-1 -&gt; obj2.InstanceMethod(index) ]\n\nlet data1 = Samples.HelloWorldTypeProvider.Type1.NestedType.StaticProperty35\n</code></pre><p>Then look for the types under the <code>Samples.HelloWorldTypeProvider</code> namespace that the type provider generated.</p>\n<p>Before you recompile the provider, make sure that you have closed all instances of Visual Studio and F# Interactive that are using the provider DLL. Otherwise, a build error will occur because the output DLL will be locked.</p>\n<p>To debug this provider by using print statements, make a script that exposes a problem with the provider, and then use the following code:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">fsc.exe -r:bin\\Debug\\HelloWorldTypeProvider.dll script.fsx\n</code></pre><p>To debug this provider by using Visual Studio, open the Visual Studio command prompt with administrative credentials, and run the following command:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">devenv.exe /debugexe fsc.exe -r:bin\\Debug\\HelloWorldTypeProvider.dll script.fsx\n</code></pre><p>As an alternative, open Visual Studio, open the Debug menu, choose <code>Debug/Attach to process…</code>, and attach to another <code>devenv</code> process where you’re editing your script. By using this method, you can more easily target particular logic in the type provider by interactively typing expressions into the second instance (with full IntelliSense and other features).</p>\n<p>You can disable Just My Code debugging to better identify errors in generated code. For information about how to enable or disable this feature, see <a href=\"https://msdn.microsoft.com/library/y740d9d3.aspx\" data-linktype=\"external\">Navigating through Code with the Debugger</a>. Also, you can also set first-chance exception catching by opening the <code>Debug</code> menu and then choosing <code>Exceptions</code> or by choosing the Ctrl+Alt+E keys to open the <code>Exceptions</code> dialog box. In that dialog box, under <code>Common Language Runtime Exceptions</code>, select the <code>Thrown</code> check box.</p>\n<h3 id=\"implementation-of-the-type-provider\">Implementation of the Type Provider</h3>\n<p>This section walks you through the principal sections of the type provider implementation. First, you define the type for the custom type provider itself:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">[&lt;TypeProvider&gt;]\ntype SampleTypeProvider(config: TypeProviderConfig) as this =\n</code></pre><p>This type must be public, and you must mark it with the <a href=\"https://msdn.microsoft.com/library/bdf7b036-7490-4ace-b79f-c5f1b1b37947\" data-linktype=\"external\">TypeProvider</a> attribute so that the compiler will recognize the type provider when a separate F# project references the assembly that contains the type. The <em>config</em> parameter is optional, and, if present, contains contextual configuration information for the type provider instance that the F# compiler creates.</p>\n<p>Next, you implement the <a href=\"https://msdn.microsoft.com/library/2c2b0571-843d-4a7d-95d4-0a7510ed5e2f\" data-linktype=\"external\">ITypeProvider</a> interface. In this case, you use the <code>TypeProviderForNamespaces</code> type from the <code>ProvidedTypes</code> API as a base type. This helper type can provide a finite collection of eagerly provided namespaces, each of which directly contains a finite number of fixed, eagerly provided types. In this context, the provider <em>eagerly</em> generates types even if they aren&#39;t needed or used.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">inherit TypeProviderForNamespaces()\n</code></pre><p>Next, define local private values that specify the namespace for the provided types, and find the type provider assembly itself. This assembly is used later as the logical parent type of the erased types that are provided.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let namespaceName = &quot;Samples.HelloWorldTypeProvider&quot;\nlet thisAssembly = Assembly.GetExecutingAssembly()\n</code></pre><p>Next, create a function to provide each of the types Type1…Type100. This function is explained in more detail later in this topic.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let makeOneProvidedType (n:int) = …\n</code></pre><p>Next, generate the 100 provided types:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let types = [ for i in 1 .. 100 -&gt; makeOneProvidedType i ]\n</code></pre><p>Next, add the types as a provided namespace:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">do this.AddNamespace(namespaceName, types)\n</code></pre><p>Finally, add an assembly attribute that indicates that you are creating a type provider DLL:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">[&lt;assembly:TypeProviderAssembly&gt;] \ndo()\n</code></pre><h3 id=\"providing-one-type-and-its-members\">Providing One Type And Its Members</h3>\n<p>The <code>makeOneProvidedType</code> function does the real work of providing one of the types.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let makeOneProvidedType (n:int) = \n…\n</code></pre><p>This step explains the implementation of this function. First, create the provided type (for example, Type1, when n = 1, or Type57, when n = 57).</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">// This is the provided type. It is an erased provided type and, in compiled code, \n// will appear as type &#39;obj&#39;.\nlet t = ProvidedTypeDefinition(thisAssembly,namespaceName,\n&quot;Type&quot; + string n,\nbaseType = Some typeof&lt;obj&gt;)\n</code></pre><p>You should note the following points:</p>\n<ul>\n<li><p>This provided type is erased.  Because you indicate that the base type is <code>obj</code>, instances will appear as values of type <a href=\"https://msdn.microsoft.com/library/dcf2430f-702b-40e5-a0a1-97518bf137f7\" data-linktype=\"external\">obj</a> in compiled code.\n<br></p>\n</li>\n<li><p>When you specify a non-nested type, you must specify the assembly and namespace. For erased types, the assembly should be the type provider assembly itself.\n<br></p>\n</li>\n</ul>\n<p>Next, add XML documentation to the type. This documentation is delayed, that is, computed on-demand if the host compiler needs it.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">t.AddXmlDocDelayed (fun () -&gt; sprintf &quot;This provided type %s&quot; (&quot;Type&quot; + string n))\n</code></pre><p>Next you add a provided static property to the type:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let staticProp = ProvidedProperty(propertyName = &quot;StaticProperty&quot;, \npropertyType = typeof&lt;string&gt;, \nIsStatic=true,\nGetterCode= (fun args -&gt; &lt;@@ &quot;Hello!&quot; @@&gt;))\n</code></pre><p>Getting this property will always evaluate to the string &quot;Hello!&quot;. The <code>GetterCode</code> for the property uses an F# quotation, which represents the code that the host compiler generates for getting the property. For more information about quotations, see <a href=\"https://msdn.microsoft.com/library/6f055397-a1f0-4f9a-927c-f0d7c6951155\" data-linktype=\"external\">Code Quotations (F#)</a>.</p>\n<p>Add XML documentation to the property.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">staticProp.AddXmlDocDelayed(fun () -&gt; &quot;This is a static property&quot;)\n</code></pre><p>Now attach the provided property to the provided type. You must attach a provided member to one and only one type. Otherwise, the member will never be accessible.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">t.AddMember staticProp\n</code></pre><p>Now create a provided constructor that takes no parameters.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let ctor = ProvidedConstructor(parameters = [ ], \nInvokeCode= (fun args -&gt; &lt;@@ &quot;The object data&quot; :&gt; obj @@&gt;))\n</code></pre><p>The <code>InvokeCode</code> for the constructor returns an F# quotation, which represents the code that the host compiler generates when the constructor is called. For example, you can use the following constructor:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">new Type10()\n</code></pre><p>An instance of the provided type will be created with underlying data &quot;The object data&quot;. The quoted code includes a conversion to <a href=\"https://msdn.microsoft.com/library/dcf2430f-702b-40e5-a0a1-97518bf137f7\" data-linktype=\"external\">obj</a> because that type is the erasure of this provided type (as you specified when you declared the provided type).</p>\n<p>Add XML documentation to the constructor, and add the provided constructor to the provided type:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">ctor.AddXmlDocDelayed(fun () -&gt; &quot;This is a constructor&quot;)\n\nt.AddMember ctor\n</code></pre><p>Create a second provided constructor that takes one parameter:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let ctor2 = \nProvidedConstructor(parameters = [ ProvidedParameter(&quot;data&quot;,typeof&lt;string&gt;) ], \nInvokeCode= (fun args -&gt; &lt;@@ (%%(args.[0]) : string) :&gt; obj @@&gt;))\n</code></pre><p>The <code>InvokeCode</code> for the constructor again returns an F# quotation, which represents the code that the host compiler generated for a call to the method. For example, you can use the following constructor:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">new Type10(&quot;ten&quot;)\n</code></pre><p>An instance of the provided type is created with underlying data &quot;ten&quot;. You may have already noticed that the <code>InvokeCode</code> function returns a quotation. The input to this function is a list of expressions, one per constructor parameter. In this case, an expression that represents the single parameter value is available in <code>args.[0]</code>. The code for a call to the constructor coerces the return value to the erased type <code>obj</code>. After you add the second provided constructor to the type, you create a provided instance property:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let instanceProp = \nProvidedProperty(propertyName = &quot;InstanceProperty&quot;, \npropertyType = typeof&lt;int&gt;, \nGetterCode= (fun args -&gt; \n&lt;@@ ((%%(args.[0]) : obj) :?&gt; string).Length @@&gt;))\ninstanceProp.AddXmlDocDelayed(fun () -&gt; &quot;This is an instance property&quot;)\nt.AddMember instanceProp\n</code></pre><p>Getting this property will return the length of the string, which is the representation object. The <code>GetterCode</code> property returns an F# quotation that specifies the code that the host compiler generates to get the property. Like <code>InvokeCode</code>, the <code>GetterCode</code> function returns a quotation. The host compiler calls this function with a list of arguments. In this case, the arguments include just the single expression that represents the instance upon which the getter is being called, which you can access by using <code>args.[0]</code>.The implementation of <code>GetterCode</code> then splices into the result quotation at the erased type <code>obj</code>, and a cast is used to satisfy the compiler&#39;s mechanism for checking types that the object is a string. The next part of <code>makeOneProvidedType</code> provides an instance method with one parameter.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let instanceMeth = \nProvidedMethod(methodName = &quot;InstanceMethod&quot;, \nparameters = [ProvidedParameter(&quot;x&quot;,typeof&lt;int&gt;)], \nreturnType = typeof&lt;char&gt;, \nInvokeCode = (fun args -&gt; \n&lt;@@ ((%%(args.[0]) : obj) :?&gt; string).Chars(%%(args.[1]) : int) @@&gt;))\n\ninstanceMeth.AddXmlDocDelayed(fun () -&gt; &quot;This is an instance method&quot;)\n// Add the instance method to the type.\nt.AddMember instanceMeth\n</code></pre><p>Finally, create a nested type that contains 100 nested properties. The creation of this nested type and its properties is delayed, that is, computed on-demand.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">t.AddMembersDelayed(fun () -&gt; \nlet nestedType = ProvidedTypeDefinition(&quot;NestedType&quot;,\nSome typeof&lt;obj&gt;\n\n)\n\nnestedType.AddMembersDelayed (fun () -&gt; \nlet staticPropsInNestedType = \n[ for i in 1 .. 100 do\nlet valueOfTheProperty = &quot;I am string &quot;  + string i\n\nlet p = ProvidedProperty(propertyName = &quot;StaticProperty&quot; + string i, \npropertyType = typeof&lt;string&gt;, \nIsStatic=true,\nGetterCode= (fun args -&gt; &lt;@@ valueOfTheProperty @@&gt;))\n\np.AddXmlDocDelayed(fun () -&gt; \nsprintf &quot;This is StaticProperty%d on NestedType&quot; i)\n\nyield p ]\nstaticPropsInNestedType)\n\n[nestedType])\n\n// The result of makeOneProvidedType is the type.\nt\n</code></pre><h3 id=\"details-about-erased-provided-types\">Details about Erased Provided Types</h3>\n<p>The example in this section provides only <em>erased provided types</em>, which are particularly useful in the following situations:</p>\n<ul>\n<li><p>When you are writing a provider for an information space that contains only data and methods.\n<br></p>\n</li>\n<li><p>When you are writing a provider where accurate runtime-type semantics aren&#39;t critical for practical use of the information space.\n<br></p>\n</li>\n<li><p>When you are writing a provider for an information space that is so large and interconnected that it isn’t technically feasible to generate real .NET types for the information space.\n<br></p>\n</li>\n</ul>\n<p>In this example, each provided type is erased to type <code>obj</code>, and all uses of the type will appear as type <code>obj</code> in compiled code. In fact, the underlying objects in these examples are strings, but the type will appear as <code>System.Object</code> in .NET compiled code. As with all uses of type erasure, you can use explicit boxing, unboxing, and casting to subvert erased types. In this case, a cast exception that isn’t valid may result when the object is used. A provider runtime can define its own private representation type to help protect against false representations. You can’t define erased types in F# itself. Only provided types may be erased. You must understand the ramifications, both practical and semantic, of using either erased types for your type provider or a provider that provides erased types. An erased type has no real .NET type. Therefore, you cannot do accurate reflection over the type, and you might subvert erased types if you use runtime casts and other techniques that rely on exact runtime type semantics. Subversion of erased types frequently results in type cast exceptions at runtime.</p>\n<h3 id=\"choosing-representations-for-erased-provided-types\">Choosing Representations for Erased Provided Types</h3>\n<p>For some uses of erased provided types, no representation is required. For example, the erased provided type might contain only static properties and members and no constructors, and no methods or properties would return an instance of the type. If you can reach instances of an erased provided type, you must consider the following questions:</p>\n<ul>\n<li><p>What is the erasure of a provided type?\n<br></p>\n<ul>\n<li><p>The erasure of a provided type is how the type appears in compiled .NET code.\n<br></p>\n</li>\n<li><p>The erasure of a provided erased class type is always the first non-erased base type in the inheritance chain of the type.\n<br></p>\n</li>\n<li><p>The erasure of a provided erased interface type is always <code>System.Object</code>.\n<br></p>\n</li>\n</ul>\n</li>\n<li><p>What are the representations of a provided type?\n<br></p>\n<ul>\n<li>The set of possible objects for an erased provided type are called its representations. In the example in this document, the representations of all the erased provided types <code>Type1..Type100</code> are always string objects.\n<br></li>\n</ul>\n</li>\n</ul>\n<p>All representations of a provided type must be compatible with the erasure of the provided type. (Otherwise, either the F# compiler will give an error for a use of the type provider, or unverifiable .NET code that isn&#39;t valid will be generated. A type provider isn’t valid if it returns code that gives a  representation that isn&#39;t valid.)</p>\n<p>You can choose a representation for provided objects by using either of the following approaches, both of which are very common:</p>\n<ul>\n<li><p>If you&#39;re simply providing a strongly typed wrapper over an existing .NET type, it often makes sense for your type to erase to that type, use instances of that type as representations, or both. This approach is appropriate when most of the existing methods on that type still make sense when using the strongly typed version.\n<br></p>\n</li>\n<li><p>If you want to create an API that differs significantly from any existing .NET API, it makes sense to create runtime types that will be the type erasure and representations for the provided types.\n<br></p>\n</li>\n</ul>\n<p>The example in this document uses strings as representations of provided objects. Frequently, it may be appropriate to use other objects for representations. For example, you may use a dictionary as a property bag:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">ProvidedConstructor(parameters = [], \nInvokeCode= (fun args -&gt; &lt;@@ (new Dictionary&lt;string,obj&gt;()) :&gt; obj @@&gt;))\n</code></pre><p>As an alternative, you may define a type in your type provider that will be used at runtime to form the representation, along with one or more runtime operations:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">type DataObject() =\nlet data = Dictionary&lt;string,obj&gt;()\nmember x.RuntimeOperation() = data.Count\n</code></pre><p>Provided members can then construct instances of this object type:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">ProvidedConstructor(parameters = [], \nInvokeCode= (fun args -&gt; &lt;@@ (new DataObject()) :&gt; obj @@&gt;))\n</code></pre><p>In this case, you may (optionally) use this type as the type erasure by specifying this type as the <code>baseType</code> when constructing the <code>ProvidedTypeDefinition</code>:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">ProvidedTypeDefinition(…, baseType = Some typeof&lt;DataObject&gt; )\n…\nProvidedConstructor(…, InvokeCode = (fun args -&gt; &lt;@@ new DataObject() @@&gt;), …)\n</code></pre><p><code>Key Lessons</code></p>\n<p>The previous section explained how to create a simple erasing type provider that provides a range of types, properties, and methods. This section also explained the concept of type erasure, including some of the advantages and disadvantages of providing erased types from a type provider, and discussed representations of erased types.</p>\n<h2 id=\"a-type-provider-that-uses-static-parameters\">A Type Provider That Uses Static Parameters</h2>\n<p>The ability to parameterize type providers by static data enables many interesting scenarios, even in cases when the provider doesn&#39;t need to access any local or remote data. In this section, you’ll learn some basic techniques for putting together such a provider.</p>\n<h3 id=\"type-checked-regex-provider\">Type Checked Regex Provider</h3>\n<p>Imagine that you want to implement a type provider for regular expressions that wraps the .NET <code>System.Text.RegularExpressions.Regex</code> libraries in an interface that provides the following compile-time guarantees:</p>\n<ul>\n<li><p>Verifying whether a regular expression is valid.\n<br></p>\n</li>\n<li><p>Providing named properties on matches that are based on any group names in the regular expression.\n<br></p>\n</li>\n</ul>\n<p>This section shows you how to use type providers to create a <code>RegExProviderType</code> type that the regular expression pattern parameterizes to provide these benefits. The compiler will report an error if the supplied pattern isn&#39;t valid, and the type provider can extract the groups from the pattern so that you can access them by using named properties on matches. When you design a type provider, you should consider how its exposed API should look to end users and how this design will translate to .NET code. The following example shows how to use such an API to get the components of the area code:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">type T = RegexTyped&lt; @&quot;(?&lt;AreaCode&gt;^\\d{3})-(?&lt;PhoneNumber&gt;\\d{3}-\\d{4}$)&quot;&gt;\nlet reg = T()\nlet result = T.IsMatch(&quot;425-555-2345&quot;)\nlet r = reg.Match(&quot;425-555-2345&quot;).Group_AreaCode.Value //r equals &quot;425&quot;\n</code></pre><p>The following example shows how the type provider translates these calls:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let reg = new Regex(@&quot;(?&lt;AreaCode&gt;^\\d{3})-(?&lt;PhoneNumber&gt;\\d{3}-\\d{4}$)&quot;)\nlet result = reg.IsMatch(&quot;425-123-2345&quot;)\nlet r = reg.Match(&quot;425-123-2345&quot;).Groups.[&quot;AreaCode&quot;].Value //r equals &quot;425&quot;\n</code></pre><p>Note the following points:</p>\n<ul>\n<li><p>The standard Regex type represents the parameterized <code>RegexTyped</code> type.\n<br></p>\n</li>\n<li><p>The <code>RegexTyped</code> constructor results in a call to the Regex constructor, passing in the static type argument for the pattern.\n<br></p>\n</li>\n<li><p>The results of the <code>Match</code> method are represented by the standard <code>System.Text.RegularExpressions.Match</code> type.\n<br></p>\n</li>\n<li><p>Each named group results in a provided property, and accessing the property results in a use of an indexer on a match’s <code>Groups</code> collection.\n<br></p>\n</li>\n</ul>\n<p>The following code is the core of the logic to implement such a provider, and this example omits the addition of all members to the provided type. For information about each added member, see the appropriate section later in this topic. For the full code, download the sample from the <a href=\"http://go.microsoft.com/fwlink/?LinkId=236999\" data-linktype=\"external\">F# 3.0 Sample Pack</a> on the Codeplex website.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">namespace Samples.FSharp.RegexTypeProvider\n\nopen System.Reflection\nopen Microsoft.FSharp.Core.CompilerServices\nopen Samples.FSharp.ProvidedTypes\nopen System.Text.RegularExpressions\n\n[&lt;TypeProvider&gt;]\ntype public CheckedRegexProvider() as this =\ninherit TypeProviderForNamespaces()\n\n// Get the assembly and namespace used to house the provided types\nlet thisAssembly = Assembly.GetExecutingAssembly()\nlet rootNamespace = &quot;Samples.FSharp.RegexTypeProvider&quot;\nlet baseTy = typeof&lt;obj&gt;\nlet staticParams = [ProvidedStaticParameter(&quot;pattern&quot;, typeof&lt;string&gt;)]\n\nlet regexTy = ProvidedTypeDefinition(thisAssembly, rootNamespace, &quot;RegexTyped&quot;, Some baseTy)\n\ndo regexTy.DefineStaticParameters(\nparameters=staticParams, \ninstantiationFunction=(fun typeName parameterValues -&gt;\n\nmatch parameterValues with \n| [| :? string as pattern|] -&gt; \n// Create an instance of the regular expression. \n//\n// This will fail with System.ArgumentException if the regular expression is not valid. \n// The exception will escape the type provider and be reported in client code.\nlet r = System.Text.RegularExpressions.Regex(pattern)            \n\n// Declare the typed regex provided type.\n// The type erasure of this type is &#39;obj&#39;, even though the representation will always be a Regex\n// This, combined with hiding the object methods, makes the IntelliSense experience simpler.\nlet ty = ProvidedTypeDefinition(\nthisAssembly, \nrootNamespace, \ntypeName, \nbaseType = Some baseTy)\n\n...\n\nty\n| _ -&gt; failwith &quot;unexpected parameter values&quot;)) \n\ndo this.AddNamespace(rootNamespace, [regexTy])\n\n[&lt;TypeProviderAssembly&gt;]\ndo ()\n</code></pre><p>Note the following points:</p>\n<ul>\n<li><p>The type provider takes two static parameters: the <code>pattern</code>, which is mandatory, and the <code>options</code>, which are optional (because a default value is provided).\n<br></p>\n</li>\n<li><p>After the static arguments are supplied, you create an instance of the regular expression. This instance will throw an exception if the Regex is malformed, and this error will be reported to users.\n<br></p>\n</li>\n<li><p>Within the <code>DefineStaticParameters</code> callback, you define the type that will be returned after the arguments are supplied.\n<br></p>\n</li>\n<li><p>This code sets <code>HideObjectMethods</code> to true so that the IntelliSense experience will remain streamlined. This attribute causes the <code>Equals</code>, <code>GetHashCode</code>, <code>Finalize</code>, and <code>GetType</code> members to be suppressed from IntelliSense lists for a provided object.\n<br></p>\n</li>\n<li><p>You use <code>obj</code> as the base type of the method, but you’ll use a <code>Regex</code> object as the runtime representation of this type, as the next example shows.\n<br></p>\n</li>\n<li><p>The call to the <code>Regex</code> constructor throws a <code>System.ArgumentException</code> when a regular expression isn’t valid. The compiler catches this exception and reports an error message to the user at compile time or in the Visual Studio editor. This exception enables regular expressions to be validated without running an application.\n<br></p>\n</li>\n</ul>\n<p>The type defined above isn&#39;t useful yet because it doesn’t contain any meaningful methods or properties. First, add a static <code>IsMatch</code> method:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let isMatch = ProvidedMethod(\nmethodName = &quot;IsMatch&quot;, \nparameters = [ProvidedParameter(&quot;input&quot;, typeof&lt;string&gt;)], \nreturnType = typeof&lt;bool&gt;, \nIsStaticMethod = true,\nInvokeCode = fun args -&gt; &lt;@@ Regex.IsMatch(%%args.[0], pattern) @@&gt;) \n\nisMatch.AddXmlDoc &quot;Indicates whether the regular expression finds a match in the specified input string.&quot; \nty.AddMember isMatch\n</code></pre><p>The previous code defines a method <code>IsMatch</code>, which takes a string as input and returns a <code>bool</code>. The only tricky part is the use of the <code>args</code> argument within the <code>InvokeCode</code> definition. In this example, <code>args</code> is a list of quotations that represents the arguments to this method. If the method is an instance method, the first argument represents the <code>this</code> argument. However, for a static method, the arguments are all just the explicit arguments to the method. Note that the type of the quoted value should match the specified return type (in this case, <code>bool</code>). Also note that this code uses the <code>AddXmlDoc</code> method to make sure that the provided method also has useful documentation, which you can supply through IntelliSense.</p>\n<p>Next, add an instance Match method. However, this method should return a value of a provided <code>Match</code> type so that the groups can be accessed in a strongly typed fashion. Thus, you first declare the <code>Match</code> type. Because this type depends on the pattern that was supplied as a static argument, this type must be nested within the parameterized type definition:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let matchTy = ProvidedTypeDefinition(\n&quot;MatchType&quot;, \nbaseType = Some baseTy, \nHideObjectMethods = true)\n\nty.AddMember matchTy\n</code></pre><p>You then add one property to the Match type for each group. At runtime, a match is represented as a <code>System.Text.RegularExpressions.Match</code> value, so the quotation that defines the property must use the <code>System.Text.RegularExpressions.Match.Groups</code> indexed property to get the relevant group.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">for group in r.GetGroupNames() do\n// Ignore the group named 0, which represents all input.\nif group &lt;&gt; &quot;0&quot; then\nlet prop = ProvidedProperty(\npropertyName = group, \npropertyType = typeof&lt;Group&gt;, \nGetterCode = fun args -&gt; &lt;@@ ((%%args.[0]:obj) :?&gt; Match).Groups.[group] @@&gt;)\nprop.AddXmlDoc(sprintf @&quot;Gets the &quot;&quot;%s&quot;&quot; group from this match&quot; group)\nmatchTy.AddMember prop\n</code></pre><p>Again, note that you’re adding XML documentation to the provided property. Also note that a property can be read if a <code>GetterCode</code> function is provided, and the property can be written if a <code>SetterCode</code> function is provided, so the resulting property is read only.</p>\n<p>Now you can create an instance method that returns a value of this <code>Match</code> type:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let matchMethod = \nProvidedMethod(\nmethodName = &quot;Match&quot;, \nparameters = [ProvidedParameter(&quot;input&quot;, typeof&lt;string&gt;)], \nreturnType = matchTy, \nInvokeCode = fun args -&gt; &lt;@@ ((%%args.[0]:obj) :?&gt; Regex).Match(%%args.[1]) :&gt; obj @@&gt;)\nmatchMeth.AddXmlDoc &quot;Searches the specified input string for the first occurrence of this regular expression&quot; \n\nty.AddMember matchMeth\n</code></pre><p>Because you are creating an instance method, <code>args.[0]</code> represents the <code>RegexTyped</code> instance on which the method is being called, and <code>args.[1]</code> is the input argument.</p>\n<p>Finally, provide a constructor so that instances of the provided type can be created.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let ctor = ProvidedConstructor(\nparameters = [], \nInvokeCode = fun args -&gt; &lt;@@ Regex(pattern, options) :&gt; obj @@&gt;)\nctor.AddXmlDoc(&quot;Initializes a regular expression instance.&quot;)\n\nty.AddMember ctor\n</code></pre><p>The constructor merely erases to the creation of a standard .NET Regex instance, which is again boxed to an object because <code>obj</code> is the erasure of the provided type. With that change, the sample API usage that specified earlier in the topic works as expected. The following code is complete and final:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">namespace Samples.FSharp.RegexTypeProvider\n\nopen System.Reflection\nopen Microsoft.FSharp.Core.CompilerServices\nopen Samples.FSharp.ProvidedTypes\nopen System.Text.RegularExpressions\n\n[&lt;TypeProvider&gt;]\ntype public CheckedRegexProvider() as this =\ninherit TypeProviderForNamespaces()\n\n// Get the assembly and namespace used to house the provided types.\nlet thisAssembly = Assembly.GetExecutingAssembly()\nlet rootNamespace = &quot;Samples.FSharp.RegexTypeProvider&quot;\nlet baseTy = typeof&lt;obj&gt;\nlet staticParams = [ProvidedStaticParameter(&quot;pattern&quot;, typeof&lt;string&gt;)]\n\nlet regexTy = ProvidedTypeDefinition(thisAssembly, rootNamespace, &quot;RegexTyped&quot;, Some baseTy)\n\ndo regexTy.DefineStaticParameters(\nparameters=staticParams, \ninstantiationFunction=(fun typeName parameterValues -&gt;\n\nmatch parameterValues with \n| [| :? string as pattern|] -&gt; \n// Create an instance of the regular expression. \n\n\n\n\nlet r = System.Text.RegularExpressions.Regex(pattern)            \n\n// Declare the typed regex provided type.\n\n\n\nlet ty = ProvidedTypeDefinition(\nthisAssembly, \nrootNamespace, \ntypeName, \nbaseType = Some baseTy)\n\nty.AddXmlDoc &quot;A strongly typed interface to the regular expression &#39;%s&#39;&quot;\n\n// Provide strongly typed version of Regex.IsMatch static method.\nlet isMatch = ProvidedMethod(\nmethodName = &quot;IsMatch&quot;, \nparameters = [ProvidedParameter(&quot;input&quot;, typeof&lt;string&gt;)], \nreturnType = typeof&lt;bool&gt;, \nIsStaticMethod = true,\nInvokeCode = fun args -&gt; &lt;@@ Regex.IsMatch(%%args.[0], pattern) @@&gt;) \n\nisMatch.AddXmlDoc &quot;Indicates whether the regular expression finds a match in the specified input string&quot;\n\nty.AddMember isMatch\n\n// Provided type for matches\n// Again, erase to obj even though the representation will always be a Match\nlet matchTy = ProvidedTypeDefinition(\n&quot;MatchType&quot;, \nbaseType = Some baseTy, \nHideObjectMethods = true)\n\n// Nest the match type within parameterized Regex type.\nty.AddMember matchTy\n\n// Add group properties to match type\nfor group in r.GetGroupNames() do\n// Ignore the group named 0, which represents all input.\nif group &lt;&gt; &quot;0&quot; then\nlet prop = ProvidedProperty(\npropertyName = group, \npropertyType = typeof&lt;Group&gt;, \nGetterCode = fun args -&gt; &lt;@@ ((%%args.[0]:obj) :?&gt; Match).Groups.[group] @@&gt;)\nprop.AddXmlDoc(sprintf @&quot;Gets the &quot;&quot;%s&quot;&quot; group from this match&quot; group)\nmatchTy.AddMember(prop)\n\n// Provide strongly typed version of Regex.Match instance method.\nlet matchMeth = ProvidedMethod(\nmethodName = &quot;Match&quot;, \nparameters = [ProvidedParameter(&quot;input&quot;, typeof&lt;string&gt;)], \nreturnType = matchTy, \nInvokeCode = fun args -&gt; &lt;@@ ((%%args.[0]:obj) :?&gt; Regex).Match(%%args.[1]) :&gt; obj @@&gt;)\nmatchMeth.AddXmlDoc &quot;Searches the specified input string for the first occurence of this regular expression&quot;\n\nty.AddMember matchMeth\n\n// Declare a constructor.\nlet ctor = ProvidedConstructor(\nparameters = [], \nInvokeCode = fun args -&gt; &lt;@@ Regex(pattern) :&gt; obj @@&gt;)\n\n// Add documentation to the constructor.\nctor.AddXmlDoc &quot;Initializes a regular expression instance&quot;\n\nty.AddMember ctor\n\nty\n| _ -&gt; failwith &quot;unexpected parameter values&quot;)) \n\ndo this.AddNamespace(rootNamespace, [regexTy])\n\n[&lt;TypeProviderAssembly&gt;]\ndo ()\n</code></pre><p><code>Key Lessons</code></p>\n<p>This section explained how to create a type provider that operates on its static parameters. The provider checks the static parameter and provides operations based on its value.</p>\n<h2 id=\"a-type-provider-that-is-backed-by-local-data\">A Type Provider That Is Backed By Local Data</h2>\n<p>Frequently you might want type providers to present APIs based on not only static parameters but also information from local or remote systems. This section discusses type providers that are based on local data, such as local data files.</p>\n<h3 id=\"simple-csv-file-provider\">Simple CSV File Provider</h3>\n<p>As a simple example, consider a type provider for accessing scientific data in Comma Separated Value (CSV) format. This section assumes that the CSV files contain a header row followed by floating point data, as the following table illustrates:</p>\n<table>\n<thead>\n<tr>\n<th>Distance (meter)</th>\n<th>Time (second)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>50.0</td>\n<td>3.7</td>\n</tr>\n<tr>\n<td>100.0</td>\n<td>5.2</td>\n</tr>\n<tr>\n<td>150.0</td>\n<td>6.4</td>\n</tr>\n</tbody>\n</table>\n<p>This section shows how to provide a type that you can use to get rows with a <code>Distance</code> property of type <code>float&lt;meter&gt;</code> and a <code>Time</code> property of type <code>float&lt;second&gt;</code>. For simplicity, the following assumptions are made:</p>\n<ul>\n<li><p>Header names are either unit-less or have the form “Name (unit)” and don&#39;t contain commas.\n<br></p>\n</li>\n<li><p>Units are all Systeme International (SI) units as the <a href=\"https://msdn.microsoft.com/library/3cb43485-11f5-4aa7-a779-558f19d4013b\" data-linktype=\"external\">Microsoft.FSharp.Data.UnitSystems.SI.UnitNames Module (F#)</a> module defines.\n<br></p>\n</li>\n<li><p>Units are all simple (for example, meter) rather than compound (for example, meter/second).\n<br></p>\n</li>\n<li><p>All columns contain floating point data.\n<br></p>\n</li>\n</ul>\n<p>A more complete provider would loosen these restrictions.</p>\n<p>Again the first step is to consider how the API should look. Given an <code>info.csv</code> file with the contents from the previous table (in comma-separated format), users of the provider should be able to write code that resembles the following example:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let info = new MiniCsv&lt;&quot;info.csv&quot;&gt;()\nfor row in info.Data do\nlet time = row.Time\nprintfn &quot;%f&quot; (float time)\n</code></pre><p>In this case, the compiler should convert these calls into something like the following example:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let info = new MiniCsvFile(&quot;info.csv&quot;)\nfor row in info.Data do\nlet (time:float) = row.[1]\nprintfn &quot;%f&quot; (float time)\n</code></pre><p>The optimal translation will require the type provider to define a real <code>CsvFile</code> type in the type provider&#39;s assembly. Type providers often rely on a few helper types and methods to wrap important logic. Because measures are erased at runtime, you can use a <code>float[]</code> as the erased type for a row. The compiler will treat different columns as having different measure types. For example, the first column in our example has type <code>float&lt;meter&gt;</code>, and the second has <code>float&lt;second&gt;</code>. However, the erased representation can remain quite simple.</p>\n<p>The following code shows the core of the implementation.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">// Simple type wrapping CSV data\ntype CsvFile(filename) =\n// Cache the sequence of all data lines (all lines but the first)\nlet data = \nseq { for line in File.ReadAllLines(filename) |&gt; Seq.skip 1 do\nyield line.Split(&#39;,&#39;) |&gt; Array.map float }\n|&gt; Seq.cache\nmember __.Data = data\n\n[&lt;TypeProvider&gt;]\ntype public MiniCsvProvider(cfg:TypeProviderConfig) as this =\ninherit TypeProviderForNamespaces()\n\n// Get the assembly and namespace used to house the provided types.\nlet asm = System.Reflection.Assembly.GetExecutingAssembly()\nlet ns = &quot;Samples.FSharp.MiniCsvProvider&quot;\n\n// Create the main provided type.\nlet csvTy = ProvidedTypeDefinition(asm, ns, &quot;MiniCsv&quot;, Some(typeof&lt;obj&gt;))\n\n// Parameterize the type by the file to use as a template.\nlet filename = ProvidedStaticParameter(&quot;filename&quot;, typeof&lt;string&gt;)\ndo csvTy.DefineStaticParameters([filename], fun tyName [| :? string as filename |] -&gt;\n\n// Resolve the filename relative to the resolution folder.\nlet resolvedFilename = Path.Combine(cfg.ResolutionFolder, filename)\n\n// Get the first line from the file.\nlet headerLine = File.ReadLines(resolvedFilename) |&gt; Seq.head\n\n// Define a provided type for each row, erasing to a float[].\nlet rowTy = ProvidedTypeDefinition(&quot;Row&quot;, Some(typeof&lt;float[]&gt;))\n\n// Extract header names from the file, splitting on commas.\n// use Regex matching to get the position in the row at which the field occurs\nlet headers = Regex.Matches(headerLine, &quot;[^,]+&quot;)\n\n// Add one property per CSV field.\nfor i in 0 .. headers.Count - 1 do\nlet headerText = headers.[i].Value\n\n// Try to decompose this header into a name and unit.\nlet fieldName, fieldTy =\nlet m = Regex.Match(headerText, @&quot;(?&lt;field&gt;.+) \\((?&lt;unit&gt;.+)\\)&quot;)\nif m.Success then\n\n\nlet unitName = m.Groups.[&quot;unit&quot;].Value\nlet units = ProvidedMeasureBuilder.Default.SI unitName\nm.Groups.[&quot;field&quot;].Value, ProvidedMeasureBuilder.Default.AnnotateType(typeof&lt;float&gt;,[units])\n\n\nelse\n// no units, just treat it as a normal float\nheaderText, typeof&lt;float&gt;\n\nlet prop = ProvidedProperty(fieldName, fieldTy, \nGetterCode = fun [row] -&gt; &lt;@@ (%%row:float[]).[i] @@&gt;)\n\n// Add metadata that defines the property&#39;s location in the referenced file.\nprop.AddDefinitionLocation(1, headers.[i].Index + 1, filename)\nrowTy.AddMember(prop) \n\n// Define the provided type, erasing to CsvFile.\nlet ty = ProvidedTypeDefinition(asm, ns, tyName, Some(typeof&lt;CsvFile&gt;))\n\n// Add a parameterless constructor that loads the file that was used to define the schema.\nlet ctor0 = ProvidedConstructor([], \nInvokeCode = fun [] -&gt; &lt;@@ CsvFile(resolvedFilename) @@&gt;)\nty.AddMember ctor0\n\n// Add a constructor that takes the file name to load.\nlet ctor1 = ProvidedConstructor([ProvidedParameter(&quot;filename&quot;, typeof&lt;string&gt;)], \nInvokeCode = fun [filename] -&gt; &lt;@@ CsvFile(%%filename) @@&gt;)\nty.AddMember ctor1\n\n// Add a more strongly typed Data property, which uses the existing property at runtime.\nlet prop = ProvidedProperty(&quot;Data&quot;, typedefof&lt;seq&lt;_&gt;&gt;.MakeGenericType(rowTy), \nGetterCode = fun [csvFile] -&gt; &lt;@@ (%%csvFile:CsvFile).Data @@&gt;)\nty.AddMember prop\n\n// Add the row type as a nested type.\nty.AddMember rowTy\nty)\n\n// Add the type to the namespace.\ndo this.AddNamespace(ns, [csvTy])\n</code></pre><p>Note the following points about the implementation:</p>\n<ul>\n<li><p>Overloaded constructors allow either the original file or one that has an identical schema to be read. This pattern is common when you write a type provider for local or remote data sources, and this pattern allows a local file to be used as the template for remote data.\n<br>  You can use the <a href=\"https://msdn.microsoft.com/library/1cda7b9a-3d07-475d-9315-d65e1c97eb44\" data-linktype=\"external\">TypeProviderConfig</a> value that’s passed in to the type provider constructor to resolve relative file names.\n<br></p>\n</li>\n<li><p>You can use the <code>AddDefinitionLocation</code> method to define the location of the provided properties. Therefore, if you use <code>Go To Definition</code> on a provided property, the CSV file will open in Visual Studio.\n<br></p>\n</li>\n<li><p>You can use the <code>ProvidedMeasureBuilder</code> type to look up the SI units and to generate the relevant <code>float&lt;_&gt;</code> types.\n<br></p>\n</li>\n</ul>\n<p><code>Key Lessons</code></p>\n<p>This section explained how to create a type provider for a local data source with a simple schema that&#39;s contained in the data source itself.</p>\n<h2 id=\"going-further\">Going Further</h2>\n<p>The following sections include suggestions for further study.</p>\n<h3 id=\"a-look-at-the-compiled-code-for-erased-types\">A Look at the Compiled Code for Erased Types</h3>\n<p>To give you some idea of how the use of the type provider corresponds to the code that&#39;s emitted, look at the following function by using the <code>HelloWorldTypeProvider</code> that&#39;s used earlier in this topic.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">let function1 () = \nlet obj1 = Samples.HelloWorldTypeProvider.Type1(&quot;some data&quot;)\nobj1.InstanceProperty\n</code></pre><p>Here’s an image of the resulting code decompiled by using ildasm.exe:</p>\n<pre class=\"loading\"><code>.class public abstract auto ansi sealed Module1\nextends [mscorlib]System.Object\n{\n.custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAtt\nribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags)\n= ( 01 00 07 00 00 00 00 00 )\n.method public static int32  function1() cil managed\n{\n// Code size       24 (0x18)\n.maxstack  3\n.locals init ([0] object obj1)\nIL_0000:  nop\nIL_0001:  ldstr      &quot;some data&quot;\nIL_0006:  unbox.any  [mscorlib]System.Object\nIL_000b:  stloc.0\nIL_000c:  ldloc.0\nIL_000d:  call       !!0 [FSharp.Core_2]Microsoft.FSharp.Core.LanguagePrimit\nives/IntrinsicFunctions::UnboxGeneric&lt;string&gt;(object)\nIL_0012:  callvirt   instance int32 [mscorlib_3]System.String::get_Length()\nIL_0017:  ret\n} // end of method Module1::function1\n\n} // end of class Module1\n</code></pre><p>As the example shows, all mentions of the type <code>Type1</code> and the <code>InstanceProperty</code> property have been erased, leaving only operations on the runtime types involved.</p>\n<h3 id=\"design-and-naming-conventions-for-type-providers\">Design and Naming Conventions for Type Providers</h3>\n<p>Observe the following conventions when authoring type providers.</p>\n<ul>\n<li><code>Providers for Connectivity Protocols</code>\n<br>  In general, names of most provider DLLs for data and service connectivity protocols, such as OData or SQL connections, should end in <code>TypeProvider</code> or <code>TypeProviders</code>. For example, use a DLL name that resembles the following string:\n<br></li>\n</ul>\n<pre class=\"loading\"><code>  Fabrikam.Management.BasicTypeProviders.dll\n</code></pre><p>  Ensure that your provided types are members of the corresponding namespace, and indicate the connectivity protocol that you implemented:\n<br></p>\n<pre class=\"loading\"><code>  Fabrikam.Management.BasicTypeProviders.WmiConnection&lt;…&gt;\n  Fabrikam.Management.BasicTypeProviders.DataProtocolConnection&lt;…&gt;\n</code></pre><ul>\n<li><code>Utility Providers for General Coding</code>\n<br>  For a utility type provider such as that for regular expressions, the type provider may be part of a base library, as the following example shows:\n<br></li>\n</ul>\n<pre class=\"loading\"><code class=\"lang-fsharp\">  #r &quot;Fabrikam.Core.Text.Utilities.dll&quot;\n</code></pre><p>  In this case, the provided type would appear at an appropriate point according to normal .NET design conventions:\n<br></p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">  open Fabrikam.Core.Text.RegexTyped\n\n  let regex = new RegexTyped&lt;&quot;a+b+a+b+&quot;&gt;()\n</code></pre><ul>\n<li><code>Singleton Data Sources</code>\n<br>  Some type providers connect to a single dedicated data source and provide only data. In this case, you should drop the <code>TypeProvider</code> suffix and use normal conventions for .NET naming:\n<br></li>\n</ul>\n<pre class=\"loading\"><code class=\"lang-fsharp\">  #r &quot;Fabrikam.Data.Freebase.dll&quot;\n\n  let data = Fabrikam.Data.Freebase.Astronomy.Asteroids\n</code></pre><p>  For more information, see the <code>GetConnection</code> design convention that&#39;s described later in this topic.\n<br></p>\n<h3 id=\"design-patterns-for-type-providers\">Design Patterns for Type Providers</h3>\n<p>The following sections describe design patterns you can use when authoring type providers.</p>\n<h4 id=\"the-getconnection-design-pattern\">The GetConnection Design Pattern</h4>\n<p>Most type providers should be written to use the <code>GetConnection</code> pattern that&#39;s used by the type providers in FSharp.Data.TypeProviders.dll, as the following example shows:</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">#r &quot;Fabrikam.Data.WebDataStore.dll&quot;\n\ntype Service = Fabrikam.Data.WebDataStore&lt;…static connection parameters…&gt;\n\nlet connection = Service.GetConnection(…dynamic connection parameters…)\n\nlet data = connection.Astronomy.Asteroids\n</code></pre><h4 id=\"type-providers-backed-by-remote-data-and-services\">Type Providers Backed By Remote Data and Services</h4>\n<p>Before you create a type provider that&#39;s backed by remote data and services, you must consider a range of issues that are inherent in connected programming. These issues include the following considerations:</p>\n<ul>\n<li><p>schema mapping\n<br></p>\n</li>\n<li><p>liveness and invalidation in the presence of schema change\n<br></p>\n</li>\n<li><p>schema caching\n<br></p>\n</li>\n<li><p>asynchronous implementations of data access operations\n<br></p>\n</li>\n<li><p>supporting queries, including LINQ queries\n<br></p>\n</li>\n<li><p>credentials and authentication\n<br></p>\n</li>\n</ul>\n<p>This topic doesn&#39;t explore these issues further.</p>\n<h3 id=\"additional-authoring-techniques\">Additional Authoring Techniques</h3>\n<p>When you write your own type providers, you might want to use the following additional techniques.</p>\n<ul>\n<li><code>Creating Types and Members On-Demand</code>\n<br>  The ProvidedType API has delayed versions of AddMember.\n<br></li>\n</ul>\n<pre class=\"loading\"><code class=\"lang-fsharp\">  type ProvidedType =\n  member AddMemberDelayed  : (unit -&gt; MemberInfo)      -&gt; unit\n  member AddMembersDelayed : (unit -&gt; MemberInfo list) -&gt; unit\n</code></pre><p>  These versions are used to create on-demand spaces of types.\n<br></p>\n<ul>\n<li><p><code>Providing Array, ByRef, and Pointer types</code>\n<br>  You make provided members (whose signatures include array types, byref types, and instantiations of generic types) by using the normal <code>MakeArrayType</code>, <code>MakePointerType</code>, and <code>MakeGenericType</code> on any instance of System.Type, including <code>ProvidedTypeDefinitions</code>.\n<br></p>\n</li>\n<li><p><code>Providing Unit of Measure Annotations</code>\n<br>  The ProvidedTypes API provides helpers for providing measure annotations. For example, to provide the type <code>float&lt;kg&gt;</code>, use the following code:\n<br></p>\n</li>\n</ul>\n<pre class=\"loading\"><code class=\"lang-fsharp\">  let measures = ProvidedMeasureBuilder.Default\n  let kg = measures.SI &quot;kilogram&quot;\n  let m = measures.SI &quot;meter&quot;\n  let float_kg = measures.AnnotateType(typeof&lt;float&gt;,[kg])\n</code></pre><p>  To provide the type <code>Nullable&lt;decimal&lt;kg/m^2&gt;&gt;</code>, use the following code:\n<br></p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">  let kgpm2 = measures.Ratio(kg, measures.Square m)\n  let dkgpm2 = measures.AnnotateType(typeof&lt;decimal&gt;,[kgpm2])\n  let nullableDecimal_kgpm2 = typedefof&lt;System.Nullable&lt;_&gt;&gt;.MakeGenericType [|dkgpm2 |]\n</code></pre><ul>\n<li><p><code>Accessing Project-Local or Script-Local Resources</code>\n<br>  Each instance of a type provider can be given a <code>TypeProviderConfig</code> value during construction. This value contains the &quot;resolution folder&quot; for the provider (that is, the project folder for the compilation or the directory that contains a script), the list of referenced assemblies, and other information.\n<br></p>\n</li>\n<li><p><code>Invalidation</code>\n<br>  Providers can raise invalidation signals to notify the F# language service that the schema assumptions may have changed. When invalidation occurs, a typecheck is redone if the provider is being hosted in Visual Studio. This signal will be ignored when the provider is hosted in F# Interactive or by the F# Compiler (fsc.exe).\n<br></p>\n</li>\n<li><p><code>Caching Schema Information</code>\n<br>  Providers must often cache access to schema information. The cached data should be stored by using a file name that&#39;s given as a static parameter or as user data. An example of schema caching is the <code>LocalSchemaFile</code> parameter in the type providers in the <code>FSharp.Data.TypeProviders</code> assembly. In the implementation of these providers, this static parameter directs the type provider to use the schema information in the specified local file instead of accessing the data source over the network. To use cached schema information, you must also set the static parameter <code>ForceUpdate</code> to <code>false</code>. You could use a similar technique to enable online and offline data access.\n<br></p>\n</li>\n<li><p><code>Backing Assembly</code>\n<br>  When you compile a .dll or .exe file, the backing .dll file for generated types is statically linked into the resulting assembly. This link is created by copying the Intermediate Language (IL) type definitions and any managed resources from the backing assembly into the final assembly. When you use F# Interactive, the backing .dll file isn&#39;t copied and is instead loaded directly into the F# Interactive process.\n<br></p>\n</li>\n<li><p><code>Exceptions and Diagnostics from Type Providers</code>\n<br>  All uses of all members from provided types may throw exceptions. In all cases, if a type provider throws an exception, the host compiler attributes the error to a specific type provider.\n<br></p>\n<ul>\n<li><p>Type provider exceptions should never result in internal compiler errors.\n<br></p>\n</li>\n<li><p>Type providers can&#39;t report warnings.\n<br></p>\n</li>\n<li><p>When a type provider is hosted in the F# compiler, an F# development environment, or F# Interactive, all exceptions from that provider are caught. The Message property is always the error text, and no stack trace appears. If you’re going to throw an exception, you can throw the following examples:\n<br></p>\n<ul>\n<li><p><code>System.NotSupportedException</code>\n<br></p>\n</li>\n<li><p><code>System.IO.IOException</code>\n<br></p>\n</li>\n<li><p><code>System.Exception</code>\n<br></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"providing-generated-types\">Providing Generated Types</h4>\n<p>So far, this document has explained how provide erased types. You can also use the type provider mechanism in F# to provide generated types, which are added as real .NET type definitions into the users&#39; program. You must refer to generated provided types by using a type definition.</p>\n<pre class=\"loading\"><code class=\"lang-fsharp\">open Microsoft.FSharp.TypeProviders \n\ntype Service = ODataService&lt;&quot; http://services.odata.org/Northwind/Northwind.svc/&quot;&gt;\n</code></pre><p>The ProvidedTypes-0.2 helper code that is part of the F# 3.0 release has only limited support for providing generated types. The following statements must be true for a generated type definition:</p>\n<ul>\n<li><p>IsErased must be set to <code>false</code>.\n<br></p>\n</li>\n<li><p>The provider must have an assembly that has an actual backing .NET .dll file with a matching .dll file on disk.\n<br></p>\n</li>\n</ul>\n<p>You must also call <code>ConvertToGenerated</code> on a root provided type whose nested types form a closed set of generated types. This call emits the given provided type definition and its nested type definitions into an assembly and adjusts the <code>Assembly</code> property of all provided type definitions to return that assembly. The assembly is emitted only when the Assembly property on the root type is accessed for the first time. The host F# compiler does access this property when it processes a generative type declaration for the type.</p>\n<h2 id=\"rules-and-limitations\">Rules and Limitations</h2>\n<p>When you write type providers, keep the following rules and limitations in mind.</p>\n<ul>\n<li><p><code>Provided types must be reachable.</code>\n<br>  All provided types should be reachable from the non-nested types. The non-nested types are given in the call to the <code>TypeProviderForNamespaces</code> constructor or a call to <code>AddNamespace</code>. For example, if the provider provides a type <code>StaticClass.P : T</code>, you must ensure that T is either a non-nested type or nested under one.\n<br>  For example, some providers have a static class such as <code>DataTypes</code> that contain these <code>T1, T2, T3, ...</code> types. Otherwise, the error says that a reference to type T in assembly A was found, but the type couldn&#39;t be found in that assembly. If this error appears, verify that all your subtypes can be reached from the provider types. Note: These <code>T1, T2, T3...</code> types are referred to as the <em>on-the-fly</em> types. Remember to put them in an accessible namespace or a parent type.\n<br></p>\n</li>\n<li><p><code>Limitations of the Type Provider Mechanism</code>\n<br>  The type provider mechanism in F# has the following limitations:\n<br></p>\n<ul>\n<li><p>The underlying infrastructure for type providers in F# doesn&#39;t support provided generic types or provided generic methods.\n<br></p>\n</li>\n<li><p>The mechanism doesn&#39;t support nested types with static parameters.\n<br></p>\n</li>\n</ul>\n</li>\n<li><p><code>Limitations of the ProvidedTypes Support Code</code>\n<br>  The <code>ProvidedTypes</code> support code has the following rules and limitations:\n<br></p>\n<ol>\n<li><p>Provided properties with indexed getters and setters aren&#39;t implemented.\n<br></p>\n</li>\n<li><p>Provided events aren&#39;t implemented.\n<br></p>\n</li>\n<li><p>The provided types and information objects should be used only for the type provider mechanism in F#. They aren&#39;t more generally usable as System.Type objects.\n<br></p>\n</li>\n<li><p>The constructs that you can use in quotations that define method implementations have several limitations. You can refer to the source code for ProvidedTypes-<em>Version</em> to see which constructs are supported in quotations.\n<br></p>\n</li>\n</ol>\n</li>\n<li><p><code>Type providers must generate output assemblies that are .dll files, not .exe files.</code>\n<br></p>\n</li>\n</ul>\n<h2 id=\"development-tips\">Development Tips</h2>\n<p>You might find the following tips helpful during the development process.</p>\n<ul>\n<li><p><code>Run Two Instances of Visual Studio.</code> You can develop the type provider in one instance and test the provider in the other because the test IDE will take a lock on the .dll file that prevents the type provider from being rebuilt. Thus, you must close the second instance of Visual Studio while the provider is built in the first instance, and then you must reopen the second instance after the provider is built.\n<br></p>\n</li>\n<li><p><code>Debug type providers by using invocations of fsc.exe.</code> You can invoke type providers by using the following tools:\n<br></p>\n<ul>\n<li><p>fsc.exe (The F# command line compiler)\n<br></p>\n</li>\n<li><p>fsi.exe (The F# Interactive compiler)\n<br></p>\n</li>\n<li><p>devenv.exe (Visual Studio)\n<br></p>\n</li>\n</ul>\n<p>You can often debug type providers most easily by using fsc.exe on a test script file (for example, script.fsx). You can launch a debugger from a command prompt.\n<br></p>\n</li>\n</ul>\n<pre class=\"loading\"><code>  devenv /debugexe fsc.exe script.fsx\n</code></pre><p>  You can use print-to-stdout logging.\n<br></p>\n<h2 id=\"see-also\">See Also</h2>\n<p><a href=\"index\" data-linktype=\"relative-path\">Type Providers</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"cartermp\">\r\n<meta name=\"ms.author\" content=\"phcart\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"fsharp\">\r\n<meta name=\"ms.assetid\" content=\"82bec076-19d4-470c-979f-6c3a14b7c70a\">\r\n<meta name=\"description\" content=\"Tutorial: Creating a Type Provider (F#)\">\r\n<meta name=\"keywords\" content=\"visual f#, f#, functional programming\">\r\n<meta name=\"ms.topic\" content=\"language-reference\">\r\n<meta name=\"ms.date\" content=\"05/16/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-fsharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/tutorials/type-providers/creating-a-type-provider.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/tutorials/type-providers/creating-a-type-provider.md\">\r\n<meta name=\"document_id\" content=\"3a0809bd-7aa0-2650-33fe-4115ae72ea2c\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../../toc2.json\">\r\n","rawMetadata":{"author":"cartermp","ms.author":"phcart","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Tutorial: Creating a Type Provider (F#) | Microsoft Docs","ms.devlang":"fsharp","ms.assetid":"82bec076-19d4-470c-979f-6c3a14b7c70a","description":"Tutorial: Creating a Type Provider (F#)","keywords":"visual f#, f#, functional programming","ms.topic":"language-reference","ms.date":"05/16/2016","ms.technology":"devlang-fsharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Petr Onderka","author_email":"gsvick@gmail.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"Improve titles of some F# articles (#1003)","commit_sha":"d18cfd736f1dbd61ab9e209de4aaa878a88162cd","commit_date":"2016-09-03 11:22:59 -0700"},{"author_name":"Phillip Carter","author_email":"phillip.carter@outlook.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Add Visual F# Conceptual Content (#900)","commit_sha":"c27bed7dbad6b24c55734fcab0333bd3a1de85d6","commit_date":"2016-08-12 17:06:05 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter","id":"6309070"},"contributors":[{"profile_url":"https://github.com/cartermp","display_name":"Phillip Carter"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/svick","display_name":"Petr Onderka","id":"287848"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/fsharp/tutorials/type-providers/creating-a-type-provider.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/fsharp/tutorials/type-providers/creating-a-type-provider.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/fsharp/tutorials/type-providers/creating-a-type-provider.md","document_id":"3a0809bd-7aa0-2650-33fe-4115ae72ea2c","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/fsharp/tutorials/type-providers/creating-a-type-provider","toc_asset_id":"articles/toc.json","toc_rel":"../../../toc.json","_op_ogTitle":"Tutorial: Creating a Type Provider (F#)","_op_displayDate":"2016-5-16","_op_displayDate_source":"2016-05-16T00:00:00Z","_op_wordCount":7349,"_op_rawTitle":"<h1 id=\"tutorial-creating-a-type-provider\" sourcefile=\"docs/fsharp/tutorials/type-providers/creating-a-type-provider.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Tutorial: Creating a Type Provider</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/fsharp/tutorials/type-providers/creating-a-type-provider","fileRelativePath":"articles/fsharp/tutorials/type-providers/creating-a-type-provider.html"},"themesRelativePathToOutputRoot":"_themes/"}