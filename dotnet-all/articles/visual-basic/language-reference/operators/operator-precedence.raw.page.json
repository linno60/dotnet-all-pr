{"content":"<div><div class=\"content\">\n<p>When several operations occur in an expression, each part is evaluated and resolved in a predetermined order called <em>operator precedence</em>.  </p>\n<h2 id=\"precedence-rules\">Precedence Rules</h2>\n<p> When expressions contain operators from more than one category, they are evaluated according to the following rules:  </p>\n<ul>\n<li><p>The arithmetic and concatenation operators have the order of precedence described in the following section, and all have greater precedence than the comparison, logical, and bitwise operators.  </p>\n</li>\n<li><p>All comparison operators have equal precedence, and all have greater precedence than the logical and bitwise operators, but lower precedence than the arithmetic and concatenation operators.  </p>\n</li>\n<li><p>The logical and bitwise operators have the order of precedence described in the following section, and all have lower precedence than the arithmetic, concatenation, and comparison operators.  </p>\n</li>\n<li><p>Operators with equal precedence are evaluated left to right in the order in which they appear in the expression.  </p>\n</li>\n</ul>\n<h2 id=\"precedence-order\">Precedence Order</h2>\n<p> Operators are evaluated in the following order of precedence:  </p>\n<h3 id=\"await-operator\">Await Operator</h3>\n<p> Await  </p>\n<h3 id=\"arithmetic-and-concatenation-operators\">Arithmetic and Concatenation Operators</h3>\n<p> Exponentiation (<code>^</code>)  </p>\n<p> Unary identity and negation (<code>+</code>, <code>–</code>)  </p>\n<p> Multiplication and floating-point division (<code>*</code>, <code>/</code>)  </p>\n<p> Integer division (<code>\\</code>)  </p>\n<p> Modulus arithmetic (<code>Mod</code>)  </p>\n<p> Addition and subtraction (<code>+</code>, <code>–</code>)  </p>\n<p> String concatenation (<code>&amp;</code>)  </p>\n<p> Arithmetic bit shift (<code>&lt;&lt;</code>, <code>&gt;&gt;</code>)  </p>\n<h3 id=\"comparison-operators\">Comparison Operators</h3>\n<p> All comparison operators (<code>=</code>, <code>&lt;&gt;</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>Is</code>, <code>IsNot</code>, <code>Like</code>, <code>TypeOf</code>...<code>Is</code>)  </p>\n<h3 id=\"logical-and-bitwise-operators\">Logical and Bitwise Operators</h3>\n<p> Negation (<code>Not</code>)  </p>\n<p> Conjunction (<code>And</code>, <code>AndAlso</code>)  </p>\n<p> Inclusive disjunction (<code>Or</code>, <code>OrElse</code>)  </p>\n<p> Exclusive disjunction (<code>Xor</code>)  </p>\n<h3 id=\"comments\">Comments</h3>\n<p> The <code>=</code> operator is only the equality comparison operator, not the assignment operator.  </p>\n<p> The string concatenation operator (<code>&amp;</code>) is not an arithmetic operator, but in precedence it is grouped with the arithmetic operators.  </p>\n<p> The <code>Is</code> and <code>IsNot</code> operators are object reference comparison operators. They do not compare the values of two objects; they check only to determine whether two object variables refer to the same object instance.  </p>\n<h2 id=\"associativity\">Associativity</h2>\n<p> When operators of equal precedence appear together in an expression, for example multiplication and division, the compiler evaluates each operation as it encounters it from left to right. The following example illustrates this.  </p>\n<pre class=\"loading\"><code>Dim n1 As Integer = 96 / 8 / 4  \nDim n2 As Integer = (96 / 8) / 4  \nDim n3 As Integer = 96 / (8 / 4)  \n</code></pre><p> The first expression evaluates the division 96 / 8 (which results in 12) and then the division 12 / 4, which results in three. Because the compiler evaluates the operations for <code>n1</code> from left to right, the evaluation is the same when that order is explicitly indicated for <code>n2</code>. Both <code>n1</code> and <code>n2</code> have a result of three. By contrast, <code>n3</code> has a result of 48, because the parentheses force the compiler to evaluate 8 / 4 first.  </p>\n<p> Because of this behavior, operators are said to be <em>left associative</em> in Visual Basic.  </p>\n<h2 id=\"overriding-precedence-and-associativity\">Overriding Precedence and Associativity</h2>\n<p> You can use parentheses to force some parts of an expression to be evaluated before others. This can override both the order of precedence and the left associativity. Visual Basic always performs operations that are enclosed in parentheses before those outside. However, within parentheses, it maintains ordinary precedence and associativity, unless you use parentheses within the parentheses. The following example illustrates this.  </p>\n<pre class=\"loading\"><code>Dim a, b, c, d, e, f, g As Double  \na = 8.0  \nb = 3.0  \nc = 4.0  \nd = 2.0  \ne = 1.0  \nf = a - b + c / d * e  \n&#39; The preceding line sets f to 7.0. Because of natural operator   \n&#39; precedence and associativity, it is exactly equivalent to the   \n&#39; following line.  \nf = (a - b) + ((c / d) * e)  \n&#39; The following line overrides the natural operator precedence   \n&#39; and left associativity.  \ng = (a - (b + c)) / (d * e)  \n&#39; The preceding line sets g to 0.5.  \n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"assignment-operator\" data-linktype=\"relative-path\">= Operator</a><br> <a href=\"is-operator\" data-linktype=\"relative-path\">Is Operator</a><br> <a href=\"isnot-operator\" data-linktype=\"relative-path\">IsNot Operator</a><br> <a href=\"like-operator\" data-linktype=\"relative-path\">Like Operator</a><br> <a href=\"typeof-operator\" data-linktype=\"relative-path\">TypeOf Operator</a><br> <a href=\"await-operator\" data-linktype=\"relative-path\">Await Operator</a><br> <a href=\"operators-listed-by-functionality\" data-linktype=\"relative-path\">Operators Listed by Functionality</a><br> <a href=\"../../programming-guide/language-features/operators-and-expressions/index\" data-linktype=\"relative-path\">Operators and Expressions</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"shoag\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"toc2.json\">\r\n<meta name=\"ms.suite\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"cbbdb282-f572-458e-a520-008a675f8063\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"18\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-visual-basic\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"ms.reviewer\" content=\"\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/visual-basic/language-reference/operators/operator-precedence.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/language-reference/operators/operator-precedence.md\">\r\n<meta name=\"document_id\" content=\"b831261a-bb50-6b2d-9514-504adc56d74a\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../../toc2.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"shoag","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Operator Precedence in Visual Basic | Microsoft Docs","ms.suite":"","ms.assetid":"cbbdb282-f572-458e-a520-008a675f8063","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":18,"ms.topic":"article","dev_langs":["vb"],"helpviewer_keywords":["arithmetic operators, precedence","operator precedence","logical operators, precedence","operators [Visual Basic], associativity","operators [Visual Basic], resolution","associativity of operators","operators [Visual Basic], precedence","precedence, of operators","comparison operators, precedence","math operators","order of precedence"],"ms.date":"2015-07-20","ms.technology":["devlang-visual-basic"],"ms.prod":".net","ms.reviewer":"","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/visual-basic/language-reference/operators/operator-precedence.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/language-reference/operators/operator-precedence.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/visual-basic/language-reference/operators/operator-precedence.md","document_id":"b831261a-bb50-6b2d-9514-504adc56d74a","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/visual-basic/language-reference/operators/operator-precedence","toc_asset_id":"articles/toc.json","toc_rel":"../../../toc.json","_op_ogTitle":"Operator Precedence in Visual Basic","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":636,"_op_rawTitle":"<h1 id=\"operator-precedence-in-visual-basic\" sourcefile=\"docs/visual-basic/language-reference/operators/operator-precedence.md\" sourcestartlinenumber=\"46\" sourceendlinenumber=\"46\">Operator Precedence in Visual Basic</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/visual-basic/language-reference/operators/operator-precedence","fileRelativePath":"articles/visual-basic/language-reference/operators/operator-precedence.html"},"themesRelativePathToOutputRoot":"_themes/"}