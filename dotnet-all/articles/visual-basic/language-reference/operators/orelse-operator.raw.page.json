{"content":"<div><div class=\"content\">\n<p>Performs short-circuiting inclusive logical disjunction on two expressions.  </p>\n<h2 id=\"syntax\">Syntax</h2>\n<pre class=\"loading\"><code>\nresult = expression1 OrElse expression2  \n</code></pre><h2 id=\"parts\">Parts</h2>\n<p> <code>result</code><br> Required. Any <code>Boolean</code> expression.  </p>\n<p> <code>expression1</code><br> Required. Any <code>Boolean</code> expression.  </p>\n<p> <code>expression2</code><br> Required. Any <code>Boolean</code> expression.  </p>\n<h2 id=\"remarks\">Remarks</h2>\n<p> A logical operation is said to be <em>short-circuiting</em> if the compiled code can bypass the evaluation of one expression depending on the result of another expression. If the result of the first expression evaluated determines the final result of the operation, there is no need to evaluate the second expression, because it cannot change the final result. Short-circuiting can improve performance if the bypassed expression is complex, or if it involves procedure calls.  </p>\n<p> If either or both expressions evaluate to <code>True</code>, <code>result</code> is <code>True</code>. The following table illustrates how <code>result</code> is determined.  </p>\n<table>\n<thead>\n<tr>\n<th>If <code>expression1</code> is</th>\n<th>And <code>expression2</code> is</th>\n<th>The value of <code>result</code> is</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>True</code></td>\n<td>(not evaluated)</td>\n<td><code>True</code></td>\n</tr>\n<tr>\n<td><code>False</code></td>\n<td><code>True</code></td>\n<td><code>True</code></td>\n</tr>\n<tr>\n<td><code>False</code></td>\n<td><code>False</code></td>\n<td><code>False</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"data-types\">Data Types</h2>\n<p> The <code>OrElse</code> operator is defined only for the <a href=\"../data-types/boolean-data-type\" data-linktype=\"relative-path\">Boolean Data Type</a>. Visual Basic converts each operand as necessary to <code>Boolean</code> and performs the operation entirely in <code>Boolean</code>. If you assign the result to a numeric type, Visual Basic converts it from <code>Boolean</code> to that type. This could produce unexpected behavior. For example, <code>5 OrElse 12</code> results in <code>â€“1</code> when converted to <code>Integer</code>.  </p>\n<h2 id=\"overloading\">Overloading</h2>\n<p> The <a href=\"or-operator\" data-linktype=\"relative-path\">Or Operator</a> and the <a href=\"istrue-operator\" data-linktype=\"relative-path\">IsTrue Operator</a> can be <em>overloaded</em>, which means that a class or structure can redefine their behavior when an operand has the type of that class or structure. Overloading the <code>Or</code> and <code>IsTrue</code> operators affects the behavior of the <code>OrElse</code> operator. If your code uses <code>OrElse</code> on a class or structure that overloads <code>Or</code> and <code>IsTrue</code>, be sure you understand their redefined behavior. For more information, see <a href=\"../../programming-guide/language-features/procedures/operator-procedures\" data-linktype=\"relative-path\">Operator Procedures</a>.  </p>\n<h2 id=\"example\">Example</h2>\n<p> The following example uses the <code>OrElse</code> operator to perform logical disjunction on two expressions. The result is a <code>Boolean</code> value that represents whether either of the two expressions is true. If the first expression is <code>True</code>, the second is not evaluated.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrOperators#37\">        Dim a As Integer = 10\n        Dim b As Integer = 8\n        Dim c As Integer = 6\n        Dim firstCheck, secondCheck, thirdCheck As Boolean\n        firstCheck = a &gt; b OrElse b &gt; c\n        secondCheck = b &gt; a OrElse b &gt; c\n        thirdCheck = b &gt; a OrElse c &gt; b\n</code></pre><p> The preceding example produces results of <code>True</code>, <code>True</code>, and <code>False</code> respectively. In the calculation of <code>firstCheck</code>, the second expression is not evaluated because the first is already <code>True</code>. However, the second expression is evaluated in the calculation of <code>secondCheck</code>.  </p>\n<h2 id=\"example-1\">Example</h2>\n<p> The following example shows an <code>If</code>...<code>Then</code> statement containing two procedure calls. If the first call returns <code>True</code>, the second procedure is not called. This could produce unexpected results if the second procedure performs important tasks that should always be performed when this section of the code runs.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrOperators#38\">        If testFunction(5) = True OrElse otherFunction(4) = True Then\n            &#39; If testFunction(5) is True, otherFunction(4) is not called.\n            &#39; Insert code to be executed.\n        End If\n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"logical-bitwise-operators\" data-linktype=\"relative-path\">Logical/Bitwise Operators (Visual Basic)</a><br> <a href=\"operator-precedence\" data-linktype=\"relative-path\">Operator Precedence in Visual Basic</a><br> <a href=\"operators-listed-by-functionality\" data-linktype=\"relative-path\">Operators Listed by Functionality</a><br> <a href=\"or-operator\" data-linktype=\"relative-path\">Or Operator</a><br> <a href=\"istrue-operator\" data-linktype=\"relative-path\">IsTrue Operator</a><br> <a href=\"../../programming-guide/language-features/operators-and-expressions/logical-and-bitwise-operators\" data-linktype=\"relative-path\">Logical and Bitwise Operators in Visual Basic</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"shoag\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-all/api/toc2.json\">\r\n<meta name=\"ms.suite\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"253803d8-05b0-47d7-b213-abd222847779\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"15\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-visual-basic\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"ms.reviewer\" content=\"\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/visual-basic/language-reference/operators/orelse-operator.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/language-reference/operators/orelse-operator.md\">\r\n<meta name=\"document_id\" content=\"cc6fe46c-04eb-4251-e8ae-4b22383a2b92\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../../toc2.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"shoag","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"OrElse Operator (Visual Basic) | Microsoft Docs","ms.suite":"","ms.assetid":"253803d8-05b0-47d7-b213-abd222847779","f1_keywords":["OrElse","vb.OrElse"],"translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":15,"ms.topic":"article","dev_langs":["vb"],"helpviewer_keywords":["short-circuiting","operators [Visual Basic], short-circuiting","operators [Visual Basic], disjunction","short-circuit evaluation","OrElse operator [Visual Basic]"],"ms.date":"2015-07-20","ms.technology":["devlang-visual-basic"],"ms.prod":".net","ms.reviewer":"","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/visual-basic/language-reference/operators/orelse-operator.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/language-reference/operators/orelse-operator.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/visual-basic/language-reference/operators/orelse-operator.md","document_id":"cc6fe46c-04eb-4251-e8ae-4b22383a2b92","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/visual-basic/language-reference/operators/orelse-operator","toc_asset_id":"articles/toc.json","toc_rel":"../../../toc.json","_op_ogTitle":"OrElse Operator (Visual Basic)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":515,"_op_rawTitle":"<h1 id=\"orelse-operator-visual-basic\" sourcefile=\"docs/visual-basic/language-reference/operators/orelse-operator.md\" sourcestartlinenumber=\"43\" sourceendlinenumber=\"43\">OrElse Operator (Visual Basic)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/visual-basic/language-reference/operators/orelse-operator","fileRelativePath":"articles/visual-basic/language-reference/operators/orelse-operator.html"},"themesRelativePathToOutputRoot":"_themes/"}