{"content":"<div><div class=\"content\">\n<p>When you interoperate between COM and the managed code of the .NET Framework, you may encounter one or more of the following common issues.  </p>\n<h2 id=\"a-namevbconinteroperabilitymarshalinganchor1a-interop-marshaling\"><a name=\"vbconinteroperabilitymarshalinganchor1\"></a> Interop Marshaling</h2>\n<p> At times, you may have to use data types that are not part of the .NET Framework. Interop assemblies handle most of the work for COM objects, but you may have to control the data types that are used when managed objects are exposed to COM. For example, structures in class libraries must specify the <code>BStr</code> unmanaged type on strings sent to COM objects created by Visual Basic 6.0 and earlier versions. In such cases, you can use the <a class=\"xref\" href=\"../../../../api/system.runtime.interopservices.marshalasattribute\" data-linktype=\"relative-path\">MarshalAsAttribute</a> attribute to cause managed types to be exposed as unmanaged types.  </p>\n<h2 id=\"a-namevbconinteroperabilitymarshalinganchor2a-exporting-fixed-length-strings-to-unmanaged-code\"><a name=\"vbconinteroperabilitymarshalinganchor2\"></a> Exporting Fixed-Length Strings to Unmanaged Code</h2>\n<p> In Visual Basic 6.0 and earlier versions, strings are exported to COM objects as sequences of bytes without a null termination character. For compatibility with other languages, Visual Basic 2005 includes a termination character when exporting strings. The best way to address this incompatibility is to export strings that lack the termination character as arrays of <code>Byte</code> or <code>Char</code>.  </p>\n<h2 id=\"a-namevbconinteroperabilitymarshalinganchor3a-exporting-inheritance-hierarchies\"><a name=\"vbconinteroperabilitymarshalinganchor3\"></a> Exporting Inheritance Hierarchies</h2>\n<p> Managed class hierarchies flatten out when exposed as COM objects. For example, if you define a base class with a member, and then inherit the base class in a derived class that is exposed as a COM object, clients that use the derived class in the COM object will not be able to use the inherited members. Base class members can be accessed from COM objects only as instances of a base class, and then only if the base class is also created as a COM object.  </p>\n<h2 id=\"overloaded-methods\">Overloaded Methods</h2>\n<p> Although you can create overloaded methods with Visual Basic, they are not supported by COM. When a class that contains overloaded methods is exposed as a COM object, new method names are generated for the overloaded methods.  </p>\n<p> For example, consider a class that has two overloads of the <code>Synch</code> method. When the class is exposed as a COM object, the new generated method names could be <code>Synch</code> and <code>Synch_2</code>.  </p>\n<p> The renaming can cause two problems for consumers of the COM object.  </p>\n<ol>\n<li><p>Clients might not expect the generated method names.  </p>\n</li>\n<li><p>The generated method names in the class exposed as a COM object can change when new overloads are added to the class or its base class. This can cause versioning problems.  </p>\n</li>\n</ol>\n<p> To solve both problems, give each method a unique name, instead of using overloading, when you develop objects that will be exposed as COM objects.  </p>\n<h2 id=\"a-namevbconinteroperabilitymarshalinganchor4a-use-of-com-objects-through-interop-assemblies\"><a name=\"vbconinteroperabilitymarshalinganchor4\"></a> Use of COM Objects Through Interop Assemblies</h2>\n<p> You use interop assemblies almost as if they are managed code replacements for the COM objects they represent. However, because they are wrappers and not actual COM objects, there are some differences between using interop assemblies and standard assemblies. These areas of difference include the exposure of classes, and data types for parameters and return values.  </p>\n<h2 id=\"a-namevbconinteroperabilitymarshalinganchor5a-classes-exposed-as-both-interfaces-and-classes\"><a name=\"vbconinteroperabilitymarshalinganchor5\"></a> Classes Exposed as Both Interfaces and Classes</h2>\n<p> Unlike classes in standard assemblies, COM classes are exposed in interop assemblies as both an interface and a class that represents the COM class. The interface&#39;s name is identical to that of the COM class. The name of the interop class is the same as that of the original COM class, but with the word &quot;Class&quot; appended. For example, suppose you have a project with a reference to an interop assembly for a COM object. If the COM class is named <code>MyComClass</code>, IntelliSense and the Object Browser show an interface named <code>MyComClass</code> and a class named <code>MyComClassClass</code>.  </p>\n<h2 id=\"a-namevbconinteroperabilitymarshalinganchor6a-creating-instances-of-a-net-framework-class\"><a name=\"vbconinteroperabilitymarshalinganchor6\"></a> Creating Instances of a .NET Framework Class</h2>\n<p> Generally, you create an instance of a .NET Framework class using the <code>New</code> statement with a class name. Having a COM class represented by an interop assembly is the one case in which you can use the <code>New</code> statement with an interface. Unless you are using the COM class with an <code>Inherits</code> statement, you can use the interface just as you would a class. The following code demonstrates how to create a <code>Command</code> object in a project that has a reference to the Microsoft ActiveX Data Objects 2.8 Library COM object:  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrInterop#20\">Dim cmd As New ADODB.Command\n</code></pre><p> However, if you are using the COM class as the base for a derived class, you must use the interop class that represents the COM class, as in the following code:  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrInterop#21\">Class DerivedCommand\n    Inherits ADODB.CommandClass\nEnd Class\n</code></pre><div class=\"NOTE\"><h5>Note</h5><p> Interop assemblies implicitly implement interfaces that represent COM classes. You should not try to use the <code>Implements</code> statement to implement these interfaces or an error will result.  </p>\n</div>\n<h2 id=\"a-namevbconinteroperabilitymarshalinganchor7a-data-types-for-parameters-and-return-values\"><a name=\"vbconinteroperabilitymarshalinganchor7\"></a> Data Types for Parameters and Return Values</h2>\n<p> Unlike members of standard assemblies, interop assembly members may have data types that differ from those used in the  original object declaration. Although interop assemblies implicitly convert COM types to compatible common language runtime types, you should pay attention to the data types that are used by both sides to prevent runtime errors. For example, in COM objects created in Visual Basic 6.0 and earlier versions, values of type <code>Integer</code> assume the .NET Framework equivalent type, <code>Short</code>. It is recommended that you use the Object Browser to examine the characteristics of imported members before you use them.  </p>\n<h2 id=\"a-namevbconinteroperabilitymarshalinganchor8a-module-level-com-methods\"><a name=\"vbconinteroperabilitymarshalinganchor8\"></a> Module level COM methods</h2>\n<p> Most COM objects are used by creating an instance of a COM class using the <code>New</code> keyword and then calling methods of the object. One exception to this rule involves COM objects that contain <code>AppObj</code> or <code>GlobalMultiUse</code> COM classes. Such classes resemble module level methods in Visual Basic 2005 classes. Visual Basic 6.0 and earlier versions implicitly create instances of such objects for you the first time that you call one of their methods. For example, in Visual Basic 6.0 you can add a reference to the Microsoft DAO 3.6 Object Library and call the <code>DBEngine</code> method without first creating an instance:  </p>\n<pre class=\"loading\"><code>Dim db As DAO.Database  \n&#39; Open the database.  \nSet db = DBEngine.OpenDatabase(&quot;C:\\nwind.mdb&quot;)  \n&#39; Use the database object.  \n</code></pre><p> Visual Basic 2005 requires that you always create instances of COM objects before you can use their methods. To use these methods in Visual Basic 2005, declare a variable of the desired class and use the new keyword to assign the object to the object variable. The <code>Shared</code> keyword can be used when you want to make sure that only one instance of the class is created.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrInterop#23\">&#39; Class level variable.\nShared DBEngine As New DAO.DBEngine\n\nSub DAOOpenRecordset()\n    Dim db As DAO.Database\n    Dim rst As DAO.Recordset\n    Dim fld As DAO.Field\n    &#39; Open the database.\n    db = DBEngine.OpenDatabase(&quot;C:\\nwind.mdb&quot;)\n\n    &#39; Open the Recordset.\n    rst = db.OpenRecordset(\n        &quot;SELECT * FROM Customers WHERE Region = &#39;WA&#39;&quot;,\n        DAO.RecordsetTypeEnum.dbOpenForwardOnly,\n        DAO.RecordsetOptionEnum.dbReadOnly)\n    &#39; Print the values for the fields in the debug window.\n    For Each fld In rst.Fields\n        Debug.WriteLine(fld.Value.ToString &amp; &quot;;&quot;)\n    Next\n    Debug.WriteLine(&quot;&quot;)\n    &#39; Close the Recordset.\n    rst.Close()\nEnd Sub\n</code></pre><h2 id=\"a-namevbconinteroperabilitymarshalinganchor9a-unhandled-errors-in-event-handlers\"><a name=\"vbconinteroperabilitymarshalinganchor9\"></a> Unhandled Errors in Event Handlers</h2>\n<p> One common interop problem involves errors in event handlers that handle events raised by COM objects. Such errors are ignored unless you specifically check for errors using <code>On Error</code> or <code>Try...Catch...Finally</code> statements. For example, the following example is from a Visual Basic 2005 project that has a reference to the Microsoft ActiveX Data Objects 2.8 Library COM object.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrInterop#24\">&#39; To use this example, add a reference to the \n&#39;     Microsoft ActiveX Data Objects 2.8 Library  \n&#39; from the COM tab of the project references page.\nDim WithEvents cn As New ADODB.Connection\nSub ADODBConnect()\n    cn.ConnectionString =\n    &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp;\n    &quot;Data Source=C:\\NWIND.MDB&quot;\n    cn.Open()\n    MsgBox(cn.ConnectionString)\nEnd Sub\n\nPrivate Sub Form1_Load(ByVal sender As System.Object,\n    ByVal e As System.EventArgs) Handles MyBase.Load\n\n    ADODBConnect()\nEnd Sub\n\nPrivate Sub cn_ConnectComplete(\n    ByVal pError As ADODB.Error,\n    ByRef adStatus As ADODB.EventStatusEnum,\n    ByVal pConnection As ADODB.Connection) Handles cn.ConnectComplete\n\n    &#39;  This is the event handler for the cn_ConnectComplete event raised \n    &#39;  by the ADODB.Connection object when a database is opened.\n    Dim x As Integer = 6\n    Dim y As Integer = 0\n    Try\n        x = CInt(x / y) &#39; Attempt to divide by zero.\n        &#39; This procedure would fail silently without exception handling.\n    Catch ex As Exception\n        MsgBox(&quot;There was an error: &quot; &amp; ex.Message)\n    End Try\nEnd Sub\n</code></pre><p> This example raises an error as expected. However, if you try the same example without the <code>Try...Catch...Finally</code> block, the error is ignored as if you used the <code>OnError Resume Next</code> statement. Without error handling, the division by zero silently fails. Because such errors never raise unhandled exception errors, it is important that you use some form of exception handling in event handlers that handle events from COM objects.  </p>\n<h3 id=\"understanding-com-interop-errors\">Understanding COM interop errors</h3>\n<p> Without error handling, interop calls often generate errors that provide little information. Whenever possible, use structured error handling to provide more information about problems when they occur. This can be especially helpful when you debug applications. For example:  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrInterop#25\">Try\n    &#39; Place call to COM object here.\nCatch ex As Exception\n    &#39; Display information about the failed call.\nEnd Try\n</code></pre><p> You can find information such as the error description, HRESULT, and the source of COM errors by examining the contents of the exception object.  </p>\n<h2 id=\"a-namevbconinteroperabilitymarshalinganchor10a-activex-control-issues\"><a name=\"vbconinteroperabilitymarshalinganchor10\"></a> ActiveX Control Issues</h2>\n<p> Most ActiveX controls that work with Visual Basic 6.0 work with Visual Basic 2005 without trouble. The main exceptions are container controls, or controls that visually contain other controls. Some examples of older controls that do not work correctly with Visual Studio are as follows:  </p>\n<ul>\n<li><p>Microsoft Forms 2.0 Frame control  </p>\n</li>\n<li><p>Up-Down control, also known as the spin control  </p>\n</li>\n<li><p>Sheridan Tab Control  </p>\n</li>\n</ul>\n<p> There are only a few workarounds for unsupported ActiveX control problems. You can migrate existing controls to Visual Studio if you own the original source code. Otherwise, you can check with software vendors for updated .NET-compatible versions of controls to replace unsupported ActiveX controls.  </p>\n<h2 id=\"a-namevbconinteroperabilitymarshalinganchor11a-passing-readonly-properties-of-controls-byref\"><a name=\"vbconinteroperabilitymarshalinganchor11\"></a> Passing ReadOnly Properties of Controls ByRef</h2>\n<p> Visual Basic 2005 sometimes raises COM errors such as &quot;Error 0x800A017F CTL_E_SETNOTSUPPORTED&quot; when you pass <code>ReadOnly</code> properties of some older ActiveX controls as <code>ByRef</code> parameters to other procedures. Similar procedure calls from Visual Basic 6.0 do not raise an error, and the parameters are treated as if you passed them by value. The error message you see in Visual Basic 2005 is the COM object reporting that you are trying to change a property that does not have a property <code>Set</code> procedure.  </p>\n<p> If you have access to the procedure being called, you can prevent this error by using the <code>ByVal</code> keyword to declare parameters that accept <code>ReadOnly</code> properties. For example:  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrInterop#26\">Sub ProcessParams(ByVal c As Object)\n    &#39;Use the arguments here.\nEnd Sub\n</code></pre><p> If you do not have access to the source code for the procedure being called, you can force the property to be passed by value by adding an extra set of brackets around the calling procedure. For example, in a project that has a reference to the Microsoft ActiveX Data Objects 2.8 Library COM object, you can use:  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrInterop#27\">Sub PassByVal(ByVal pError As ADODB.Error)\n    &#39; The extra set of parentheses around the arguments\n    &#39; forces them to be passed by value.\n    ProcessParams((pError.Description))\nEnd Sub\n</code></pre><h2 id=\"a-namevbconinteroperabilitymarshalinganchor12a-deploying-assemblies-that-expose-interop\"><a name=\"vbconinteroperabilitymarshalinganchor12\"></a> Deploying Assemblies That Expose Interop</h2>\n<p> Deploying assemblies that expose COM interfaces presents some unique challenges. For example, a potential problem occurs when separate applications reference the same COM assembly. This situation is common when a new version of an assembly is installed and another application is still using the old version of the assembly. If you uninstall an assembly that shares a DLL, you can unintentionally make it unavailable to the other assemblies.  </p>\n<p> To avoid this problem, you should install shared assemblies to the Global Assembly Cache (GAC) and use a MergeModule for the component. If you cannot install the application in the GAC, it should be installed to CommonFilesFolder in a version-specific subdirectory.  </p>\n<p> Assemblies that are not shared should be located side by side in the directory with the calling application.  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a class=\"xref\" href=\"../../../../api/system.runtime.interopservices.marshalasattribute\" data-linktype=\"relative-path\">MarshalAsAttribute</a><br> <a href=\"index\" data-linktype=\"relative-path\">COM Interop</a><br> <a href=\"http://msdn.microsoft.com/library/ec0a8d63-11b3-4acd-b398-da1e37e97382\" data-linktype=\"external\">Tlbimp.exe (Type Library Importer)</a><br> <a href=\"http://msdn.microsoft.com/library/a487d61b-d166-467b-a7ca-d8b52fbff42d\" data-linktype=\"external\">Tlbexp.exe (Type Library Exporter)</a><br> <a href=\"walkthrough-implementing-inheritance-with-com-objects\" data-linktype=\"relative-path\">Walkthrough: Implementing Inheritance with COM Objects</a><br> <a href=\"../../language-reference/statements/inherits-statement\" data-linktype=\"relative-path\">Inherits Statement</a><br> <a href=\"http://msdn.microsoft.com/library/cf5eacd0-d3ec-4879-b6da-5fd5e4372202\" data-linktype=\"external\">Global Assembly Cache</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"shoag\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"ms.suite\" content=\"\">\r\n<meta name=\"ms.custom\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"b324cc1e-b03c-4f39-aea6-6a6d5bfd0e37\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"21\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-visual-basic\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"ms.reviewer\" content=\"\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/visual-basic/programming-guide/com-interop/troubleshooting-interoperability.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/programming-guide/com-interop/troubleshooting-interoperability.md\">\r\n<meta name=\"document_id\" content=\"f20206f4-69d7-ba40-3e36-b292240c262d\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../../toc2.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"shoag","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Troubleshooting Interoperability (Visual Basic) | Microsoft Docs","ms.suite":"","ms.custom":"","ms.assetid":"b324cc1e-b03c-4f39-aea6-6a6d5bfd0e37","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":21,"ms.topic":"article","dev_langs":["vb"],"helpviewer_keywords":["interop, deploying assemblies","assemblies [Visual Basic]","interop, installing assemblies that share components","COM objects, troubleshooting","interop, sharing components","troubleshooting interoperability","interoperability, troubleshooting","COM interop, troubleshooting","assemblies [Visual Basic], deploying","troubleshooting Visual Basic, interoperability","interop assemblies","interoperability, sharing components","shared components, using with assemblies"],"ms.date":"2015-07-20","ms.technology":["devlang-visual-basic"],"ms.prod":".net","ms.reviewer":"","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/visual-basic/programming-guide/com-interop/troubleshooting-interoperability.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/programming-guide/com-interop/troubleshooting-interoperability.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/visual-basic/programming-guide/com-interop/troubleshooting-interoperability.md","document_id":"f20206f4-69d7-ba40-3e36-b292240c262d","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/visual-basic/programming-guide/com-interop/troubleshooting-interoperability","toc_asset_id":"articles/toc.json","toc_rel":"../../../toc.json","_op_ogTitle":"Troubleshooting Interoperability (Visual Basic)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":1959,"_op_rawTitle":"<h1 id=\"troubleshooting-interoperability-visual-basic\" sourcefile=\"docs/visual-basic/programming-guide/com-interop/troubleshooting-interoperability.md\" sourcestartlinenumber=\"48\" sourceendlinenumber=\"48\">Troubleshooting Interoperability (Visual Basic)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/visual-basic/programming-guide/com-interop/troubleshooting-interoperability","fileRelativePath":"articles/visual-basic/programming-guide/com-interop/troubleshooting-interoperability.html"},"themesRelativePathToOutputRoot":"_themes/"}