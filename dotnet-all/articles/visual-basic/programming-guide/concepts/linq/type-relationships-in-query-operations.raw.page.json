{"content":"<div><div class=\"content\">\n<p>Variables used in Language-Integrated Query (LINQ) query operations are strongly typed and must be compatible with each other. Strong typing is used in the data source, in the query itself, and in the query execution. The following illustration identifies terms used to describe a LINQ query. For more information about the parts of a query, see <a href=\"basic-query-operations\" data-linktype=\"relative-path\">Basic Query Operations (Visual Basic)</a>.  </p>\n<p> <img src=\"media/sjltyperels.png\" alt=\"Pseudocode query with elements highlighted.\" title=\"SJLtypeRels\" data-linktype=\"relative-path\"><br>Parts of a LINQ query  </p>\n<p> The type of the range variable in the query must be compatible with the type of the elements in the data source. The type of the query variable must be compatible with the sequence element defined in the <code>Select</code> clause. Finally, the type of the sequence elements also must be compatible with the type of the loop control variable that is used in the <code>For Each</code> statement that executes the query. This strong typing facilitates identification of type errors at compile time.  </p>\n<p> Visual Basic makes strong typing convenient by implementing local type inference, also known as <em>implicit typing</em>. That feature is used in the previous example, and you will see it used throughout the LINQ samples and documentation. In Visual Basic, local type inference is accomplished simply by using a <code>Dim</code> statement without an <code>As</code> clause. In the following example, <code>city</code> is strongly typed as a string.  </p>\n<pre><code class=\"lang-vb\" name=\"VbLINQTypeRels#1\">Dim city = &quot;Seattle&quot;\n</code></pre><div class=\"NOTE\"><h5>Note</h5><p> Local type inference works only when <code>Option Infer</code> is set to <code>On</code>. For more information, see <a href=\"../../../language-reference/statements/option-infer-statement\" data-linktype=\"relative-path\">Option Infer Statement</a>.  </p>\n</div>\n<p> However, even if you use local type inference in a query, the same type relationships are present among the variables in the data source, the query variable, and the query execution loop. It is useful to have a basic understanding of these type relationships when you are writing LINQ queries, or working with the samples and code examples in the documentation.  </p>\n<p> You may need to specify an explicit type for a range variable that does not match the type returned from the data source. You can specify the type of the range variable by using an <code>As</code> clause. However, this results in an error if the conversion is a <a href=\"../../language-features/data-types/widening-and-narrowing-conversions\" data-linktype=\"relative-path\">narrowing conversion</a> and <code>Option Strict</code> is set to <code>On</code>. Therefore, we recommend that you perform the conversion on the values retrieved from the data source. You can convert the values from the data source to the explicit range variable type by using the <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/bb341406(v=vs.110).aspx\" data-linktype=\"external\">Cast</a> method. You can also cast the values selected in the <code>Select</code> clause to an explicit type that is different from the type of the range variable. These points are illustrated in the following code.  </p>\n<pre><code class=\"lang-vb\" name=\"VbLINQTypeRels#4\">Dim numbers1() As Integer = {1, 2, 4, 16, 32, 64}\nDim numbers2() As Double = {5.0#, 10.0#, 15.0#}\n\n&#39; This code does not result in an error.\nDim numberQuery1 = From n As Integer In numbers1 Where n &gt; 5\n\n&#39; This code results in an error with Option Strict set to On. The type Double\n&#39; cannot be implicitly cast as type Integer.\nDim numberQuery2 = From n As Integer In numbers2 Where n &gt; 5\n\n&#39; This code casts the values in the data source to type Integer. The type of\n&#39; the range variable is Integer.\nDim numberQuery3 = From n In numbers2.Cast(Of Integer)() Where n &gt; 5\n\n&#39; This code returns the value of the range variable converted to Integer. The type of\n&#39; the range variable is Double.\nDim numberQuery4 = From n In numbers2 Where n &gt; 5 Select CInt(n)\n</code></pre><h2 id=\"queries-that-return-entire-elements-of-the-source-data\">Queries That Return Entire Elements of the Source Data</h2>\n<p> The following example shows a LINQ query operation that returns a sequence of elements selected from the source data. The source, <code>names</code>, contains an array of strings, and the query output is a sequence containing strings that start with the letter M.  </p>\n<pre><code class=\"lang-vb\" name=\"VbLINQTypeRels#2\">Dim names = {&quot;John&quot;, &quot;Rick&quot;, &quot;Maggie&quot;, &quot;Mary&quot;}\nDim mNames = From name In names\n             Where name.IndexOf(&quot;M&quot;) = 0\n             Select name\n\nFor Each nm In mNames\n    Console.WriteLine(nm)\nNext\n</code></pre><p> This is equivalent to the following code, but is much shorter and easier to write. Reliance on local type inference in queries is the preferred style in Visual Basic.  </p>\n<pre><code class=\"lang-vb\" name=\"VbLINQTypeRels#3\">Dim names2 = {&quot;John&quot;, &quot;Rick&quot;, &quot;Maggie&quot;, &quot;Mary&quot;}\nDim mNames2 As IEnumerable(Of String) =\n    From name As String In names\n    Where name.IndexOf(&quot;M&quot;) = 0\n    Select name\n\nFor Each nm As String In mNames\n    Console.WriteLine(nm)\nNext\n</code></pre><p> The following relationships exist in both of the previous code examples, whether the types are determined implicitly or explicitly.  </p>\n<ol>\n<li><p>The type of the elements in the data source, <code>names</code>, is the type of the range variable, <code>name</code>, in the query.  </p>\n</li>\n<li><p>The type of the object that is selected, <code>name</code>, determines the type of the query variable, <code>mNames</code>. Here <code>name</code> is a string, so the query variable is IEnumerable(Of String) in Visual Basic.  </p>\n</li>\n<li><p>The query defined in <code>mNames</code> is executed in the <code>For Each</code> loop. The loop iterates over the result of executing the query. Because <code>mNames</code>, when it is executed, will return a sequence of strings, the loop iteration variable, <code>nm</code>, also is a string.  </p>\n</li>\n</ol>\n<h2 id=\"queries-that-return-one-field-from-selected-elements\">Queries That Return One Field from Selected Elements</h2>\n<p> The following example shows a LINQ to SQL query operation that returns a sequence containing only one part of each element selected from the data source. The query takes a collection of <code>Customer</code> objects as its data source and projects only the <code>Name</code> property in the result. Because the customer name is a string, the query produces a sequence of strings as output.  </p>\n<p><codecontentplaceholder>0</codecontentplaceholder><br> The relationships between variables are like those in the simpler example.  </p>\n<ol>\n<li><p>The type of the elements in the data source, <code>customers</code>, is the type of the range variable, <code>cust</code>, in the query. In this example, that type is <code>Customer</code>.  </p>\n</li>\n<li><p>The <code>Select</code> statement returns the <code>Name</code> property of each <code>Customer</code> object instead of the whole object. Because <code>Name</code> is a string, the query variable, <code>custNames</code>, will again be IEnumerable(Of String), not of <code>Customer</code>.  </p>\n</li>\n<li><p>Because <code>custNames</code> represents a sequence of strings, the <code>For Each</code> loop&#39;s iteration variable, <code>custName</code>, must be a string.  </p>\n</li>\n</ol>\n<p> Without local type inference, the previous example would be more cumbersome to write and to understand, as the following example shows.  </p>\n<p><codecontentplaceholder>1</codecontentplaceholder>  </p>\n<h2 id=\"queries-that-require-anonymous-types\">Queries That Require Anonymous Types</h2>\n<p> The following example shows a more complex situation. In the previous example, it was inconvenient to specify types for all the variables explicitly. In this example, it is impossible. Instead of selecting entire <code>Customer</code> elements from the data source, or a single field from each element, the <code>Select</code> clause in this query returns two properties of the original <code>Customer</code> object: <code>Name</code> and <code>City</code>. In response to the <code>Select</code> clause, the compiler defines an anonymous type that contains those two properties. The result of executing <code>nameCityQuery</code> in the <code>For Each</code> loop is a collection of instances of the new anonymous type. Because the anonymous type has no usable name, you cannot specify the type of <code>nameCityQuery</code> or <code>custInfo</code> explicitly. That is, with an anonymous type, you have no type name to use in place of <code>String</code> in <code>IEnumerable(Of String)</code>. For more information, see <a href=\"../../language-features/objects-and-classes/anonymous-types\" data-linktype=\"relative-path\">Anonymous Types</a>.  </p>\n<p><codecontentplaceholder>2</codecontentplaceholder><br> Although it is not possible to specify types for all the variables in the previous example, the relationships remain the same.  </p>\n<ol>\n<li><p>The type of the elements in the data source is again the type of the range variable in the query. In this example, <code>cust</code> is an instance of <code>Customer</code>.  </p>\n</li>\n<li><p>Because the <code>Select</code> statement produces an anonymous type, the query variable, <code>nameCityQuery</code>, must be implicitly typed as an anonymous type. An anonymous type has no usable name, and therefore cannot be specified explicitly.  </p>\n</li>\n<li><p>The type of the iteration variable in the <code>For Each</code> loop is the anonymous type created in step 2. Because the type has no usable name, the type of the loop iteration variable must be determined implicitly.  </p>\n</li>\n</ol>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"getting-started-with-linq\" data-linktype=\"relative-path\">Getting Started with LINQ in Visual Basic</a><br> <a href=\"../../language-features/objects-and-classes/anonymous-types\" data-linktype=\"relative-path\">Anonymous Types</a><br> <a href=\"../../language-features/variables/local-type-inference\" data-linktype=\"relative-path\">Local Type Inference</a><br> <a href=\"../../language-features/linq/introduction-to-linq\" data-linktype=\"relative-path\">Introduction to LINQ in Visual Basic</a><br> <a href=\"../../language-features/linq/index\" data-linktype=\"relative-path\">LINQ</a><br> <a href=\"../../../language-reference/queries/queries\" data-linktype=\"relative-path\">Queries</a></p>\n</div></div>","outputRootRelativePath":"../../../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"shoag\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.suite\" content=\"\">\r\n<meta name=\"ms.custom\" content=\"\">\r\n<meta name=\"ms.tgt_pltfrm\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"b5ff4da5-f3fd-4a8e-aaac-1cbf52fa16f6\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"34\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"translation.priority.mt\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.mt\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.mt\" content=\"pt-br\">\r\n<meta name=\"translation.priority.mt\" content=\"tr-tr\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-visual-basic\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"ms.reviewer\" content=\"\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/visual-basic/programming-guide/concepts/linq/type-relationships-in-query-operations.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/programming-guide/concepts/linq/type-relationships-in-query-operations.md\">\r\n<meta name=\"document_id\" content=\"218e49c3-e26c-6723-c0b4-23d8ce3ee8b5\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"shoag","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","title":"Type Relationships in Query Operations (Visual Basic) | Microsoft Docs","ms.suite":"","ms.custom":"","ms.tgt_pltfrm":"","ms.assetid":"b5ff4da5-f3fd-4a8e-aaac-1cbf52fa16f6","translation.priority.ht":["de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","ru-ru","zh-cn","zh-tw"],"caps.latest.revision":34,"ms.topic":"article","dev_langs":["vb"],"helpviewer_keywords":["variable relationships [LINQ in Visual Basic]","type information inferred [LINQ in Visual Basic]","type relationships [LINQ in Visual Basic]","queries [LINQ in Visual Basic], type relationships","data sources [LINQ in Visual Basic], type relationships","LINQ [Visual Basic], type relationships","inferring type information [LINQ in Visual Basic]","relationships [LINQ in Visual Basic]"],"translation.priority.mt":["cs-cz","pl-pl","pt-br","tr-tr"],"ms.date":"2015-07-20","ms.technology":["devlang-visual-basic"],"ms.prod":".net","ms.reviewer":"","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/visual-basic/programming-guide/concepts/linq/type-relationships-in-query-operations.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/programming-guide/concepts/linq/type-relationships-in-query-operations.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/visual-basic/programming-guide/concepts/linq/type-relationships-in-query-operations.md","document_id":"218e49c3-e26c-6723-c0b4-23d8ce3ee8b5","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/visual-basic/programming-guide/concepts/linq/type-relationships-in-query-operations","toc_asset_id":"articles/visual-basic/programming-guide/concepts/linq/toc.json","toc_rel":"toc.json","_op_ogTitle":"Type Relationships in Query Operations (Visual Basic)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":1302,"_op_rawTitle":"<h1 id=\"type-relationships-in-query-operations-visual-basic\" sourcefile=\"docs/visual-basic/programming-guide/concepts/linq/type-relationships-in-query-operations.md\" sourcestartlinenumber=\"44\" sourceendlinenumber=\"44\">Type Relationships in Query Operations (Visual Basic)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/visual-basic/programming-guide/concepts/linq/type-relationships-in-query-operations","fileRelativePath":"articles/visual-basic/programming-guide/concepts/linq/type-relationships-in-query-operations.html"},"themesRelativePathToOutputRoot":"_themes/"}