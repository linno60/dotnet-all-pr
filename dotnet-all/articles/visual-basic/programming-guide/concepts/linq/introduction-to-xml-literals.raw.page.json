{"content":"<div><div class=\"content\">\n<p>This section provides information about creating XML trees in Visual Basic.  </p>\n<p> For information about using the results of LINQ queries as the content for an XML tree, see <a href=\"functional-construction-linq-to-xml\" data-linktype=\"relative-path\">Functional Construction (LINQ to XML) (Visual Basic)</a>.  </p>\n<p> For more information on XML literals in Visual Basic, see <a href=\"../../language-features/xml/overview-of-linq-to-xml\" data-linktype=\"relative-path\">Overview of LINQ to XML in Visual Basic</a>.  </p>\n<h2 id=\"creating-xml-trees\">Creating XML Trees</h2>\n<p> The following example shows how to create an <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>, in this case <code>contacts</code>:  </p>\n<pre class=\"loading\"><code class=\"lang-vb\">Dim contacts As XElement = _  \n    &lt;Contacts&gt;  \n        &lt;Contact&gt;  \n            &lt;Name&gt;Patrick Hines&lt;/Name&gt;  \n            &lt;Phone&gt;206-555-0144&lt;/Phone&gt;  \n            &lt;Address&gt;  \n                &lt;Street1&gt;123 Main St&lt;/Street1&gt;  \n                &lt;City&gt;Mercer Island&lt;/City&gt;  \n                &lt;State&gt;WA&lt;/State&gt;  \n                &lt;Postal&gt;68042&lt;/Postal&gt;  \n            &lt;/Address&gt;  \n        &lt;/Contact&gt;  \n    &lt;/Contacts&gt;  \n</code></pre><h3 id=\"creating-an-xelement-with-simple-content\">Creating an XElement with Simple Content</h3>\n<p> You can create an <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a> that contains simple content, as follows:  </p>\n<pre class=\"loading\"><code class=\"lang-vb\">Dim n as XElement = &lt;Customer&gt;Adventure Works&lt;/Customer&gt;  \nConsole.WriteLine(n)   \n</code></pre><p> This example produces the following output:  </p>\n<pre class=\"loading\"><code class=\"lang-xml\">&lt;Customer&gt;Adventure Works&lt;/Customer&gt;  \n</code></pre><h3 id=\"creating-an-empty-element\">Creating an Empty Element</h3>\n<p> You can create an empty <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>, as follows:  </p>\n<pre class=\"loading\"><code class=\"lang-vb\">Dim n As XElement = &lt;Customer/&gt;  \nConsole.WriteLine(n)  \n</code></pre><p> This example produces the following output:  </p>\n<pre class=\"loading\"><code class=\"lang-xml\">&lt;Customer /&gt;  \n</code></pre><h3 id=\"using-embedded-expressions\">Using Embedded Expressions</h3>\n<p> An important feature of XML literals is that they allow embedded expressions. Embedded expressions enable you to evaluate an expression and insert the results of the expression into the XML tree. If the expression evaluates to a type of <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>, an element is inserted into the tree. If the expression evaluates to a type of <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xattribute\" data-linktype=\"relative-path\">XAttribute</a>, an attribute is inserted into the tree. You can insert elements and attributes into the tree only where they are valid.  </p>\n<p> It is important to note that only a single expression can go into an embedded expression. You cannot embed multiple statements. If an expression extends beyond a single line, you must use the line continuation character.  </p>\n<p> If you use an embedded expression to add existing nodes (including elements) and attributes to a new XML tree and if the existing nodes are already parented, the nodes are cloned. The newly cloned nodes are attached to the new XML tree. If the existing nodes are not parented, the nodes are simply attached to the new XML tree. The last example in this topic demonstrates this.  </p>\n<p> The following example uses an embedded expression to insert an element into the tree:  </p>\n<pre class=\"loading\"><code class=\"lang-vb\">xmlTree1 As XElement = _  \n    &lt;Root&gt;  \n        &lt;Child&gt;Contents&lt;/Child&gt;  \n    &lt;/Root&gt;  \nDim xmlTree2 As XElement = _  \n    &lt;Root&gt;  \n        &lt;%= xmlTree1.&lt;Child&gt; %&gt;  \n    &lt;/Root&gt;  \nConsole.WriteLine(xmlTree2)  \n</code></pre><p> This example produces the following output:  </p>\n<pre class=\"loading\"><code class=\"lang-xml\">&lt;Root&gt;  \n  &lt;Child&gt;Contents&lt;/Child&gt;  \n&lt;/Root&gt;  \n</code></pre><h3 id=\"using-embedded-expressions-for-content\">Using Embedded Expressions for Content</h3>\n<p> You can use an embedded expression to supply the content of an element:  </p>\n<pre class=\"loading\"><code class=\"lang-vb\">Dim str As String  \nstr = &quot;Some content&quot;  \nDim root As XElement = &lt;Root&gt;&lt;%= str %&gt;&lt;/Root&gt;  \nConsole.WriteLine(root)  \n</code></pre><p> This example produces the following output:  </p>\n<pre class=\"loading\"><code class=\"lang-xml\">&lt;Root&gt;Some content&lt;/Root&gt;  \n</code></pre><h3 id=\"using-a-linq-query-in-an-embedded-expression\">Using a LINQ Query in an Embedded Expression</h3>\n<p> You can use the results of a LINQ query for the content of an element:  </p>\n<pre class=\"loading\"><code class=\"lang-vb\">Dim arr As Integer() = {1, 2, 3}  \n\nDim n As XElement = _  \n    &lt;Root&gt;  \n        &lt;%= From i In arr Select &lt;Child&gt;&lt;%= i %&gt;&lt;/Child&gt; %&gt;  \n    &lt;/Root&gt;  \n\nConsole.WriteLine(n)  \n</code></pre><p> This example produces the following output:  </p>\n<pre class=\"loading\"><code class=\"lang-xml\">&lt;Root&gt;  \n  &lt;Child&gt;1&lt;/Child&gt;  \n  &lt;Child&gt;2&lt;/Child&gt;  \n  &lt;Child&gt;3&lt;/Child&gt;  \n&lt;/Root&gt;  \n</code></pre><h3 id=\"using-embedded-expressions-for-node-names\">Using Embedded Expressions for Node Names</h3>\n<p> You can also use embedded expressions to calculate attribute names, attribute values, element names, and element values:  </p>\n<pre class=\"loading\"><code class=\"lang-vb\">Dim eleName As String = &quot;ele&quot;  \nDim attName As String = &quot;att&quot;  \nDim attValue As String = &quot;aValue&quot;  \nDim eleValue As String = &quot;eValue&quot;  \nDim n As XElement = _  \n    &lt;Root &lt;%= attName %&gt;=&lt;%= attValue %&gt;&gt;  \n        &lt;&lt;%= eleName %&gt;&gt;  \n            &lt;%= eleValue %&gt;  \n        &lt;/&gt;  \n    &lt;/Root&gt;  \nConsole.WriteLine(n)  \n</code></pre><p> This example produces the following output:  </p>\n<pre class=\"loading\"><code class=\"lang-xml\">&lt;Root att=&quot;aValue&quot;&gt;  \n  &lt;ele&gt;eValue&lt;/ele&gt;  \n&lt;/Root&gt;  \n</code></pre><h3 id=\"cloning-vs-attaching\">Cloning vs. Attaching</h3>\n<p> As mentioned earlier, if you use an embedded expression to add existing nodes (including elements) and attributes to a new XML tree, if the existing nodes are already parented, the nodes are cloned and the newly cloned nodes are attached to the new XML tree. If the existing nodes are not parented, they are simply attached to the new XML tree.  </p>\n<pre class=\"loading\"><code class=\"lang-vb\">&#39; Create a tree with a child element.  \nDim xmlTree1 As XElement = _  \n    &lt;Root&gt;  \n        &lt;Child1&gt;1&lt;/Child1&gt;  \n    &lt;/Root&gt;  \n\n&#39; Create an element that is not parented.  \nDim child2 As XElement = &lt;Child2&gt;2&lt;/Child2&gt;  \n\n&#39; Create a tree and add Child1 and Child2 to it.  \nDim xmlTree2 As XElement = _  \n    &lt;Root&gt;  \n        &lt;%= xmlTree1.&lt;Child1&gt;(0) %&gt;  \n        &lt;%= child2 %&gt;  \n    &lt;/Root&gt;  \n\n&#39; Compare Child1 identity.  \nConsole.WriteLine(&quot;Child1 was {0}&quot;, _  \n    IIf(xmlTree1.Element(&quot;Child1&quot;) Is xmlTree2.Element(&quot;Child1&quot;), _  \n    &quot;attached&quot;, &quot;cloned&quot;))  \n\n&#39; Compare Child2 identity.  \nConsole.WriteLine(&quot;Child2 was {0}&quot;, _  \n    IIf(child2 Is xmlTree2.Element(&quot;Child2&quot;), _  \n    &quot;attached&quot;, &quot;cloned&quot;))  \n</code></pre><p> This example produces the following output:  </p>\n<pre class=\"loading\"><code>Child1 was cloned  \nChild2 was attached  \n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"creating-xml-trees\" data-linktype=\"relative-path\">Creating XML Trees (Visual Basic)</a></p>\n</div></div>","outputRootRelativePath":"../../../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"shoag\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet/toc2.json\">\r\n<meta name=\"ms.suite\" content=\"\">\r\n<meta name=\"ms.custom\" content=\"\">\r\n<meta name=\"ms.tgt_pltfrm\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"94fc0e03-978e-4c08-ab6c-0dc3c1e64f10\">\r\n<meta name=\"caps.latest.revision\" content=\"3\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"translation.priority.mt\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.mt\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.mt\" content=\"pt-br\">\r\n<meta name=\"translation.priority.mt\" content=\"tr-tr\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-visual-basic\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"ms.reviewer\" content=\"\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/visual-basic/programming-guide/concepts/linq/introduction-to-xml-literals.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/programming-guide/concepts/linq/introduction-to-xml-literals.md\">\r\n<meta name=\"document_id\" content=\"cd3cffa1-b8e9-cc16-f684-3f83473316d3\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"shoag","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Introduction to XML Literals in Visual Basic2 | Microsoft Docs","ms.suite":"","ms.custom":"","ms.tgt_pltfrm":"","ms.assetid":"94fc0e03-978e-4c08-ab6c-0dc3c1e64f10","caps.latest.revision":3,"ms.topic":"article","dev_langs":["vb"],"translation.priority.mt":["cs-cz","pl-pl","pt-br","tr-tr"],"ms.date":"2015-07-20","ms.technology":["devlang-visual-basic"],"ms.prod":".net","ms.reviewer":"","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/visual-basic/programming-guide/concepts/linq/introduction-to-xml-literals.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/programming-guide/concepts/linq/introduction-to-xml-literals.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/visual-basic/programming-guide/concepts/linq/introduction-to-xml-literals.md","document_id":"cd3cffa1-b8e9-cc16-f684-3f83473316d3","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/visual-basic/programming-guide/concepts/linq/introduction-to-xml-literals","toc_asset_id":"articles/visual-basic/programming-guide/concepts/linq/toc.json","toc_rel":"toc.json","_op_ogTitle":"Introduction to XML Literals in Visual Basic2","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":721,"_op_rawTitle":"<h1 id=\"introduction-to-xml-literals-in-visual-basic\" sourcefile=\"docs/visual-basic/programming-guide/concepts/linq/introduction-to-xml-literals.md\" sourcestartlinenumber=\"25\" sourceendlinenumber=\"25\">Introduction to XML Literals in Visual Basic</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/visual-basic/programming-guide/concepts/linq/introduction-to-xml-literals","fileRelativePath":"articles/visual-basic/programming-guide/concepts/linq/introduction-to-xml-literals.html"},"themesRelativePathToOutputRoot":"_themes/"}