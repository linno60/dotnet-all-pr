{"content":"<div><div class=\"content\">\n<p>When you have to process large XML files, it might not be feasible to load the whole XML tree into memory. This topic shows how to stream fragments using an <a class=\"xref\" href=\"../../../../../api/system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a>.  </p>\n<p> One of the most effective ways to use an <a class=\"xref\" href=\"../../../../../api/system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a> to read <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a> objects is to write your own custom axis method. An axis method typically returns a collection such as <a class=\"xref\" href=\"../../../../../api/system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable&lt;T&gt;</a> of <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>, as shown in the example in this topic. In the custom axis method, after you create the XML fragment by calling the <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xnode#System_Xml_Linq_XNode_ReadFrom_\" data-linktype=\"relative-path\">ReadFrom</a> method, return the collection using <code>yield return</code>. This provides deferred execution semantics to your custom axis method.  </p>\n<p> When you create an XML tree from an <a class=\"xref\" href=\"../../../../../api/system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a> object, the <a class=\"xref\" href=\"../../../../../api/system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a> must be positioned on an element. The <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xnode#System_Xml_Linq_XNode_ReadFrom_\" data-linktype=\"relative-path\">ReadFrom</a> method does not return until it has read the close tag of the element.  </p>\n<p> If you want to create a partial tree, you can instantiate an <a class=\"xref\" href=\"../../../../../api/system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a>, position the reader on the node that you want to convert to an <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a> tree, and then create the <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a> object.  </p>\n<p> The topic <a href=\"how-to-stream-xml-fragments-with-access-to-header-information\" data-linktype=\"relative-path\">How to: Stream XML Fragments with Access to Header Information (Visual Basic)</a> contains information and an example on how to stream a more complex document.  </p>\n<p> The topic <a href=\"how-to-perform-streaming-transform-of-large-xml-documents\" data-linktype=\"relative-path\">How to: Perform Streaming Transform of Large XML Documents (Visual Basic)</a> contains an example of using LINQ to XML to transform extremely large XML documents while maintaining a small memory footprint.  </p>\n<h2 id=\"example\">Example</h2>\n<p> This example creates a custom axis method. You can query it by using a LINQ query. The custom axis method, <code>StreamRootChildDoc</code>, is a method that is designed specifically to read a document that has a repeating <code>Child</code> element.  </p>\n<pre class=\"loading\"><code class=\"lang-vb\">Module Module1  \n    Sub Main()  \n        Dim markup = &quot;&lt;Root&gt;&quot; &amp;  \n                     &quot;  &lt;Child Key=&quot;&quot;01&quot;&quot;&gt;&quot; &amp;  \n                     &quot;    &lt;GrandChild&gt;aaa&lt;/GrandChild&gt;&quot; &amp;  \n                     &quot;  &lt;/Child&gt;&quot; &amp;  \n                     &quot;  &lt;Child Key=&quot;&quot;02&quot;&quot;&gt;&quot; &amp;  \n                     &quot;    &lt;GrandChild&gt;bbb&lt;/GrandChild&gt;&quot; &amp;  \n                     &quot;  &lt;/Child&gt;&quot; &amp;  \n                     &quot;  &lt;Child Key=&quot;&quot;03&quot;&quot;&gt;&quot; &amp;  \n                     &quot;    &lt;GrandChild&gt;ccc&lt;/GrandChild&gt;&quot; &amp;  \n                     &quot;  &lt;/Child&gt;&quot; &amp;  \n                     &quot;&lt;/Root&gt;&quot;  \n\n        Dim grandChildData =  \n             From el In New StreamRootChildDoc(New IO.StringReader(markup))  \n             Where CInt(el.@Key) &gt; 1  \n             Select el.&lt;GrandChild&gt;.Value  \n\n        For Each s In grandChildData  \n            Console.WriteLine(s)  \n        Next  \n    End Sub  \nEnd Module  \n\nPublic Class StreamRootChildDoc  \n    Implements IEnumerable(Of XElement)  \n\n    Private _stringReader As IO.StringReader  \n\n    Public Sub New(ByVal stringReader As IO.StringReader)  \n        _stringReader = stringReader  \n    End Sub  \n\n    Public Function GetEnumerator() As IEnumerator(Of XElement) Implements IEnumerable(Of XElement).GetEnumerator  \n        Return New StreamChildEnumerator(_stringReader)  \n    End Function  \n\n    Public Function GetEnumerator1() As IEnumerator Implements IEnumerable.GetEnumerator  \n        Return Me.GetEnumerator()  \n    End Function  \nEnd Class  \n\nPublic Class StreamChildEnumerator  \n    Implements IEnumerator(Of XElement)  \n\n    Private _current As XElement  \n    Private _reader As Xml.XmlReader  \n    Private _stringReader As IO.StringReader  \n\n    Public Sub New(ByVal stringReader As IO.StringReader)  \n        _stringReader = stringReader  \n        _reader = Xml.XmlReader.Create(_stringReader)  \n        _reader.MoveToContent()  \n    End Sub  \n\n    Public ReadOnly Property Current As XElement Implements IEnumerator(Of XElement).Current  \n        Get  \n            Return _current  \n        End Get  \n    End Property  \n\n    Public ReadOnly Property Current1 As Object Implements IEnumerator.Current  \n        Get  \n            Return Me.Current  \n        End Get  \n    End Property  \n\n    Public Function MoveNext() As Boolean Implements IEnumerator.MoveNext  \n        While _reader.Read()  \n            Select Case _reader.NodeType  \n                Case Xml.XmlNodeType.Element  \n                    Dim el = TryCast(XElement.ReadFrom(_reader), XElement)  \n                    If el IsNot Nothing Then  \n                        _current = el  \n                        Return True  \n                    End If  \n            End Select  \n        End While  \n\n        Return False  \n    End Function  \n\n    Public Sub Reset() Implements IEnumerator.Reset  \n        _reader = Xml.XmlReader.Create(_stringReader)  \n        _reader.MoveToContent()  \n    End Sub  \n\n#Region &quot;IDisposable Support&quot;  \n    Private disposedValue As Boolean &#39; To detect redundant calls  \n\n    &#39; IDisposable  \n    Protected Overridable Sub Dispose(ByVal disposing As Boolean)  \n        If Not Me.disposedValue Then  \n            If disposing Then  \n                _reader.Close()  \n            End If  \n        End If  \n        Me.disposedValue = True  \n    End Sub  \n\n    Public Sub Dispose() Implements IDisposable.Dispose  \n        Dispose(True)  \n        GC.SuppressFinalize(Me)  \n    End Sub  \n#End Region  \n\nEnd Class  \n</code></pre><p> This example produces the following output:  </p>\n<pre class=\"loading\"><code>bbb  \nccc  \n</code></pre><p> In this example, the source document is very small. However, even if there were millions of <code>Child</code> elements, this example would still have a small memory footprint.  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../../language-features/control-flow/walkthrough-implementing-ienumerable-of-t\" data-linktype=\"relative-path\">Walkthrough: Implementing IEnumerable(Of T) in Visual Basic</a><br> <a href=\"parsing-xml\" data-linktype=\"relative-path\">Parsing XML (Visual Basic)</a></p>\n</div></div>","outputRootRelativePath":"../../../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"shoag\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"ms.suite\" content=\"\">\r\n<meta name=\"ms.custom\" content=\"\">\r\n<meta name=\"ms.tgt_pltfrm\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"f67ce598-4a12-4dcb-9a07-24deca02a111\">\r\n<meta name=\"caps.latest.revision\" content=\"3\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"translation.priority.mt\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.mt\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.mt\" content=\"pt-br\">\r\n<meta name=\"translation.priority.mt\" content=\"tr-tr\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-visual-basic\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"ms.reviewer\" content=\"\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-04-01 05:46 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/401ac8986dee5f9f1504fb6c4e1f627d87f0f236/docs/visual-basic/programming-guide/concepts/linq/how-to-stream-xml-fragments-from-an-xmlreader.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/programming-guide/concepts/linq/how-to-stream-xml-fragments-from-an-xmlreader.md\">\r\n<meta name=\"document_id\" content=\"1b4c823f-9c7e-fa69-88a6-4b97220a932b\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"shoag","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","uhfHeaderId":"MSDocsHeader-DotNet","title":"How to: Stream XML Fragments from an XmlReader (Visual Basic) | Microsoft Docs","ms.suite":"","ms.custom":"","ms.tgt_pltfrm":"","ms.assetid":"f67ce598-4a12-4dcb-9a07-24deca02a111","caps.latest.revision":3,"ms.topic":"article","dev_langs":["vb"],"translation.priority.mt":["cs-cz","pl-pl","pt-br","tr-tr"],"ms.date":"2015-07-20","ms.technology":["devlang-visual-basic"],"ms.prod":".net","ms.reviewer":"","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"tompratt-AQ","author_email":"v-thprat@microsoft.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"Added missing samples to migrated topics (#1733)","commit_sha":"401ac8986dee5f9f1504fb6c4e1f627d87f0f236","commit_date":"2017-03-17 01:04:44 -0700"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2017-04-01 05:46 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"},{"profile_url":"https://github.com/tompratt-AQ","display_name":"tompratt-AQ","id":"26311438"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"4/1/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/401ac8986dee5f9f1504fb6c4e1f627d87f0f236/docs/visual-basic/programming-guide/concepts/linq/how-to-stream-xml-fragments-from-an-xmlreader.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/programming-guide/concepts/linq/how-to-stream-xml-fragments-from-an-xmlreader.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/visual-basic/programming-guide/concepts/linq/how-to-stream-xml-fragments-from-an-xmlreader.md","document_id":"1b4c823f-9c7e-fa69-88a6-4b97220a932b","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/visual-basic/programming-guide/concepts/linq/how-to-stream-xml-fragments-from-an-xmlreader","toc_asset_id":"articles/visual-basic/programming-guide/concepts/linq/toc.json","toc_rel":"toc.json","_op_ogTitle":"How to: Stream XML Fragments from an XmlReader (Visual Basic)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":587,"_op_rawTitle":"<h1 id=\"how-to-stream-xml-fragments-from-an-xmlreader-visual-basic\" sourcefile=\"docs/visual-basic/programming-guide/concepts/linq/how-to-stream-xml-fragments-from-an-xmlreader.md\" sourcestartlinenumber=\"25\" sourceendlinenumber=\"25\">How to: Stream XML Fragments from an XmlReader (Visual Basic)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/visual-basic/programming-guide/concepts/linq/how-to-stream-xml-fragments-from-an-xmlreader","fileRelativePath":"articles/visual-basic/programming-guide/concepts/linq/how-to-stream-xml-fragments-from-an-xmlreader.html"},"themesRelativePathToOutputRoot":"_themes/"}