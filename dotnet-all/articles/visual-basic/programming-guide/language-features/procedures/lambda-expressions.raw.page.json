{"content":"<div><div class=\"content\">\n<p>A <em>lambda expression</em> is a function or subroutine without a name that can be used wherever a delegate is valid. Lambda expressions can be functions or subroutines and can be single-line or multi-line. You can pass values from the current scope to a lambda expression.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The <code>RemoveHandler</code> statement is an exception. You cannot pass a lambda expression in for the delegate parameter of <code>RemoveHandler</code>.  </p>\n</div>\n<p> You create lambda expressions by using the <code>Function</code> or <code>Sub</code> keyword, just as you create a standard function or subroutine. However, lambda expressions are included in a statement.  </p>\n<p> The following example is a lambda expression that increments its argument and returns the value. The example shows both the single-line and multi-line lambda expression syntax for a function.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrLambdas#14\">Dim increment1 = Function(x) x + 1\nDim increment2 = Function(x)\n                     Return x + 2\n                 End Function\n\n&#39; Write the value 2.\nConsole.WriteLine(increment1(1))\n\n&#39; Write the value 4.\nConsole.WriteLine(increment2(2))\n</code></pre><p> The following example is a lambda expression that writes a value to the console. The example shows both the single-line and multi-line lambda expression syntax for a subroutine.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrLambdas#15\">Dim writeline1 = Sub(x) Console.WriteLine(x)\nDim writeline2 = Sub(x)\n                     Console.WriteLine(x)\n                 End Sub\n\n&#39; Write &quot;Hello&quot;.\nwriteline1(&quot;Hello&quot;)\n\n&#39; Write &quot;World&quot;\nwriteline2(&quot;World&quot;)\n</code></pre><p> Notice that in the previous examples the lambda expressions are assigned to a variable name. Whenever you refer to the variable, you invoke the lambda expression. You can also declare and invoke a lambda expression at the same time, as shown in the following example.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrLambdas#3\">Console.WriteLine((Function(num As Integer) num + 1)(5))\n</code></pre><p> A lambda expression can be returned as the value of a function call (as is shown in the example in the <a href=\"#context\" data-linktype=\"self-bookmark\">Context</a> section later in this topic), or passed in as an argument to a parameter that takes a delegate type, as shown in the following example.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrLambdas#8\">Module Module2\n\n    Sub Main()\n        &#39; The following line will print Success, because 4 is even.\n        testResult(4, Function(num) num Mod 2 = 0)\n        &#39; The following line will print Failure, because 5 is not &gt; 10.\n        testResult(5, Function(num) num &gt; 10)\n    End Sub\n\n    &#39; Sub testResult takes two arguments, an integer value and a \n    &#39; delegate function that takes an integer as input and returns\n    &#39; a boolean. \n    &#39; If the function returns True for the integer argument, Success\n    &#39; is displayed.\n    &#39; If the function returns False for the integer argument, Failure\n    &#39; is displayed.\n    Sub testResult(ByVal value As Integer, ByVal fun As Func(Of Integer, Boolean))\n        If fun(value) Then\n            Console.WriteLine(&quot;Success&quot;)\n        Else\n            Console.WriteLine(&quot;Failure&quot;)\n        End If\n    End Sub\n\nEnd Module\n</code></pre><h2 id=\"lambda-expression-syntax\">Lambda Expression Syntax</h2>\n<p> The syntax of a lambda expression resembles that of a standard function or subroutine. The differences are as follows:  </p>\n<ul>\n<li><p>A lambda expression does not have a name.  </p>\n</li>\n<li><p>Lambda expressions cannot have modifiers, such as <code>Overloads</code> or <code>Overrides</code>.  </p>\n</li>\n<li><p>Single-line lambda functions do not use an <code>As</code> clause to designate the return type. Instead, the type is inferred from the value that the body of the lambda expression evaluates to. For example, if the body of the lambda expression is <code>cust.City = &quot;London&quot;</code>, its return type is <code>Boolean</code>.  </p>\n</li>\n<li><p>In multi-line lambda functions, you can either specify a return type by using an <code>As</code> clause, or omit the <code>As</code> clause so that the return type is inferred. When the <code>As</code> clause is omitted for a multi-line lambda function, the return type is inferred to be the dominant type from all the <code>Return</code> statements in the multi-line lambda function. The <em>dominant type</em> is a unique type that all other types can widen to. If this unique type cannot be determined, the dominant type is the unique type that all other types in the array can narrow to. If neither of these unique types can be determined, the dominant type is <code>Object</code>. In this case, if <code>Option Strict</code> is set to <code>On</code>, a compiler error occurs.  </p>\n<p> For example, if the expressions supplied to the <code>Return</code> statement contain values of type <code>Integer</code>, <code>Long</code>, and <code>Double</code>, the resulting array is of type <code>Double</code>. Both <code>Integer</code> and <code>Long</code> widen to <code>Double</code> and only <code>Double</code>. Therefore, <code>Double</code> is the dominant type. For more information, see <a href=\"../data-types/widening-and-narrowing-conversions\" data-linktype=\"relative-path\">Widening and Narrowing Conversions</a>.  </p>\n</li>\n<li><p>The body of a single-line function must be an expression that returns a value, not a statement. There is no <code>Return</code> statement for single-line functions. The value returned by the single-line function is the value of the expression in the body of the function.  </p>\n</li>\n<li><p>The body of a single-line subroutine must be single-line statement.  </p>\n</li>\n<li><p>Single-line functions and subroutines do not include an <code>End Function</code> or <code>End Sub</code> statement.  </p>\n</li>\n<li><p>You can specify the data type of a lambda expression parameter by using the <code>As</code> keyword, or the data type of the parameter can be inferred. Either all parameters must have specified data types or all must be inferred.  </p>\n</li>\n<li><p><code>Optional</code> and <code>Paramarray</code> parameters are not permitted.  </p>\n</li>\n<li><p>Generic parameters are not permitted.  </p>\n</li>\n</ul>\n<h2 id=\"async-lambdas\">Async Lambdas</h2>\n<p> You can easily create lambda expressions and statements that incorporate asynchronous processing by using the <a href=\"../../../language-reference/modifiers/async\" data-linktype=\"relative-path\">Async</a> and <a href=\"../../../language-reference/operators/await-operator\" data-linktype=\"relative-path\">Await Operator</a> keywords. For example, the following Windows Forms example contains an event handler that calls and awaits an async method, <code>ExampleMethodAsync</code>.  </p>\n<pre class=\"loading\"><code class=\"lang-vb\">Public Class Form1  \n\n    Async Sub Button1_Click(sender As Object, e As EventArgs) Handles Button1.Click  \n        &#39; ExampleMethodAsync returns a Task.  \n        Await ExampleMethodAsync()  \n        TextBox1.Text = vbCrLf &amp; &quot;Control returned to button1_Click.&quot;  \n    End Sub  \n\n    Async Function ExampleMethodAsync() As Task  \n        &#39; The following line simulates a task-returning asynchronous process.  \n        Await Task.Delay(1000)  \n    End Function  \n\nEnd Class  \n</code></pre><p> You can add the same event handler by using an async lambda in an <a href=\"../../../language-reference/statements/addhandler-statement\" data-linktype=\"relative-path\">AddHandler Statement</a>. To add this handler, add an <code>Async</code> modifier before the lambda parameter list, as the following example shows.  </p>\n<pre class=\"loading\"><code class=\"lang-vb\">Public Class Form1  \n\n    Private Sub Form1_Load(sender As Object, e As EventArgs) Handles MyBase.Load  \n        AddHandler Button1.Click,   \n            Async Sub(sender1, e1)  \n                &#39; ExampleMethodAsync returns a Task.  \n                Await ExampleMethodAsync()  \n                TextBox1.Text = vbCrLf &amp; &quot;Control returned to Button1_ Click.&quot;  \n            End Sub  \n    End Sub  \n\n    Async Function ExampleMethodAsync() As Task  \n        &#39; The following line simulates a task-returning asynchronous process.  \n        Await Task.Delay(1000)  \n    End Function  \n\nEnd Class  \n</code></pre><p> For more information about how to create and use async methods, see <a href=\"../../concepts/async/index\" data-linktype=\"relative-path\">Asynchronous Programming with Async and Await</a>.  </p>\n<h2 id=\"a-namecontexta-context\"><a name=\"context\"></a> Context</h2>\n<p> A lambda expression shares its context with the scope within which it is defined. It has the same access rights as any code written in the containing scope. This includes access to member variables, functions and subs, <code>Me</code>, and parameters and local variables in the containing scope.  </p>\n<p> Access to local variables and parameters in the containing scope can extend beyond the lifetime of that scope. As long as a delegate referring to a lambda expression is not available to garbage collection, access to the variables in the original environment is retained. In the following example, variable <code>target</code> is local to <code>makeTheGame</code>, the method in which the lambda expression <code>playTheGame</code> is defined. Note that the returned lambda expression, assigned to <code>takeAGuess</code> in <code>Main</code>, still has access to the local variable <code>target</code>.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrLambdas#12\">Module Module6\n\n    Sub Main()\n        &#39; Variable takeAGuess is a Boolean function. It stores the target\n        &#39; number that is set in makeTheGame.\n        Dim takeAGuess As gameDelegate = makeTheGame()\n\n        &#39; Set up the loop to play the game.\n        Dim guess As Integer\n        Dim gameOver = False\n        While Not gameOver\n            guess = CInt(InputBox(&quot;Enter a number between 1 and 10 (0 to quit)&quot;, &quot;Guessing Game&quot;, &quot;0&quot;))\n            &#39; A guess of 0 means you want to give up.\n            If guess = 0 Then\n                gameOver = True\n            Else\n                &#39; Tests your guess and announces whether you are correct. Method takeAGuess\n                &#39; is called multiple times with different guesses. The target value is not \n                &#39; accessible from Main and is not passed in.\n                gameOver = takeAGuess(guess)\n                Console.WriteLine(&quot;Guess of &quot; &amp; guess &amp; &quot; is &quot; &amp; gameOver)\n            End If\n        End While\n\n    End Sub\n\n    Delegate Function gameDelegate(ByVal aGuess As Integer) As Boolean\n\n    Public Function makeTheGame() As gameDelegate\n\n        &#39; Generate the target number, between 1 and 10. Notice that \n        &#39; target is a local variable. After you return from makeTheGame,\n        &#39; it is not directly accessible.\n        Randomize()\n        Dim target As Integer = CInt(Int(10 * Rnd() + 1))\n\n        &#39; Print the answer if you want to be sure the game is not cheating\n        &#39; by changing the target at each guess.\n        Console.WriteLine(&quot;(Peeking at the answer) The target is &quot; &amp; target)\n\n        &#39; The game is returned as a lambda expression. The lambda expression\n        &#39; carries with it the environment in which it was created. This \n        &#39; environment includes the target number. Note that only the current\n        &#39; guess is a parameter to the returned lambda expression, not the target. \n\n        &#39; Does the guess equal the target?\n        Dim playTheGame = Function(guess As Integer) guess = target\n\n        Return playTheGame\n\n    End Function\n\nEnd Module\n</code></pre><p> The following example demonstrates the wide range of access rights of the nested lambda expression. When the returned lambda expression is executed from <code>Main</code> as <code>aDel</code>, it accesses these elements:  </p>\n<ul>\n<li><p>A field of the class in which it is defined: <code>aField</code>  </p>\n</li>\n<li><p>A property of the class in which it is defined: <code>aProp</code>  </p>\n</li>\n<li><p>A parameter of method <code>functionWithNestedLambda</code>, in which it is defined: <code>level1</code>  </p>\n</li>\n<li><p>A local variable of <code>functionWithNestedLambda</code>: <code>localVar</code>  </p>\n</li>\n<li><p>A parameter of the lambda expression in which it is nested: <code>level2</code>  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrLambdas#9\">Module Module3\n\n    Sub Main()\n        &#39; Create an instance of the class, with 1 as the value of \n        &#39; the property.\n        Dim lambdaScopeDemoInstance = \n            New LambdaScopeDemoClass With {.Prop = 1}\n\n        &#39; Variable aDel will be bound to the nested lambda expression  \n        &#39; returned by the call to functionWithNestedLambda.\n        &#39; The value 2 is sent in for parameter level1.\n        Dim aDel As aDelegate = \n            lambdaScopeDemoInstance.functionWithNestedLambda(2)\n\n        &#39; Now the returned lambda expression is called, with 4 as the \n        &#39; value of parameter level3.\n        Console.WriteLine(&quot;First value returned by aDel:   &quot; &amp; aDel(4))\n\n        &#39; Change a few values to verify that the lambda expression has \n        &#39; access to the variables, not just their original values.\n        lambdaScopeDemoInstance.aField = 20\n        lambdaScopeDemoInstance.Prop = 30\n        Console.WriteLine(&quot;Second value returned by aDel: &quot; &amp; aDel(40))\n    End Sub\n\n    Delegate Function aDelegate(\n        ByVal delParameter As Integer) As Integer\n\n    Public Class LambdaScopeDemoClass\n        Public aField As Integer = 6\n        Dim aProp As Integer\n\n        Property Prop() As Integer\n            Get\n                Return aProp\n            End Get\n            Set(ByVal value As Integer)\n                aProp = value\n            End Set\n        End Property\n\n        Public Function functionWithNestedLambda(\n            ByVal level1 As Integer) As aDelegate\n\n            Dim localVar As Integer = 5\n\n            &#39; When the nested lambda expression is executed the first \n            &#39; time, as aDel from Main, the variables have these values:\n            &#39; level1 = 2\n            &#39; level2 = 3, after aLambda is called in the Return statement\n            &#39; level3 = 4, after aDel is called in Main\n            &#39; locarVar = 5\n            &#39; aField = 6\n            &#39; aProp = 1\n            &#39; The second time it is executed, two values have changed:\n            &#39; aField = 20\n            &#39; aProp = 30\n            &#39; level3 = 40\n            Dim aLambda = Function(level2 As Integer) _\n                              Function(level3 As Integer) _\n                                  level1 + level2 + level3 + localVar +\n                                    aField + aProp\n\n            &#39; The function returns the nested lambda, with 3 as the \n            &#39; value of parameter level2.\n            Return aLambda(3)\n        End Function\n\n    End Class\nEnd Module\n</code></pre></li>\n</ul>\n<h2 id=\"converting-to-a-delegate-type\">Converting to a Delegate Type</h2>\n<p> A lambda expression can be implicitly converted to a compatible delegate type. For information about the general requirements for compatibility, see <a href=\"../delegates/relaxed-delegate-conversion\" data-linktype=\"relative-path\">Relaxed Delegate Conversion</a>. For example, the following code example shows a lambda expression that implicitly converts to <code>Func(Of Integer, Boolean)</code> or a matching delegate signature.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrLambdas#16\">&#39; Explicitly specify a delegate type.\nDelegate Function MultipleOfTen(ByVal num As Integer) As Boolean\n\n&#39; This function matches the delegate type.\nFunction IsMultipleOfTen(ByVal num As Integer) As Boolean\n    Return num Mod 10 = 0\nEnd Function\n\n&#39; This method takes an input parameter of the delegate type. \n&#39; The checkDelegate parameter could also be of \n&#39; type Func(Of Integer, Boolean).\nSub CheckForMultipleOfTen(ByVal values As Integer(),\n                          ByRef checkDelegate As MultipleOfTen)\n    For Each value In values\n        If checkDelegate(value) Then\n            Console.WriteLine(value &amp; &quot; is a multiple of ten.&quot;)\n        Else\n            Console.WriteLine(value &amp; &quot; is not a multiple of ten.&quot;)\n        End If\n    Next\nEnd Sub\n\n&#39; This method shows both an explicitly defined delegate and a\n&#39; lambda expression passed to the same input parameter.\nSub CheckValues()\n    Dim values = {5, 10, 11, 20, 40, 30, 100, 3}\n    CheckForMultipleOfTen(values, AddressOf IsMultipleOfTen)\n    CheckForMultipleOfTen(values, Function(num) num Mod 10 = 0)\nEnd Sub\n</code></pre><p> The following code example shows a lambda expression that implicitly converts to <code>Sub(Of Double, String, Double)</code> or a matching delegate signature.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrLambdas#23\">Module Module1\n    Delegate Sub StoreCalculation(ByVal value As Double,\n                                  ByVal calcType As String,\n                                  ByVal result As Double)\n\n    Sub Main()\n        &#39; Create a DataTable to store the data.\n        Dim valuesTable = New DataTable(&quot;Calculations&quot;)\n        valuesTable.Columns.Add(&quot;Value&quot;, GetType(Double))\n        valuesTable.Columns.Add(&quot;Calculation&quot;, GetType(String))\n        valuesTable.Columns.Add(&quot;Result&quot;, GetType(Double))\n\n        &#39; Define a lambda subroutine to write to the DataTable.\n        Dim writeToValuesTable = Sub(value As Double, calcType As String, result As Double)\n                                     Dim row = valuesTable.NewRow()\n                                     row(0) = value\n                                     row(1) = calcType\n                                     row(2) = result\n                                     valuesTable.Rows.Add(row)\n                                 End Sub\n\n        &#39; Define the source values.\n        Dim s = {1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n        &#39; Perform the calculations.\n        Array.ForEach(s, Sub(c) CalculateSquare(c, writeToValuesTable))\n        Array.ForEach(s, Sub(c) CalculateSquareRoot(c, writeToValuesTable))\n\n        &#39; Display the data.\n        Console.WriteLine(&quot;Value&quot; &amp; vbTab &amp; &quot;Calculation&quot; &amp; vbTab &amp; &quot;Result&quot;)\n        For Each row As DataRow In valuesTable.Rows\n            Console.WriteLine(row(0).ToString() &amp; vbTab &amp;\n                              row(1).ToString() &amp; vbTab &amp;\n                              row(2).ToString())\n        Next\n\n    End Sub\n\n\n    Sub CalculateSquare(ByVal number As Double, ByVal writeTo As StoreCalculation)\n        writeTo(number, &quot;Square     &quot;, number ^ 2)\n    End Sub\n\n    Sub CalculateSquareRoot(ByVal number As Double, ByVal writeTo As StoreCalculation)\n        writeTo(number, &quot;Square Root&quot;, Math.Sqrt(number))\n    End Sub\nEnd Module\n</code></pre><p> When you assign lambda expressions to delegates or pass them as arguments to procedures, you can specify the parameter names but omit their data types, letting the types be taken from the delegate.  </p>\n<h2 id=\"examples\">Examples</h2>\n<ul>\n<li><p>The following example defines a lambda expression that returns <code>True</code> if the nullable argument has an assigned value, and <code>False</code> if its value is <code>Nothing</code>.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrLambdas#4\">Dim notNothing =\n  Function(num? As Integer) num IsNot Nothing\nDim arg As Integer = 14\nConsole.WriteLine(&quot;Does the argument have an assigned value?&quot;)\nConsole.WriteLine(notNothing(arg))\n</code></pre></li>\n<li><p>The following example defines a lambda expression that returns the index of the last element in an array.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrLambdas#5\">Dim numbers() = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\nDim lastIndex =\n  Function(intArray() As Integer) intArray.Length - 1\nFor i = 0 To lastIndex(numbers)\n    numbers(i) += 1\nNext\n</code></pre></li>\n</ul>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"index\" data-linktype=\"relative-path\">Procedures</a><br> <a href=\"../linq/introduction-to-linq\" data-linktype=\"relative-path\">Introduction to LINQ in Visual Basic</a><br> <a href=\"../delegates/index\" data-linktype=\"relative-path\">Delegates</a><br> <a href=\"../../../language-reference/statements/function-statement\" data-linktype=\"relative-path\">Function Statement</a><br> <a href=\"../../../language-reference/statements/sub-statement\" data-linktype=\"relative-path\">Sub Statement</a><br> <a href=\"../data-types/nullable-value-types\" data-linktype=\"relative-path\">Nullable Value Types</a><br> <a href=\"../delegates/how-to-pass-procedures-to-another-procedure\" data-linktype=\"relative-path\">How to: Pass Procedures to Another Procedure in Visual Basic</a><br> <a href=\"how-to-create-a-lambda-expression\" data-linktype=\"relative-path\">How to: Create a Lambda Expression</a><br> <a href=\"../delegates/relaxed-delegate-conversion\" data-linktype=\"relative-path\">Relaxed Delegate Conversion</a></p>\n</div></div>","outputRootRelativePath":"../../../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"shoag\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"ms.suite\" content=\"\">\r\n<meta name=\"ms.custom\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"137064b0-3928-4bfa-ba71-c3f9cbd951e2\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"52\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-visual-basic\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"ms.reviewer\" content=\"\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/0a5d76c154aeb9b749c9c3fc5ad0962e93754a62/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md\">\r\n<meta name=\"document_id\" content=\"8db7bda5-0cc0-e541-44fa-ac79f0e78b7f\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"shoag","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","uhfHeaderId":"MSDocsHeader-DotNet","title":"Lambda Expressions (Visual Basic) | Microsoft Docs","ms.suite":"","ms.custom":"","ms.assetid":"137064b0-3928-4bfa-ba71-c3f9cbd951e2","f1_keywords":["vb.LambdaFunction"],"translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":52,"ms.topic":"article","dev_langs":["vb"],"helpviewer_keywords":["functions [Visual Basic], lambda expressions","lambda expressions [Visual Basic]","expressions [Visual Basic], lambda","inline functions [Visual Basic]"],"ms.date":"2015-07-20","ms.technology":["devlang-visual-basic"],"ms.prod":".net","ms.reviewer":"","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Steve Hoag","author_email":"shoag@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganizing the VB TOC (#1348)","commit_sha":"0a5d76c154aeb9b749c9c3fc5ad0962e93754a62","commit_date":"2017-02-14 10:22:48 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/0a5d76c154aeb9b749c9c3fc5ad0962e93754a62/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md","document_id":"8db7bda5-0cc0-e541-44fa-ac79f0e78b7f","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/visual-basic/programming-guide/language-features/procedures/lambda-expressions","toc_asset_id":"articles/visual-basic/programming-guide/language-features/procedures/toc.json","toc_rel":"toc.json","_op_ogTitle":"Lambda Expressions (Visual Basic)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":2368,"_op_rawTitle":"<h1 id=\"lambda-expressions-visual-basic\" sourcefile=\"docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md\" sourcestartlinenumber=\"41\" sourceendlinenumber=\"41\">Lambda Expressions (Visual Basic)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/visual-basic/programming-guide/language-features/procedures/lambda-expressions","fileRelativePath":"articles/visual-basic/programming-guide/language-features/procedures/lambda-expressions.html"},"themesRelativePathToOutputRoot":"_themes/"}