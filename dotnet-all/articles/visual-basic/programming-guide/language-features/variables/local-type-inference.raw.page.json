{"content":"<div><div class=\"content\">\n<p>The Visual Basic compiler uses <em>type inference</em> to determine the data types of local variables declared without an <code>As</code> clause. The compiler infers the type of the variable from the type of the initialization expression. This enables you to declare variables without explicitly stating a type, as shown in the following example. As a result of the declarations, both <code>num1</code> and <code>num2</code> are strongly typed as integers.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrTypeInference#1\">Public Sub inferenceExample()\n\n    &#39; Using explicit typing.\n    Dim num1 As Integer = 3\n\n    &#39; Using local type inference.\n    Dim num2 = 3\n\nEnd Sub\n</code></pre><div class=\"NOTE\"><h5>Note</h5><p> If you do not want <code>num2</code> in the previous example to be typed as an <code>Integer</code>, you can specify another type by using a declaration like <code>Dim num3 As Object = 3</code> or <code>Dim num4 As Double = 3</code>.  </p>\n</div>\n<p> Local type inference applies at procedure level. It cannot be used to declare variables at module level (within a class, structure, module, or interface but not within a procedure or block). If <code>num2</code> in the previous example were a field of a class instead of a local variable in a procedure, the declaration would cause an error with <code>Option Strict</code> on, and would classify <code>num2</code> as an <code>Object</code> with <code>Option Strict</code> off. Similarly, local type inference does not apply to procedure level variables declared as <code>Static</code>.  </p>\n<h2 id=\"type-inference-vs-late-binding\">Type Inference vs. Late Binding</h2>\n<p> Code that uses type inference resembles code that relies on late binding. However, type inference strongly types the variable instead of leaving it as <code>Object</code>. The compiler uses a variable&#39;s initializer to determine the variable&#39;s type at compile time to produce early-bound code. In the previous example, <code>num2</code>, like <code>num1</code>, is typed as an <code>Integer</code>.  </p>\n<p> The behavior of early-bound variables differs from that of late-bound variables, for which the type is known only at run time. Knowing the type early enables the compiler to identify problems before execution, allocate memory precisely, and perform other optimizations. Early binding also enables the Visual Basic integrated development environment (IDE) to provide IntelliSense Help about the members of an object. Early binding is also preferred for performance. This is because all data stored in a late-bound variable must be wrapped as type <code>Object</code>, and accessing members of the type at run time makes the program slower.  </p>\n<h2 id=\"examples\">Examples</h2>\n<p> Type inference occurs when a local variable is declared without an <code>As</code> clause and initialized. The compiler uses the type of the assigned initial value as the type of the variable. For example, each of the following lines of code declares a variable of type <code>String</code>.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrTypeInference#2\">&#39; Using explicit typing.\nDim name1 As String = &quot;Springfield&quot;\n\n&#39; Using local type inference.\nDim name2 = &quot;Springfield&quot;\n</code></pre><p> The following code demonstrates two equivalent ways to create an array of integers.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrTypeInference#3\">&#39; Using explicit typing.\nDim someNumbers1() As Integer = New Integer() {4, 18, 11, 9, 8, 0, 5}\n\n&#39; Using local type inference.\nDim someNumbers2 = New Integer() {4, 18, 11, 9, 8, 0, 5}\n</code></pre><p> It is convenient to use type inference to determine the type of a loop control variable. In the following code, the compiler infers that <code>number</code> is an <code>Integer</code> because <code>someNumbers2</code> from the previous example is an array of integers.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrTypeInference#4\">Dim total = 0\nFor Each number In someNumbers2\n    total += number\nNext\n</code></pre><p> Local type inference can be used in <code>Using</code> statements to establish the type of the resource name, as the following example demonstrates.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrTypeInference#7\">Using proc = New System.Diagnostics.Process\n    &#39; Insert code to work with the resource.\nEnd Using\n</code></pre><p> The type of a variable can also be inferred from the return values of functions, as the following example demonstrates. Both <code>pList1</code> and <code>pList2</code> are arrays of processes because <code>Process.GetProcesses</code> returns an array of processes.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrTypeInference#5\">&#39; Using explicit typing.\nDim pList1() As Process = Process.GetProcesses()\n\n&#39; Using local type inference.\nDim pList2 = Process.GetProcesses()\n</code></pre><h2 id=\"option-infer\">Option Infer</h2>\n<p> <code>Option Infer</code> enables you specify whether local type inference is allowed in a particular file. To enable or to block the option, type one of the following statements at the start of the file.  </p>\n<p> <code>Option Infer On</code>  </p>\n<p> <code>Option Infer Off</code>  </p>\n<p> If you do not specify a value for <code>Option Infer</code> in your code, the compiler default is <code>Option Infer On</code>. For projects upgraded from Visual Basic 2008 or earlier, the compiler default is <code>Option Infer Off</code>.  </p>\n<p> If the value set for <code>Option Infer</code> in a file conflicts with the value set in the IDE or on the command line, the value in the file has precedence.  </p>\n<p> For more information, see <a href=\"../../../language-reference/statements/option-infer-statement\" data-linktype=\"relative-path\">Option Infer Statement</a> and <a href=\"https://docs.microsoft.com/visualstudio/ide/reference/compile-page-project-designer-visual-basic\" data-linktype=\"external\">Compile Page, Project Designer (Visual Basic)</a>.  </p>\n<h2 id=\"restrictions\">Restrictions</h2>\n<p> Type inference can be used only for non-static local variables; it cannot be used to determine the type of class fields, properties, or functions.  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../objects-and-classes/anonymous-types\" data-linktype=\"relative-path\">Anonymous Types</a><br> <a href=\"../early-late-binding/index\" data-linktype=\"relative-path\">Early and Late Binding</a><br> <a href=\"../../../language-reference/statements/for-each-next-statement\" data-linktype=\"relative-path\">For Each...Next Statement</a><br> <a href=\"../../../language-reference/statements/for-next-statement\" data-linktype=\"relative-path\">For...Next Statement</a><br> <a href=\"../../../language-reference/statements/option-infer-statement\" data-linktype=\"relative-path\">Option Infer Statement</a><br> <a href=\"../../../reference/command-line-compiler/optioninfer\" data-linktype=\"relative-path\">/optioninfer</a><br> <a href=\"../linq/introduction-to-linq\" data-linktype=\"relative-path\">Introduction to LINQ in Visual Basic</a></p>\n</div></div>","outputRootRelativePath":"../../../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"shoag\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"ms.suite\" content=\"\">\r\n<meta name=\"ms.custom\" content=\"\">\r\n<meta name=\"ms.tgt_pltfrm\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"b8307f18-2e56-4ab3-a45a-826873f400f6\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"43\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-visual-basic\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"ms.reviewer\" content=\"\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/0a5d76c154aeb9b749c9c3fc5ad0962e93754a62/docs/visual-basic/programming-guide/language-features/variables/local-type-inference.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/programming-guide/language-features/variables/local-type-inference.md\">\r\n<meta name=\"document_id\" content=\"7bcab81d-5701-46a6-1616-3cf286063453\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"shoag","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","uhfHeaderId":"MSDocsHeader-DotNet","title":"Local Type Inference (Visual Basic) | Microsoft Docs","ms.suite":"","ms.custom":"","ms.tgt_pltfrm":"","ms.assetid":"b8307f18-2e56-4ab3-a45a-826873f400f6","f1_keywords":["local type inference","vb.TypeInfer"],"translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":43,"ms.topic":"article","dev_langs":["vb"],"helpviewer_keywords":["Option Infer statement","local type inference [Visual Basic]","implicitly-typed local variables [Visual Basic]","variables [Visual Basic], type inference","inference [Visual Basic]","type inference [Visual Basic]"],"ms.date":"2015-07-20","ms.technology":["devlang-visual-basic"],"ms.prod":".net","ms.reviewer":"","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Steve Hoag","author_email":"shoag@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganizing the VB TOC (#1348)","commit_sha":"0a5d76c154aeb9b749c9c3fc5ad0962e93754a62","commit_date":"2017-02-14 10:22:48 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Absolute urls and other fixes (#1281)","commit_sha":"f7dffe4885b331cec8d37f3cc5c9163f69c3b4c9","commit_date":"2016-11-22 12:57:26 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/0a5d76c154aeb9b749c9c3fc5ad0962e93754a62/docs/visual-basic/programming-guide/language-features/variables/local-type-inference.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/programming-guide/language-features/variables/local-type-inference.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/visual-basic/programming-guide/language-features/variables/local-type-inference.md","document_id":"7bcab81d-5701-46a6-1616-3cf286063453","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/visual-basic/programming-guide/language-features/variables/local-type-inference","toc_asset_id":"articles/visual-basic/programming-guide/language-features/variables/toc.json","toc_rel":"toc.json","_op_ogTitle":"Local Type Inference (Visual Basic)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":801,"_op_rawTitle":"<h1 id=\"local-type-inference-visual-basic\" sourcefile=\"docs/visual-basic/programming-guide/language-features/variables/local-type-inference.md\" sourcestartlinenumber=\"44\" sourceendlinenumber=\"44\">Local Type Inference (Visual Basic)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/visual-basic/programming-guide/language-features/variables/local-type-inference","fileRelativePath":"articles/visual-basic/programming-guide/language-features/variables/local-type-inference.html"},"themesRelativePathToOutputRoot":"_themes/"}