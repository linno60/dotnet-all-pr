{"content":"<div><div class=\"content\">\n<p>This page lists some common problems that can occur when you perform operations on intrinsic data types.  </p>\n<h2 id=\"floating-point-expressions-do-not-compare-as-equal\">Floating-Point Expressions Do Not Compare as Equal</h2>\n<p> When you work with floating-point numbers (<a href=\"../../../language-reference/data-types/single-data-type\" data-linktype=\"relative-path\">Single Data Type</a> and <a href=\"../../../language-reference/data-types/double-data-type\" data-linktype=\"relative-path\">Double Data Type</a>), remember that they are stored as binary fractions. This means they cannot hold an exact representation of any quantity that is not a binary fraction (of the form k / (2 ^ n) where k and n are integers). For example, 0.5 (= 1/2) and 0.3125 (= 5/16) can be held as precise values, whereas 0.2 (= 1/5) and 0.3 (= 3/10) can be only approximations.  </p>\n<p> Because of this imprecision, you cannot rely on exact results when you operate on floating-point values. In particular, two values that are theoretically equal might have slightly different representations.  </p>\n<table>\n<thead>\n<tr>\n<th>To compare floating-point quantities</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1.  Calculate the absolute value of their difference by using the <a class=\"xref\" href=\"../../../../../api/system.math#System_Math_Abs_\" data-linktype=\"relative-path\">Abs</a> method of the <a class=\"xref\" href=\"../../../../../api/system.math\" data-linktype=\"relative-path\">Math</a> class in the <a class=\"xref\" href=\"../../../../../api/system\" data-linktype=\"relative-path\">System</a> namespace.<br>2.  Determine an acceptable maximum difference, such that you can consider the two quantities to be equal for practical purposes if their difference is no larger.<br>3.  Compare the absolute value of the difference to the acceptable difference.</td>\n</tr>\n</tbody>\n</table>\n<p> The following example demonstrates both incorrect and correct comparison of two <code>Double</code> values.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrDataTypes#10\">    Dim oneThird As Double = 1.0 / 3.0\n    Dim pointThrees As Double = 0.333333333333333\n\n    &#39; The following comparison does not indicate equality.\n    Dim exactlyEqual As Boolean = (oneThird = pointThrees)\n\n    &#39; The following comparison indicates equality.\n    Dim closeEnough As Double = 0.000000000000001\n    Dim absoluteDifference As Double = Math.Abs(oneThird - pointThrees)\n    Dim practicallyEqual As Boolean = (absoluteDifference &lt; closeEnough)\n\n    MsgBox(&quot;1.0 / 3.0 is represented as &quot; &amp; oneThird.ToString(&quot;G17&quot;) &amp;\n        vbCrLf &amp; &quot;0.333333333333333 is represented as &quot; &amp;\n        pointThrees.ToString(&quot;G17&quot;) &amp;\n        vbCrLf &amp; &quot;Exact comparison generates &quot; &amp; CStr(exactlyEqual) &amp;\n        vbCrLf &amp; &quot;Acceptable difference comparison generates &quot; &amp;\n        CStr(practicallyEqual))\n</code></pre><p> The previous example uses the <a class=\"xref\" href=\"../../../../../api/system.double#System_Double_ToString_\" data-linktype=\"relative-path\">ToString</a> method of the <a class=\"xref\" href=\"../../../../../api/system.double\" data-linktype=\"relative-path\">Double</a> structure so that it can specify better  precision than the <code>CStr</code> keyword uses. The default is 15 digits, but the &quot;G17&quot; format extends it to 17 digits.  </p>\n<h2 id=\"mod-operator-does-not-return-accurate-result\">Mod Operator Does Not Return Accurate Result</h2>\n<p> Because of the imprecision of floating-point storage, the <a href=\"../../../language-reference/operators/mod-operator\" data-linktype=\"relative-path\">Mod Operator</a> can return an unexpected result when at least one of the operands is floating-point.  </p>\n<p> The <a href=\"../../../language-reference/data-types/decimal-data-type\" data-linktype=\"relative-path\">Decimal Data Type</a> does not use floating-point representation. Many numbers that are inexact in <code>Single</code> and <code>Double</code> are exact in <code>Decimal</code> (for example 0.2 and 0.3). Although arithmetic is slower in <code>Decimal</code> than in floating-point, it might be worth the performance decrease to achieve better precision.  </p>\n<table>\n<thead>\n<tr>\n<th>To find the integer remainder of floating-point quantities</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1.  Declare variables as <code>Decimal</code>.<br>2.  Use the literal type character <code>D</code> to force literals to <code>Decimal</code>, in case their values are too large for the <code>Long</code> data type.</td>\n</tr>\n</tbody>\n</table>\n<p> The following example demonstrates the potential imprecision of floating-point operands.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrDataTypes#11\">    Dim two As Double = 2.0\n    Dim zeroPointTwo As Double = 0.2\n    Dim quotient As Double = two / zeroPointTwo\n    Dim doubleRemainder As Double = two Mod zeroPointTwo\n\n    MsgBox(&quot;2.0 is represented as &quot; &amp; two.ToString(&quot;G17&quot;) &amp;\n        vbCrLf &amp; &quot;0.2 is represented as &quot; &amp; zeroPointTwo.ToString(&quot;G17&quot;) &amp;\n        vbCrLf &amp; &quot;2.0 / 0.2 generates &quot; &amp; quotient.ToString(&quot;G17&quot;) &amp;\n        vbCrLf &amp; &quot;2.0 Mod 0.2 generates &quot; &amp;\n        doubleRemainder.ToString(&quot;G17&quot;))\n\n    Dim decimalRemainder As Decimal = 2D Mod 0.2D\n    MsgBox(&quot;2.0D Mod 0.2D generates &quot; &amp; CStr(decimalRemainder))\n</code></pre><p> The previous example uses the <a class=\"xref\" href=\"../../../../../api/system.double#System_Double_ToString_\" data-linktype=\"relative-path\">ToString</a> method of the <a class=\"xref\" href=\"../../../../../api/system.double\" data-linktype=\"relative-path\">Double</a> structure so that it can specify better precision than the <code>CStr</code> keyword uses. The default is 15 digits, but the &quot;G17&quot; format extends it to 17 digits.  </p>\n<p> Because <code>zeroPointTwo</code> is <code>Double</code>, its value for 0.2 is an infinitely repeating binary fraction with a stored value of 0.20000000000000001. Dividing 2.0 by this quantity yields 9.9999999999999995 with a remainder of 0.19999999999999991.  </p>\n<p> In the expression for <code>decimalRemainder</code>, the literal type character <code>D</code> forces both operands to <code>Decimal</code>, and 0.2 has a precise representation. Therefore the <code>Mod</code> operator yields the expected remainder of 0.0.  </p>\n<p> Note that it is not sufficient to declare <code>decimalRemainder</code> as <code>Decimal</code>. You must also force the literals to <code>Decimal</code>, or they use <code>Double</code> by default and <code>decimalRemainder</code> receives the same inaccurate value as <code>doubleRemainder</code>.  </p>\n<h2 id=\"boolean-type-does-not-convert-to-numeric-type-accurately\">Boolean Type Does Not Convert to Numeric Type Accurately</h2>\n<p> <a href=\"../../../language-reference/data-types/boolean-data-type\" data-linktype=\"relative-path\">Boolean Data Type</a> values are not stored as numbers, and the stored values are not intended to be equivalent to numbers. For compatibility with earlier versions, Visual Basic provides conversion keywords (<a href=\"../../../language-reference/functions/ctype-function\" data-linktype=\"relative-path\">CType Function</a>, <code>CBool</code>, <code>CInt</code>, and so on) to convert between <code>Boolean</code> and numeric types. However, other languages sometimes perform these conversions differently, as do the .NET Framework methods.  </p>\n<p> You should never write code that relies on equivalent numeric values for <code>True</code> and <code>False</code>. Whenever possible, you should restrict usage of <code>Boolean</code> variables to the logical values for which they are designed. If you must mix <code>Boolean</code> and numeric values, make sure that you understand the conversion method that you select.  </p>\n<h3 id=\"conversion-in-visual-basic\">Conversion in Visual Basic</h3>\n<p> When you use the <code>CType</code> or <code>CBool</code> conversion keywords to convert numeric data types to <code>Boolean</code>, 0 becomes <code>False</code> and all other values become <code>True</code>. When you convert <code>Boolean</code> values to numeric types by using the conversion keywords, <code>False</code> becomes 0 and <code>True</code> becomes -1.  </p>\n<h3 id=\"conversion-in-the-framework\">Conversion in the Framework</h3>\n<p> The <a class=\"xref\" href=\"../../../../../api/system.convert#System_Convert_ToInt32_\" data-linktype=\"relative-path\">ToInt32</a> method of the <a class=\"xref\" href=\"../../../../../api/system.convert\" data-linktype=\"relative-path\">Convert</a> class in the <a class=\"xref\" href=\"../../../../../api/system\" data-linktype=\"relative-path\">System</a> namespace converts <code>True</code> to +1.  </p>\n<p> If you must convert a <code>Boolean</code> value to a numeric data type, be careful about which conversion method you use.  </p>\n<h2 id=\"character-literal-generates-compiler-error\">Character Literal Generates Compiler Error</h2>\n<p> In the absence of any type characters, Visual Basic assumes default data types for literals. The default type for a character literal — enclosed in quotation marks (<code>&quot; &quot;</code>) — is <code>String</code>.  </p>\n<p> The <code>String</code> data type does not widen to the <a href=\"../../../language-reference/data-types/char-data-type\" data-linktype=\"relative-path\">Char Data Type</a>. This means that if you want to assign a literal to a <code>Char</code> variable, you must either make a narrowing conversion or force the literal to the <code>Char</code> type.  </p>\n<table>\n<thead>\n<tr>\n<th>To create a Char literal to assign to a variable or constant</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1.  Declare the variable or constant as <code>Char</code>.<br>2.  Enclose the character value in quotation marks (<code>&quot; &quot;</code>).<br>3.  Follow the closing double quotation mark with the literal type character <code>C</code> to force the literal to <code>Char</code>. This is necessary if the type checking switch (<a href=\"../../../language-reference/statements/option-strict-statement\" data-linktype=\"relative-path\">Option Strict Statement</a>) is <code>On</code>, and it is desirable in any case.</td>\n</tr>\n</tbody>\n</table>\n<p> The following example demonstrates both unsuccessful and successful assignments of a literal to a <code>Char</code> variable.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrDataTypes#12\">    Dim charVar As Char\n    &#39; The following statement attempts to convert a String literal to Char.\n    &#39; Because Option Strict is On, it generates a compiler error.\n    charVar = &quot;Z&quot;\n    &#39; The following statement succeeds because it specifies a Char literal.\n    charVar = &quot;Z&quot;c\n    &#39; The following statement succeeds because it converts String to Char.\n    charVar = CChar(&quot;Z&quot;)\n</code></pre><p> There is always a risk in using narrowing conversions, because they can fail at run time. For example, a conversion from <code>String</code> to <code>Char</code> can fail if the <code>String</code> value contains more than one character. Therefore, it is better programming to use the <code>C</code> type character.  </p>\n<h2 id=\"string-conversion-fails-at-run-time\">String Conversion Fails at Run Time</h2>\n<p> The <a href=\"../../../language-reference/data-types/string-data-type\" data-linktype=\"relative-path\">String Data Type</a> participates in very few widening conversions. <code>String</code> widens only to itself and <code>Object</code>, and only <code>Char</code> and <code>Char()</code> (a <code>Char</code> array) widen to <code>String</code>. This is because <code>String</code> variables and constants can contain values that other data types cannot contain.  </p>\n<p> When the type checking switch (<a href=\"../../../language-reference/statements/option-strict-statement\" data-linktype=\"relative-path\">Option Strict Statement</a>) is <code>On</code>, the compiler disallows all implicit narrowing conversions. This includes those involving <code>String</code>. Your code can still use conversion keywords such as <code>CStr</code> and <a href=\"../../../language-reference/functions/ctype-function\" data-linktype=\"relative-path\">CType Function</a>, which direct the .NET Framework to attempt the conversion.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The narrowing-conversion error is suppressed for conversions from the elements in a <code>For Each…Next</code> collection to the loop control variable. For more information and examples, see the &quot;Narrowing Conversions&quot; section in <a href=\"../../../language-reference/statements/for-each-next-statement\" data-linktype=\"relative-path\">For Each...Next Statement</a>.  </p>\n</div>\n<h3 id=\"narrowing-conversion-protection\">Narrowing Conversion Protection</h3>\n<p> The disadvantage of narrowing conversions is that they can fail at run time. For example, if a <code>String</code> variable contains anything other than &quot;True&quot; or &quot;False,&quot; it cannot be converted to <code>Boolean</code>. If it contains punctuation characters, conversion to any numeric type fails. Unless you know that your <code>String</code> variable always holds values that the destination type can accept, you should not try a conversion.  </p>\n<p> If you must convert from <code>String</code> to another data type, the safest procedure is to enclose the attempted conversion in the <a href=\"../../../language-reference/statements/try-catch-finally-statement\" data-linktype=\"relative-path\">Try...Catch...Finally Statement</a>. This lets you deal with a run-time failure.  </p>\n<h3 id=\"character-arrays\">Character Arrays</h3>\n<p> A single <code>Char</code> and an array of <code>Char</code> elements both widen to <code>String</code>. However, <code>String</code> does not widen to <code>Char()</code>. To convert a <code>String</code> value to a <code>Char</code> array, you can use the <a class=\"xref\" href=\"../../../../../api/system.string#System_String_ToCharArray_\" data-linktype=\"relative-path\">ToCharArray</a> method of the <a class=\"xref\" href=\"../../../../../api/system.string\" data-linktype=\"relative-path\">System.String</a> class.  </p>\n<h3 id=\"meaningless-values\">Meaningless Values</h3>\n<p> In general, <code>String</code> values are not meaningful in other data types, and conversion is highly artificial and dangerous. Whenever possible, you should restrict usage of <code>String</code> variables to the character sequences for which they are designed. You should never write code that relies on equivalent values in other types.  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"index\" data-linktype=\"relative-path\">Data Types</a><br> <a href=\"type-characters\" data-linktype=\"relative-path\">Type Characters</a><br> <a href=\"value-types-and-reference-types\" data-linktype=\"relative-path\">Value Types and Reference Types</a><br> <a href=\"type-conversions\" data-linktype=\"relative-path\">Type Conversions in Visual Basic</a><br> <a href=\"../../../language-reference/data-types/data-type-summary\" data-linktype=\"relative-path\">Data Types</a><br> <a href=\"../../../language-reference/functions/type-conversion-functions\" data-linktype=\"relative-path\">Type Conversion Functions</a><br> <a href=\"efficient-use-of-data-types\" data-linktype=\"relative-path\">Efficient Use of Data Types</a></p>\n</div></div>","outputRootRelativePath":"../../../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"shoag\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet/toc2.json\">\r\n<meta name=\"ms.suite\" content=\"\">\r\n<meta name=\"ms.custom\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"90040d67-b630-4125-a6ae-37195b079042\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"29\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-visual-basic\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"ms.reviewer\" content=\"\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md\">\r\n<meta name=\"document_id\" content=\"8be5ab1c-41b7-4068-aa00-7c1c47e9cfd1\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"shoag","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Troubleshooting Data Types (Visual Basic) | Microsoft Docs","ms.suite":"","ms.custom":"","ms.assetid":"90040d67-b630-4125-a6ae-37195b079042","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":29,"ms.topic":"article","dev_langs":["vb"],"helpviewer_keywords":["Char data type, converting","Decimal data type, conversions","data types [Visual Basic], troubleshooting","literals, default types","type characters, literal","Mod operator [Visual Basic], in floating-point operations","troubleshooting Visual Basic, data types","troubleshooting data types","floating-point numbers, precision","Boolean data type, converting","literal types","literal type characters","floating-point numbers, imprecision","String data type, converting","floating-point numbers, comparison","floating-point numbers"],"ms.date":"2015-07-20","ms.technology":["devlang-visual-basic"],"ms.prod":".net","ms.reviewer":"","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md","document_id":"8be5ab1c-41b7-4068-aa00-7c1c47e9cfd1","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types","toc_asset_id":"articles/visual-basic/programming-guide/language-features/data-types/toc.json","toc_rel":"toc.json","_op_ogTitle":"Troubleshooting Data Types (Visual Basic)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":1487,"_op_rawTitle":"<h1 id=\"troubleshooting-data-types-visual-basic\" sourcefile=\"docs/visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.md\" sourcestartlinenumber=\"51\" sourceendlinenumber=\"51\">Troubleshooting Data Types (Visual Basic)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types","fileRelativePath":"articles/visual-basic/programming-guide/language-features/data-types/troubleshooting-data-types.html"},"themesRelativePathToOutputRoot":"_themes/"}