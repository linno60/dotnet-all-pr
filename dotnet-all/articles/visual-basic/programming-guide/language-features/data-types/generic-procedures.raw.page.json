{"content":"<div><div class=\"content\">\n<p>A <em>generic procedure</em>, also called a <em>generic method</em>, is a procedure defined with at least one type parameter. This allows the calling code to tailor the data types to its requirements each time it calls the procedure.  </p>\n<p> A procedure is not generic simply by virtue of being defined inside a generic class or a generic structure. To be generic, the procedure must take at least one type parameter, in addition to any normal parameters it might take. A generic class or structure can contain nongeneric procedures, and a nongeneric class, structure, or module can contain generic procedures.  </p>\n<p> A generic procedure can use its type parameters in its normal parameter list, in its return type if it has one, and in its procedure code.  </p>\n<h2 id=\"type-inference\">Type Inference</h2>\n<p> You can call a generic procedure without supplying any type arguments at all. If you call it this way, the compiler attempts to determine the appropriate data types to pass to the procedure&#39;s type arguments. This is called <em>type inference</em>. The following code shows a call in which the compiler infers that it should pass type <code>String</code> to the type parameter <code>t</code>.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrDataTypes#15\">    Public Sub testSub(Of t)(ByVal arg As t)\n    End Sub\n    Public Sub callTestSub()\n        testSub(&quot;Use this string&quot;)\n    End Sub\n</code></pre><p> If the compiler cannot infer the type arguments from the context of your call, it reports an error. One possible cause of such an error is an array rank mismatch. For example, suppose you define a normal parameter as an array of a type parameter. If you call the generic procedure supplying an array of a different rank (number of dimensions), the mismatch causes type inference to fail. The following code shows a call in which a two-dimensional array is passed to a procedure that expects a one-dimensional array.  </p>\n<p> <code>Public Sub demoSub(Of t)(ByVal arg() As t)</code>  </p>\n<p> <code>End Sub</code>  </p>\n<p> <code>Public Sub callDemoSub()</code>  </p>\n<p> <code>Dim twoDimensions(,) As Integer</code>  </p>\n<p> <code>demoSub(twoDimensions)</code>  </p>\n<p> <code>End Sub</code>  </p>\n<p> You can invoke type inference only by omitting all the type arguments. If you supply one type argument, you must supply them all.  </p>\n<p> Type inference is supported only for generic procedures. You cannot invoke type inference on generic classes, structures, interfaces, or delegates.  </p>\n<h2 id=\"example\">Example</h2>\n<h3 id=\"description\">Description</h3>\n<p> The following example defines a generic <code>Function</code> procedure to find a particular element in an array. It defines one type parameter and uses it to construct the two parameters in the parameter list.  </p>\n<h3 id=\"code\">Code</h3>\n<pre><code class=\"lang-vb\" name=\"VbVbalrDataTypes#14\">    Public Function findElement(Of T As IComparable) (\n            ByVal searchArray As T(), ByVal searchValue As T) As Integer\n\n        If searchArray.GetLength(0) &gt; 0 Then\n            For i As Integer = 0 To searchArray.GetUpperBound(0)\n                If searchArray(i).CompareTo(searchValue) = 0 Then Return i\n            Next i\n        End If\n\n        Return -1\n    End Function\n</code></pre><h3 id=\"comments\">Comments</h3>\n<p> The preceding example requires the ability to compare <code>searchValue</code> against each element of <code>searchArray</code>. To guarantee this ability, it constrains the type parameter <code>T</code> to implement the <a class=\"xref\" href=\"../../../../../api/system.icomparable-1\" data-linktype=\"relative-path\">IComparable&lt;T&gt;</a> interface. The code uses the <a class=\"xref\" href=\"../../../../../api/system.icomparable-1#System_IComparable_1_CompareTo_\" data-linktype=\"relative-path\">CompareTo</a> method instead of the <code>=</code> operator, because there is no guarantee that a type argument supplied for <code>T</code> supports the <code>=</code> operator.  </p>\n<p> You can test the <code>findElement</code> procedure with the following code.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrDataTypes#13\">    Public Sub tryFindElement()\n        Dim stringArray() As String = {&quot;abc&quot;, &quot;def&quot;, &quot;xyz&quot;}\n        Dim stringSearch As String = &quot;abc&quot;\n        Dim integerArray() As Integer = {7, 8, 9}\n        Dim integerSearch As Integer = 8\n        Dim dateArray() As Date = {#4/17/1969#, #9/20/1998#, #5/31/2004#}\n        Dim dateSearch As Date = Microsoft.VisualBasic.DateAndTime.Today\n        MsgBox(CStr(findElement(Of String)(stringArray, stringSearch)))\n        MsgBox(CStr(findElement(Of Integer)(integerArray, integerSearch)))\n        MsgBox(CStr(findElement(Of Date)(dateArray, dateSearch)))\n    End Sub\n</code></pre><p> The preceding calls to <code>MsgBox</code> display &quot;0&quot;, &quot;1&quot;, and &quot;-1&quot; respectively.  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"generic-types\" data-linktype=\"relative-path\">Generic Types in Visual Basic</a><br> <a href=\"how-to-define-a-class-that-can-provide-identical-functionality\" data-linktype=\"relative-path\">How to: Define a Class That Can Provide Identical Functionality on Different Data Types</a><br> <a href=\"how-to-use-a-generic-class\" data-linktype=\"relative-path\">How to: Use a Generic Class</a><br> <a href=\"../procedures/index\" data-linktype=\"relative-path\">Procedures</a><br> <a href=\"../procedures/procedure-parameters-and-arguments\" data-linktype=\"relative-path\">Procedure Parameters and Arguments</a><br> <a href=\"../../../language-reference/statements/type-list\" data-linktype=\"relative-path\">Type List</a><br> <a href=\"../../../language-reference/statements/parameter-list\" data-linktype=\"relative-path\">Parameter List</a></p>\n</div></div>","outputRootRelativePath":"../../../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"shoag\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc2.json\">\r\n<meta name=\"ms.suite\" content=\"\">\r\n<meta name=\"ms.custom\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"95577b28-137f-4d5c-a149-919c828600e5\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"11\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-visual-basic\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"ms.reviewer\" content=\"\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-21 01:42 AM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/visual-basic/programming-guide/language-features/data-types/generic-procedures.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/visual-basic/programming-guide/language-features/data-types/generic-procedures.md\">\r\n<meta name=\"document_id\" content=\"f443f538-2c3a-8b3f-32d5-e6918f0550e3\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"shoag","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Generic Procedures in Visual Basic | Microsoft Docs","ms.suite":"","ms.custom":"","ms.assetid":"95577b28-137f-4d5c-a149-919c828600e5","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":11,"ms.topic":"article","dev_langs":["vb"],"helpviewer_keywords":["generic methods, type inference","generics [Visual Basic], type inference","procedures, generic","generic procedures","type inference, generics","generic methods","type inference","generics [Visual Basic], procedures","generic procedures, type inference"],"ms.date":"2015-07-20","ms.technology":["devlang-visual-basic"],"ms.prod":".net","ms.reviewer":"","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2017-03-21 01:42 AM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"3/21/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/visual-basic/programming-guide/language-features/data-types/generic-procedures.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/visual-basic/programming-guide/language-features/data-types/generic-procedures.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/visual-basic/programming-guide/language-features/data-types/generic-procedures.md","document_id":"f443f538-2c3a-8b3f-32d5-e6918f0550e3","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/visual-basic/programming-guide/language-features/data-types/generic-procedures","toc_asset_id":"articles/visual-basic/programming-guide/language-features/data-types/toc.json","toc_rel":"toc.json","_op_ogTitle":"Generic Procedures in Visual Basic","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":603,"_op_rawTitle":"<h1 id=\"generic-procedures-in-visual-basic\" sourcefile=\"docs/visual-basic/programming-guide/language-features/data-types/generic-procedures.md\" sourcestartlinenumber=\"44\" sourceendlinenumber=\"44\">Generic Procedures in Visual Basic</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/visual-basic/programming-guide/language-features/data-types/generic-procedures","fileRelativePath":"articles/visual-basic/programming-guide/language-features/data-types/generic-procedures.html"},"themesRelativePathToOutputRoot":"_themes/"}