{"content":"<div><div class=\"content\">\n<p>Visual Basic supports anonymous types, which enable you to create objects without writing a class definition for the data type. Instead, the compiler generates a class for you. The class has no usable name, inherits directly from <a class=\"xref\" href=\"../../../../../api/system.object\" data-linktype=\"relative-path\">Object</a>, and contains the properties you specify in declaring the object. Because the name of the data type is not specified, it is referred to as an <em>anonymous type</em>.  </p>\n<p> The following example declares and creates variable <code>product</code> as an instance of an anonymous type that has two properties, <code>Name</code> and <code>Price</code>.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrAnonymousTypes#1\">&#39; Variable product is an instance of a simple anonymous type.\nDim product = New With {Key .Name = &quot;paperclips&quot;, .Price = 1.29}\n</code></pre><p> A <em>query expression</em> uses anonymous types to combine columns of data selected by a query. You cannot define the type of the result in advance, because you cannot predict the columns a particular query might select. Anonymous types enable you to write a query that selects any number of columns, in any order. The compiler creates a data type that matches the specified properties and the specified order.  </p>\n<p> In the following examples, <code>products</code> is a list of product objects, each of which has many properties. Variable <code>namePriceQuery</code> holds the definition of a query that, when it is executed, returns a collection of instances of an anonymous type that has two properties, <code>Name</code> and <code>Price</code>.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrAnonymousTypes#2\">Dim namePriceQuery = From prod In products\n                     Select prod.Name, prod.Price\n</code></pre><p> Variable <code>nameQuantityQuery</code> holds the definition of a query that, when it is executed, returns a collection of instances of an anonymous type that has two properties, <code>Name</code> and <code>OnHand</code>.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrAnonymousTypes#3\">Dim nameQuantityQuery = From prod In products\n                        Select prod.Name, prod.OnHand\n</code></pre><p> For more information about the code created by the compiler for an anonymous type, see <a href=\"anonymous-type-definition\" data-linktype=\"relative-path\">Anonymous Type Definition</a>.  </p>\n<div class=\"CAUTION\"><h5>Caution</h5><p> The name of the anonymous type is compiler generated and may vary from compilation to compilation. Your code should not use or rely on the name of an anonymous type because the name might change when a project is recompiled.  </p>\n</div>\n<h2 id=\"declaring-an-anonymous-type\">Declaring an Anonymous Type</h2>\n<p> The declaration of an instance of an anonymous type uses an initializer list to specify the properties of the type. You can specify only properties when you declare an anonymous type, not other class elements such as methods or events. In the following example, <code>product1</code> is an instance of an anonymous type that has two properties: <code>Name</code> and <code>Price</code>.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrAnonymousTypes#4\">&#39; Variable product1 is an instance of a simple anonymous type.\nDim product1 = New With {.Name = &quot;paperclips&quot;, .Price = 1.29}\n&#39; -or-\n&#39; product2 is an instance of an anonymous type with key properties.\nDim product2 = New With {Key .Name = &quot;paperclips&quot;, Key .Price = 1.29}\n</code></pre><p> If you designate properties as key properties, you can use them to compare two anonymous type instances for equality. However, the values of key properties cannot be changed. See the Key Properties section later in this topic for more information.  </p>\n<p> Notice that declaring an instance of an anonymous type is like declaring an instance of a named type by using an object initializer:  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrAnonymousTypes#5\">&#39; Variable product3 is an instance of a class named Product.\nDim product3 = New Product With {.Name = &quot;paperclips&quot;, .Price = 1.29}\n</code></pre><p> For more information about other ways to specify anonymous type properties, see <a href=\"how-to-infer-property-names-and-types-in-anonymous-type-declarations\" data-linktype=\"relative-path\">How to: Infer Property Names and Types in Anonymous Type Declarations</a>.  </p>\n<h2 id=\"key-properties\">Key Properties</h2>\n<p> Key properties differ from non-key properties in several fundamental ways:  </p>\n<ul>\n<li><p>Only the values of key properties are compared in order to determine whether two instances are equal.  </p>\n</li>\n<li><p>The values of key properties are read-only and cannot be changed.  </p>\n</li>\n<li><p>Only key property values are included in the compiler-generated hash code algorithm for an anonymous type.  </p>\n</li>\n</ul>\n<h3 id=\"equality\">Equality</h3>\n<p> Instances of anonymous types can be equal only if they are instances of the same anonymous type. The compiler treats two instances as instances of the same type if they meet the following conditions:  </p>\n<ul>\n<li><p>They are declared in the same assembly.  </p>\n</li>\n<li><p>Their properties have the same names, the same inferred types, and are declared in the same order. Name comparisons are not case-sensitive.  </p>\n</li>\n<li><p>The same properties in each are marked as key properties.  </p>\n</li>\n<li><p>At least one property in each declaration is a key property.  </p>\n<p>An instance of an anonymous types that has no key properties is equal only to itself.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrAnonymousTypes#6\">&#39; prod1 and prod2 have no key values.\nDim prod1 = New With {.Name = &quot;paperclips&quot;, .Price = 1.29}\nDim prod2 = New With {.Name = &quot;paperclips&quot;, .Price = 1.29}\n\n&#39; The following line displays False, because prod1 and prod2 have no\n&#39; key properties.\nConsole.WriteLine(prod1.Equals(prod2))\n\n&#39; The following statement displays True because prod1 is equal to itself.\nConsole.WriteLine(prod1.Equals(prod1))\n</code></pre><p>Two instances of the same anonymous type are equal if the values of their key properties are equal. The following examples illustrate how equality is tested.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrAnonymousTypes#7\">Dim prod3 = New With {Key .Name = &quot;paperclips&quot;, Key .Price = 1.29}\nDim prod4 = New With {Key .Name = &quot;paperclips&quot;, Key .Price = 1.29}\n&#39; The following line displays True, because prod3 and prod4 are\n&#39; instances of the same anonymous type, and the values of their\n&#39; key properties are equal.\nConsole.WriteLine(prod3.Equals(prod4))\n\nDim prod5 = New With {Key .Name = &quot;paperclips&quot;, Key .Price = 1.29}\nDim prod6 = New With {Key .Name = &quot;paperclips&quot;, Key .Price = 1.29,\n                      .OnHand = 423}\n&#39; The following line displays False, because prod5 and prod6 do not \n&#39; have the same properties.\nConsole.WriteLine(prod5.Equals(prod6))\n\nDim prod7 = New With {Key .Name = &quot;paperclips&quot;, Key .Price = 1.29,\n                      .OnHand = 24}\nDim prod8 = New With {Key .Name = &quot;paperclips&quot;, Key .Price = 1.29,\n                      .OnHand = 423}\n&#39; The following line displays True, because prod7 and prod8 are\n&#39; instances of the same anonymous type, and the values of their\n&#39; key properties are equal. The equality check does not compare the\n&#39; values of the non-key field.\nConsole.WriteLine(prod7.Equals(prod8))\n</code></pre></li>\n</ul>\n<h3 id=\"read-only-values\">Read-Only Values</h3>\n<p> The values of key properties cannot be changed. For example, in <code>prod8</code> in the previous example, the <code>Name</code> and <code>Price</code> fields are <code>read-only</code>, but <code>OnHand</code> can be changed.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrAnonymousTypes#8\">&#39; The following statement will not compile, because Name is a key\n&#39; property and its value cannot be changed.\n&#39; prod8.Name = &quot;clamps&quot;\n\n&#39; OnHand is not a Key property. Its value can be changed.\nprod8.OnHand = 22\n</code></pre><h2 id=\"anonymous-types-from-query-expressions\">Anonymous Types from Query Expressions</h2>\n<p> Query expressions do not always require the creation of anonymous types. When possible, they use an existing type to hold the column data. This occurs when the query returns either whole records from the data source, or only one field from each record. In the following code examples, <code>customers</code> is a collection of objects of a <code>Customer</code> class. The class has many properties, and you can include one or more of them in the query result, in any order. In the first two examples, no anonymous types are required because the queries select elements of named types:  </p>\n<ul>\n<li><p><code>custs1</code> contains a collection of strings, because <code>cust.Name</code> is a string.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrAnonymousTypes#30\">Dim custs1 = From cust In customers\n             Select cust.Name\n</code></pre></li>\n<li><p><code>custs2</code> contains a collection of <code>Customer</code> objects, because each element of <code>customers</code> is a <code>Customer</code> object, and the whole element is selected by the query.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrAnonymousTypes#31\">Dim custs2 = From cust In customers\n             Select cust\n</code></pre><p>However, appropriate named types are not always available. You might want to select customer names and addresses for one purpose, customer ID numbers and locations for another, and customer names, addresses, and order histories for a third. Anonymous types enable you to select any combination of properties, in any order, without first declaring a new named type to hold the result. Instead, the compiler creates an anonymous type for each compilation of properties. The following query selects only the customer&#39;s name and ID number from each <code>Customer</code> object in <code>customers</code>. Therefore, the compiler creates an anonymous type that contains only those two properties.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrAnonymousTYpes#32\">Dim custs3 = From cust In customers\n             Select cust.Name, cust.ID\n</code></pre><p>Both the names and the data types of the properties in the anonymous type are taken from the arguments to <code>Select</code>, <code>cust.Name</code> and <code>cust.ID</code>. The properties in an anonymous type that is created by a query are always key properties. When <code>custs3</code> is executed in the following <code>For Each</code> loop, the result is a collection of instances of an anonymous type with two key properties, <code>Name</code> and <code>ID</code>.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrAnonymousTypes#33\">For Each selectedCust In custs3\n    Console.WriteLine(selectedCust.ID &amp; &quot;: &quot; &amp; selectedCust.Name)\nNext\n</code></pre><p>The elements in the collection represented by <code>custs3</code> are strongly typed, and you can use IntelliSense to navigate through the available properties and to verify their types.  </p>\n<p>For more information, see <a href=\"../linq/introduction-to-linq\" data-linktype=\"relative-path\">Introduction to LINQ in Visual Basic</a>.  </p>\n</li>\n</ul>\n<h2 id=\"deciding-whether-to-use-anonymous-types\">Deciding Whether to Use Anonymous Types</h2>\n<p> Before you create an object as an instance of an anonymous class, consider whether that is the best option. For example, if you want to create a temporary object to contain related data, and you have no need for other fields and methods that a complete class might contain, an anonymous type is a good solution. Anonymous types are also convenient if you want a different selection of properties for each declaration, or if you want to change the order of the properties. However, if your project includes several objects that have the same properties, in a fixed order, you can declare them more easily by using a named type with a class constructor. For example, with an appropriate constructor, it is easier to declare several instances of a <code>Product</code> class than it is to declare several instances of an anonymous type.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrAnonymousTypes#9\">&#39; Declaring instances of a named type.\nDim firstProd1 As New Product(&quot;paperclips&quot;, 1.29)\nDim secondProd1 As New Product(&quot;desklamp&quot;, 28.99)\nDim thirdProd1 As New Product(&quot;stapler&quot;, 5.09)\n\n&#39; Declaring instances of an anonymous type.\nDim firstProd2 = New With {Key .Name = &quot;paperclips&quot;, Key .Price = 1.29}\nDim secondProd2 = New With {Key .Name = &quot;desklamp&quot;, Key .Price = 28.99}\nDim thirdProd2 = New With {Key .Name = &quot;stapler&quot;, Key .Price = 5.09}\n</code></pre><p> Another advantage of named types is that the compiler can catch an accidental mistyping of a property name. In the previous examples, <code>firstProd2</code>, <code>secondProd2</code>, and <code>thirdProd2</code> are intended to be instances of the same anonymous type. However, if you were to accidentally declare <code>thirdProd2</code> in one of the following ways, its type would be different from that of <code>firstProd2</code> and <code>secondProd2</code>.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrAnonymousTypes#10\">&#39; Dim thirdProd2 = New With {Key .Nmae = &quot;stapler&quot;, Key .Price = 5.09}\n&#39; Dim thirdProd2 = New With {Key .Name = &quot;stapler&quot;, Key .Price = &quot;5.09&quot;}\n&#39; Dim thirdProd2 = New With {Key .Name = &quot;stapler&quot;, .Price = 5.09}\n</code></pre><p> More importantly, there are limitations on the use of anonymous types that do not apply to instances of named types. <code>firstProd2</code>, <code>secondProd2</code>, and <code>thirdProd2</code> are instances of the same anonymous type. However, the name for the shared anonymous type is not available and cannot appear where a type name is expected in your code. For example, an anonymous type cannot be used to define a method signature, to declare another variable or field, or in any type declaration. As a result, anonymous types are not appropriate when you have to share information across methods.  </p>\n<h2 id=\"an-anonymous-type-definition\">An Anonymous Type Definition</h2>\n<p> In response to the declaration of an instance of an anonymous type, the compiler creates a new class definition that contains the specified properties.  </p>\n<p> If the anonymous type contains at least one key property, the definition overrides three members inherited from <a class=\"xref\" href=\"../../../../../api/system.object\" data-linktype=\"relative-path\">Object</a>: <a class=\"xref\" href=\"../../../../../api/system.object#System_Object_Equals_\" data-linktype=\"relative-path\">Equals</a>, <a class=\"xref\" href=\"../../../../../api/system.object#System_Object_GetHashCode_\" data-linktype=\"relative-path\">GetHashCode</a>, and <a class=\"xref\" href=\"../../../../../api/system.object#System_Object_ToString_\" data-linktype=\"relative-path\">ToString</a>. The code produced for testing equality and determining the hash code value considers only the key properties. If the anonymous type contains no key properties, only <a class=\"xref\" href=\"../../../../../api/system.object#System_Object_ToString_\" data-linktype=\"relative-path\">ToString</a> is overridden. Explicitly named properties of an anonymous type cannot conflict with these generated methods. That is, you cannot use <code>.Equals</code>, <code>.GetHashCode</code>, or <code>.ToString</code> to name a property.  </p>\n<p> Anonymous type definitions that have at least one key property also implement the <a class=\"xref\" href=\"../../../../../api/system.iequatable-1\" data-linktype=\"relative-path\">System.IEquatable&lt;T&gt;</a> interface, where <code>T</code> is the type of the anonymous type.  </p>\n<p> For more information about the code created by the compiler and the functionality of the overridden methods, see <a href=\"anonymous-type-definition\" data-linktype=\"relative-path\">Anonymous Type Definition</a>.  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"object-initializers-named-and-anonymous-types\" data-linktype=\"relative-path\">Object Initializers: Named and Anonymous Types</a><br> <a href=\"../variables/local-type-inference\" data-linktype=\"relative-path\">Local Type Inference</a><br> <a href=\"../linq/introduction-to-linq\" data-linktype=\"relative-path\">Introduction to LINQ in Visual Basic</a><br> <a href=\"how-to-infer-property-names-and-types-in-anonymous-type-declarations\" data-linktype=\"relative-path\">How to: Infer Property Names and Types in Anonymous Type Declarations</a><br> <a href=\"anonymous-type-definition\" data-linktype=\"relative-path\">Anonymous Type Definition</a><br> <a href=\"../../../language-reference/modifiers/key\" data-linktype=\"relative-path\">Key</a></p>\n</div></div>","outputRootRelativePath":"../../../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"shoag\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"ms.suite\" content=\"\">\r\n<meta name=\"ms.custom\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"7b87532c-4b3e-4398-8503-6ea9d67574a4\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"46\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-visual-basic\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"ms.reviewer\" content=\"\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md\">\r\n<meta name=\"document_id\" content=\"cbb3603b-ffa5-bad5-2bf5-805a568c0b96\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"shoag","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","uhfHeaderId":"MSDocsHeader-DotNet","title":"Anonymous Types (Visual Basic) | Microsoft Docs","ms.suite":"","ms.custom":"","ms.assetid":"7b87532c-4b3e-4398-8503-6ea9d67574a4","f1_keywords":["vb.AnonymousType"],"translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":46,"ms.topic":"article","dev_langs":["vb"],"helpviewer_keywords":["anonymous types [Visual Basic], about anonymous types","anonymous types [Visual Basic]","types [Visual Basic], anonymous"],"ms.date":"2015-07-20","ms.technology":["devlang-visual-basic"],"ms.prod":".net","ms.reviewer":"","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md","document_id":"cbb3603b-ffa5-bad5-2bf5-805a568c0b96","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types","toc_asset_id":"articles/visual-basic/programming-guide/language-features/objects-and-classes/toc.json","toc_rel":"toc.json","_op_ogTitle":"Anonymous Types (Visual Basic)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":2017,"_op_rawTitle":"<h1 id=\"anonymous-types-visual-basic\" sourcefile=\"docs/visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.md\" sourcestartlinenumber=\"40\" sourceendlinenumber=\"40\">Anonymous Types (Visual Basic)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types","fileRelativePath":"articles/visual-basic/programming-guide/language-features/objects-and-classes/anonymous-types.html"},"themesRelativePathToOutputRoot":"_themes/"}