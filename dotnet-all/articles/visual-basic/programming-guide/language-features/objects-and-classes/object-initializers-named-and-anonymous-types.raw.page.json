{"content":"<div><div class=\"content\">\n<p>Object initializers enable you to specify properties for a complex object by using a single expression. They can be used to create instances of named types and of anonymous types.  </p>\n<h2 id=\"declarations\">Declarations</h2>\n<p> Declarations of instances of named and anonymous types can look almost identical, but their effects are not the same. Each category has abilities and restrictions of its own. The following example shows a convenient way to declare and initialize an instance of a named class, <code>Customer</code>, by using an object initializer list. Notice that the name of the class is specified after the keyword <code>New</code>.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrObjectInit#1\">Dim namedCust = New Customer With {.Name = &quot;Terry Adams&quot;}\n</code></pre><p> An anonymous type has no usable name. Therefore an instantiation of an anonymous type cannot include a class name.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrObjectInit#2\">Dim anonymousCust = New With {.Name = &quot;Hugo Garcia&quot;}\n</code></pre><p> The requirements and results of the two declarations are not the same. For <code>namedCust</code>, a <code>Customer</code> class that has a <code>Name</code> property must already exist, and the declaration creates an instance of that class. For <code>anonymousCust</code>, the compiler defines a new class that has one property, a string called <code>Name</code>, and creates a new instance of that class.  </p>\n<h2 id=\"named-types\">Named Types</h2>\n<p> Object initializers provide a simple way to call the constructor of a type and then set the values of some or all properties in a single statement. The compiler invokes the appropriate constructor for the statement: the default constructor if no arguments are presented, or a parameterized constructor if one or more arguments are sent. After that, the specified properties are initialized in the order in which they are presented in the initializer list.  </p>\n<p> Each initialization in the initializer list consists of the assignment of an initial value to a member of the class. The names and data types of the members are determined when the class is defined. In the following examples, the <code>Customer</code> class must exist, and must have members named <code>Name</code> and <code>City</code> that can accept string values.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrObjectInit#3\">Dim cust0 As Customer = New Customer With {.Name = &quot;Toni Poe&quot;, \n                                           .City = &quot;Louisville&quot;}\n</code></pre><p> Alternatively, you can obtain the same result by using the following code:  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrObjectInit#4\">Dim cust1 As New Customer With {.Name = &quot;Toni Poe&quot;, \n                                .City = &quot;Louisville&quot;}\n</code></pre><p> Each of these declarations is equivalent to the following example, which creates a <code>Customer</code> object by using the default constructor, and then specifies initial values for the <code>Name</code> and <code>City</code> properties by using a <code>With</code> statement.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrObjectInit#5\">Dim cust2 As New Customer()\nWith cust2\n    .Name = &quot;Toni Poe&quot;\n    .City = &quot;Louisville&quot;\nEnd With\n</code></pre><p> If the <code>Customer</code> class contains a parameterized constructor that enables you to send in a value for <code>Name</code>, for example, you can also declare and initialize a <code>Customer</code> object in the following ways:  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrObjectInit#6\">Dim cust3 As Customer = \n    New Customer(&quot;Toni Poe&quot;) With {.City = &quot;Louisville&quot;}\n&#39; --or--\nDim cust4 As New Customer(&quot;Toni Poe&quot;) With {.City = &quot;Louisville&quot;}\n</code></pre><p> You do not have to initialize all properties, as the following code shows.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrObjectInit#7\">Dim cust5 As Customer = New Customer With {.Name = &quot;Toni Poe&quot;}\n</code></pre><p> However, the initialization list cannot be empty. Uninitialized properties retain their default values.  </p>\n<h3 id=\"type-inference-with-named-types\">Type Inference with Named Types</h3>\n<p> You can shorten the code for the declaration of <code>cust1</code> by combining object initializers and local type inference. This enables you to omit the <code>As</code> clause in the variable declaration. The data type of the variable is inferred from the type of the object that is created by the assignment. In the following example, the type of <code>cust6</code> is <code>Customer</code>.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrObjectInit#8\">Dim cust6 = New Customer With {.Name = &quot;Toni Poe&quot;, \n                               .City = &quot;Louisville&quot;}\n</code></pre><h3 id=\"remarks-about-named-types\">Remarks About Named Types</h3>\n<ul>\n<li><p>A class member cannot be initialized more than one time in the object initializer list. The declaration of <code>cust7</code> causes an error.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrObjectInit#9\">&#39;&#39; This code does not compile because Name is initialized twice.\n&#39; Dim cust7 = New Customer With {.Name = &quot;Toni Poe&quot;, \n&#39;                                .City = &quot;Louisville&quot;,\n&#39;                                .Name = &quot;Blue Yonder Airlines&quot;}\n</code></pre></li>\n<li><p>A member can be used to initialize itself or another field. If a member is accessed before it has been initialized, as in the following declaration for <code>cust8</code>, the default value will be used. Remember that when a declaration that uses an object initializer is processed, the first thing that happens is that the appropriate constructor is invoked. After that, the individual fields in the initializer list are initialized. In the following examples, the default value for <code>Name</code> is assigned for <code>cust8</code>, and an initialized value is assigned in <code>cust9</code>.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrObjectInit#10\">Dim cust8 = New Customer With {.Name = .Name &amp; &quot;, President&quot;}\nDim cust9 = New Customer With {.Name = &quot;Toni Poe&quot;, \n                               .Title = .Name &amp; &quot;, President&quot;}\n</code></pre><p> The following example uses the parameterized constructor from <code>cust3</code> and <code>cust4</code> to declare and initialize <code>cust10</code> and <code>cust11</code>.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrObjectInit#11\">Dim cust10 = New Customer(&quot;Toni Poe&quot;) With {.Name = .Name &amp; &quot;, President&quot;}\n&#39; --or--\nDim cust11 As New Customer(&quot;Toni Poe&quot;) With {.Name = .Name &amp; &quot;, President&quot;}\n</code></pre></li>\n<li><p>Object initializers can be nested. In the following example, <code>AddressClass</code> is a class that has two properties, <code>City</code> and <code>State</code>, and the <code>Customer</code> class has an <code>Address</code> property that is an instance of <code>AddressClass</code>.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrObjectInit#12\">Dim cust12 = \n    New Customer With {.Name = &quot;Toni Poe&quot;, \n                       .Address = \n                           New AddressClass With {.City = &quot;Louisville&quot;, \n                                                  .State = &quot;Kentucky&quot;}}\nConsole.WriteLine(cust12.Address.State)\n</code></pre></li>\n<li><p>The initialization list cannot be empty.  </p>\n</li>\n<li><p>The instance being initialized cannot be of type Object.  </p>\n</li>\n<li><p>Class members being initialized cannot be shared members, read-only members, constants, or method calls.  </p>\n</li>\n<li><p>Class members being initialized cannot be indexed or qualified. The following examples raise compiler errors:  </p>\n<p> <code>&#39;&#39; Not valid.</code>  </p>\n<p> <code>&#39; Dim c1 = New Customer With {.OrderNumbers(0) = 148662}</code>  </p>\n<p> <code>&#39; Dim c2 = New Customer with {.Address.City = &quot;Springfield&quot;}</code>  </p>\n</li>\n</ul>\n<h2 id=\"anonymous-types\">Anonymous Types</h2>\n<p> Anonymous types use object initializers to create instances of new types that you do not explicitly define and name. Instead, the compiler generates a type according to the properties you designate in the object initializer list. Because the name of the type is not specified, it is referred to as an <em>anonymous type</em>. For example, compare the following declaration to the earlier one for <code>cust6</code>.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrObjectInit#13\">Dim cust13 = New With {.Name = &quot;Toni Poe&quot;, \n                       .City = &quot;Louisville&quot;}\n</code></pre><p> The only difference syntactically is that no name is specified after <code>New</code> for the data type. However, what happens is quite different. The compiler defines a new anonymous type that has two properties, <code>Name</code> and <code>City</code>, and creates an instance of it with the specified values. Type inference determines the types of <code>Name</code> and <code>City</code> in the example to be strings.  </p>\n<div class=\"CAUTION\"><h5>Caution</h5><p> The name of the anonymous type is generated by the compiler, and may vary from compilation to compilation. Your code should not use or rely on the name of an anonymous type.  </p>\n</div>\n<p> Because the name of the type is not available, you cannot use an <code>As</code> clause to declare <code>cust13</code>. Its type must be inferred. Without using late binding, this limits the use of anonymous types to local variables.  </p>\n<p> Anonymous types provide critical support for LINQ queries. For more information about the use of anonymous types in queries, see <a href=\"anonymous-types\" data-linktype=\"relative-path\">Anonymous Types</a> and <a href=\"../linq/introduction-to-linq\" data-linktype=\"relative-path\">Introduction to LINQ in Visual Basic</a>.  </p>\n<h3 id=\"remarks-about-anonymous-types\">Remarks About Anonymous Types</h3>\n<ul>\n<li><p>Typically, all or most of the properties in an anonymous type declaration will be key properties, which are indicated by typing the keyword <code>Key</code> in front of the property name.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrObjectInit#14\">\nDim anonymousCust1 = New With {Key .Name = &quot;Hugo Garcia&quot;, \n                               Key .City = &quot;Louisville&quot;}\n</code></pre><p> For more information about key properties, see <a href=\"../../../language-reference/modifiers/key\" data-linktype=\"relative-path\">Key</a>.  </p>\n</li>\n<li><p>Like named types, initializer lists for anonymous type definitions must declare at least one property.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrObjectInit#2\">Dim anonymousCust = New With {.Name = &quot;Hugo Garcia&quot;}\n</code></pre></li>\n<li><p>When an instance of an anonymous type is declared, the compiler generates a matching anonymous type definition. The names and data types of the properties are taken from the instance declaration, and are included by the compiler in the definition. The properties are not named and defined in advance, as they would be for a named type. Their types are inferred. You cannot specify the data types of the properties by using an <code>As</code> clause.  </p>\n</li>\n<li><p>Anonymous types can also establish the names and values of their properties in several other ways. For example, an anonymous type property can take both the name and the value of a variable, or the name and value of a property of another object.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrObjectInit#15\">&#39; Create a variable, Name, and give it an initial value.\nDim Name = &quot;Hugo Garcia&quot;\n\n&#39; Variable anonymousCust2 will have one property, Name, with \n&#39; &quot;Hugo Garcia&quot; as its initial value.\nDim anonymousCust2 = New With {Key Name}\n\n&#39; The next declaration uses a property from namedCust, defined\n&#39; in an earlier example. After the declaration, anonymousCust3 will\n&#39; have one property, Name, with &quot;Terry Adams&quot; as its value.\nDim anonymousCust3 = New With {Key namedCust.Name}\n</code></pre><p> For more information about the options for defining properties in anonymous types, see <a href=\"how-to-infer-property-names-and-types-in-anonymous-type-declarations\" data-linktype=\"relative-path\">How to: Infer Property Names and Types in Anonymous Type Declarations</a>.  </p>\n</li>\n</ul>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../variables/local-type-inference\" data-linktype=\"relative-path\">Local Type Inference</a><br> <a href=\"anonymous-types\" data-linktype=\"relative-path\">Anonymous Types</a><br> <a href=\"../linq/introduction-to-linq\" data-linktype=\"relative-path\">Introduction to LINQ in Visual Basic</a><br> <a href=\"how-to-infer-property-names-and-types-in-anonymous-type-declarations\" data-linktype=\"relative-path\">How to: Infer Property Names and Types in Anonymous Type Declarations</a><br> <a href=\"../../../language-reference/modifiers/key\" data-linktype=\"relative-path\">Key</a><br> <a href=\"how-to-declare-an-object-by-using-an-object-initializer\" data-linktype=\"relative-path\">How to: Declare an Object by Using an Object Initializer</a></p>\n</div></div>","outputRootRelativePath":"../../../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"shoag\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"ms.suite\" content=\"\">\r\n<meta name=\"ms.custom\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"e2df3807-a70f-49dd-ac94-f1e07f472b1b\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"27\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-visual-basic\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"ms.reviewer\" content=\"\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/visual-basic/programming-guide/language-features/objects-and-classes/object-initializers-named-and-anonymous-types.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/programming-guide/language-features/objects-and-classes/object-initializers-named-and-anonymous-types.md\">\r\n<meta name=\"document_id\" content=\"91d9cba0-47e6-d329-7df2-73a33bf1da17\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"shoag","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Object Initializers: Named and Anonymous Types (Visual Basic) | Microsoft Docs","ms.suite":"","ms.custom":"","ms.assetid":"e2df3807-a70f-49dd-ac94-f1e07f472b1b","f1_keywords":["vb.ObjectInitializer"],"translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":27,"ms.topic":"article","dev_langs":["vb"],"helpviewer_keywords":["object initializers [Visual Basic]","anonymous types [Visual Basic], object initializers","initializing properties [Visual Basic]","initializers [Visual Basic]","named types [Visual Basic]"],"ms.date":"2015-07-20","ms.technology":["devlang-visual-basic"],"ms.prod":".net","ms.reviewer":"","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/visual-basic/programming-guide/language-features/objects-and-classes/object-initializers-named-and-anonymous-types.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/programming-guide/language-features/objects-and-classes/object-initializers-named-and-anonymous-types.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/visual-basic/programming-guide/language-features/objects-and-classes/object-initializers-named-and-anonymous-types.md","document_id":"91d9cba0-47e6-d329-7df2-73a33bf1da17","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/visual-basic/programming-guide/language-features/objects-and-classes/object-initializers-named-and-anonymous-types","toc_asset_id":"articles/visual-basic/programming-guide/language-features/objects-and-classes/toc.json","toc_rel":"toc.json","_op_ogTitle":"Object Initializers: Named and Anonymous Types (Visual Basic)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":1509,"_op_rawTitle":"<h1 id=\"object-initializers-named-and-anonymous-types-visual-basic\" sourcefile=\"docs/visual-basic/programming-guide/language-features/objects-and-classes/object-initializers-named-and-anonymous-types.md\" sourcestartlinenumber=\"42\" sourceendlinenumber=\"42\">Object Initializers: Named and Anonymous Types (Visual Basic)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/visual-basic/programming-guide/language-features/objects-and-classes/object-initializers-named-and-anonymous-types","fileRelativePath":"articles/visual-basic/programming-guide/language-features/objects-and-classes/object-initializers-named-and-anonymous-types.html"},"themesRelativePathToOutputRoot":"_themes/"}