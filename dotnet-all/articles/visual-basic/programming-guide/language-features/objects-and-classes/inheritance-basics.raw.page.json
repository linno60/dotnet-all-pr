{"content":"<div><div class=\"content\">\n<p>The <code>Inherits</code> statement is used to declare a new class, called a <em>derived class</em>, based on an existing class, known as a <em>base class</em>. Derived classes inherit, and can extend, the properties, methods, events, fields, and constants defined in the base class. The following section describes some of the rules for inheritance, and the modifiers you can use to change the way classes inherit or are inherited:  </p>\n<ul>\n<li><p>By default, all classes are inheritable unless marked with the <code>NotInheritable</code> keyword. Classes can inherit from other classes in your project or from classes in other assemblies that your project references.  </p>\n</li>\n<li><p>Unlike languages that allow multiple inheritance, Visual Basic allows only single inheritance in classes; that is, derived classes can have only one base class. Although multiple inheritance is not allowed in classes, classes can implement multiple interfaces, which can effectively accomplish the same ends.  </p>\n</li>\n<li><p>To prevent exposing restricted items in a base class, the access type of a derived class must be equal to or more restrictive than its base class. For example, a <code>Public</code> class cannot inherit a <code>Friend</code> or a <code>Private</code> class, and a <code>Friend</code> class cannot inherit a <code>Private</code> class.  </p>\n</li>\n</ul>\n<h2 id=\"inheritance-modifiers\">Inheritance Modifiers</h2>\n<p> Visual Basic introduces the following class-level statements and modifiers to support inheritance:  </p>\n<ul>\n<li><p><code>Inherits</code> statement — Specifies the base class.  </p>\n</li>\n<li><p><code>NotInheritable</code> modifier — Prevents programmers from using the class as a base class.  </p>\n</li>\n<li><p><code>MustInherit</code> modifier — Specifies that the class is intended for use as a base class only. Instances of <code>MustInherit</code> classes cannot be created directly; they can only be created as base class instances of a derived class. (Other programming languages, such as C++ and C#, use the term <em>abstract class</em> to describe such a class.)  </p>\n</li>\n</ul>\n<h2 id=\"overriding-properties-and-methods-in-derived-classes\">Overriding Properties and Methods in Derived Classes</h2>\n<p> By default, a derived class inherits properties and methods from its base class. If an inherited property or method has to behave differently in the derived class it can be <em>overridden</em>. That is, you can define a new implementation of the method in the derived class. The following modifiers are used to control how properties and methods are overridden:  </p>\n<ul>\n<li><p><code>Overridable</code> — Allows a property or method in a class to be overridden in a derived class.  </p>\n</li>\n<li><p><code>Overrides</code> — Overrides an <code>Overridable</code> property or method defined in the base class.  </p>\n</li>\n<li><p><code>NotOverridable</code> — Prevents a property or method from being overridden in an inheriting class. By default, <code>Public</code> methods are <code>NotOverridable</code>.  </p>\n</li>\n<li><p><code>MustOverride</code> — Requires that a derived class override the property or method. When the <code>MustOverride</code> keyword is used, the method definition consists of just the <code>Sub</code>, <code>Function</code>, or <code>Property</code> statement. No other statements are allowed, and specifically there is no <code>End Sub</code> or <code>End Function</code> statement. <code>MustOverride</code> methods must be declared in <code>MustInherit</code> classes.  </p>\n<p>Suppose you want to define classes to handle payroll. You could define a generic <code>Payroll</code> class that contains a <code>RunPayroll</code> method that calculates payroll for a typical week. You could then use <code>Payroll</code> as a base class for a more specialized <code>BonusPayroll</code> class, which could be used when distributing employee bonuses.  </p>\n<p>The <code>BonusPayroll</code> class can inherit, and override, the <code>PayEmployee</code> method defined in the base <code>Payroll</code> class.  </p>\n<p>The following example defines a base class, <code>Payroll,</code> and a derived class, <code>BonusPayroll</code>, which overrides an inherited method, <code>PayEmployee</code>. A procedure, <code>RunPayroll</code>, creates and then passes a <code>Payroll</code> object and a <code>BonusPayroll</code> object to a function, <code>Pay</code>, that executes the <code>PayEmployee</code> method of both objects.  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrOOP#28\">Const BonusRate As Decimal = 1.45D\nConst PayRate As Decimal = 14.75D\n\nClass Payroll\n    Overridable Function PayEmployee( \n        ByVal HoursWorked As Decimal, \n        ByVal PayRate As Decimal) As Decimal\n\n        PayEmployee = HoursWorked * PayRate\n    End Function\nEnd Class\n\nClass BonusPayroll\n    Inherits Payroll\n    Overrides Function PayEmployee( \n        ByVal HoursWorked As Decimal, \n        ByVal PayRate As Decimal) As Decimal\n\n        &#39; The following code calls the original method in the base \n        &#39; class, and then modifies the returned value.\n        PayEmployee = MyBase.PayEmployee(HoursWorked, PayRate) * BonusRate\n    End Function\nEnd Class\n\nSub RunPayroll()\n    Dim PayrollItem As Payroll = New Payroll\n    Dim BonusPayrollItem As New BonusPayroll\n    Dim HoursWorked As Decimal = 40\n\n    MsgBox(&quot;Normal pay is: &quot; &amp; \n        PayrollItem.PayEmployee(HoursWorked, PayRate))\n    MsgBox(&quot;Pay with bonus is: &quot; &amp; \n        BonusPayrollItem.PayEmployee(HoursWorked, PayRate))\nEnd Sub\n</code></pre></li>\n</ul>\n<h2 id=\"the-mybase-keyword\">The MyBase Keyword</h2>\n<p> The <code>MyBase</code> keyword behaves like an object variable that refers to the base class of the current instance of a class. <code>MyBase</code> is frequently used to access base class members that are overridden or shadowed in a derived class. In particular, <code>MyBase.New</code> is used to explicitly call a base class constructor from a derived class constructor.  </p>\n<p> For example, suppose you are designing a derived class that overrides a method inherited from the base class. The overridden method can call the method in the base class and modify the return value as shown in the following code fragment:  </p>\n<pre><code class=\"lang-vb\" name=\"VbVbalrOOP#109\">Class DerivedClass\n    Inherits BaseClass\n    Public Overrides Function CalculateShipping( \n        ByVal Dist As Double, \n        ByVal Rate As Double) As Double\n\n        &#39; Call the method in the base class and modify the return value.\n        Return MyBase.CalculateShipping(Dist, Rate) * 2\n    End Function\nEnd Class\n</code></pre><p> The following list describes restrictions on using <code>MyBase</code>:  </p>\n<ul>\n<li><p><code>MyBase</code> refers to the immediate base class and its inherited members. It cannot be used to access <code>Private</code> members in the class.  </p>\n</li>\n<li><p><code>MyBase</code> is a keyword, not a real object. <code>MyBase</code> cannot be assigned to a variable, passed to procedures, or used in an <code>Is</code> comparison.  </p>\n</li>\n<li><p>The method that <code>MyBase</code> qualifies does not have to be defined in the immediate base class; it may instead be defined in an indirectly inherited base class. In order for a reference qualified by <code>MyBase</code> to compile correctly, some base class must contain a method matching the name and types of parameters that appear in the call.  </p>\n</li>\n<li><p>You cannot use <code>MyBase</code> to call <code>MustOverride</code> base class methods.  </p>\n</li>\n<li><p><code>MyBase</code> cannot be used to qualify itself. Therefore, the following code is not valid:  </p>\n<p> <code>MyBase.MyBase.BtnOK_Click()</code>  </p>\n</li>\n<li><p><code>MyBase</code> cannot be used in modules.  </p>\n</li>\n<li><p><code>MyBase</code> cannot be used to access base class members that are marked as <code>Friend</code> if the base class is in a different assembly.  </p>\n<p>For more information and another example, see <a href=\"../declared-elements/how-to-access-a-variable-hidden-by-a-derived-class\" data-linktype=\"relative-path\">How to: Access a Variable Hidden by a Derived Class</a>.  </p>\n</li>\n</ul>\n<h2 id=\"the-myclass-keyword\">The MyClass Keyword</h2>\n<p> The <code>MyClass</code> keyword behaves like an object variable that refers to the current instance of a class as originally implemented. <code>MyClass</code> resembles <code>Me</code>, but every method and property call on <code>MyClass</code> is treated as if the method or property were <a href=\"../../../language-reference/modifiers/notoverridable\" data-linktype=\"relative-path\">NotOverridable</a>. Therefore, the method or property is not affected by overriding in a derived class.  </p>\n<ul>\n<li><p><code>MyClass</code> is a keyword, not a real object. <code>MyClass</code> cannot be assigned to a variable, passed to procedures, or used in an <code>Is</code> comparison.  </p>\n</li>\n<li><p><code>MyClass</code> refers to the containing class and its inherited members.  </p>\n</li>\n<li><p><code>MyClass</code> can be used as a qualifier for <code>Shared</code> members.  </p>\n</li>\n<li><p><code>MyClass</code> cannot be used inside a <code>Shared</code> method, but can be used inside an instance method to access a shared member of a class.  </p>\n</li>\n<li><p><code>MyClass</code> cannot be used in standard modules.  </p>\n</li>\n<li><p><code>MyClass</code> can be used to qualify a method that is defined in a base class and that has no implementation of the method provided in that class. Such a reference has the same meaning as <code>MyBase.</code><em>Method</em>.  </p>\n<p>The following example compares <code>Me</code> and <code>MyClass</code>.  </p>\n</li>\n</ul>\n<pre class=\"loading\"><code>Class baseClass  \n    Public Overridable Sub testMethod()  \n        MsgBox(&quot;Base class string&quot;)  \n    End Sub  \n    Public Sub useMe()  \n        &#39; The following call uses the calling class&#39;s method, even if   \n        &#39; that method is an override.  \n        Me.testMethod()  \n    End Sub  \n    Public Sub useMyClass()  \n        &#39; The following call uses this instance&#39;s method and not any  \n        &#39; override.  \n        MyClass.testMethod()  \n    End Sub  \nEnd Class  \nClass derivedClass : Inherits baseClass  \n    Public Overrides Sub testMethod()  \n        MsgBox(&quot;Derived class string&quot;)  \n    End Sub  \nEnd Class  \nClass testClasses  \n    Sub startHere()  \n        Dim testObj As derivedClass = New derivedClass()  \n        &#39; The following call displays &quot;Derived class string&quot;.  \n        testObj.useMe()  \n        &#39; The following call displays &quot;Base class string&quot;.  \n        testObj.useMyClass()  \n    End Sub  \nEnd Class  \n</code></pre><p> Even though <code>derivedClass</code> overrides <code>testMethod</code>, the <code>MyClass</code> keyword in <code>useMyClass</code> nullifies the effects of overriding, and the compiler resolves the call to the base class version of <code>testMethod</code>.  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../../../language-reference/statements/inherits-statement\" data-linktype=\"relative-path\">Inherits Statement</a><br> <a href=\"../../program-structure/me-my-mybase-and-myclass\" data-linktype=\"relative-path\">Me, My, MyBase, and MyClass</a></p>\n</div></div>","outputRootRelativePath":"../../../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"shoag\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"ms.suite\" content=\"\">\r\n<meta name=\"ms.custom\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"dfc8deba-f5b3-4d1d-a937-7cb826446fc5\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"23\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-visual-basic\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"ms.reviewer\" content=\"\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/visual-basic/programming-guide/language-features/objects-and-classes/inheritance-basics.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/programming-guide/language-features/objects-and-classes/inheritance-basics.md\">\r\n<meta name=\"document_id\" content=\"ef4a93a3-9092-a099-bf68-9aaa800f1df8\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"shoag","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","uhfHeaderId":"MSDocsHeader-DotNet","title":"Inheritance Basics (Visual Basic) | Microsoft Docs","ms.suite":"","ms.custom":"","ms.assetid":"dfc8deba-f5b3-4d1d-a937-7cb826446fc5","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":23,"ms.topic":"article","dev_langs":["vb"],"helpviewer_keywords":["derived classes, inheritance","MyClass keyword, using","MyBase keyword, using","Inherits statement, inheritance","overriding, Overridable keyword","MustInherit keyword, using","Overrides keyword, using","inheritance","MustInherit classes","MustOverride keyword, using","classes [Visual Basic], derived","NotInheritable keyword, using","base classes, extending properties and methods","NotOverridable keyword, using","base classes, inheritance","abstract classes, inheritance","overriding, Overrides keyword"],"ms.date":"2015-07-20","ms.technology":["devlang-visual-basic"],"ms.prod":".net","ms.reviewer":"","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/visual-basic/programming-guide/language-features/objects-and-classes/inheritance-basics.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/visual-basic/programming-guide/language-features/objects-and-classes/inheritance-basics.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/visual-basic/programming-guide/language-features/objects-and-classes/inheritance-basics.md","document_id":"ef4a93a3-9092-a099-bf68-9aaa800f1df8","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/visual-basic/programming-guide/language-features/objects-and-classes/inheritance-basics","toc_asset_id":"articles/visual-basic/programming-guide/language-features/objects-and-classes/toc.json","toc_rel":"toc.json","_op_ogTitle":"Inheritance Basics (Visual Basic)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":1320,"_op_rawTitle":"<h1 id=\"inheritance-basics-visual-basic\" sourcefile=\"docs/visual-basic/programming-guide/language-features/objects-and-classes/inheritance-basics.md\" sourcestartlinenumber=\"52\" sourceendlinenumber=\"52\">Inheritance Basics (Visual Basic)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/visual-basic/programming-guide/language-features/objects-and-classes/inheritance-basics","fileRelativePath":"articles/visual-basic/programming-guide/language-features/objects-and-classes/inheritance-basics.html"},"themesRelativePathToOutputRoot":"_themes/"}