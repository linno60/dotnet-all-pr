{"content":"<div><div class=\"content\">\n<p>Backtracking occurs when a regular expression pattern contains optional <a href=\"quantifiers\" data-linktype=\"relative-path\">quantifiers</a> or <a href=\"alternation\" data-linktype=\"relative-path\">alternation constructs</a>, and the regular expression engine returns to a previous saved state to continue its search for a match. Backtracking is central to the power of regular expressions; it makes it possible for expressions to be powerful and flexible, and to match very complex patterns. At the same time, this power comes at a cost. Backtracking is often the single most important factor that affects the performance of the regular expression engine. Fortunately, the developer has control over the behavior of the regular expression engine and how it uses backtracking. This topic explains how backtracking works and how it can be controlled.</p>\n<div class=\"NOTE\"><h5>Note</h5><p>In general, a Nondeterministic Finite Automaton (NFA) engine like the  regular expression engine places the responsibility for crafting efficient, fast regular expressions on the developer.</p>\n</div>\n<p>This topic contains the following sections:</p>\n<ul>\n<li><p><a href=\"#linear-comparison-without-backtracking\" data-linktype=\"self-bookmark\">Linear comparison without backtracking</a></p>\n</li>\n<li><p><a href=\"#backtracking-with-optional-quantifiers-or-alternation-constructs\" data-linktype=\"self-bookmark\">Backtracking with optional quantifiers or alternation constructs</a></p>\n</li>\n<li><p><a href=\"#backtracking-with-nested-optional-quantifiers\" data-linktype=\"self-bookmark\">Backtracking with nested optional quantifiers</a></p>\n</li>\n<li><p><a href=\"#controlling-backtracking\" data-linktype=\"self-bookmark\">Controlling backtracking</a></p>\n</li>\n</ul>\n<h2 id=\"linear-comparison-without-backtracking\">Linear comparison without backtracking</h2>\n<p>If a regular expression pattern has no optional quantifiers or alternation constructs, the regular expression engine executes in linear time. That is, after the regular expression engine matches the first language element in the pattern with text in the input string, it tries to match the next language element in the pattern with the next character or group of characters in the input string. This continues until the match either succeeds or fails. In either case, the regular expression engine advances by one character at a time in the input string.</p>\n<p>The following example provides an illustration. The regular expression <code>e{2}\\w\\b</code> looks for two occurrences of the letter &quot;e&quot; followed by any word character followed by a word boundary.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\nusing System.Text.RegularExpressions;\n\npublic class Example\n{\n   public static void Main()\n   {\n      string input = &quot;needing a reed&quot;;\n      string pattern = @&quot;e{2}\\w\\b&quot;;\n      foreach (Match match in Regex.Matches(input, pattern))\n         Console.WriteLine(&quot;{0} found at position {1}&quot;, \n                           match.Value, match.Index);\n   }\n}\n// The example displays the following output:\n//       eed found at position 11\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Imports System.Text.RegularExpressions\n\nModule Example\n   Public Sub Main()\n      Dim input As String = &quot;needing a reed&quot;\n      Dim pattern As String = &quot;e{2}\\w\\b&quot;\n      For Each match As Match In Regex.Matches(input, pattern)\n         Console.WriteLine(&quot;{0} found at position {1}&quot;, _\n                           match.Value, match.Index)\n      Next   \n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       eed found at position 11\n</code></pre><p>Although this regular expression includes the quantifier <code>{2}</code>, it is evaluated in a linear manner. The regular expression engine does not backtrack because <code>{2}</code> is not an optional quantifier; it specifies an exact number and not a variable number of times that the previous subexpression must match. As a result, the regular expression engine tries to match the regular expression pattern with the input string as shown in the following table.</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Position in pattern</th>\n<th>Position in string</th>\n<th>Result</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>e</td>\n<td>&quot;needing a reed&quot; (index 0)</td>\n<td>No match.</td>\n</tr>\n<tr>\n<td>2</td>\n<td>e</td>\n<td>&quot;eeding a reed&quot; (index 1)</td>\n<td>Possible match.</td>\n</tr>\n<tr>\n<td>3</td>\n<td>e{2}</td>\n<td>&quot;eding a reed&quot; (index 2)</td>\n<td>Possible match.</td>\n</tr>\n<tr>\n<td>4</td>\n<td>\\w</td>\n<td>&quot;ding a reed&quot; (index 3)</td>\n<td>Possible match.</td>\n</tr>\n<tr>\n<td>5</td>\n<td>\\b</td>\n<td>&quot;ing a reed&quot; (index 4)</td>\n<td>Possible match fails.</td>\n</tr>\n<tr>\n<td>6</td>\n<td>e</td>\n<td>&quot;eding a reed&quot; (index 2)</td>\n<td>Possible match.</td>\n</tr>\n<tr>\n<td>7</td>\n<td>e{2}</td>\n<td>&quot;ding a reed&quot; (index 3)</td>\n<td>Possible match fails.</td>\n</tr>\n<tr>\n<td>8</td>\n<td>e</td>\n<td>&quot;ding a reed&quot; (index 3)</td>\n<td>Match fails.</td>\n</tr>\n<tr>\n<td>9</td>\n<td>e</td>\n<td>&quot;ing a reed&quot; (index 4)</td>\n<td>No match.</td>\n</tr>\n<tr>\n<td>10</td>\n<td>e</td>\n<td>&quot;ng a reed&quot; (index 5)</td>\n<td>No match.</td>\n</tr>\n<tr>\n<td>11</td>\n<td>e</td>\n<td>&quot;g a reed&quot; (index 6)</td>\n<td>No match.</td>\n</tr>\n<tr>\n<td>12</td>\n<td>e</td>\n<td>&quot; a reed&quot; (index 7)</td>\n<td>No match.</td>\n</tr>\n<tr>\n<td>13</td>\n<td>e</td>\n<td>&quot;a reed&quot; (index 8)</td>\n<td>No match.</td>\n</tr>\n<tr>\n<td>14</td>\n<td>e</td>\n<td>&quot; reed&quot; (index 9)</td>\n<td>No match.</td>\n</tr>\n<tr>\n<td>15</td>\n<td>e</td>\n<td>&quot;reed&quot; (index 10)</td>\n<td>No match</td>\n</tr>\n<tr>\n<td>16</td>\n<td>e</td>\n<td>&quot;eed&quot; (index 11)</td>\n<td>Possible match.</td>\n</tr>\n<tr>\n<td>17</td>\n<td>e{2}</td>\n<td>&quot;ed&quot; (index 12)</td>\n<td>Possible match.</td>\n</tr>\n<tr>\n<td>18</td>\n<td>\\w</td>\n<td>&quot;d&quot; (index 13)</td>\n<td>Possible match.</td>\n</tr>\n<tr>\n<td>19</td>\n<td>\\b</td>\n<td>&quot;&quot; (index 14)</td>\n<td>Match.</td>\n</tr>\n</tbody>\n</table>\n<p>If a regular expression pattern includes no optional quantifiers or alternation constructs, the maximum number of comparisons required to match the regular expression pattern with the input string is roughly equivalent to the number of characters in the input string. In this case, the regular expression engine uses 19 comparisons to identify possible matches in this 13-character string. In other words, the regular expression engine runs in near-linear time if it contains no optional quantifiers or alternation constructs.</p>\n<h2 id=\"backtracking-with-optional-quantifiers-or-alternation-constructs\">Backtracking with optional quantifiers or alternation constructs</h2>\n<p>When a regular expression includes optional quantifiers or alternation constructs, the evaluation of the input string is no longer linear. Pattern matching with an NFA engine is driven by the language elements in the regular expression and not by the characters to be matched in the input string. Therefore, the regular expression engine tries to fully match optional or alternative subexpressions. When it advances to the next language element in the subexpression and the match is unsuccessful, the regular expression engine can abandon a portion of its successful match and return to an earlier saved state in the interest of matching the regular expression as a whole with the input string. This process of returning to a previous saved state to find a match is known as backtracking.</p>\n<p>For example, consider the regular expression pattern <code>.*(es)</code>, which matches the characters &quot;es&quot; and all the characters that precede it. As the following example shows, if the input string is &quot;Essential services are provided by regular expressions.&quot;, the pattern matches the whole string up to and including the &quot;es&quot; in &quot;expressions&quot;.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\nusing System.Text.RegularExpressions;\n\npublic class Example\n{\n   public static void Main()\n   {\n      string input = &quot;Essential services are provided by regular expressions.&quot;;\n      string pattern = &quot;.*(es)&quot;; \n      Match m = Regex.Match(input, pattern, RegexOptions.IgnoreCase);\n      if (m.Success) {\n         Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}&quot;, \n                           m.Value, m.Index);\n         Console.WriteLine(&quot;&#39;es&#39; found at position {0}&quot;, \n                           m.Groups[1].Index);      \n      } \n   }\n}\n//    &#39;Essential services are provided by regular expres&#39; found at position 0\n//    &#39;es&#39; found at position 47\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Imports System.Text.RegularExpressions\n\nModule Example\n   Public Sub Main()\n      Dim input As String = &quot;Essential services are provided by regular expressions.&quot;\n      Dim pattern As String = &quot;.*(es)&quot; \n      Dim m As Match = Regex.Match(input, pattern, RegexOptions.IgnoreCase)\n      If m.Success Then\n         Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}&quot;, _\n                           m.Value, m.Index)\n         Console.WriteLine(&quot;&#39;es&#39; found at position {0}&quot;, _\n                           m.Groups(1).Index)                  \n      End If     \n   End Sub\nEnd Module\n&#39;    &#39;Essential services are provided by regular expres&#39; found at position 0\n&#39;    &#39;es&#39; found at position 47\n</code></pre><p>To do this, the regular expression engine uses backtracking as follows:</p>\n<ul>\n<li><p>It matches the <code>.*</code> (which matches zero, one, or more occurrences of any character) with the whole input string.</p>\n</li>\n<li><p>It attempts to match &quot;e&quot; in the regular expression pattern. However, the input string has no remaining characters available to match.</p>\n</li>\n<li><p>It backtracks to its last successful match, &quot;Essential services are provided by regular expressions&quot;, and attempts to match &quot;e&quot; with the period at the end of the sentence. The match fails.</p>\n</li>\n<li><p>It continues to backtrack to a previous successful match one character at a time until the tentatively matched substring is &quot;Essential services are provided by regular expr&quot;. It then compares the &quot;e&quot; in the pattern to the second &quot;e&quot; in &quot;expressions&quot; and finds a match.</p>\n</li>\n<li><p>It compares &quot;s&quot; in the pattern to the &quot;s&quot; that follows the matched &quot;e&quot; character (the first &quot;s&quot; in &quot;expressions&quot;). The match is successful.</p>\n</li>\n</ul>\n<p>When you use backtracking, matching the regular expression pattern with the input string, which is 55 characters long, requires 67 comparison operations. Interestingly, if the regular expression pattern included a lazy quantifier, <code>.*?(es),</code> matching the regular expression would require additional comparisons. In this case, instead of having to backtrack from the end of the string to the &quot;r&quot; in &quot;expressions&quot;, the regular expression engine would have to backtrack all the way to the beginning of the string to match &quot;Es&quot; and would require 113 comparisons. Generally, if a regular expression pattern has a single alternation construct or a single optional quantifier, the number of comparison operations required to match the pattern is more than twice the number of characters in the input string.</p>\n<h2 id=\"backtracking-with-nested-optional-quantifiers\">Backtracking with nested optional quantifiers</h2>\n<p>The number of comparison operations required to match a regular expression pattern can increase exponentially if the pattern includes a large number of alternation constructs, if it includes nested alternation constructs, or, most commonly, if it includes nested optional quantifiers. For example, the regular expression pattern <code>^(a+)+$</code> is designed to match a complete string that contains one or more &quot;a&quot; characters. The example provides two input strings of identical length, but only the first string matches the pattern. The <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/system.diagnostics.stopwatch(v=vs.110).aspx\" data-linktype=\"external\">System.Diagnostics.Stopwatch</a> class is used to determine how long the match operation takes. </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\nusing System.Diagnostics;\nusing System.Text.RegularExpressions;\n\npublic class Example\n{\n   public static void Main()\n   {\n      string pattern = &quot;^(a+)+$&quot;;\n      string[] inputs = { &quot;aaaaaa&quot;, &quot;aaaaa!&quot; };\n      Regex rgx = new Regex(pattern);\n      Stopwatch sw;\n\n      foreach (string input in inputs) {\n         sw = Stopwatch.StartNew();   \n         Match match = rgx.Match(input);\n         sw.Stop();\n         if (match.Success)\n            Console.WriteLine(&quot;Matched {0} in {1}&quot;, match.Value, sw.Elapsed);\n         else\n            Console.WriteLine(&quot;No match found in {0}&quot;, sw.Elapsed);\n      }\n   }\n}\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Imports System.Diagnostics\nImports System.Text.RegularExpressions\n\nModule Example\n   Public Sub Main()\n      Dim pattern As String = &quot;^(a+)+$&quot;\n      Dim inputs() As String = { &quot;aaaaaa&quot;, &quot;aaaaa!&quot; }\n      Dim rgx As New Regex(pattern)\n      Dim sw As Stopwatch\n\n      For Each input As String In inputs\n         sw = Stopwatch.StartNew()   \n         Dim match As Match = rgx.Match(input)\n         sw.Stop()\n         If match.Success Then\n            Console.WriteLine(&quot;Matched {0} in {1}&quot;, match.Value, sw.Elapsed)\n         Else\n            Console.WriteLine(&quot;No match found in {0}&quot;, sw.Elapsed)\n         End If      \n      Next\n   End Sub\nEnd Module\n</code></pre><p>As the output from the example shows, the regular expression engine took about twice as long to find that an input string did not match the pattern as it did to identify a matching string. This is because an unsuccessful match always represents a worst-case scenario. The regular expression engine must use the regular expression to follow all possible paths through the data before it can conclude that the match is unsuccessful, and the nested parentheses create many additional paths through the data. The regular expression engine concludes that the second string did not match the pattern by doing the following:</p>\n<ul>\n<li><p>It checks that it was at the beginning of the string, and then matches the first five characters in the string with the pattern a+. It then determines that there are no additional groups of &quot;a&quot; characters in the string. Finally, it tests for the end of the string. Because one additional character remains in the string, the match fails. This failed match requires 9 comparisons. The regular expression engine also saves state information from its matches of &quot;a&quot; (which we will call match 1), &quot;aa&quot; (match 2), &quot;aaa&quot; (match 3), and &quot;aaaa&quot; (match 4).</p>\n</li>\n<li><p>It returns to the previously saved match 4. It determines that there is one additional &quot;a&quot; character to assign to an additional captured group. Finally, it tests for the end of the string. Because one additional character remains in the string, the match fails. This failed match requires 4 comparisons. So far, a total of 13 comparisons have been performed.</p>\n</li>\n<li><p>It returns to the previously saved match 3. It determines that there are two additional &quot;a&quot; characters to assign to an additional captured group. However, the end-of-string test fails. It then returns to match3 and tries to match the two additional &quot;a&quot; characters in two additional captured groups. The end-of-string test still fails. These failed matches require 12 comparisons. So far, a total of 25 comparisons have been performed. </p>\n</li>\n</ul>\n<p>Comparison of the input string with the regular expression continues in this way until the regular expression engine has tried all possible combinations of matches, and then concludes that there is no match. Because of the nested quantifiers, this comparison is an O(2n) or an exponential operation, where n is the number of characters in the input string. This means that in the worst case, an input string of 30 characters requires approximately 1,073,741,824 comparisons, and an input string of 40 characters requires approximately 1,099,511,627,776 comparisons. If you use strings of these or even greater lengths, regular expression methods can take an extremely long time to complete when they process input that does not match the regular expression pattern.</p>\n<h2 id=\"controlling-backtracking\">Controlling backtracking</h2>\n<p>Backtracking lets you create powerful, flexible regular expressions. However, as the previous section showed, these benefits may be coupled with unacceptably poor performance. To prevent excessive backtracking, you should define a time-out interval when you instantiate a <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/system.text.regularexpressions.regex(v=vs.110).aspx\" data-linktype=\"external\">Regex</a> object or call a static regular expression matching method. This is discussed in the next section. In addition, .NET Core supports three regular expression language elements that limit or suppress backtracking and that support complex regular expressions with little or no performance penalty: <a href=\"#nonbacktracking-subexpression\" data-linktype=\"self-bookmark\">nonbacktracking subexpressions</a>, <a href=\"#lookbehind-assertions\" data-linktype=\"self-bookmark\">lookbehind assertions</a>, and <a href=\"#lookahead-assertions\" data-linktype=\"self-bookmark\">lookahead assertions</a>. For more information about each language element, see <a href=\"grouping\" data-linktype=\"relative-path\">Grouping constructs in regular expressions</a>.</p>\n<h3 id=\"defining-a-time-out-interval\">Defining a time-out interval</h3>\n<p>You can set a time-out value that represents the longest interval the regular expression engine will search for a single match before it abandons the attempt and throws a <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/system.text.regularexpressions.regexmatchtimeoutexception(v=vs.110).aspx\" data-linktype=\"external\">RegexMatchTimeoutException</a> exception. You specify the time-out interval by supplying a <a class=\"xref\" href=\"../../../api/system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> value to the <code>Regex(String, RegexOptions, TimeSpan)</code> constructor for instance regular expressions. In addition, each static pattern matching method has an overload with a <a class=\"xref\" href=\"../../../api/system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> value to the [Regex.Regex(String, RegexOptions, TimeSpan)] parameter that allows you to specify a time-out value. By default, the time-out interval is set to <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/hh194622(v=vs.110).aspx\" data-linktype=\"external\">Regex.InfiniteMatchTimeout</a> and the regular expression engine does not time out. </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p>We recommend th&gt;at you always set a time-out interval if your regular expression relies on backtracking.</p>\n</div>\n<p>A <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/system.text.regularexpressions.regexmatchtimeoutexception(v=vs.110).aspx\" data-linktype=\"external\">RegexMatchTimeoutException</a>n exception indicates that the regular expression engine was unable to find a match within in the specified time-out interval but does not indicate why the exception was thrown. The reason might be excessive backtracking, but it is also possible that the time-out interval was set too low given the system load at the time the exception was thrown. When you handle the exception, you can choose to abandon further matches with the input string or increase the time-out interval and retry the matching operation. </p>\n<p>For example, the following code calls the <code>Regex(String, RegexOptions, TimeSpan)</code> constructor to instantiate a Regex object with a time-out value of one second. The regular expression pattern <code>(a+)+$</code>, which matches one or more sequences of one or more &quot;a&quot; characters at the end of a line, is subject to excessive backtracking. If a <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/system.text.regularexpressions.regexmatchtimeoutexception(v=vs.110).aspx\" data-linktype=\"external\">RegexMatchTimeoutException</a> is thrown, the example increases the time-out value up to a maximum interval of three seconds. After that, it abandons the attempt to match the pattern.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\nusing System.ComponentModel;\nusing System.Diagnostics;\nusing System.Security;\nusing System.Text.RegularExpressions;\nusing System.Threading; \n\npublic class Example\n{\n   const int MaxTimeoutInSeconds = 3;\n\n   public static void Main()\n   {\n      string pattern = @&quot;(a+)+$&quot;;    // DO NOT REUSE THIS PATTERN.\n      Regex rgx = new Regex(pattern, RegexOptions.IgnoreCase, TimeSpan.FromSeconds(1));       \n      Stopwatch sw = null;\n\n      string[] inputs= { &quot;aa&quot;, &quot;aaaa&gt;&quot;, \n                         &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;,\n                         &quot;aaaaaaaaaaaaaaaaaaaaaa&gt;&quot;,\n                         &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&gt;&quot; };\n\n      foreach (var inputValue in inputs) {\n         Console.WriteLine(&quot;Processing {0}&quot;, inputValue);\n         bool timedOut = false;\n         do { \n            try {\n               sw = Stopwatch.StartNew();\n               // Display the result.\n               if (rgx.IsMatch(inputValue)) {\n                  sw.Stop();\n                  Console.WriteLine(@&quot;Valid: &#39;{0}&#39; ({1:ss\\.fffffff} seconds)&quot;, \n                                    inputValue, sw.Elapsed); \n               }\n               else {\n                  sw.Stop();\n                  Console.WriteLine(@&quot;&#39;{0}&#39; is not a valid string. ({1:ss\\.fffff} seconds)&quot;, \n                                    inputValue, sw.Elapsed);\n               }\n            }\n            catch (RegexMatchTimeoutException e) {   \n               sw.Stop();\n               // Display the elapsed time until the exception.\n               Console.WriteLine(@&quot;Timeout with &#39;{0}&#39; after {1:ss\\.fffff}&quot;, \n                                 inputValue, sw.Elapsed);\n               Thread.Sleep(1500);       // Pause for 1.5 seconds.\n\n               // Increase the timeout interval and retry.\n               TimeSpan timeout = e.MatchTimeout.Add(TimeSpan.FromSeconds(1));\n               if (timeout.TotalSeconds &gt; MaxTimeoutInSeconds) {\n                  Console.WriteLine(&quot;Maximum timeout interval of {0} seconds exceeded.&quot;,\n                                    MaxTimeoutInSeconds);\n                  timedOut = false;\n               }\n               else {               \n                  Console.WriteLine(&quot;Changing the timeout interval to {0}&quot;, \n                                    timeout); \n                  rgx = new Regex(pattern, RegexOptions.IgnoreCase, timeout);\n                  timedOut = true;\n               }\n            }\n         } while (timedOut);\n         Console.WriteLine();\n      }   \n   }\n}\n// The example displays output like the following :\n//    Processing aa\n//    Valid: &#39;aa&#39; (00.0000779 seconds)\n//    \n//    Processing aaaa&gt;\n//    &#39;aaaa&gt;&#39; is not a valid string. (00.00005 seconds)\n//    \n//    Processing aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n//    Valid: &#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#39; (00.0000043 seconds)\n//    \n//    Processing aaaaaaaaaaaaaaaaaaaaaa&gt;\n//    Timeout with &#39;aaaaaaaaaaaaaaaaaaaaaa&gt;&#39; after 01.00469\n//    Changing the timeout interval to 00:00:02\n//    Timeout with &#39;aaaaaaaaaaaaaaaaaaaaaa&gt;&#39; after 02.01202\n//    Changing the timeout interval to 00:00:03\n//    Timeout with &#39;aaaaaaaaaaaaaaaaaaaaaa&gt;&#39; after 03.01043\n//    Maximum timeout interval of 3 seconds exceeded.\n//    \n//    Processing aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&gt;\n//    Timeout with &#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&gt;&#39; after 03.01018\n//    Maximum timeout interval of 3 seconds exceeded.\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Imports System.ComponentModel\nImports System.Diagnostics\nImports System.Security\nImports System.Text.RegularExpressions\nImports System.Threading \n\nModule Example\n   Const MaxTimeoutInSeconds As Integer = 3\n\n   Public Sub Main()\n      Dim pattern As String = &quot;(a+)+$&quot;    &#39; DO NOT REUSE THIS PATTERN.\n      Dim rgx As New Regex(pattern, RegexOptions.IgnoreCase, TimeSpan.FromSeconds(1))       \n      Dim sw As Stopwatch = Nothing\n\n      Dim inputs() As String = { &quot;aa&quot;, &quot;aaaa&gt;&quot;, \n                                 &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;,\n                                 &quot;aaaaaaaaaaaaaaaaaaaaaa&gt;&quot;,\n                                 &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&gt;&quot; }\n\n      For Each inputValue In inputs\n         Console.WriteLine(&quot;Processing {0}&quot;, inputValue)\n         Dim timedOut As Boolean = False\n         Do \n            Try\n               sw = Stopwatch.StartNew()\n               &#39; Display the result.\n               If rgx.IsMatch(inputValue) Then\n                  sw.Stop()\n                  Console.WriteLine(&quot;Valid: &#39;{0}&#39; ({1:ss\\.fffffff} seconds)&quot;, \n                                    inputValue, sw.Elapsed) \n               Else\n                  sw.Stop()\n                  Console.WriteLine(&quot;&#39;{0}&#39; is not a valid string. ({1:ss\\.fffff} seconds)&quot;, \n                                    inputValue, sw.Elapsed)\n               End If\n            Catch e As RegexMatchTimeoutException   \n               sw.Stop()\n               &#39; Display the elapsed time until the exception.\n               Console.WriteLine(&quot;Timeout with &#39;{0}&#39; after {1:ss\\.fffff}&quot;, \n                                 inputValue, sw.Elapsed)\n               Thread.Sleep(1500)       &#39; Pause for 1.5 seconds.\n\n               &#39; Increase the timeout interval and retry.\n               Dim timeout As TimeSpan = e.MatchTimeout.Add(TimeSpan.FromSeconds(1))\n               If timeout.TotalSeconds &gt; MaxTimeoutInSeconds Then\n                  Console.WriteLine(&quot;Maximum timeout interval of {0} seconds exceeded.&quot;,\n                                    MaxTimeoutInSeconds)\n                  timedOut = False\n               Else                \n                  Console.WriteLine(&quot;Changing the timeout interval to {0}&quot;, \n                                    timeout) \n                  rgx = New Regex(pattern, RegexOptions.IgnoreCase, timeout)\n                  timedOut = True\n               End If\n            End Try\n         Loop While timedOut\n         Console.WriteLine()\n      Next   \n   End Sub \nEnd Module\n&#39; The example displays output like the following:\n&#39;    Processing aa\n&#39;    Valid: &#39;aa&#39; (00.0000779 seconds)\n&#39;    \n&#39;    Processing aaaa&gt;\n&#39;    &#39;aaaa&gt;&#39; is not a valid string. (00.00005 seconds)\n&#39;    \n&#39;    Processing aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n&#39;    Valid: &#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#39; (00.0000043 seconds)\n&#39;    \n&#39;    Processing aaaaaaaaaaaaaaaaaaaaaa&gt;\n&#39;    Timeout with &#39;aaaaaaaaaaaaaaaaaaaaaa&gt;&#39; after 01.00469\n&#39;    Changing the timeout interval to 00:00:02\n&#39;    Timeout with &#39;aaaaaaaaaaaaaaaaaaaaaa&gt;&#39; after 02.01202\n&#39;    Changing the timeout interval to 00:00:03\n&#39;    Timeout with &#39;aaaaaaaaaaaaaaaaaaaaaa&gt;&#39; after 03.01043\n&#39;    Maximum timeout interval of 3 seconds exceeded.\n&#39;    \n&#39;    Processing aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&gt;\n&#39;    Timeout with &#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&gt;&#39; after 03.01018\n&#39;    Maximum timeout interval of 3 seconds exceeded.\n</code></pre><h3 id=\"nonbacktracking-subexpression\">Nonbacktracking subexpression</h3>\n<p>The <strong>(?&gt;</strong> <em>subexpression</em><strong>)</strong> language element suppresses backtracking in a subexpression. It is useful for preventing the performance problems associated with failed matches. </p>\n<p>The following example illustrates how suppressing backtracking improves performance when using nested quantifiers. It measures the time required for the regular expression engine to determine that an input string does not match two regular expressions. The first regular expression uses backtracking to attempt to match a string that contains one or more occurrences of one or more hexadecimal digits, followed by a colon, followed by one or more hexadecimal digits, followed by two colons. The second regular expression is identical to the first, except that it disables backtracking. As the output from the example shows, the performance improvement from disabling backtracking is significant.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\nusing System.Diagnostics;\nusing System.Text.RegularExpressions;\n\npublic class Example\n{\n   public static void Main()\n   {\n      string input = &quot;b51:4:1DB:9EE1:5:27d60:f44:D4:cd:E:5:0A5:4a:D24:41Ad:&quot;;\n      bool matched;\n      Stopwatch sw;\n\n      Console.WriteLine(&quot;With backtracking:&quot;);\n      string backPattern = &quot;^(([0-9a-fA-F]{1,4}:)*([0-9a-fA-F]{1,4}))*(::)$&quot;;\n      sw = Stopwatch.StartNew();\n      matched = Regex.IsMatch(input, backPattern);\n      sw.Stop();\n      Console.WriteLine(&quot;Match: {0} in {1}&quot;, Regex.IsMatch(input, backPattern), sw.Elapsed);\n      Console.WriteLine();\n\n      Console.WriteLine(&quot;Without backtracking:&quot;);\n      string noBackPattern = &quot;^((?&gt;[0-9a-fA-F]{1,4}:)*(?&gt;[0-9a-fA-F]{1,4}))*(::)$&quot;;\n      sw = Stopwatch.StartNew();\n      matched = Regex.IsMatch(input, noBackPattern);\n      sw.Stop();\n      Console.WriteLine(&quot;Match: {0} in {1}&quot;, Regex.IsMatch(input, noBackPattern), sw.Elapsed);\n   }\n}\n// The example displays output like the following:\n//       With backtracking:\n//       Match: False in 00:00:27.4282019\n//       \n//       Without backtracking:\n//       Match: False in 00:00:00.0001391\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Imports System.Diagnostics\nImports System.Text.RegularExpressions\n\nModule Example\n   Public Sub Main()\n      Dim input As String = &quot;b51:4:1DB:9EE1:5:27d60:f44:D4:cd:E:5:0A5:4a:D24:41Ad:&quot;\n      Dim matched As Boolean\n      Dim sw As Stopwatch\n\n      Console.WriteLine(&quot;With backtracking:&quot;)\n      Dim backPattern As String = &quot;^(([0-9a-fA-F]{1,4}:)*([0-9a-fA-F]{1,4}))*(::)$&quot;\n      sw = Stopwatch.StartNew()\n      matched = Regex.IsMatch(input, backPattern)\n      sw.Stop()\n      Console.WriteLine(&quot;Match: {0} in {1}&quot;, Regex.IsMatch(input, backPattern), sw.Elapsed)\n      Console.WriteLine()\n\n      Console.WriteLine(&quot;Without backtracking:&quot;)\n      Dim noBackPattern As String = &quot;^((?&gt;[0-9a-fA-F]{1,4}:)*(?&gt;[0-9a-fA-F]{1,4}))*(::)$&quot;\n      sw = Stopwatch.StartNew()\n      matched = Regex.IsMatch(input, noBackPattern)\n      sw.Stop()\n      Console.WriteLine(&quot;Match: {0} in {1}&quot;, Regex.IsMatch(input, noBackPattern), sw.Elapsed)\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       With backtracking:\n&#39;       Match: False in 00:00:27.4282019\n&#39;       \n&#39;       Without backtracking:\n&#39;       Match: False in 00:00:00.0001391\n</code></pre><h3 id=\"lookbehind-assertions\">Lookbehind assertions</h3>\n<p>.NET includes two language elements, <strong>(?&lt;</strong>=<em>subexpression</em><strong>)</strong> and <strong>(?&lt;!</strong><em>subexpression</em><strong>)</strong>, that match the previous character or characters in the input string. Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately precede the current character can be matched by <em>subexpression</em>, without advancing or backtracking. </p>\n<p><strong>(?&lt;</strong>=<em>subexpression</em><strong>)</strong> is a positive lookbehind assertion; that is, the character or characters before the current position must match <em>subexpression</em>. <strong>(?&lt;!</strong><em>subexpression</em><strong>)</strong> is a negative lookbehind assertion; that is, the character or characters before the current position must not match <em>subexpression</em>. Both positive and negative lookbehind assertions are most useful when <em>subexpression</em> is a subset of the previous <em>subexpression</em>. </p>\n<p>The following example uses two equivalent regular expression patterns that validate the user name in an e-mail address. The first pattern is subject to poor performance because of excessive backtracking. The second pattern modifies the first regular expression by replacing a nested quantifier with a positive lookbehind assertion. The output from the example displays the execution time of the <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/ktzf2d23(v=vs.110).aspx\" data-linktype=\"external\">Regex.IsMatch</a> method.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\nusing System.Diagnostics;\nusing System.Text.RegularExpressions;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Stopwatch sw;\n      string input = &quot;aaaaaaaaaaaaaaaaaaaa&quot;;\n      bool result;\n\n      string pattern = @&quot;^[0-9A-Z]([-.\\w]*[0-9A-Z])?@&quot;;\n      sw = Stopwatch.StartNew();\n      result = Regex.IsMatch(input, pattern, RegexOptions.IgnoreCase);\n      sw.Stop();\n      Console.WriteLine(&quot;Match: {0} in {1}&quot;, result, sw.Elapsed);\n\n      string behindPattern = @&quot;^[0-9A-Z][-.\\w]*(?&lt;=[0-9A-Z])@&quot;;\n      sw = Stopwatch.StartNew();\n      result = Regex.IsMatch(input, behindPattern, RegexOptions.IgnoreCase);\n      sw.Stop();\n      Console.WriteLine(&quot;Match with Lookbehind: {0} in {1}&quot;, result, sw.Elapsed);\n   }\n}\n// The example displays output similar to the following:\n//       Match: True in 00:00:00.0017549\n//       Match with Lookbehind: True in 00:00:00.0000659\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Module Example\n   Public Sub Main()\n      Dim sw As Stopwatch\n      Dim input As String = &quot;aaaaaaaaaaaaaaaaaaaa&quot;\n      Dim result As Boolean\n\n      Dim pattern As String = &quot;^[0-9A-Z]([-.\\w]*[0-9A-Z])?@&quot;\n      sw = Stopwatch.StartNew()\n      result = Regex.IsMatch(input, pattern, RegexOptions.IgnoreCase)\n      sw.Stop()\n      Console.WriteLine(&quot;Match: {0} in {1}&quot;, result, sw.Elapsed)\n\n      Dim behindPattern As String = &quot;^[0-9A-Z][-.\\w]*(?&lt;=[0-9A-Z])@&quot;\n      sw = Stopwatch.StartNew()\n      result = Regex.IsMatch(input, behindPattern, RegexOptions.IgnoreCase)\n      sw.Stop()\n      Console.WriteLine(&quot;Match with Lookbehind: {0} in {1}&quot;, result, sw.Elapsed)\n   End Sub\nEnd Module\n&#39; The example displays output similar to the following:\n&#39;       Match: True in 00:00:00.0017549\n&#39;       Match with Lookbehind: True in 00:00:00.0000659\n</code></pre><p>The first regular expression pattern, <code>^[0-9A-Z]([-.\\w]*[0-9A-Z])*@, is defined as shown in the following table.</code></p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>^</code></td>\n<td>Start the match at the beginning of the string.</td>\n</tr>\n<tr>\n<td><code>[0-9A-Z]</code></td>\n<td>Match an alphanumeric character. This comparison is case-insensitive, because the <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/ktzf2d23(v=vs.110).aspx\" data-linktype=\"external\">Regex.IsMatch</a> method is called with the <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/system.text.regularexpressions.regexoptions(v=vs.110).aspx\" data-linktype=\"external\">RegexOptions.IgnoreCase</a> option.</td>\n</tr>\n<tr>\n<td><code>[-.\\w]*</code></td>\n<td>Match zero, one, or more occurrences of a hyphen, period, or word character.</td>\n</tr>\n<tr>\n<td><code>[0-9A-Z]</code></td>\n<td>Match an alphanumeric character.</td>\n</tr>\n<tr>\n<td><code>([-.\\w]*[0-9A-Z])*</code></td>\n<td>Match zero or more occurrences of the combination of zero or more hyphens, periods, or word characters, followed by an alphanumeric character. This is the first capturing group.</td>\n</tr>\n<tr>\n<td><code>@</code></td>\n<td>Match an at sign (&quot;@&quot;).</td>\n</tr>\n</tbody>\n</table>\n<p>The second regular expression pattern, <code>^[0-9A-Z][-.\\w]*(?&lt;=[0-9A-Z])@</code>, uses a positive lookbehind assertion. It is defined as shown in the following table.</p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>^</code></td>\n<td>Start the match at the beginning of the string.</td>\n</tr>\n<tr>\n<td><code>[0-9A-Z]</code></td>\n<td>Match an alphanumeric character. This comparison is case-insensitive, because the <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/ktzf2d23(v=vs.110).aspx\" data-linktype=\"external\">Regex.IsMatch</a> method is called with the <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/system.text.regularexpressions.regexoptions(v=vs.110).aspx\" data-linktype=\"external\">RegexOptions.IgnoreCase</a> option.</td>\n</tr>\n<tr>\n<td><code>[-.\\w]*</code></td>\n<td>Match zero or more occurrences of a hyphen, period, or word character.</td>\n</tr>\n<tr>\n<td><code>(?&lt;=[0-9A-Z])</code></td>\n<td>Look back at the last matched character and continue the match if it is alphanumeric. Note that alphanumeric characters are a subset of the set that consists of periods, hyphens, and all word characters.</td>\n</tr>\n<tr>\n<td><code>@</code></td>\n<td>Match an at sign (&quot;@&quot;).</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"lookahead-assertions\">Lookahead assertions</h3>\n<p>.NET includes two language elements, <strong>(?</strong>=<em>subexpression</em><strong>)</strong> and <strong>(?!</strong><em>subexpression</em><strong>)</strong>, that match the next character or characters in the input string. Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately follow the current character can be matched by <em>subexpression</em>, without advancing or backtracking. </p>\n<p><strong>(?</strong>=<em>subexpression</em><strong>)</strong> is a positive lookahead assertion; that is, the character or characters after the current position must match <em>subexpression</em>. <strong>(?!</strong><em>subexpression</em><strong>)</strong> is a negative lookahead assertion; that is, the character or characters after the current position must not match <em>subexpression</em>. Both positive and negative lookahead assertions are most useful when <em>subexpression</em> is a subset of the next <em>subexpression</em>. </p>\n<p>The following example uses two equivalent regular expression patterns that validate a fully qualified type name. The first pattern is subject to poor performance because of excessive backtracking. The second modifies the first regular expression by replacing a nested quantifier with a positive lookahead assertion. The output from the example displays the execution time of the <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/ktzf2d23(v=vs.110).aspx\" data-linktype=\"external\">Regex.IsMatch</a> method.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\nusing System.Diagnostics;\nusing System.Text.RegularExpressions;\n\npublic class Example\n{\n   public static void Main()\n   {\n      string input = &quot;aaaaaaaaaaaaaaaaaaaaaa.&quot;;\n      bool result;\n      Stopwatch sw;\n\n      string pattern = @&quot;^(([A-Z]\\w*)+\\.)*[A-Z]\\w*$&quot;;\n      sw = Stopwatch.StartNew();\n      result = Regex.IsMatch(input, pattern, RegexOptions.IgnoreCase);\n      sw.Stop();\n      Console.WriteLine(&quot;{0} in {1}&quot;, result, sw.Elapsed);\n\n      string aheadPattern = @&quot;^((?=[A-Z])\\w+\\.)*[A-Z]\\w*$&quot;;\n      sw = Stopwatch.StartNew();\n      result = Regex.IsMatch(input, aheadPattern, RegexOptions.IgnoreCase);\n      sw.Stop();\n      Console.WriteLine(&quot;{0} in {1}&quot;, result, sw.Elapsed);\n   }\n}\n// The example displays the following output:\n//       False in 00:00:03.8003793\n//       False in 00:00:00.0000866\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Imports System.Diagnostics\nImports System.Text.RegularExpressions\n\nModule Example\n   Public Sub Main()\n      Dim input As String = &quot;aaaaaaaaaaaaaaaaaaaaaa.&quot;\n      Dim result As Boolean\n      Dim sw As Stopwatch\n\n      Dim pattern As String = &quot;^(([A-Z]\\w*)+\\.)*[A-Z]\\w*$&quot;\n      sw = Stopwatch.StartNew()\n      result = Regex.IsMatch(input, pattern, RegexOptions.IgnoreCase)\n      sw.Stop()\n      Console.WriteLine(&quot;{0} in {1}&quot;, result, sw.Elapsed)\n\n      Dim aheadPattern As String = &quot;^((?=[A-Z])\\w+\\.)*[A-Z]\\w*$&quot;\n      sw = Stopwatch.StartNew()\n      result = Regex.IsMatch(input, aheadPattern, RegexOptions.IgnoreCase)\n      sw.Stop()\n      Console.WriteLine(&quot;{0} in {1}&quot;, result, sw.Elapsed)\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       False in 00:00:03.8003793\n&#39;       False in 00:00:00.0000866\n</code></pre><p>The first regular expression pattern, <code>^(([A-Z]\\w*)+\\.)*[A-Z]\\w*$</code>, is defined as shown in the following table.</p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>^</code></td>\n<td>Start the match at the beginning of the string.</td>\n</tr>\n<tr>\n<td><code>([A-Z]\\w*)+\\.</code></td>\n<td>Match an alphabetical character (A-Z) followed by zero or more word characters one or more times, followed by a period. This comparison is case-insensitive, because the <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/ktzf2d23(v=vs.110).aspx\" data-linktype=\"external\">Regex.IsMatch</a> method is called with the <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/system.text.regularexpressions.regexoptions(v=vs.110).aspx\" data-linktype=\"external\">RegexOptions.IgnoreCase</a> option.</td>\n</tr>\n<tr>\n<td><code>(([A-Z]\\w*)+\\.)*</code></td>\n<td>Match the previous pattern zero or more times.</td>\n</tr>\n<tr>\n<td><code>[A-Z]\\w*</code></td>\n<td>Match an alphabetical character followed by zero or more word characters.</td>\n</tr>\n<tr>\n<td><code>$</code></td>\n<td>End the match at the end of the input string.</td>\n</tr>\n</tbody>\n</table>\n<p>The second regular expression pattern, <code>^((?=[A-Z])\\w+\\.)*[A-Z]\\w*$</code>, uses a positive lookahead assertion. It is defined as shown in the following table.</p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>^</code></td>\n<td>Start the match at the beginning of the string.</td>\n</tr>\n<tr>\n<td><code>(?=[A-Z])</code></td>\n<td>Look ahead to the first character and continue the match if it is alphabetical (A-Z). This comparison is case-insensitive, because the <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/ktzf2d23(v=vs.110).aspx\" data-linktype=\"external\">Regex.IsMatch</a> method is called with the <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/system.text.regularexpressions.regexoptions(v=vs.110).aspx\" data-linktype=\"external\">RegexOptions.IgnoreCase</a> option.</td>\n</tr>\n<tr>\n<td><code>\\w+\\.</code></td>\n<td>Match one or more word characters followed by a period.</td>\n</tr>\n<tr>\n<td><code>((?=[A-Z])\\w+\\.)*</code></td>\n<td>Match the pattern of one or more word characters followed by a period zero or more times. The initial word character must be alphabetical.</td>\n</tr>\n<tr>\n<td><code>[A-Z]\\w*</code></td>\n<td>Match an alphabetical character followed by zero or more word characters.</td>\n</tr>\n<tr>\n<td><code>$</code></td>\n<td>End the match at the end of the input string.</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"see-also\">See also</h2>\n<p><a href=\"regular-expressions\" data-linktype=\"relative-path\">.NET regular expressions</a></p>\n<p><a href=\"quick-ref\" data-linktype=\"relative-path\">Regular expression language - quick reference</a></p>\n<p><a href=\"quantifiers\" data-linktype=\"relative-path\">Quantifiers in regular expressions</a></p>\n<p><a href=\"alternation\" data-linktype=\"relative-path\">Alternation constructs in regular expressions</a></p>\n<p><a href=\"grouping\" data-linktype=\"relative-path\">Grouping constructs in regular expressions</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"shoag\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc.json\">\r\n<meta name=\"ms.devlang\" content=\"dotnet\">\r\n<meta name=\"ms.assetid\" content=\"8a3e6298-26b7-4c99-bd97-c9892f6c9418\">\r\n<meta name=\"description\" content=\"Backtracking in regular expressions\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"07/28/2016\">\r\n<meta name=\"ms.technology\" content=\"dotnet-standard\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-21 01:42 AM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/standard/base-types/backtracking.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/standard/base-types/backtracking.md\">\r\n<meta name=\"document_id\" content=\"d8536c23-42e2-24a8-8b65-da85c6a35717\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"shoag","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Backtracking in regular expressions | Microsoft Docs","ms.devlang":"dotnet","ms.assetid":"8a3e6298-26b7-4c99-bd97-c9892f6c9418","description":"Backtracking in regular expressions","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"07/28/2016","ms.technology":"dotnet-standard","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"fixed broken anchors (#1194)","commit_sha":"b20713600d7c3ddc31be5885733a1e8910ede8c6","commit_date":"2016-11-02 20:45:13 -0700"},{"author_name":"Steve Hoag","author_email":"shoag@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Porting base type docs take 4 (#1053)","commit_sha":"fb00da6505c9edb6a49d2003ae9bcb8e74c11d6c","commit_date":"2016-10-06 10:32:59 -0700"}],"updated_at":"2017-03-21 01:42 AM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"3/21/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/standard/base-types/backtracking.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/standard/base-types/backtracking.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/standard/base-types/backtracking.md","document_id":"d8536c23-42e2-24a8-8b65-da85c6a35717","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/standard/base-types/backtracking","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Backtracking in regular expressions","_op_displayDate":"2016-7-28","_op_displayDate_source":"2016-07-28T00:00:00Z","_op_wordCount":4384,"_op_rawTitle":"<h1 id=\"backtracking-in-regular-expressions\" sourcefile=\"docs/standard/base-types/backtracking.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Backtracking in regular expressions</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/standard/base-types/backtracking","fileRelativePath":"articles/standard/base-types/backtracking.html"},"themesRelativePathToOutputRoot":"_themes/"}