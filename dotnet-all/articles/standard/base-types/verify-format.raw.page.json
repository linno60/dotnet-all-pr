{"content":"<div><div class=\"content\">\n<p>The following example uses a regular expression to verify that a string is in valid email format.</p>\n<h2 id=\"example\">Example</h2>\n<p>The example defines an <code>IsValidEmail</code> method, which returns <code>true</code> if the string contains a valid email address and <code>false</code> if it does not, but takes no other action. </p>\n<p>To verify that the email address is valid, the <code>IsValidEmail</code> method calls the <a class=\"xref\" href=\"../../../api/system.text.regularexpressions.regex#System_Text_RegularExpressions_Regex_Replace_System_String_System_Text_RegularExpressions_MatchEvaluator_\" data-linktype=\"relative-path\">Regex.Replace(String, String, MatchEvaluator)</a> method with the <code>(@)(.+)$</code> regular expression pattern to separate the domain name from the email address. The third parameter is a <a class=\"xref\" href=\"../../../api/system.text.regularexpressions.matchevaluator\" data-linktype=\"relative-path\">MatchEvaluator</a> delegate that represents the method that processes and replaces the matched text. The regular expression pattern is interpreted as follows. </p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>(@)</code></td>\n<td>Match the @ character. This is the first capturing group.</td>\n</tr>\n<tr>\n<td><code>(.+)</code></td>\n<td>Match one or more occurrences of any character. This is the second capturing group.</td>\n</tr>\n<tr>\n<td><code>$</code></td>\n<td>End the match at the end of the string.</td>\n</tr>\n</tbody>\n</table>\n<p>The domain name along with the @ character is passed to the <code>DomainMapper</code> method, which uses the <a class=\"xref\" href=\"../../../api/system.globalization.idnmapping\" data-linktype=\"relative-path\">IdnMapping</a> class to translate Unicode characters that are outside the US-ASCII character range to Punycode. The method also sets the <code>invalid</code> flag to <code>true</code> if the <a class=\"xref\" href=\"../../../api/system.globalization.idnmapping#System_Globalization_IdnMapping_GetAscii_System_String_\" data-linktype=\"relative-path\">IdnMapping.GetAscii</a> method detects any invalid characters in the domain name. The method returns the Punycode domain name preceded by the @ symbol to the <code>IsValidEmail</code> method. </p>\n<p>The <code>IsValidEmail</code> method then calls the <a class=\"xref\" href=\"../../../api/system.text.regularexpressions.regex#System_Text_RegularExpressions_Regex_IsMatch_System_String_System_String_\" data-linktype=\"relative-path\">Regex.IsMatch(String, String)</a> method to verify that the address conforms to a regular expression pattern. </p>\n<p>Note that the <code>IsValidEmail</code> method does not perform authentication to validate the email address. It merely determines whether its format is valid for an email address. In addition, the <code>IsValidEmail</code> method does not verify that the top-level domain name is a valid domain name listed at the <a href=\"https://www.iana.org/domains/root/db\" data-linktype=\"external\">IANA Root Zone Database</a>, which would require a look-up operation. Instead, the regular expression merely verifies that the top-level domain name consists of between two and twenty-four ASCII characters, with alphanumeric first and last characters and the remaining characters being either alphanumeric or a hyphen (-). </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\nusing System.Globalization;\nusing System.Text.RegularExpressions;\n\npublic class RegexUtilities\n{\n   bool invalid = false;\n\n   public bool IsValidEmail(string strIn)\n   {\n       invalid = false;\n       if (String.IsNullOrEmpty(strIn))\n          return false;\n\n       // Use IdnMapping class to convert Unicode domain names.\n       try {\n          strIn = Regex.Replace(strIn, @&quot;(@)(.+)$&quot;, this.DomainMapper,\n                                RegexOptions.None, TimeSpan.FromMilliseconds(200));\n       }\n       catch (RegexMatchTimeoutException) {\n         return false;\n       }\n\n        if (invalid)\n           return false;\n\n       // Return true if strIn is in valid e-mail format.\n       try {\n          return Regex.IsMatch(strIn,\n                @&quot;^(?(&quot;&quot;)(&quot;&quot;.+?(?&lt;!\\\\)&quot;&quot;@)|(([0-9a-z]((\\.(?!\\.))|[-!#\\$%&amp;&#39;\\*\\+/=\\?\\^`\\{\\}\\|~\\w])*)(?&lt;=[0-9a-z])@))&quot; +\n                @&quot;(?(\\[)(\\[(\\d{1,3}\\.){3}\\d{1,3}\\])|(([0-9a-z][-\\w]*[0-9a-z]*\\.)+[a-z0-9][\\-a-z0-9]{0,22}[a-z0-9]))$&quot;,\n                RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(250));\n       }\n       catch (RegexMatchTimeoutException) {\n          return false;\n       }\n   }\n\n   private string DomainMapper(Match match)\n   {\n      // IdnMapping class with default property values.\n      IdnMapping idn = new IdnMapping();\n\n      string domainName = match.Groups[2].Value;\n      try {\n         domainName = idn.GetAscii(domainName);\n      }\n      catch (ArgumentException) {\n         invalid = true;\n      }\n      return match.Groups[1].Value + domainName;\n   }\n}\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Imports System.Globalization\nImports System.Text.RegularExpressions\n\nPublic Class RegexUtilities\n   Dim invalid As Boolean = False\n\n   public Function IsValidEmail(strIn As String) As Boolean\n       invalid = False\n       If String.IsNullOrEmpty(strIn) Then Return False\n\n       &#39; Use IdnMapping class to convert Unicode domain names.\n       Try\n          strIn = Regex.Replace(strIn, &quot;(@)(.+)$&quot;, AddressOf Me.DomainMapper, \n                                RegexOptions.None, TimeSpan.FromMilliseconds(200))\n       Catch e As RegexMatchTimeoutException\n          Return False\n       End Try\n\n       If invalid Then Return False\n\n       &#39; Return true if strIn is in valid e-mail format.\n       Try\n          Return Regex.IsMatch(strIn,\n                 &quot;^(?(&quot;&quot;)(&quot;&quot;.+?(?&lt;!\\\\)&quot;&quot;@)|(([0-9a-z]((\\.(?!\\.))|[-!#\\$%&amp;&#39;\\*\\+/=\\?\\^`\\{\\}\\|~\\w])*)(?&lt;=[0-9a-z])@))&quot; +\n                 &quot;(?(\\[)(\\[(\\d{1,3}\\.){3}\\d{1,3}\\])|(([0-9a-z][-\\w]*[0-9a-z]*\\.)+[a-z0-9][\\-a-z0-9]{0,22}[a-z0-9]))$&quot;,\n                 RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(250))\n       Catch e As RegexMatchTimeoutException\n          Return False\n       End Try  \n   End Function\n\n   Private Function DomainMapper(match As Match) As String\n      &#39; IdnMapping class with default property values.\n      Dim idn As New IdnMapping()\n\n      Dim domainName As String = match.Groups(2).Value\n      Try\n         domainName = idn.GetAscii(domainName)\n      Catch e As ArgumentException\n         invalid = True      \n      End Try      \n      Return match.Groups(1).Value + domainName\n   End Function\nEnd Class\n</code></pre><p>In this example, the regular expression pattern <code>^(?(&quot;)(&quot;.+?(?&lt;!\\\\)&quot;@)|(([0-9a-z]((\\.(?!\\.))|[-!#\\$%&amp;&#39;\\*\\+/=\\?\\^</code>{}|~\\w])<em>)(?&lt;=[0-9a-z])@))(?([)([(\\d{1,3}.){3}\\d{1,3}])|(([0-9a-z][-\\w]</em>[0-9a-z]*.)+[a-z0-9][-a-z0-9]{0,22}[a-z0-9]))$` is interpreted as shown in the following table. Note that the regular expression is compiled using the <a class=\"xref\" href=\"../../../api/system.text.regularexpressions.regexoptions#System_Text_RegularExpressions_RegexOptions_IgnoreCase\" data-linktype=\"relative-path\">RegexOptions.IgnoreCase</a> flag.</p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>^</code></td>\n<td>Begin the match at the start of the string.</td>\n</tr>\n<tr>\n<td><code>(?(&quot;)</code></td>\n<td>Determine whether the first character is a quotation mark. <code>(?(&quot;)</code> is the beginning of an alternation construct.</td>\n</tr>\n<tr>\n<td><code>(?(&quot;&quot;)(&quot;&quot;.+?(?&lt;!\\\\)&quot;&quot;@)</code></td>\n<td>If the first character is a quotation mark, match a beginning quotation mark followed by at least one occurrence of any character, followed by an ending quotation mark. The ending quotation mark must not be preceded by a backslash character <code>(\\). (?&lt;!</code> is the beginning of a zero-width negative lookbehind assertion. The string should conclude with an at sign (@).</td>\n</tr>\n<tr>\n<td>`&#124;(([0-9a-z]</td>\n<td>If the first character is not a quotation mark, match any alphabetic character from a to z or A to Z (the comparison is case insensitive), or any numeric character from 0 to 9.</td>\n</tr>\n<tr>\n<td><code>(\\.(?!\\.))</code></td>\n<td>If the next character is a period, match it. If it is not a period, look ahead to the next character and continue the match. <code>(?!\\.)</code> is a zero-width negative lookahead assertion that prevents two consecutive periods from appearing in the local part of an email address.</td>\n</tr>\n<tr>\n<td><code>&amp;#124;[-!#\\$%&amp;&#39;\\*\\+/=\\?\\^</code>{}&amp;#124;~\\w]</td>\n<td>If the next character is not a period, match any word character or one of the following characters: -!#$%&#39;*+=?^`{}&#124;~.</td>\n</tr>\n<tr>\n<td><code>((\\.(?!\\.))&amp;#124;[-!#\\$%&#39;\\*\\+/=\\?\\^</code>{}&amp;#124;~\\w])*</td>\n<td>Match the alternation pattern (a period followed by a non-period, or one of a number of characters) zero or more times.</td>\n</tr>\n<tr>\n<td><code>@</code></td>\n<td>Match the @ character.</td>\n</tr>\n<tr>\n<td><code>(?&lt;=[0-9a-z])</code></td>\n<td>Continue the match if the character that precedes the @ character is A through Z, a through z, or 0 through 9. The <code>(?&lt;=[0-9a-z])</code> construct defines a zero-width positive lookbehind assertion.</td>\n</tr>\n<tr>\n<td><code>(?(\\[)</code></td>\n<td>Check whether the character that follows @ is an opening bracket.</td>\n</tr>\n<tr>\n<td><code>(\\[(\\d{1,3}\\.){3}\\d{1,3}\\])</code></td>\n<td>If it is an opening bracket, match the opening bracket followed by an IP address (four sets of one to three digits, with each set separated by a period) and a closing bracket.</td>\n</tr>\n<tr>\n<td><code>&amp;#124;(([0-9a-z][-\\w]*[0-9a-z]*\\.)+</code></td>\n<td>If the character that follows @ is not an opening bracket, match one alphanumeric character with a value of A-Z, a-z, or 0-9, followed by zero or more occurrences of a word character or a hyphen, followed by zero or one alphanumeric character with a value of A-Z, a-z, or 0-9, followed by a period. This pattern can be repeated one or more times, and must be followed by the top-level domain name.</td>\n</tr>\n<tr>\n<td><code>[a-z0-9][\\-a-z0-9]{0,22}[a-z0-9]))</code></td>\n<td>The top-level domain name must begin and end with an alphanumeric character (a-z, A-Z, and 0-9). It can also include from zero to 22 ASCII characters that are either alphanumeric or hyphens.</td>\n</tr>\n<tr>\n<td><code>$</code></td>\n<td>End the match at the end of the string.</td>\n</tr>\n</tbody>\n</table>\n<p>You can call the <code>IsValidEmail</code> and <code>DomainMapper</code> methods by using code such as the following:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">public class Application\n{\n   public static void Main()\n   {\n      RegexUtilities util = new RegexUtilities();\n      string[] emailAddresses = { &quot;david.jones@proseware.com&quot;, &quot;d.j@server1.proseware.com&quot;,\n                                  &quot;jones@ms1.proseware.com&quot;, &quot;j.@server1.proseware.com&quot;,\n                                  &quot;j@proseware.com9&quot;, &quot;js#internal@proseware.com&quot;,\n                                  &quot;j_9@[129.126.118.1]&quot;, &quot;j..s@proseware.com&quot;,\n                                  &quot;js*@proseware.com&quot;, &quot;js@proseware..com&quot;,\n                                  &quot;js@proseware.com9&quot;, &quot;j.s@server1.proseware.com&quot;,\n                                   &quot;\\&quot;j\\\\\\&quot;s\\\\\\&quot;\\&quot;@proseware.com&quot;, &quot;js@contoso.中国&quot; };\n\n      foreach (var emailAddress in emailAddresses) {\n         if (util.IsValidEmail(emailAddress))\n            Console.WriteLine(&quot;Valid: {0}&quot;, emailAddress);\n         else\n            Console.WriteLine(&quot;Invalid: {0}&quot;, emailAddress);\n      }                                            \n   }\n}\n// The example displays the following output:\n//       Valid: david.jones@proseware.com\n//       Valid: d.j@server1.proseware.com\n//       Valid: jones@ms1.proseware.com\n//       Invalid: j.@server1.proseware.com\n//       Valid: j@proseware.com9\n//       Valid: js#internal@proseware.com\n//       Valid: j_9@[129.126.118.1]\n//       Invalid: j..s@proseware.com\n//       Invalid: js*@proseware.com\n//       Invalid: js@proseware..com\n//       Valid: js@proseware.com9\n//       Valid: j.s@server1.proseware.com\n//       Valid: &quot;j\\&quot;s\\&quot;&quot;@proseware.com\n//       Valid: js@contoso.ä¸­å›½\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Public Class Application\n   Public Shared Sub Main()\n      Dim util As New RegexUtilities()\n      Dim emailAddresses() As String = { &quot;david.jones@proseware.com&quot;, &quot;d.j@server1.proseware.com&quot;, _\n                                         &quot;jones@ms1.proseware.com&quot;, &quot;j.@server1.proseware.com&quot;, _\n                                         &quot;j@proseware.com9&quot;, &quot;js#internal@proseware.com&quot;, _\n                                         &quot;j_9@[129.126.118.1]&quot;, &quot;j..s@proseware.com&quot;, _\n                                         &quot;js*@proseware.com&quot;, &quot;js@proseware..com&quot;, _\n                                         &quot;js@proseware.com9&quot;, &quot;j.s@server1.proseware.com&quot;,\n                                         &quot;&quot;&quot;j\\&quot;&quot;s\\&quot;&quot;&quot;&quot;@proseware.com&quot;, &quot;js@contoso.中国&quot; }\n\n      For Each emailAddress As String In emailAddresses\n         If util.IsValidEmail(emailAddress) Then\n            Console.WriteLine(&quot;Valid: {0}&quot;, emailAddress)\n         Else\n            Console.WriteLine(&quot;Invalid: {0}&quot;, emailAddress)\n         End If      \n      Next                                            \n   End Sub\nEnd Class\n&#39; The example displays the following output:\n&#39;       Valid: david.jones@proseware.com\n&#39;       Valid: d.j@server1.proseware.com\n&#39;       Valid: jones@ms1.proseware.com\n&#39;       Invalid: j.@server1.proseware.com\n&#39;       Valid: j@proseware.com9\n&#39;       Valid: js#internal@proseware.com\n&#39;       Valid: j_9@[129.126.118.1]\n&#39;       Invalid: j..s@proseware.com\n&#39;       Invalid: js*@proseware.com\n&#39;       Invalid: js@proseware..com\n&#39;       Valid: js@proseware.com9\n&#39;       Valid: j.s@server1.proseware.com\n&#39;       Valid: &quot;j\\&quot;s\\&quot;&quot;@proseware.com\n&#39;       Valid: js@contoso.ä¸­å›½\n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p><a href=\"regular-expressions\" data-linktype=\"relative-path\">.NET regular expressions</a></p>\n<p><a href=\"regex-examples\" data-linktype=\"relative-path\">Regular expression examples</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"shoag\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"dotnet\">\r\n<meta name=\"ms.assetid\" content=\"6d735520-4059-4754-b34c-d117299d36f1\">\r\n<meta name=\"description\" content=\"How to verify that strings are in valid email format\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"07/28/2016\">\r\n<meta name=\"ms.technology\" content=\"dotnet-standard\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/standard/base-types/verify-format.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/standard/base-types/verify-format.md\">\r\n<meta name=\"document_id\" content=\"f836f299-1e7a-82a5-46b6-0255282ce324\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"shoag","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"How to: verify that strings are in valid email format | Microsoft Docs","ms.devlang":"dotnet","ms.assetid":"6d735520-4059-4754-b34c-d117299d36f1","description":"How to verify that strings are in valid email format","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"07/28/2016","ms.technology":"dotnet-standard","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Steve Hoag","author_email":"shoag@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Porting base type docs take 4 (#1053)","commit_sha":"fb00da6505c9edb6a49d2003ae9bcb8e74c11d6c","commit_date":"2016-10-06 10:32:59 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/standard/base-types/verify-format.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/standard/base-types/verify-format.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/standard/base-types/verify-format.md","document_id":"f836f299-1e7a-82a5-46b6-0255282ce324","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/standard/base-types/verify-format","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"How to: verify that strings are in valid email format","_op_displayDate":"2016-7-28","_op_displayDate_source":"2016-07-28T00:00:00Z","_op_wordCount":1257,"_op_rawTitle":"<h1 id=\"how-to-verify-that-strings-are-in-valid-email-format\" sourcefile=\"docs/standard/base-types/verify-format.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">How to: verify that strings are in valid email format</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/standard/base-types/verify-format","fileRelativePath":"articles/standard/base-types/verify-format.html"},"themesRelativePathToOutputRoot":"_themes/"}