{"content":"<div><div class=\"content\">\n<p>Backreferences provide a convenient way to identify a repeated character or substring within a string. For example, if the input string contains multiple occurrences of an arbitrary substring, you can match the first occurrence with a capturing group, and then use a backreference to match subsequent occurrences of the substring. </p>\n<div class=\"NOTE\"><h5>Note</h5><p>A separate syntax is used to refer to named and numbered capturing groups in replacement strings. For more information, see <a href=\"substitutions\" data-linktype=\"relative-path\">Substitutions in regular expressions</a>.</p>\n</div>\n<p>.NET defines separate language elements to refer to numbered and named capturing groups. For more information about capturing groups, see <a href=\"grouping\" data-linktype=\"relative-path\">Grouping constructs in regular expressions</a>.</p>\n<h2 id=\"numbered-backreferences\">Numbered Backreferences</h2>\n<p>A numbered backreference uses the following syntax:</p>\n<p><strong>\\</strong><em>number</em></p>\n<p>where <em>number</em> is the ordinal position of the capturing group in the regular expression. For example, <code>\\4</code> matches the contents of the fourth capturing group. If <em>number</em> is not defined in the regular expression pattern, a parsing error occurs, and the regular expression engine throws an <a class=\"xref\" href=\"../../../api/system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a>. For example, the regular expression <code>\\b(\\w+)\\s\\1</code> is valid, because <code>(\\w+)</code> is the first and only capturing group in the expression. On the other hand, <code>\\b(\\w+)\\s\\2</code> is invalid and throws an argument exception, because there is no capturing group numbered <code>\\2</code>.</p>\n<p>Note the ambiguity between octal escape codes (such as <code>\\16</code>) and <strong>\\</strong><em>number</em> backreferences that use the same notation. This ambiguity is resolved as follows:</p>\n<ul>\n<li><p>The expressions <code>\\1</code> through <code>\\9</code> are always interpreted as backreferences, and not as octal codes.</p>\n</li>\n<li><p>If the first digit of a multidigit expression is 8 or 9 (such as <code>\\80</code> or <code>\\91</code>), the expression as interpreted as a literal.</p>\n</li>\n<li><p>Expressions from <code>\\10</code> and greater are considered backreferences if there is a backreference corresponding to that number; otherwise, they are interpreted as octal codes.</p>\n</li>\n<li><p>If a regular expression contains a backreference to an undefined group number, a parsing error occurs, and the regular expression engine throws an <a class=\"xref\" href=\"../../../api/system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a>.</p>\n</li>\n</ul>\n<p>If the ambiguity is a problem, you can use the <strong>\\k&lt;</strong><em>name</em><strong>&gt;</strong> notation, which is unambiguous and cannot be confused with octal character codes. Similarly, hexadecimal codes such as <code>\\xdd</code> are unambiguous and cannot be confused with backreferences.</p>\n<p>The following example finds doubled word characters in a string. It defines a regular expression, <code>(\\w)\\1,</code> which consists of the following elements.</p>\n<table>\n<thead>\n<tr>\n<th>Element</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>(\\w)</code></td>\n<td>Match a word character and assign it to the first capturing group.</td>\n</tr>\n<tr>\n<td><code>\\1</code></td>\n<td>Match the next character that is the same as the value of the first capturing group.</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\nusing System.Text.RegularExpressions;\n\npublic class Example\n{\n   public static void Main()\n   {\n      string pattern = @&quot;(\\w)\\1&quot;;\n      string input = &quot;trellis llama webbing dresser swagger&quot;;\n      foreach (Match match in Regex.Matches(input, pattern))\n         Console.WriteLine(&quot;Found &#39;{0}&#39; at position {1}.&quot;, \n                           match.Value, match.Index);\n   }\n}\n// The example displays the following output:\n//       Found &#39;ll&#39; at position 3.\n//       Found &#39;ll&#39; at position 8.\n//       Found &#39;bb&#39; at position 16.\n//       Found &#39;ss&#39; at position 25.\n//       Found &#39;gg&#39; at position 33.\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Imports System.Text.RegularExpressions\n\nModule Example\n   Public Sub Main()\n      Dim pattern As String = &quot;(\\w)\\1&quot;\n      Dim input As String = &quot;trellis llama webbing dresser swagger&quot;\n      For Each match As Match In Regex.Matches(input, pattern)\n         Console.WriteLine(&quot;Found &#39;{0}&#39; at position {1}.&quot;, _\n                           match.Value, match.Index)\n      Next   \n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       Found &#39;ll&#39; at position 3.\n&#39;       Found &#39;ll&#39; at position 8.\n&#39;       Found &#39;bb&#39; at position 16.\n&#39;       Found &#39;ss&#39; at position 25.\n&#39;       Found &#39;gg&#39; at position 33.\n</code></pre><h2 id=\"named-backreferences\">Named Backreferences</h2>\n<p>A named backreference is defined by using the following syntax:</p>\n<p><strong>\\k&lt;</strong><em>name</em><strong>&gt;</strong></p>\n<p>or:</p>\n<p><strong>\\k&#39;</strong><em>name</em><strong>&#39;</strong></p>\n<p>where <em>name</em> is the name of a capturing group defined in the regular expression pattern. If <em>name</em> is not defined in the regular expression pattern, a parsing error occurs, and the regular expression engine throws an <a class=\"xref\" href=\"../../../api/system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a>.</p>\n<p>The following example finds doubled word characters in a string. It defines a regular expression, <code>(?&lt;char&gt;\\w)\\k&lt;char&gt;</code>, which consists of the following elements.</p>\n<table>\n<thead>\n<tr>\n<th>Element</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>(?&lt;char&gt;\\w)</code></td>\n<td>Match a word character and assign it to a capturing group named char.</td>\n</tr>\n<tr>\n<td><code>\\k&lt;char&gt;</code></td>\n<td>Match the next character that is the same as the value of the char capturing group.</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\nusing System.Text.RegularExpressions;\n\npublic class Example\n{\n   public static void Main()\n   {\n      string pattern = @&quot;(?&lt;char&gt;\\w)\\k&lt;char&gt;&quot;;\n      string input = &quot;trellis llama webbing dresser swagger&quot;;\n      foreach (Match match in Regex.Matches(input, pattern))\n         Console.WriteLine(&quot;Found &#39;{0}&#39; at position {1}.&quot;, \n                           match.Value, match.Index);\n   }\n}\n// The example displays the following output:\n//       Found &#39;ll&#39; at position 3.\n//       Found &#39;ll&#39; at position 8.\n//       Found &#39;bb&#39; at position 16.\n//       Found &#39;ss&#39; at position 25.\n//       Found &#39;gg&#39; at position 33.\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Imports System.Text.RegularExpressions\n\nModule Example\n   Public Sub Main()\n      Dim pattern As String = &quot;(?&lt;char&gt;\\w)\\k&lt;char&gt;&quot;\n      Dim input As String = &quot;trellis llama webbing dresser swagger&quot;\n      For Each match As Match In Regex.Matches(input, pattern)\n         Console.WriteLine(&quot;Found &#39;{0}&#39; at position {1}.&quot;, _\n                           match.Value, match.Index)\n      Next   \n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       Found &#39;ll&#39; at position 3.\n&#39;       Found &#39;ll&#39; at position 8.\n&#39;       Found &#39;bb&#39; at position 16.\n&#39;       Found &#39;ss&#39; at position 25.\n&#39;       Found &#39;gg&#39; at position 33.\n</code></pre><p>Note that <em>name</em> can also be the string representation of a number. For example, the following example uses the regular expression <code>(?&lt;2&gt;\\w)\\k&lt;2&gt;</code> to find doubled word characters in a string.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\nusing System.Text.RegularExpressions;\n\npublic class Example\n{\n   public static void Main()\n   {\n      string pattern = @&quot;(?&lt;2&gt;\\w)\\k&lt;2&gt;&quot;;\n      string input = &quot;trellis llama webbing dresser swagger&quot;;\n      foreach (Match match in Regex.Matches(input, pattern))\n         Console.WriteLine(&quot;Found &#39;{0}&#39; at position {1}.&quot;, \n                           match.Value, match.Index);\n   }\n}\n// The example displays the following output:\n//       Found &#39;ll&#39; at position 3.\n//       Found &#39;ll&#39; at position 8.\n//       Found &#39;bb&#39; at position 16.\n//       Found &#39;ss&#39; at position 25.\n//       Found &#39;gg&#39; at position 33.\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Imports System.Text.RegularExpressions\n\nModule Example\n   Public Sub Main()\n      Dim pattern As String = &quot;(?&lt;2&gt;\\w)\\k&lt;2&gt;&quot;\n      Dim input As String = &quot;trellis llama webbing dresser swagger&quot;\n      For Each match As Match In Regex.Matches(input, pattern)\n         Console.WriteLine(&quot;Found &#39;{0}&#39; at position {1}.&quot;, _\n                           match.Value, match.Index)\n      Next   \n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       Found &#39;ll&#39; at position 3.\n&#39;       Found &#39;ll&#39; at position 8.\n&#39;       Found &#39;bb&#39; at position 16.\n&#39;       Found &#39;ss&#39; at position 25.\n&#39;       Found &#39;gg&#39; at position 33.\n</code></pre><h2 id=\"what-backreferences-match\">What Backreferences Match</h2>\n<p>A backreference refers to the most recent definition of a group (the definition most immediately to the left, when matching left to right). When a group makes multiple captures, a backreference refers to the most recent capture. </p>\n<p>The following example includes a regular expression pattern, <code>(?&lt;1&gt;a)(?&lt;1&gt;\\1b)*</code>, which redefines the \\1 named group. The following table describes each pattern in the regular expression. </p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>(?&lt;1&gt;a)</code></td>\n<td>Match the character &quot;a&quot; and assign the result to the capturing group named 1.</td>\n</tr>\n<tr>\n<td><code>(?&lt;1&gt;\\1b)*</code></td>\n<td>Match 0 or 1 occurrence of the group named 1 along with a &quot;b&quot;, and assign the result to the capturing group named 1.</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\nusing System.Text.RegularExpressions;\n\npublic class Example\n{\n   public static void Main()\n   {\n      string pattern = @&quot;(?&lt;1&gt;a)(?&lt;1&gt;\\1b)*&quot;;\n      string input = &quot;aababb&quot;;\n      foreach (Match match in Regex.Matches(input, pattern))\n      {\n         Console.WriteLine(&quot;Match: &quot; + match.Value);\n         foreach (Group group in match.Groups)\n            Console.WriteLine(&quot;   Group: &quot; + group.Value);\n      }\n   }\n}\n// The example displays the following output:\n//          Group: aababb\n//          Group: abb\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Imports System.Text.RegularExpressions\n\nModule Example\n   Public Sub Main()\n      Dim pattern As String = &quot;(?&lt;1&gt;a)(?&lt;1&gt;\\1b)*&quot;\n      Dim input As String = &quot;aababb&quot;\n      For Each match As Match In Regex.Matches(input, pattern)\n         Console.WriteLine(&quot;Match: &quot; + match.Value)\n         For Each group As Group In match.Groups\n            Console.WriteLIne(&quot;   Group: &quot; + group.Value)\n         Next\n      Next\n   End Sub\nEnd Module\n&#39; The example display the following output:\n&#39;          Group: aababb\n&#39;          Group: abb\n</code></pre><p>In comparing the regular expression with the input string (&quot;aababb&quot;), the regular expression engine performs the following operations:</p>\n<ol>\n<li><p>It starts at the beginning of the string, and successfully matches &quot;a&quot; with the expression <code>(?&lt;1&gt;a)</code>. The value of the 1 group is now &quot;a&quot;.</p>\n</li>\n<li><p>It advances to the second character, and successfully matches the string &quot;ab&quot; with the expression <code>\\1b</code>, or &quot;ab&quot;. It then assigns the result, &quot;ab&quot; to <code>\\1</code>.</p>\n</li>\n<li><p>It advances to the fourth character. The expression <code>(?&lt;1&gt;\\1b)</code> is to be matched zero or more times, so it successfully matches the string &quot;abb&quot; with the expression <code>\\1b</code>. It assigns the result, &quot;abb&quot;, back to <code>\\1</code>.</p>\n</li>\n</ol>\n<p>In this example, * is a looping quantifier -- it is evaluated repeatedly until the regular expression engine cannot match the pattern it defines. Looping quantifiers do not clear group definitions.</p>\n<p>If a group has not captured any substrings, a backreference to that group is undefined and never matches. This is illustrated by the regular expression pattern <code>\\b(\\p{Lu}{2})(\\d{2})?(\\p{Lu}{2})\\b,</code> which is defined as follows:</p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>\\b</code></td>\n<td>Begin the match on a word boundary.</td>\n</tr>\n<tr>\n<td><code>(\\p{Lu}{2})</code></td>\n<td>Match two uppercase letters. This is the first capturing group.</td>\n</tr>\n<tr>\n<td><code>(\\d{2})?</code></td>\n<td>Match zero or one occurrence of two decimal digits. This is the second capturing group.</td>\n</tr>\n<tr>\n<td><code>(\\p{Lu}{2})</code></td>\n<td>Match two uppercase letters. This is the third capturing group.</td>\n</tr>\n<tr>\n<td><code>\\b</code></td>\n<td>End the match on a word boundary.</td>\n</tr>\n</tbody>\n</table>\n<p>An input string can match this regular expression even if the two decimal digits that are defined by the second capturing group are not present. The following example shows that even though the match is successful, an empty capturing group is found between two successful capturing groups.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\nusing System.Text.RegularExpressions;\n\npublic class Example\n{\n   public static void Main()\n   {\n      string pattern = @&quot;\\b(\\p{Lu}{2})(\\d{2})?(\\p{Lu}{2})\\b&quot;;\n      string[] inputs = { &quot;AA22ZZ&quot;, &quot;AABB&quot; };\n      foreach (string input in inputs)\n      {\n         Match match = Regex.Match(input, pattern);\n         if (match.Success)\n         {\n            Console.WriteLine(&quot;Match in {0}: {1}&quot;, input, match.Value);\n            if (match.Groups.Count &gt; 1)\n            {\n               for (int ctr = 1; ctr &lt;= match.Groups.Count - 1; ctr++)\n               {\n                  if (match.Groups[ctr].Success)\n                     Console.WriteLine(&quot;Group {0}: {1}&quot;, \n                                       ctr, match.Groups[ctr].Value);\n                  else\n                     Console.WriteLine(&quot;Group {0}: &lt;no match&gt;&quot;, ctr);\n               }\n            }\n         }\n         Console.WriteLine();\n      }      \n   }\n}\n// The example displays the following output:\n//       Match in AA22ZZ: AA22ZZ\n//       Group 1: AA\n//       Group 2: 22\n//       Group 3: ZZ\n//       \n//       Match in AABB: AABB\n//       Group 1: AA\n//       Group 2: &lt;no match&gt;\n//       Group 3: BB\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Imports System.Text.RegularExpressions\n\nModule Example\n   Public Sub Main()\n      Dim pattern As String = &quot;\\b(\\p{Lu}{2})(\\d{2})?(\\p{Lu}{2})\\b&quot;\n      Dim inputs() As String = { &quot;AA22ZZ&quot;, &quot;AABB&quot; }\n      For Each input As String In inputs\n         Dim match As Match = Regex.Match(input, pattern)\n         If match.Success Then\n            Console.WriteLine(&quot;Match in {0}: {1}&quot;, input, match.Value)\n            If match.Groups.Count &gt; 1 Then\n               For ctr As Integer = 1 To match.Groups.Count - 1\n                  If match.Groups(ctr).Success Then\n                     Console.WriteLine(&quot;Group {0}: {1}&quot;, _\n                                       ctr, match.Groups(ctr).Value)\n                  Else\n                     Console.WriteLine(&quot;Group {0}: &lt;no match&gt;&quot;, ctr)\n                  End If      \n               Next\n            End If\n         End If\n         Console.WriteLine()\n      Next      \n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       Match in AA22ZZ: AA22ZZ\n&#39;       Group 1: AA\n&#39;       Group 2: 22\n&#39;       Group 3: ZZ\n&#39;       \n&#39;       Match in AABB: AABB\n&#39;       Group 1: AA\n&#39;       Group 2: &lt;no match&gt;\n&#39;       Group 3: BB\n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p><a href=\"quick-ref\" data-linktype=\"relative-path\">Regular expression language - quick reference</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"shoag\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"dotnet\">\r\n<meta name=\"ms.assetid\" content=\"c453ed78-650f-4c3c-9ab4-9d89d250bf88\">\r\n<meta name=\"description\" content=\"Backreference constructs in regular expressions\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"07/28/2016\">\r\n<meta name=\"ms.technology\" content=\"dotnet-standard\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/standard/base-types/backreference.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/standard/base-types/backreference.md\">\r\n<meta name=\"document_id\" content=\"17dea978-bf2a-3dbf-b5fb-664236a7882d\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"shoag","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Backreference constructs in regular expressions | Microsoft Docs","ms.devlang":"dotnet","ms.assetid":"c453ed78-650f-4c3c-9ab4-9d89d250bf88","description":"Backreference constructs in regular expressions","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"07/28/2016","ms.technology":"dotnet-standard","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"fixed broken anchors (#1194)","commit_sha":"b20713600d7c3ddc31be5885733a1e8910ede8c6","commit_date":"2016-11-02 20:45:13 -0700"},{"author_name":"Steve Hoag","author_email":"shoag@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Porting base type docs take 4 (#1053)","commit_sha":"fb00da6505c9edb6a49d2003ae9bcb8e74c11d6c","commit_date":"2016-10-06 10:32:59 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/standard/base-types/backreference.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/standard/base-types/backreference.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/standard/base-types/backreference.md","document_id":"17dea978-bf2a-3dbf-b5fb-664236a7882d","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/standard/base-types/backreference","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Backreference constructs in regular expressions","_op_displayDate":"2016-7-28","_op_displayDate_source":"2016-07-28T00:00:00Z","_op_wordCount":1779,"_op_rawTitle":"<h1 id=\"backreference-constructs-in-regular-expressions\" sourcefile=\"docs/standard/base-types/backreference.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Backreference constructs in regular expressions</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/standard/base-types/backreference","fileRelativePath":"articles/standard/base-types/backreference.html"},"themesRelativePathToOutputRoot":"_themes/"}