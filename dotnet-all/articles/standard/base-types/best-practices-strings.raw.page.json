{"content":"<div><div class=\"content\">\n<p>.NET provides extensive support for developing localized and globalized applications, and makes it easy to apply the conventions of either the current culture or a specific culture when performing common operations such as sorting and displaying strings. But sorting or comparing strings is not always a culture-sensitive operation. For example, strings that are used internally by an application typically should be handled identically across all cultures. When culturally independent string data, such as XML tags, HTML tags, user names, file paths, and the names of system objects, are interpreted as if they were culture-sensitive, application code can be subject to subtle bugs, poor performance, and, in some cases, security issues.</p>\n<p>This article examines the string sorting, comparison, and casing methods in .NET, presents recommendations for selecting an appropriate string-handling method, and provides additional information about string-handling methods. It also examines how formatted data, such as numeric data and date and time data, is handled for display and for storage. </p>\n<p>This article contains the following sections:</p>\n<ul>\n<li><p><a href=\"#recommendations-for-string-usage\" data-linktype=\"self-bookmark\">Recommendations for string usage</a></p>\n</li>\n<li><p><a href=\"#specifying-string-comparisons-explicitly\" data-linktype=\"self-bookmark\">Specifying string comparisons explicitly</a></p>\n</li>\n<li><p><a href=\"#the-details-of-string-comparison\" data-linktype=\"self-bookmark\">The details of string comparison</a></p>\n</li>\n<li><p><a href=\"#choosing-a-stringcomparison-member-for-your-method-call\" data-linktype=\"self-bookmark\">Choosing a StringComparison member for your method call</a></p>\n</li>\n<li><p><a href=\"#common-string-comparison-methods\" data-linktype=\"self-bookmark\">Common string comparison methods</a></p>\n</li>\n<li><p><a href=\"#methods-that-perform-string-comparison-indirectly\" data-linktype=\"self-bookmark\">Methods that perform string comparison indirectly</a></p>\n</li>\n<li><p><a href=\"#displaying-and-persisting-formatted-data\" data-linktype=\"self-bookmark\">Displaying and persisting formatted data</a></p>\n</li>\n</ul>\n<h2 id=\"recommendations-for-string-usage\">Recommendations for string usage</h2>\n<p>When you develop with .NET, follow these simple recommendations when you use strings: </p>\n<ul>\n<li><p>Use overloads that explicitly specify the string comparison rules for string operations. Typically, this involves calling a method overload that has a parameter of type <a class=\"xref\" href=\"../../../api/system.stringcomparison\" data-linktype=\"relative-path\">StringComparison</a>.</p>\n</li>\n<li><p>Use <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_Ordinal\" data-linktype=\"relative-path\">StringComparison.Ordinal</a> or <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_OrdinalIgnoreCase\" data-linktype=\"relative-path\">StringComparison.OrdinalIgnoreCase</a> for comparisons as your safe default for culture-agnostic string matching.</p>\n</li>\n<li><p>Use comparisons with <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_Ordinal\" data-linktype=\"relative-path\">StringComparison.Ordinal</a> or <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_OrdinalIgnoreCase\" data-linktype=\"relative-path\">StringComparison.OrdinalIgnoreCase</a> for better performance.</p>\n</li>\n<li><p>Use string operations that are based on <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_CurrentCulture\" data-linktype=\"relative-path\">StringComparison.CurrentCulture</a> when you display output to the user.</p>\n</li>\n<li><p>Use the non-linguistic <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_Ordinal\" data-linktype=\"relative-path\">StringComparison.Ordinal</a> or <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_OrdinalIgnoreCase\" data-linktype=\"relative-path\">StringComparison.OrdinalIgnoreCase</a> values instead of string operations based on <a class=\"xref\" href=\"../../../api/system.globalization.cultureinfo#System_Globalization_CultureInfo_InvariantCulture\" data-linktype=\"relative-path\">CultureInfo.InvariantCulture</a> when the comparison is linguistically irrelevant (symbolic, for example).</p>\n</li>\n<li><p>Use the <a class=\"xref\" href=\"../../../api/system.string#System_String_ToUpperInvariant\" data-linktype=\"relative-path\">String.ToUpperInvariant</a> method instead of the <a class=\"xref\" href=\"../../../api/system.string#System_String_ToLowerInvariant\" data-linktype=\"relative-path\">String.ToLowerInvariant</a> method when you normalize strings for comparison.</p>\n</li>\n<li><p>Use an overload of the <a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String</a> <code>Equals</code> method to test whether two strings are equal.</p>\n</li>\n<li><p>Use an overload of the <a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String</a> <code>Compare</code> and <a class=\"xref\" href=\"../../../api/system.string#System_String_CompareTo_System_String_\" data-linktype=\"relative-path\">String.CompareTo</a> methods to sort strings, not to check for equality.</p>\n</li>\n<li><p>Use culture-sensitive formatting to display non-string data, such as numbers and dates, in a user interface. Use formatting with the invariant culture to persist non-string data in string form.</p>\n</li>\n</ul>\n<p>Avoid the following practices when you use strings:</p>\n<ul>\n<li><p>Do not use overloads that do not explicitly or implicitly specify the string comparison rules for string operations. </p>\n</li>\n<li><p>Do not use an overload of the <a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String</a> <code>Compare</code> or <a class=\"xref\" href=\"../../../api/system.string#System_String_CompareTo_System_String_\" data-linktype=\"relative-path\">String.CompareTo</a> methods and test for a return value of zero to determine whether two strings are equal.</p>\n</li>\n<li><p>Do not use culture-sensitive formatting to persist numeric data or date and time data in string form.</p>\n</li>\n</ul>\n<h2 id=\"specifying-string-comparisons-explicitly\">Specifying string comparisons explicitly</h2>\n<p>Most of the string manipulation methods in .NET are overloaded. Typically, one or more overloads accept default settings, whereas others accept no defaults and instead define the precise way in which strings are to be compared or manipulated. Most of the methods that do not rely on defaults include a parameter of type <a class=\"xref\" href=\"../../../api/system.stringcomparison\" data-linktype=\"relative-path\">StringComparison</a>, which is an enumeration that explicitly specifies rules for string comparison by culture and case. The following table describes the <a class=\"xref\" href=\"../../../api/system.stringcomparison\" data-linktype=\"relative-path\">StringComparison</a> enumeration members. </p>\n<table>\n<thead>\n<tr>\n<th>StringComparison member</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_CurrentCulture\" data-linktype=\"relative-path\">StringComparison.CurrentCulture</a></td>\n<td>Performs a case-sensitive comparison using the current culture.</td>\n</tr>\n<tr>\n<td><a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_CurrentCultureIgnoreCase\" data-linktype=\"relative-path\">CurrentCultureIgnoreCase</a></td>\n<td>Performs a case-insensitive comparison using the current culture.</td>\n</tr>\n<tr>\n<td><a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_Ordinal\" data-linktype=\"relative-path\">StringComparison.Ordinal</a></td>\n<td>Performs an ordinal comparison.</td>\n</tr>\n<tr>\n<td><a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_OrdinalIgnoreCase\" data-linktype=\"relative-path\">StringComparison.OrdinalIgnoreCase</a></td>\n<td>Performs a case-insensitive ordinal comparison.</td>\n</tr>\n</tbody>\n</table>\n<p>For example, the <a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String</a> <code>IndexOf</code> method, which returns the index of a substring in a <a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String</a> object that matches either a character or a string, has nine overloads:</p>\n<ul>\n<li><p><a class=\"xref\" href=\"../../../api/system.string#System_String_IndexOf_System_Char_\" data-linktype=\"relative-path\">IndexOf(Char)</a>, <a class=\"xref\" href=\"../../../api/system.string#System_String_IndexOf_System_Char_System_Int32_\" data-linktype=\"relative-path\">IndexOf(Char, Int32)</a>, and <a class=\"xref\" href=\"../../../api/system.string#System_String_IndexOf_System_Char_System_Int32_System_Int32_\" data-linktype=\"relative-path\">IndexOf(Char, Int32, Int32)</a>, which by default perform an ordinal (case-sensitive and culture-insensitive) search for a character in the string.</p>\n</li>\n<li><p><a class=\"xref\" href=\"../../../api/system.string#System_String_IndexOf_System_String_\" data-linktype=\"relative-path\">IndexOf(String)</a>, <a class=\"xref\" href=\"../../../api/system.string#System_String_IndexOf_System_String_System_Int32_\" data-linktype=\"relative-path\">IndexOf(String, Int32)</a>, and <a class=\"xref\" href=\"../../../api/system.string#System_String_IndexOf_System_String_System_Int32_System_Int32_\" data-linktype=\"relative-path\">IndexOf(String, Int32, Int32)</a>, which by default perform a case-sensitive and culture-sensitive search for a substring in the string.</p>\n</li>\n<li><p><a class=\"xref\" href=\"../../../api/system.string#System_String_IndexOf_System_String_System_StringComparison_\" data-linktype=\"relative-path\">IndexOf(String, StringComparison)</a>, <a class=\"xref\" href=\"../../../api/system.string#System_String_IndexOf_System_String_System_Int32_System_StringComparison_\" data-linktype=\"relative-path\">IndexOf(String, Int32, StringComparison)</a>, and <a class=\"xref\" href=\"../../../api/system.string#System_String_IndexOf_System_String_System_Int32_System_Int32_System_StringComparison_\" data-linktype=\"relative-path\">IndexOf(String, Int32, Int32, StringComparison)</a>, which include a parameter of type StringComparison that allows the form of the comparison to be specified.</p>\n</li>\n</ul>\n<p>We recommend that you select an overload that does not use default values, for the following reasons:</p>\n<ul>\n<li><p>Some overloads with default parameters (those that search for a <a class=\"xref\" href=\"../../../api/system.char\" data-linktype=\"relative-path\">Char</a> in the string instance) perform an ordinal comparison, whereas others (those that search for a string in the string instance) are culture-sensitive. It is difficult to remember which method uses which default value, and easy to confuse the overloads.</p>\n</li>\n<li><p>The intent of the code that relies on default values for method calls is not clear. In the following example, which relies on defaults, it is difficult to know whether the developer actually intended an ordinal or a linguistic comparison of two strings, or whether a case difference between <code>protocol</code> and &quot;http&quot; might cause the test for equality to return <code>false</code>.</p>\n</li>\n</ul>\n<pre class=\"loading\"><code class=\"lang-csharp\">string protocol = GetProtocol(url);       \nif (String.Equals(protocol, &quot;http&quot;, StringComparison.OrdinalIgnoreCase)) {\n   // ...Code to handle HTTP protocol.\n}\nelse {\n   throw new InvalidOperationException();\n}\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Dim protocol As String = GetProtocol(url)       \nIf String.Equals(protocol, &quot;http&quot;) Then\n  &#39; ...Code to handle HTTP protocol.\nElse\n   Throw New InvalidOperationException()\nEnd If\n</code></pre><p>In general, we recommend that you call a method that does not rely on defaults, because it makes the intent of the code unambiguous. This, in turn, makes the code more readable and easier to debug and maintain. The following example addresses the questions raised about the previous example. It makes it clear that ordinal comparison is used and that differences in case are ignored. </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">string protocol = GetProtocol(url);       \nif (String.Equals(protocol, &quot;http&quot;, StringComparison.OrdinalIgnoreCase)) {\n   // ...Code to handle HTTP protocol.\n}\nelse {\n   throw new InvalidOperationException();\n}\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Dim protocol As String = GetProtocol(url)       \nIf String.Equals(protocol, &quot;http&quot;, StringComparison.OrdinalIgnoreCase) Then\n   &#39; ...Code to handle HTTP protocol.\nElse\n   Throw New InvalidOperationException()\nEnd If\n</code></pre><h2 id=\"the-details-of-string-comparison\">The details of string comparison</h2>\n<p>String comparison is the heart of many string-related operations, particularly sorting and testing for equality. Strings sort in a determined order: If &quot;my&quot; appears before &quot;string&quot; in a sorted list of strings, &quot;my&quot; must compare less than or equal to &quot;string&quot;. Additionally, comparison implicitly defines equality. The comparison operation returns zero for strings it deems equal. A good interpretation is that neither string is less than the other. Most meaningful operations involving strings include one or both of these procedures: comparing with another string, and executing a well-defined sort operation.</p>\n<p>However, evaluating two strings for equality or sort order does not yield a single, correct result; the outcome depends on the criteria used to compare the strings. In particular, string comparisons that are ordinal or that are based on the casing and sorting conventions of the current culture or the invariant culture (a locale-agnostic culture based on the English language) may produce different results.</p>\n<h3 id=\"string-comparisons-that-use-the-current-culture\">String comparisons that use the current culture</h3>\n<p>One criterion involves using the conventions of the current culture when comparing strings. Comparisons that are based on the current culture use the thread&#39;s current culture or locale. You should always use comparisons that are based on the current culture when data is linguistically relevant, and when it reflects culture-sensitive user interaction. </p>\n<p>However, comparison and casing behavior in .NET changes when the culture changes. This happens when an application executes on a computer that has a different culture than the computer on which the application was developed, or when the executing thread changes its culture. This behavior is intentional, but it remains non-obvious to many developers. The following example illustrates differences in sort order between the U.S. English (&quot;en-US&quot;) and Swedish (&quot;sv-SE&quot;) cultures. Note that the words &quot;ångström&quot;, &quot;Windows&quot;, and &quot;Visual Studio&quot; appear in different positions in the sorted string arrays.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\nusing System.Globalization;\nusing System.Threading;\n\npublic class Example\n{\n   public static void Main()\n   {\n      string[] values= { &quot;able&quot;, &quot;ångström&quot;, &quot;apple&quot;, &quot;Æble&quot;, \n                         &quot;Windows&quot;, &quot;Visual Studio&quot; };\n      Array.Sort(values);\n      DisplayArray(values);\n\n      // Change culture to Swedish (Sweden).\n      string originalCulture = CultureInfo.CurrentCulture.Name;\n      Thread.CurrentThread.CurrentCulture = new CultureInfo(&quot;sv-SE&quot;);\n      Array.Sort(values);\n      DisplayArray(values);\n\n      // Restore the original culture.\n      Thread.CurrentThread.CurrentCulture = new CultureInfo(originalCulture);\n    }\n\n    private static void DisplayArray(string[] values)\n    {\n      Console.WriteLine(&quot;Sorting using the {0} culture:&quot;,  \n                        CultureInfo.CurrentCulture.Name);\n      foreach (string value in values)\n         Console.WriteLine(&quot;   {0}&quot;, value);\n\n      Console.WriteLine();\n    }\n}\n// The example displays the following output:\n//       Sorting using the en-US culture:\n//          able\n//          Æble\n//          ångström\n//          apple\n//          Visual Studio\n//          Windows\n//       \n//       Sorting using the sv-SE culture:\n//          able\n//          Æble\n//          apple\n//          Windows\n//          Visual Studio\n//          ångström\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Imports System.Globalization\nImports System.Threading\n\nModule Example\n   Public Sub Main()\n      Dim values() As String = { &quot;able&quot;, &quot;ångström&quot;, &quot;apple&quot;, _\n                                 &quot;Æble&quot;, &quot;Windows&quot;, &quot;Visual Studio&quot; }\n      Array.Sort(values)\n      DisplayArray(values)\n\n      &#39; Change culture to Swedish (Sweden).\n      Dim originalCulture As String = CultureInfo.CurrentCulture.Name\n      Thread.CurrentThread.CurrentCulture = New CultureInfo(&quot;sv-SE&quot;)\n      Array.Sort(values)\n      DisplayArray(values)\n\n      &#39; Restore the original culture.\n      Thread.CurrentThread.CurrentCulture = New CultureInfo(originalCulture)\n    End Sub\n\n    Private Sub DisplayArray(values() As String)\n      Console.WRiteLine(&quot;Sorting using the {0} culture:&quot;, _ \n                        CultureInfo.CurrentCulture.Name)\n      For Each value As String In values\n         Console.WriteLine(&quot;   {0}&quot;, value)\n      Next\n      Console.WriteLine()   \n    End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       Sorting using the en-US culture:\n&#39;          able\n&#39;          Æble\n&#39;          ångström\n&#39;          apple\n&#39;          Visual Studio\n&#39;          Windows\n&#39;       \n&#39;       Sorting using the sv-SE culture:\n&#39;          able\n&#39;          Æble\n&#39;          apple\n&#39;          Windows\n&#39;          Visual Studio\n&#39;          ångström\n</code></pre><p>Case-insensitive comparisons that use the current culture are the same as culture-sensitive comparisons, except that they ignore case as dictated by the thread&#39;s current culture. This behavior may manifest itself in sort orders as well. </p>\n<p>Comparisons that use current culture semantics are the default for the following methods:</p>\n<ul>\n<li><p><a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String</a> <code>Compare</code> overloads that do not include a <a class=\"xref\" href=\"../../../api/system.stringcomparison\" data-linktype=\"relative-path\">StringComparison</a> parameter.</p>\n</li>\n<li><p><a class=\"xref\" href=\"../../../api/system.string#System_String_CompareTo_System_String_\" data-linktype=\"relative-path\">String.CompareTo</a> overloads.</p>\n</li>\n<li><p>The default <a class=\"xref\" href=\"../../../api/system.string#System_String_StartsWith_System_String_\" data-linktype=\"relative-path\">String.StartsWith(String)</a> method. </p>\n</li>\n<li><p>The default <a class=\"xref\" href=\"../../../api/system.string#System_String_EndsWith_System_String_\" data-linktype=\"relative-path\">String.EndsWith(String)</a> method.</p>\n</li>\n<li><p><a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String</a> <code>IndexOf</code> overloads that accept a <a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String</a> as a search parameter and that do not have a <a class=\"xref\" href=\"../../../api/system.stringcomparison\" data-linktype=\"relative-path\">StringComparison</a> parameter.</p>\n</li>\n<li><p><a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String</a> <code>LastIndexOf</code> overloads that accept a <a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String</a> as a search parameter and that do not have a <a class=\"xref\" href=\"../../../api/system.stringcomparison\" data-linktype=\"relative-path\">StringComparison</a> parameter.</p>\n</li>\n</ul>\n<p>In any case, we recommend that you call an overload that has a <a class=\"xref\" href=\"../../../api/system.stringcomparison\" data-linktype=\"relative-path\">StringComparison</a> parameter to make the intent of the method call clear. </p>\n<p>Subtle and not so subtle bugs can emerge when non-linguistic string data is interpreted linguistically, or when string data from a particular culture is interpreted using the conventions of another culture. The canonical example is the Turkish-I problem.</p>\n<p>For nearly all Latin alphabets, including U.S. English, the character &quot;i&quot; (\\u0069) is the lowercase version of the character &quot;I&quot; (\\u0049). This casing rule quickly becomes the default for someone programming in such a culture. However, the Turkish (&quot;tr-TR&quot;) alphabet includes an &quot;I with a dot&quot; character &quot;İ&quot; (\\u0130), which is the capital version of &quot;i&quot;. Turkish also includes a lowercase &quot;i without a dot&quot; character, &quot;ı&quot; (\\u0131), which capitalizes to &quot;I&quot;. This behavior occurs in the Azerbaijani (&quot;az&quot;) culture as well.</p>\n<p>Therefore, assumptions made about capitalizing &quot;i&quot; or lowercasing &quot;I&quot; are not valid among all cultures. If you use the default overloads for string comparison routines, they will be subject to variance between cultures. If the data to be compared is non-linguistic, using the default overloads can produce undesirable results, as the following attempt to perform a case-insensitive comparison of the strings &quot;file&quot; and &quot;FILE&quot; illustrates.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\nusing System.Globalization;\nusing System.Threading;\n\npublic class Example\n{\n   public static void Main()\n   {\n      string fileUrl = &quot;file&quot;;\n      Thread.CurrentThread.CurrentCulture = new CultureInfo(&quot;en-US&quot;);\n      Console.WriteLine(&quot;Culture = {0}&quot;,\n                        Thread.CurrentThread.CurrentCulture.DisplayName);\n      Console.WriteLine(&quot;(file == FILE) = {0}&quot;, \n                       fileUrl.StartsWith(&quot;FILE&quot;, true, null));\n      Console.WriteLine();\n\n      Thread.CurrentThread.CurrentCulture = new CultureInfo(&quot;tr-TR&quot;);\n      Console.WriteLine(&quot;Culture = {0}&quot;,\n                        Thread.CurrentThread.CurrentCulture.DisplayName);\n      Console.WriteLine(&quot;(file == FILE) = {0}&quot;, \n                        fileUrl.StartsWith(&quot;FILE&quot;, true, null));\n   }\n}\n// The example displays the following output:\n//       Culture = English (United States)\n//       (file == FILE) = True\n//       \n//       Culture = Turkish (Turkey)\n//       (file == FILE) = False\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Imports System.Globalization\nImports System.Threading\n\nModule Example\n   Public Sub Main()\n      Dim fileUrl = &quot;file&quot;\n      Thread.CurrentThread.CurrentCulture = New CultureInfo(&quot;en-US&quot;)\n      Console.WriteLine(&quot;Culture = {0}&quot;, _\n                        Thread.CurrentThread.CurrentCulture.DisplayName)\n      Console.WriteLine(&quot;(file == FILE) = {0}&quot;, _ \n                       fileUrl.StartsWith(&quot;FILE&quot;, True, Nothing))\n      Console.WriteLine()\n\n      Thread.CurrentThread.CurrentCulture = New CultureInfo(&quot;tr-TR&quot;)\n      Console.WriteLine(&quot;Culture = {0}&quot;, _\n                        Thread.CurrentThread.CurrentCulture.DisplayName)\n      Console.WriteLine(&quot;(file == FILE) = {0}&quot;, _ \n                        fileUrl.StartsWith(&quot;FILE&quot;, True, Nothing))\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       Culture = English (United States)\n&#39;       (file == FILE) = True\n&#39;       \n&#39;       Culture = Turkish (Turkey)\n&#39;       (file == FILE) = False\n</code></pre><p>This comparison could cause significant problems if the culture is inadvertently used in security-sensitive settings, as in the following example. A method call such as <code>IsFileURI(&quot;file:&quot;)</code> returns <code>true</code> if the current culture is U.S. English, but <code>false</code> if the current culture is Turkish. Thus, on Turkish systems, someone could circumvent security measures that block access to case-insensitive URIs that begin with &quot;FILE:&quot;.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">public static bool IsFileURI(String path) \n{\n   return path.StartsWith(&quot;FILE:&quot;, true, null);\n}\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Public Shared Function IsFileURI(path As String) As Boolean \n   Return path.StartsWith(&quot;FILE:&quot;, True, Nothing)\nEnd Function\n</code></pre><p>In this case, because &quot;file:&quot; is meant to be interpreted as a non-linguistic, culture-insensitive identifier, the code should instead be written as shown in the following example.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">public static bool IsFileURI(string path) \n{\n   return path.StartsWith(&quot;FILE:&quot;, StringComparison.OrdinalIgnoreCase);\n}\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Public Shared Function IsFileURI(path As String) As Boolean \n    Return path.StartsWith(&quot;FILE:&quot;, StringComparison.OrdinalIgnoreCase)\nEnd Function\n</code></pre><h2 id=\"ordinal-string-operations\">Ordinal String Operations</h2>\n<p>Specifying the <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_Ordinal\" data-linktype=\"relative-path\">StringComparison.Ordinal</a> or <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_OrdinalIgnoreCase\" data-linktype=\"relative-path\">StringComparison.OrdinalIgnoreCase</a> value in a method call signifies a non-linguistic comparison in which the features of natural languages are ignored. Methods that are invoked with these <a class=\"xref\" href=\"../../../api/system.stringcomparison\" data-linktype=\"relative-path\">StringComparison</a> values base string operation decisions on simple byte comparisons instead of casing or equivalence tables that are parameterized by culture. In most cases, this approach best fits the intended interpretation of strings while making code faster and more reliable. </p>\n<p>Ordinal comparisons are string comparisons in which each byte of each string is compared without linguistic interpretation; for example, &quot;windows&quot; does not match &quot;Windows&quot;. Use this comparison when the context dictates that strings should be matched exactly or demands conservative matching policy. Additionally, ordinal comparison is the fastest comparison operation because it applies no linguistic rules when determining a result.</p>\n<p>Strings in .NET can contain embedded null characters. One of the clearest differences between ordinal and culture-sensitive comparison (including comparisons that use the invariant culture) concerns the handling of embedded null characters in a string. These characters are ignored when you use the <a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String</a> <code>Compare</code> and <a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String</a> <code>Equals</code> methods to perform culture-sensitive comparisons (including comparisons that use the invariant culture). As a result, in culture-sensitive comparisons, strings that contain embedded null characters can be considered equal to strings that do not. </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p>Although string comparison methods disregard embedded null characters, string search methods such as <a class=\"xref\" href=\"../../../api/system.string#System_String_Contains_System_String_\" data-linktype=\"relative-path\">String.Contains</a>, <a class=\"xref\" href=\"../../../api/system.string#System_String_EndsWith_System_String_\" data-linktype=\"relative-path\">String.EndsWith</a>, <a class=\"xref\" href=\"../../../api/system.string#System_String_IndexOf_System_Char_\" data-linktype=\"relative-path\">String.IndexOf</a>, <a class=\"xref\" href=\"../../../api/system.string#System_String_LastIndexOf_System_String_\" data-linktype=\"relative-path\">String.LastIndexOf</a>, and <a class=\"xref\" href=\"../../../api/system.string#System_String_StartsWith_System_String_\" data-linktype=\"relative-path\">String.StartsWith</a> do not. </p>\n</div>\n<p>The following example performs a culture-sensitive comparison of the string &quot;Aa&quot; with a similar string that contains several embedded null characters between &quot;A&quot; and &quot;a&quot;, and shows how the two strings are considered equal. </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      string str1 = &quot;Aa&quot;;\n      string str2 = &quot;A&quot; + new String(&#39;\\u0000&#39;, 3) + &quot;a&quot;;\n      Console.WriteLine(&quot;Comparing &#39;{0}&#39; ({1}) and &#39;{2}&#39; ({3}):&quot;, \n                        str1, ShowBytes(str1), str2, ShowBytes(str2));\n      Console.WriteLine(&quot;   With String.Compare:&quot;);\n      Console.WriteLine(&quot;      Current Culture: {0}&quot;, \n                        String.Compare(str1, str2, StringComparison.CurrentCulture));\n      Console.WriteLine(&quot;      Invariant Culture: {0}&quot;, \n                        String.Compare(str1, str2, StringComparison.InvariantCulture));\n\n      Console.WriteLine(&quot;   With String.Equals:&quot;);\n      Console.WriteLine(&quot;      Current Culture: {0}&quot;, \n                        String.Equals(str1, str2, StringComparison.CurrentCulture));\n      Console.WriteLine(&quot;      Invariant Culture: {0}&quot;, \n                        String.Equals(str1, str2, StringComparison.InvariantCulture));\n   }\n\n   private static string ShowBytes(string str)\n   {\n      string hexString = String.Empty;\n      for (int ctr = 0; ctr &lt; str.Length; ctr++)\n      {\n         string result = String.Empty;\n         result = Convert.ToInt32(str[ctr]).ToString(&quot;X4&quot;);\n         result = &quot; &quot; + result.Substring(0,2) + &quot; &quot; + result.Substring(2, 2);\n         hexString += result;\n      }\n      return hexString.Trim();\n   }\n}\n// The example displays the following output:\n//    Comparing &#39;Aa&#39; (00 41 00 61) and &#39;A   a&#39; (00 41 00 00 00 00 00 00 00 61):\n//       With String.Compare:\n//          Current Culture: 0\n//          Invariant Culture: 0\n//       With String.Equals:\n//          Current Culture: True\n//          Invariant Culture: True\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Module Example\n   Public Sub Main()\n      Dim str1 As String = &quot;Aa&quot;\n      Dim str2 As String = &quot;A&quot; + New String(Convert.ToChar(0), 3) + &quot;a&quot;\n      Console.WriteLine(&quot;Comparing &#39;{0}&#39; ({1}) and &#39;{2}&#39; ({3}):&quot;, _\n                        str1, ShowBytes(str1), str2, ShowBytes(str2))\n      Console.WriteLine(&quot;   With String.Compare:&quot;)\n      Console.WriteLine(&quot;      Current Culture: {0}&quot;, _\n                        String.Compare(str1, str2, StringComparison.CurrentCulture))\n      Console.WriteLine(&quot;      Invariant Culture: {0}&quot;, _\n                        String.Compare(str1, str2, StringComparison.InvariantCulture))\n\n      Console.WriteLine(&quot;   With String.Equals:&quot;)\n      Console.WriteLine(&quot;      Current Culture: {0}&quot;, _\n                        String.Equals(str1, str2, StringComparison.CurrentCulture))\n      Console.WriteLine(&quot;      Invariant Culture: {0}&quot;, _\n                        String.Equals(str1, str2, StringComparison.InvariantCulture))\n   End Sub\n\n   Private Function ShowBytes(str As String) As String\n      Dim hexString As String = String.Empty\n      For ctr As Integer = 0 To str.Length - 1\n         Dim result As String = String.Empty\n         result = Convert.ToInt32(str.Chars(ctr)).ToString(&quot;X4&quot;)\n         result = &quot; &quot; + result.Substring(0,2) + &quot; &quot; + result.Substring(2, 2)\n         hexString += result\n      Next\n      Return hexString.Trim()\n   End Function\nEnd Module\n</code></pre><p>However, the strings are not considered equal when you use ordinal comparison, as the following example shows.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">Console.WriteLine(&quot;Comparing &#39;{0}&#39; ({1}) and &#39;{2}&#39; ({3}):&quot;, \n                  str1, ShowBytes(str1), str2, ShowBytes(str2));\nConsole.WriteLine(&quot;   With String.Compare:&quot;);\nConsole.WriteLine(&quot;      Ordinal: {0}&quot;, \n                  String.Compare(str1, str2, StringComparison.Ordinal));\n\nConsole.WriteLine(&quot;   With String.Equals:&quot;);\nConsole.WriteLine(&quot;      Ordinal: {0}&quot;, \n                  String.Equals(str1, str2, StringComparison.Ordinal));\n// The example displays the following output:\n//    Comparing &#39;Aa&#39; (00 41 00 61) and &#39;A   a&#39; (00 41 00 00 00 00 00 00 00 61):\n//       With String.Compare:\n//          Ordinal: 97\n//       With String.Equals:\n//          Ordinal: False\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Console.WriteLine(&quot;Comparing &#39;{0}&#39; ({1}) and &#39;{2}&#39; ({3}):&quot;, _\n                  str1, ShowBytes(str1), str2, ShowBytes(str2))\nConsole.WriteLine(&quot;   With String.Compare:&quot;)\nConsole.WriteLine(&quot;      Ordinal: {0}&quot;, _\n                  String.Compare(str1, str2, StringComparison.Ordinal))\n\nConsole.WriteLine(&quot;   With String.Equals:&quot;)\nConsole.WriteLine(&quot;      Ordinal: {0}&quot;, _\n                  String.Equals(str1, str2, StringComparison.Ordinal))\n&#39; The example displays the following output:\n&#39;    Comparing &#39;Aa&#39; (00 41 00 61) and &#39;A   a&#39; (00 41 00 00 00 00 00 00 00 61):\n&#39;       With String.Compare:\n&#39;          Ordinal: 97\n&#39;       With String.Equals:\n&#39;          Ordinal: False\n</code></pre><p>Case-insensitive ordinal comparisons are the next most conservative approach. These comparisons ignore most casing; for example, &quot;windows&quot; matches &quot;Windows&quot;. When dealing with ASCII characters, this policy is equivalent to <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_Ordinal\" data-linktype=\"relative-path\">StringComparison.Ordinal</a>, except that it ignores the usual ASCII casing. Therefore, any character in [A, Z] (\\u0041-\\u005A) matches the corresponding character in [a,z] (\\u0061-\\007A). Casing outside the ASCII range uses the invariant culture&#39;s tables. Therefore, the following comparison:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">String.Compare(strA, strB, StringComparison.OrdinalIgnoreCase);\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">String.Compare(strA, strB, StringComparison.OrdinalIgnoreCase)\n</code></pre><p>is equivalent to (but faster than) this comparison: </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">String.Compare(strA.ToUpperInvariant(), strB.ToUpperInvariant(), \n               StringComparison.Ordinal);\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">String.Compare(strA.ToUpperInvariant(), strB.ToUpperInvariant(), \n               StringComparison.Ordinal)\n</code></pre><p>These comparisons are still very fast.</p>\n<p>Both <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_Ordinal\" data-linktype=\"relative-path\">StringComparison.Ordinal</a> and <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_OrdinalIgnoreCase\" data-linktype=\"relative-path\">StringComparison.OrdinalIgnoreCase</a> use the binary values directly, and are best suited for matching. When you are not sure about your comparison settings, use one of these two values. However, because they perform a byte-by-byte comparison, they do not sort by a linguistic sort order (like an English dictionary) but by a binary sort order. The results may look odd in most contexts if displayed to users.</p>\n<p>Ordinal semantics are the default for <a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String</a> <code>Equals</code> overloads that do not include a <a class=\"xref\" href=\"../../../api/system.stringcomparison\" data-linktype=\"relative-path\">StringComparison</a> argument (including the equality operator). In any case, we recommend that you call an overload that has a <a class=\"xref\" href=\"../../../api/system.stringcomparison\" data-linktype=\"relative-path\">StringComparison</a> parameter.</p>\n<h3 id=\"string-operations-that-use-the-invariant-culture\">String operations that use the invariant culture</h3>\n<p>Comparisons with the invariant culture use the <a class=\"xref\" href=\"../../../api/system.globalization.compareinfo\" data-linktype=\"relative-path\">CompareInfo</a> property returned by the static <a class=\"xref\" href=\"../../../api/system.globalization.cultureinfo#System_Globalization_CultureInfo_InvariantCulture\" data-linktype=\"relative-path\">CultureInfo.InvariantCulture</a> property. This behavior is the same on all systems; it translates any characters outside its range into what it believes are equivalent invariant characters. This policy can be useful for maintaining one set of string behavior across cultures, but it often provides unexpected results.</p>\n<p>Case-insensitive comparisons with the invariant culture use the static <a class=\"xref\" href=\"../../../api/system.globalization.compareinfo\" data-linktype=\"relative-path\">CompareInfo</a> property returned by the static <a class=\"xref\" href=\"../../../api/system.globalization.cultureinfo#System_Globalization_CultureInfo_InvariantCulture\" data-linktype=\"relative-path\">CultureInfo.InvariantCulture</a> property for comparison information as well. Any case differences among these translated characters are ignored.</p>\n<p>The <a class=\"xref\" href=\"../../../api/system.globalization.cultureinfo#System_Globalization_CultureInfo_InvariantCulture\" data-linktype=\"relative-path\">CultureInfo.InvariantCulture</a> object makes a <a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String</a> <code>Compare</code> method interpret certain sets of characters as equivalent. For example, the following equivalence is valid under the invariant culture:</p>\n<p>InvariantCulture: a + ̊ = å</p>\n<p>The latin small lette A character &quot;a&quot; (\\u0061), when it is next to the combining ring above character &quot;+ &quot; ̊&quot; (\\u030a), is interpreted as the latin small letter A with ring above character &quot;å&quot; (\\u00e5). As the following example shows, this behavior differs from ordinal comparison.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">string separated = &quot;\\u0061\\u030a&quot;;\nstring combined = &quot;\\u00e5&quot;;\n\nConsole.WriteLine(&quot;Equal sort weight of {0} and {1} using InvariantCulture: {2}&quot;,\n                  separated, combined, \n                  String.Compare(separated, combined, \n                                 StringComparison.InvariantCulture) == 0);\n\nConsole.WriteLine(&quot;Equal sort weight of {0} and {1} using Ordinal: {2}&quot;,\n                  separated, combined,\n                  String.Compare(separated, combined, \n                                 StringComparison.Ordinal) == 0);\n// The example displays the following output:\n//    Equal sort weight of a° and å using InvariantCulture: True\n//    Equal sort weight of a° and å using Ordinal: False \n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Dim separated As String = ChrW(&amp;h61) + ChrW(&amp;h30a)\nDim combined As String = ChrW(&amp;he5)\n\nConsole.WriteLine(&quot;Equal sort weight of {0} and {1} using InvariantCulture: {2}&quot;, _\n                  separated, combined, _\n                  String.Compare(separated, combined, _ \n                                 StringComparison.InvariantCulture) = 0)\n\nConsole.WriteLine(&quot;Equal sort weight of {0} and {1} using Ordinal: {2}&quot;, _\n                  separated, combined, _\n                  String.Compare(separated, combined, _\n                                 StringComparison.Ordinal) = 0)\n&#39; The example displays the following output:\n&#39;    Equal sort weight of a° and å using InvariantCulture: True\n&#39;    Equal sort weight of a° and å using Ordinal: False\n</code></pre><p>When interpreting file names, cookies, or anything else where a combination such as &quot;å&quot; can appear, ordinal comparisons still offer the most transparent and fitting behavior.</p>\n<p>On balance, the invariant culture has very few properties that make it useful for comparison. It does comparison in a linguistically relevant manner, which prevents it from guaranteeing full symbolic equivalence, but it is not the choice for display in any culture. For example, if a large data file that contains a list of sorted identifiers for display accompanies an application, adding to this list would require an insertion with invariant-style sorting.</p>\n<h2 id=\"choosing-a-stringcomparison-member-for-your-method-call\">Choosing a StringComparison member for your method call</h2>\n<p>The following table outlines the mapping from semantic string context to a <a class=\"xref\" href=\"../../../api/system.stringcomparison\" data-linktype=\"relative-path\">StringComparison</a> enumeration member.</p>\n<table>\n<thead>\n<tr>\n<th>Data</th>\n<th>Behavior</th>\n<th>Corresponding System.StringComparison value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Case-sensitive internal identifiers, case-sensitive identifiers in standards such as XML and HTTP, or case-sensitive security-related settings.</td>\n<td>A non-linguistic identifier, where bytes match exactly.</td>\n<td><a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_Ordinal\" data-linktype=\"relative-path\">StringComparison.Ordinal</a></td>\n</tr>\n<tr>\n<td>Case-insensitive internal identifiers, case-insensitive identifiers in standards such as XML and HTTP, file paths, registry keys and values, environment variables, resource identifiers (for example, handle names), or case-insensitive security-related settings.</td>\n<td>A non-linguistic identifier, where case is irrelevant.</td>\n<td><a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_OrdinalIgnoreCase\" data-linktype=\"relative-path\">StringComparison.OrdinalIgnoreCase</a></td>\n</tr>\n<tr>\n<td>Data displayed to the user or most user input.</td>\n<td>Data that requires local linguistic customs.</td>\n<td><a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_CurrentCulture\" data-linktype=\"relative-path\">StringComparison.CurrentCulture</a> or <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_CurrentCultureIgnoreCase\" data-linktype=\"relative-path\">CurrentCultureIgnoreCase</a></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"common-string-comparison-methods\">Common string comparison methods</h2>\n<p>The following sections describe the methods that are most commonly used for string comparison.</p>\n<h3 id=\"stringcompare\">String.Compare</h3>\n<p>Default interpretation: <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_CurrentCulture\" data-linktype=\"relative-path\">StringComparison.CurrentCulture</a>.</p>\n<p>As the operation most central to string interpretation, all instances of these method calls should be examined to determine whether strings should be interpreted according to the current culture, or dissociated from the culture (symbolically). Typically, it is the latter, and a <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_Ordinal\" data-linktype=\"relative-path\">StringComparison.Ordinal</a> comparison should be used instead.</p>\n<p>The <a class=\"xref\" href=\"../../../api/system.globalization.compareinfo\" data-linktype=\"relative-path\">System.Globalization.CompareInfo</a> class, which is returned by the <a class=\"xref\" href=\"../../../api/system.globalization.cultureinfo#System_Globalization_CultureInfo_CompareInfo\" data-linktype=\"relative-path\">CultureInfo.CompareInfo</a> property, also includes a <a class=\"xref\" href=\"../../../api/system.globalization.compareinfo#System_Globalization_CompareInfo_Compare_System_String_System_Int32_System_String_System_Int32_System_Globalization_CompareOptions_\" data-linktype=\"relative-path\">Compare</a> method that provides a large number of matching options (ordinal, ignoring white space, ignoring kana type, and so on) by means of the <a class=\"xref\" href=\"../../../api/system.globalization.compareoptions\" data-linktype=\"relative-path\">CompareOptions</a> flag enumeration. </p>\n<h3 id=\"stringcompareto\">String.CompareTo</h3>\n<p>Default interpretation: <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_CurrentCulture\" data-linktype=\"relative-path\">StringComparison.CurrentCulture</a>.</p>\n<p>This method does not currently offer an overload that specifies a <a class=\"xref\" href=\"../../../api/system.stringcomparison\" data-linktype=\"relative-path\">StringComparison</a> type. It is usually possible to convert this method to the recommended <a class=\"xref\" href=\"../../../api/system.string#System_String_Compare_System_String_System_String_System_StringComparison_\" data-linktype=\"relative-path\">String.Compare(String, String, StringComparison)</a> form.</p>\n<p>Types that implement the <a class=\"xref\" href=\"../../../api/system.icomparable\" data-linktype=\"relative-path\">IComparable</a> and <a class=\"xref\" href=\"../../../api/system.icomparable-1\" data-linktype=\"relative-path\">IComparable&lt;T&gt;</a> interfaces implement this method. Because it does not offer the option of a <a class=\"xref\" href=\"../../../api/system.stringcomparison\" data-linktype=\"relative-path\">StringComparison</a> parameter, implementing types often let the user specify a <a class=\"xref\" href=\"../../../api/system.stringcomparer\" data-linktype=\"relative-path\">StringComparer</a> in their constructor. The following example defines a <code>FileName</code> class whose class constructor includes a <a class=\"xref\" href=\"../../../api/system.stringcomparer\" data-linktype=\"relative-path\">StringComparer</a> parameter. This <a class=\"xref\" href=\"../../../api/system.stringcomparer\" data-linktype=\"relative-path\">StringComparer</a> object is then used in the <code>FileName.CompareTo</code> method.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\n\npublic class FileName : IComparable\n{\n   string fname;\n   StringComparer comparer; \n\n   public FileName(string name, StringComparer comparer)\n   {\n      if (String.IsNullOrEmpty(name))\n         throw new ArgumentNullException(&quot;name&quot;);\n\n      this.fname = name;\n\n      if (comparer != null)\n         this.comparer = comparer;\n      else\n         this.comparer = StringComparer.OrdinalIgnoreCase;\n   }\n\n   public string Name\n   {\n      get { return fname; }\n   }\n\n   public int CompareTo(object obj)\n   {\n      if (obj == null) return 1;\n\n      if (! (obj is FileName))\n         return comparer.Compare(this.fname, obj.ToString());\n      else\n         return comparer.Compare(this.fname, ((FileName) obj).Name);\n   }\n}\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Public Class FileName : Implements IComparable\n   Dim fname As String\n   Dim comparer As StringComparer \n\n   Public Sub New(name As String, comparer As StringComparer)\n      If String.IsNullOrEmpty(name) Then\n         Throw New ArgumentNullException(&quot;name&quot;)\n      End If\n\n      Me.fname = name\n\n      If comparer IsNot Nothing Then\n         Me.comparer = comparer\n      Else\n         Me.comparer = StringComparer.OrdinalIgnoreCase\n      End If      \n   End Sub\n\n   Public ReadOnly Property Name As String\n      Get\n         Return fname\n      End Get   \n   End Property\n\n   Public Function CompareTo(obj As Object) As Integer _\n          Implements IComparable.CompareTo\n      If obj Is Nothing Then Return 1\n\n      If Not TypeOf obj Is FileName Then\n         obj = obj.ToString()\n      Else\n         obj = CType(obj, FileName).Name\n      End If         \n      Return comparer.Compare(Me.fname, obj)\n   End Function\nEnd Class\n</code></pre><h3 id=\"stringequals\">String.Equals</h3>\n<p>Default interpretation: <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_Ordinal\" data-linktype=\"relative-path\">StringComparison.Ordinal</a>.</p>\n<p>The <a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String</a> class lets you test for equality by calling either the static or instance <code>Equals</code> method overloads, or by using the static equality operator. The overloads and operator use ordinal comparison by default. However, we still recommend that you call an overload that explicitly specifies the <a class=\"xref\" href=\"../../../api/system.stringcomparison\" data-linktype=\"relative-path\">StringComparison</a> type even if you want to perform an ordinal comparison; this makes it easier to search code for a certain string interpretation. </p>\n<h3 id=\"stringtoupper-and-stringtolower\">String.ToUpper and String.ToLower</h3>\n<p>Default interpretation: <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_CurrentCulture\" data-linktype=\"relative-path\">StringComparison.CurrentCulture</a>.</p>\n<p>You should be careful when you use these methods, because forcing a string to a uppercase or lowercase is often used as a small normalization for comparing strings regardless of case. If so, consider using a case-insensitive comparison. </p>\n<p>The <a class=\"xref\" href=\"../../../api/system.string#System_String_ToUpperInvariant\" data-linktype=\"relative-path\">String.ToUpperInvariant</a> and <a class=\"xref\" href=\"../../../api/system.string#System_String_ToLowerInvariant\" data-linktype=\"relative-path\">String.ToLowerInvariant</a> methods are also available. <a class=\"xref\" href=\"../../../api/system.string#System_String_ToUpperInvariant\" data-linktype=\"relative-path\">ToUpperInvariant</a> is the standard way to normalize case. Comparisons made using <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_OrdinalIgnoreCase\" data-linktype=\"relative-path\">StringComparison.OrdinalIgnoreCase</a> are behaviorally the composition of two calls: calling <a class=\"xref\" href=\"../../../api/system.string#System_String_ToUpperInvariant\" data-linktype=\"relative-path\">ToUpperInvariant</a> on both string arguments, and doing a comparison using <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_Ordinal\" data-linktype=\"relative-path\">StringComparison.Ordinal</a>.</p>\n<p>Overloads are also available for converting to uppercase and lowercase in a specific culture, by passing a <a class=\"xref\" href=\"../../../api/system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a> object that represents that culture to the method.</p>\n<h3 id=\"chartoupper-and-chartolower\">Char.ToUpper and Char.ToLower</h3>\n<p>Default interpretation: <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_CurrentCulture\" data-linktype=\"relative-path\">StringComparison.CurrentCulture</a>.</p>\n<p>These methods work similarly to the <a class=\"xref\" href=\"../../../api/system.string#System_String_ToUpper\" data-linktype=\"relative-path\">String.ToUpper</a> and <a class=\"xref\" href=\"../../../api/system.string#System_String_ToLower\" data-linktype=\"relative-path\">String.ToLower</a> methods described in the previous section.</p>\n<h3 id=\"stringstartswith-and-stringendswith\">String.StartsWith and String.EndsWith</h3>\n<p>Default interpretation: <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_CurrentCulture\" data-linktype=\"relative-path\">StringComparison.CurrentCulture</a>.</p>\n<p>By default, both of these methods perform a culture-sensitive comparison.</p>\n<h3 id=\"stringindexof-and-stringlastindexof\">String.IndexOf and String.LastIndexOf</h3>\n<p>Default interpretation: <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_CurrentCulture\" data-linktype=\"relative-path\">StringComparison.CurrentCulture</a>.</p>\n<p>There is a lack of consistency in how the default overloads of these methods perform comparisons. All <a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String</a> <code>IndexOf</code> and <a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String</a> <code>LastIndexOf</code> methods that include a <a class=\"xref\" href=\"../../../api/system.char\" data-linktype=\"relative-path\">Char</a> parameter perform an ordinal comparison, but the default <a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String</a> <code>IndexOf</code> and <a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String`</a> <code>LastIndexOf</code> methods that include a <a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String</a> parameter perform a culture-sensitive comparison. </p>\n<p>If you call <code>`IndexOf</code> or <code>LastIndexOf</code> method and pass it a string to locate in the current instance, we recommend that you call an overload that explicitly specifies the <a class=\"xref\" href=\"../../../api/system.stringcomparison\" data-linktype=\"relative-path\">StringComparison</a> type. The overloads that include a <a class=\"xref\" href=\"../../../api/system.char\" data-linktype=\"relative-path\">Char</a> argument do not allow you to specify a <a class=\"xref\" href=\"../../../api/system.stringcomparison\" data-linktype=\"relative-path\">StringComparison</a> type.</p>\n<h2 id=\"methods-that-perform-string-comparison-indirectly\">Methods that perform string comparison indirectly</h2>\n<p>Some non-string methods that have string comparison as a central operation use the <a class=\"xref\" href=\"../../../api/system.stringcomparer\" data-linktype=\"relative-path\">StringComparer</a> type. The <a class=\"xref\" href=\"../../../api/system.stringcomparer\" data-linktype=\"relative-path\">StringComparer</a> class includes four static properties that return <a class=\"xref\" href=\"../../../api/system.stringcomparer\" data-linktype=\"relative-path\">StringComparer</a> instances whose <code>Compare</code> methods perform the following types of string comparisons:</p>\n<ul>\n<li><p>Culture-sensitive string comparisons using the current culture. This <a class=\"xref\" href=\"../../../api/system.stringcomparer\" data-linktype=\"relative-path\">StringComparer</a> object is returned by the <a class=\"xref\" href=\"../../../api/system.stringcomparer#System_StringComparer_CurrentCulture\" data-linktype=\"relative-path\">StringComparer.CurrentCulture</a> property.</p>\n</li>\n<li><p>Case-insensitive comparisons using the current culture. This <a class=\"xref\" href=\"../../../api/system.stringcomparer\" data-linktype=\"relative-path\">StringComparer</a> object is returned by the <a class=\"xref\" href=\"../../../api/system.stringcomparer#System_StringComparer_CurrentCultureIgnoreCase\" data-linktype=\"relative-path\">StringComparer.CurrentCultureIgnoreCase</a> property.</p>\n</li>\n<li><p>Ordinal comparison. This <a class=\"xref\" href=\"../../../api/system.stringcomparer\" data-linktype=\"relative-path\">StringComparer</a> object is returned by the <a class=\"xref\" href=\"../../../api/system.stringcomparer#System_StringComparer_Ordinal\" data-linktype=\"relative-path\">StringComparer.Ordinal</a> property. </p>\n</li>\n<li><p>Case-insensitive ordinal comparison. This <a class=\"xref\" href=\"../../../api/system.stringcomparer\" data-linktype=\"relative-path\">StringComparer</a> object is returned by the <a class=\"xref\" href=\"../../../api/system.stringcomparer#System_StringComparer_OrdinalIgnoreCase\" data-linktype=\"relative-path\">StringComparer.OrdinalIgnoreCase</a> property.</p>\n</li>\n</ul>\n<h3 id=\"arraysort-and-arraybinarysearch\">Array.Sort and Array.BinarySearch</h3>\n<p>Default interpretation: <a class=\"xref\" href=\"../../../api/system.stringcomparison#System_StringComparison_CurrentCulture\" data-linktype=\"relative-path\">StringComparison.CurrentCulture</a>.</p>\n<p>When you store any data in a collection, or read persisted data from a file or database into a collection, switching the current culture can invalidate the invariants in the collection. The <a class=\"xref\" href=\"../../../api/system.array#System_Array_BinarySearch_System_Array_System_Object_\" data-linktype=\"relative-path\">Array.BinarySearch</a> method assumes that the elements in the array to be searched are already sorted. To sort any string element in the array, the <a class=\"xref\" href=\"../../../api/system.array#System_Array_Sort_System_Array_\" data-linktype=\"relative-path\">Array.Sort</a> method calls the [String] <code>Compare</code> method to order individual elements. Using a culture-sensitive comparer can be dangerous if the culture changes between the time that the array is sorted and its contents are searched. For example, in the following code, storage and retrieval operate on the comparer that is provided implicitly by the <code>Thread.CurrentThread.CurrentCulture</code> property. If the culture can change between the calls to <code>StoreNames</code> and <code>DoesNameExist</code>, and especially if the array contents are persisted somewhere between the two method calls, the binary search may fail. </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">// Incorrect.\nstring []storedNames;\n\npublic void StoreNames(string [] names)\n{\n   int index = 0;\n   storedNames = new string[names.Length];\n\n   foreach (string name in names)\n   {\n      this.storedNames[index++] = name;\n   }\n\n   Array.Sort(names); // Line A.\n}\n\npublic bool DoesNameExist(string name)\n{\n   return (Array.BinarySearch(this.storedNames, name) &gt;= 0);  // Line B.\n}\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">&#39; Incorrect.\nDim storedNames() As String\n\nPublic Sub StoreNames(names() As String)\n   Dim index As Integer = 0\n   ReDim storedNames(names.Length - 1)\n\n   For Each name As String In names\n      Me.storedNames(index) = name\n      index+= 1\n   Next\n\n   Array.Sort(names)          &#39; Line A.\nEnd Sub\n\nPublic Function DoesNameExist(name As String) As Boolean\n   Return Array.BinarySearch(Me.storedNames, name) &gt;= 0      &#39; Line B.\nEnd Function\n</code></pre><p>A recommended variation appears in the following example, which uses the same ordinal (culture-insensitive) comparison method both to sort and to search the array. The change code is reflected in the lines labeled <code>Line A</code> and <code>Line B</code> in the two examples.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">// Correct.\nstring []storedNames;\n\npublic void StoreNames(string [] names)\n{\n   int index = 0;\n   storedNames = new string[names.Length];\n\n   foreach (string name in names)\n   {\n      this.storedNames[index++] = name;\n   }\n\n   Array.Sort(names, StringComparer.Ordinal);  // Line A.\n}\n\npublic bool DoesNameExist(string name)\n{\n   return (Array.BinarySearch(this.storedNames, name, StringComparer.Ordinal) &gt;= 0);  // Line B.\n}\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">&#39; Correct.\nDim storedNames() As String\n\nPublic Sub StoreNames(names() As String)\n   Dim index As Integer = 0\n   ReDim storedNames(names.Length - 1)\n\n   For Each name As String In names\n      Me.storedNames(index) = name\n      index+= 1\n   Next\n\n   Array.Sort(names, StringComparer.Ordinal)           &#39; Line A.\nEnd Sub\n\nPublic Function DoesNameExist(name As String) As Boolean\n   Return Array.BinarySearch(Me.storedNames, name, StringComparer.Ordinal) &gt;= 0      &#39; Line B.\nEnd Function\n</code></pre><p>If this data is persisted and moved across cultures, and sorting is used to present this data to the user, you might consider using <code>StringComparison.InvariantCulture</code>, which operates linguistically for better user output but is unaffected by changes in culture. The following example modifies the two previous examples to use the invariant culture for sorting and searching the array.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">// Correct.\nstring []storedNames;\n\npublic void StoreNames(string [] names)\n{\n   int index = 0;\n   storedNames = new string[names.Length];\n\n   foreach (string name in names)\n   {\n      this.storedNames[index++] = name;\n   }\n\n   Array.Sort(names, StringComparer.InvariantCulture);  // Line A.\n}\n\npublic bool DoesNameExist(string name)\n{\n   return (Array.BinarySearch(this.storedNames, name, StringComparer.InvariantCulture) &gt;= 0);  // Line B.\n}\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">&#39; Correct.\nDim storedNames() As String\n\nPublic Sub StoreNames(names() As String)\n   Dim index As Integer = 0\n   ReDim storedNames(names.Length - 1)\n\n   For Each name As String In names\n      Me.storedNames(index) = name\n      index+= 1\n   Next\n\n   Array.Sort(names, StringComparer.InvariantCulture)           &#39; Line A.\nEnd Sub\n\nPublic Function DoesNameExist(name As String) As Boolean\n   Return Array.BinarySearch(Me.storedNames, name, StringComparer.InvariantCulture) &gt;= 0      &#39; Line B.\nEnd Function\n</code></pre><h3 id=\"collections-example-hashtable-constructor\">Collections Example: Hashtable Constructor</h3>\n<p>Hashing strings provides a second example of an operation that is affected by the way in which strings are compared. </p>\n<p>The following example instantiates a <a class=\"xref\" href=\"../../../api/system.collections.hashtable\" data-linktype=\"relative-path\">Hashtable</a> object by passing it the <a class=\"xref\" href=\"../../../api/system.stringcomparer\" data-linktype=\"relative-path\">StringComparer</a> object that is returned by the <a class=\"xref\" href=\"../../../api/system.stringcomparer#System_StringComparer_OrdinalIgnoreCase\" data-linktype=\"relative-path\">StringComparer.OrdinalIgnoreCase</a> property. Because a class <a class=\"xref\" href=\"../../../api/system.stringcomparer\" data-linktype=\"relative-path\">StringComparer</a> that is derived from <a class=\"xref\" href=\"../../../api/system.stringcomparer\" data-linktype=\"relative-path\">StringComparer</a> implements the <a class=\"xref\" href=\"../../../api/system.collections.iequalitycomparer\" data-linktype=\"relative-path\">IEqualityComparer</a> interface, its <a class=\"xref\" href=\"../../../api/system.collections.iequalitycomparer\" data-linktype=\"relative-path\">GetHashCode</a> method is used to compute the hash code of strings in the hash table.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">const int initialTableCapacity = 100;\nHashtable h;\n\npublic void PopulateFileTable(string directory)\n{\n   h = new Hashtable(initialTableCapacity, \n                     StringComparer.OrdinalIgnoreCase);\n\n   foreach (string file in Directory.GetFiles(directory))\n         h.Add(file, File.GetCreationTime(file));\n}\n\npublic void PrintCreationTime(string targetFile)\n{\n   Object dt = h[targetFile];\n   if (dt != null)\n   {\n      Console.WriteLine(&quot;File {0} was created at time {1}.&quot;,\n         targetFile, \n         (DateTime) dt);\n   }\n   else\n   {\n      Console.WriteLine(&quot;File {0} does not exist.&quot;, targetFile);\n   }\n}\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Const initialTableCapacity As Integer = 100\nDim h As Hashtable\n\nPublic Sub PopulateFileTable(dir As String)\n   h = New Hashtable(initialTableCapacity, _\n                     StringComparer.OrdinalIgnoreCase)\n\n   For Each filename As String In Directory.GetFiles(dir)\n      h.Add(filename, File.GetCreationTime(filename))\n   Next                        \nEnd Sub\n\nPublic Sub PrintCreationTime(targetFile As String)\n   Dim dt As Object = h(targetFile)\n   If dt IsNot Nothing Then\n      Console.WriteLine(&quot;File {0} was created at {1}.&quot;, _\n         targetFile, _\n         CDate(dt))\n   Else\n      Console.WriteLine(&quot;File {0} does not exist.&quot;, targetFile)\n   End If\nEnd Sub  \n</code></pre><h2 id=\"displaying-and-persisting-formatted-data\">Displaying and persisting formatted data</h2>\n<p>When you display non-string data such as numbers and dates and times to users, format them by using the user&#39;s cultural settings. By default, the <a href=\"xref:System.String.Format(System.IFormatProvider,System.String,System.Object)\" data-linktype=\"external\">String.Format</a> method and the <code>ToString</code> methods of the numeric types and the date and time types use the current thread culture for formatting operations. To explicitly specify that the formatting method should use the current culture, you can call an overload of a formatting method that has a provider parameter, such as <a href=\"xref:System.String.Format(System.IFormatProvider,System.String,System.Object)\" data-linktype=\"external\">String.Format(IFormatProvider, String, Object[])</a> or <a class=\"xref\" href=\"../../../api/system.datetime#System_DateTime_ToString_System_IFormatProvider_\" data-linktype=\"relative-path\">DateTime.ToString(IFormatProvider)</a>, and pass it the <a class=\"xref\" href=\"../../../api/system.globalization.cultureinfo#System_Globalization_CultureInfo_CurrentCulture\" data-linktype=\"relative-path\">CultureInfo.CurrentCulture</a> property. </p>\n<p>You can persist non-string data either as binary data or as formatted data. If you choose to save it as formatted data, you should call a formatting method overload that includes a <em>provider</em> parameter and pass it the <a class=\"xref\" href=\"../../../api/system.globalization.cultureinfo#System_Globalization_CultureInfo_InvariantCulture\" data-linktype=\"relative-path\">CultureInfo.InvariantCulture</a> property. The invariant culture provides a consistent format for formatted data that is independent of culture and machine. In contrast, persisting data that is formatted by using cultures other than the invariant culture has a number of limitations: </p>\n<ul>\n<li><p>The data is likely to be unusable if it is retrieved on a system that has a different culture, or if the user of the current system changes the current culture and tries to retrieve the data. </p>\n</li>\n<li><p>The properties of a culture on a specific computer can differ from standard values. At any time, a user can customize culture-sensitive display settings. Because of this, formatted data that is saved on a system may not be readable after the user customizes cultural settings. The portability of formatted data across computers is likely to be even more limited. </p>\n</li>\n<li><p>International, regional, or national standards that govern the formatting of numbers or dates and times change over time, and these changes are incorporated into operating system updates. When formatting conventions change, data that was formatted by using the previous conventions may become unreadable. </p>\n</li>\n</ul>\n<p>The following example illustrates the limited portability that results from using culture-sensitive formatting to persist data. The example saves an array of date and time values to a file. These are formatted by using the conventions of the English (United States) culture. After the application changes the current thread culture to French (Switzerland), it tries to read the saved values by using the formatting conventions of the current culture. The attempt to read two of the data items throws a <a class=\"xref\" href=\"../../../api/system.formatexception\" data-linktype=\"relative-path\">FormatException</a> exception, and the array of dates now contains two incorrect elements that are equal to <a class=\"xref\" href=\"../../../api/system.datetime#System_DateTime_MinValue\" data-linktype=\"relative-path\">MinValue</a>. </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\nusing System.Globalization;\nusing System.IO;\nusing System.Text;\nusing System.Threading;\n\npublic class Example\n{\n   private static string filename = @&quot;.\\dates.dat&quot;;\n\n   public static void Main()\n   {\n      DateTime[] dates = { new DateTime(1758, 5, 6, 21, 26, 0), \n                           new DateTime(1818, 5, 5, 7, 19, 0), \n                           new DateTime(1870, 4, 22, 23, 54, 0),  \n                           new DateTime(1890, 9, 8, 6, 47, 0), \n                           new DateTime(1905, 2, 18, 15, 12, 0) }; \n      // Write the data to a file using the current culture.\n      WriteData(dates);\n      // Change the current culture.\n      Thread.CurrentThread.CurrentCulture = CultureInfo.CreateSpecificCulture(&quot;fr-CH&quot;);\n      // Read the data using the current culture.\n      DateTime[] newDates = ReadData();\n      foreach (var newDate in newDates)\n         Console.WriteLine(newDate.ToString(&quot;g&quot;));\n   }\n\n   private static void WriteData(DateTime[] dates) \n   {\n      StreamWriter sw = new StreamWriter(filename, false, Encoding.UTF8);    \n      for (int ctr = 0; ctr &lt; dates.Length; ctr++) {\n         sw.Write(&quot;{0}&quot;, dates[ctr].ToString(&quot;g&quot;, CultureInfo.CurrentCulture));\n         if (ctr &lt; dates.Length - 1) sw.Write(&quot;|&quot;);   \n      }      \n      sw.Close();\n   }\n\n   private static DateTime[] ReadData() \n   {\n      bool exceptionOccurred = false;\n\n      // Read file contents as a single string, then split it.\n      StreamReader sr = new StreamReader(filename, Encoding.UTF8);\n      string output = sr.ReadToEnd();\n      sr.Close();   \n\n      string[] values = output.Split( new char[] { &#39;|&#39; } );\n      DateTime[] newDates = new DateTime[values.Length]; \n      for (int ctr = 0; ctr &lt; values.Length; ctr++) {\n         try {\n            newDates[ctr] = DateTime.Parse(values[ctr], CultureInfo.CurrentCulture);\n         }\n         catch (FormatException) {\n            Console.WriteLine(&quot;Failed to parse {0}&quot;, values[ctr]);\n            exceptionOccurred = true;\n         }\n      }      \n      if (exceptionOccurred) Console.WriteLine();\n      return newDates;\n   }\n}\n// The example displays the following output:\n//       Failed to parse 4/22/1870 11:54 PM\n//       Failed to parse 2/18/1905 3:12 PM\n//       \n//       05.06.1758 21:26\n//       05.05.1818 07:19\n//       01.01.0001 00:00\n//       09.08.1890 06:47\n//       01.01.0001 00:00\n//       01.01.0001 00:00\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Imports System.Globalization\nImports System.IO\nImports System.Text\nImports System.Threading\n\nModule Example\n   Private filename As String = &quot;.\\dates.dat&quot;\n\n   Public Sub Main()\n      Dim dates() As Date = { #5/6/1758 9:26PM#, #5/5/1818 7:19AM#, _ \n                              #4/22/1870 11:54PM#, #9/8/1890 6:47AM#, _ \n                              #2/18/1905 3:12PM# }\n      &#39; Write the data to a file using the current culture.\n      WriteData(dates)\n      &#39; Change the current culture.\n      Thread.CurrentThread.CurrentCulture = CultureInfo.CreateSpecificCulture(&quot;fr-CH&quot;)\n      &#39; Read the data using the current culture.\n      Dim newDates() As Date = ReadData()\n      For Each newDate In newDates\n         Console.WriteLine(newDate.ToString(&quot;g&quot;))\n      Next\n   End Sub\n\n   Private Sub WriteData(dates() As Date)\n      Dim sw As New StreamWriter(filename, False, Encoding.Utf8)    \n      For ctr As Integer = 0 To dates.Length - 1\n         sw.Write(&quot;{0}&quot;, dates(ctr).ToString(&quot;g&quot;, CultureInfo.CurrentCulture))\n         If ctr &lt; dates.Length - 1 Then sw.Write(&quot;|&quot;)   \n      Next      \n      sw.Close()\n   End Sub\n\n   Private Function ReadData() As Date()\n      Dim exceptionOccurred As Boolean = False\n\n      &#39; Read file contents as a single string, then split it.\n      Dim sr As New StreamReader(filename, Encoding.Utf8)\n      Dim output As String = sr.ReadToEnd()\n      sr.Close()   \n\n      Dim values() As String = output.Split( {&quot;|&quot;c } )\n      Dim newDates(values.Length - 1) As Date \n      For ctr As Integer = 0 To values.Length - 1\n         Try\n            newDates(ctr) = DateTime.Parse(values(ctr), CultureInfo.CurrentCulture)\n         Catch e As FormatException\n            Console.WriteLine(&quot;Failed to parse {0}&quot;, values(ctr))\n            exceptionOccurred = True\n         End Try\n      Next      \n      If exceptionOccurred Then Console.WriteLine()\n      Return newDates\n   End Function\nEnd Module\n&#39; The example displays the following output:\n&#39;       Failed to parse 4/22/1870 11:54 PM\n&#39;       Failed to parse 2/18/1905 3:12 PM\n&#39;       \n&#39;       05.06.1758 21:26\n&#39;       05.05.1818 07:19\n&#39;       01.01.0001 00:00\n&#39;       09.08.1890 06:47\n&#39;       01.01.0001 00:00\n&#39;       01.01.0001 00:00\n&#39;\n</code></pre><p>However, if you replace the <a class=\"xref\" href=\"../../../api/system.globalization.cultureinfo#System_Globalization_CultureInfo_CurrentCulture\" data-linktype=\"relative-path\">CultureInfo.CurrentCulture</a> property with <a class=\"xref\" href=\"../../../api/system.globalization.cultureinfo#System_Globalization_CultureInfo_InvariantCulture\" data-linktype=\"relative-path\">CultureInfo.InvariantCulture</a> in the calls to <a class=\"xref\" href=\"../../../api/system.datetime#System_DateTime_ToString_System_String_System_IFormatProvider_\" data-linktype=\"relative-path\">DateTime.ToString(String, IFormatProvider)</a> and <a class=\"xref\" href=\"../../../api/system.datetime#System_DateTime_Parse_System_String_System_IFormatProvider_\" data-linktype=\"relative-path\">DateTime.Parse(String, IFormatProvider)</a>, the persisted date and time data is successfully restored, as the following output shows.</p>\n<pre class=\"loading\"><code>// 06.05.1758 21:26\n// 05.05.1818 07:19\n// 22.04.1870 23:54\n// 08.09.1890 06:47\n// 18.02.1905 15:12\n</code></pre><h2 id=\"see-also\">See also</h2>\n<p><a href=\"manipulating-strings\" data-linktype=\"relative-path\">Manipulating strings</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"shoag\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc.json\">\r\n<meta name=\"ms.devlang\" content=\"dotnet\">\r\n<meta name=\"ms.assetid\" content=\"b3cefaa4-0a3f-4a96-aba9-1de30fb07c29\">\r\n<meta name=\"description\" content=\"Best practices for using strings\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"07/26/2016\">\r\n<meta name=\"ms.technology\" content=\"dotnet-standard\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-21 01:42 AM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/standard/base-types/best-practices-strings.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/standard/base-types/best-practices-strings.md\">\r\n<meta name=\"document_id\" content=\"bedcb84a-7da1-a56d-f954-522b54204733\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"shoag","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Best practices for using strings | Microsoft Docs","ms.devlang":"dotnet","ms.assetid":"b3cefaa4-0a3f-4a96-aba9-1de30fb07c29","description":"Best practices for using strings","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"07/26/2016","ms.technology":"dotnet-standard","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Petr Onderka","author_email":"gsvick@gmail.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"Fixing broken links (#1276)","commit_sha":"048197e9d58ab8126adc14a98a0225debdab79bb","commit_date":"2016-11-22 12:04:31 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"fixed broken anchors (#1194)","commit_sha":"b20713600d7c3ddc31be5885733a1e8910ede8c6","commit_date":"2016-11-02 20:45:13 -0700"},{"author_name":"Steve Hoag","author_email":"shoag@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Porting base type docs take 4 (#1053)","commit_sha":"fb00da6505c9edb6a49d2003ae9bcb8e74c11d6c","commit_date":"2016-10-06 10:32:59 -0700"}],"updated_at":"2017-03-21 01:42 AM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/svick","display_name":"Petr Onderka","id":"287848"}],"update_at":"3/21/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/standard/base-types/best-practices-strings.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/standard/base-types/best-practices-strings.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/standard/base-types/best-practices-strings.md","document_id":"bedcb84a-7da1-a56d-f954-522b54204733","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/standard/base-types/best-practices-strings","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Best practices for using strings","_op_displayDate":"2016-7-26","_op_displayDate_source":"2016-07-26T00:00:00Z","_op_wordCount":6086,"_op_rawTitle":"<h1 id=\"best-practices-for-using-strings\" sourcefile=\"docs/standard/base-types/best-practices-strings.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Best practices for using strings</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/standard/base-types/best-practices-strings","fileRelativePath":"articles/standard/base-types/best-practices-strings.html"},"themesRelativePathToOutputRoot":"_themes/"}