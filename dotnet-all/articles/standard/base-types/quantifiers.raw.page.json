{"content":"<div><div class=\"content\">\n<p>Quantifiers specify how many instances of a character, group, or character class must be present in the input for a match to be found. The following table lists the quantifiers supported by .NET.</p>\n<table>\n<thead>\n<tr>\n<th>Greedy quantifier</th>\n<th>Lazy quantifier</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>\\</strong>*</td>\n<td><strong>*?</strong></td>\n<td>Match zero or more times.</td>\n</tr>\n<tr>\n<td><strong>+</strong></td>\n<td><strong>+?</strong></td>\n<td>Match one or more times.</td>\n</tr>\n<tr>\n<td><strong>?</strong></td>\n<td><strong>??</strong></td>\n<td>Match zero or one time.</td>\n</tr>\n<tr>\n<td><strong>{</strong><em>n</em><strong>}</strong></td>\n<td><strong>{</strong><em>n</em><strong>}?</strong></td>\n<td>Match exactly n times.</td>\n</tr>\n<tr>\n<td><strong>{</strong><em>n</em><strong>,}</strong></td>\n<td><strong>{</strong><em>n</em><strong>,}?</strong></td>\n<td>Match at least n times.</td>\n</tr>\n<tr>\n<td><strong>{</strong><em>n</em><strong>,</strong><em>m</em><strong>}</strong></td>\n<td><strong>{</strong><em>n</em><strong>,</strong><em>m</em><strong>}?</strong></td>\n<td>Match from n to m times.</td>\n</tr>\n</tbody>\n</table>\n<p>The quantities <em>n</em> and <em>m</em> are integer constants. Ordinarily, quantifiers are greedy; they cause the regular expression engine to match as many occurrences of particular patterns as possible. Appending the <code>?</code> character to a quantifier makes it lazy; it causes the regular expression engine to match as few occurrences as possible. For a complete description of the difference between greedy and lazy quantifiers, see the section <a href=\"#greedy-and-lazy-quantifiers\" data-linktype=\"self-bookmark\">Greedy and lazy quantifiers</a> later in this topic.</p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p>Nesting quantifiers (for example, as the regular expression pattern <code>(a*)*</code> does) can increase the number of comparisons that the regular expression engine must perform, as an exponential function of the number of characters in the input string. For more information about this behavior and its workarounds, see <a href=\"backtracking\" data-linktype=\"relative-path\">Backtracking in regular expressions</a>.</p>\n</div>\n<h2 id=\"regular-expression-quantifiers\">Regular expression quantifiers</h2>\n<p>The following sections list the quantifiers supported by .NET regular expressions. </p>\n<div class=\"NOTE\"><h5>Note</h5><p>If the *, +, ?, {, and } characters are encountered in a regular expression pattern, the regular expression engine interprets them as quantifiers or part of quantifier constructs unless they are included in a <a href=\"classes\" data-linktype=\"relative-path\">character class</a>. To interpret these as literal characters outside a character class, you must escape them by preceding them with a backslash. For example, the string <code>\\*</code> in a regular expression pattern is interpreted as a literal asterisk (&quot;*&quot;) character.</p>\n</div>\n<h3 id=\"match-zero-or-more-times-\">Match zero or more times: *</h3>\n<p>The * quantifier matches the preceding element zero or more times. It is equivalent to the <strong>{0,}</strong> quantifier. <strong>\\</strong>* is a greedy quantifier whose lazy equivalent is <strong>*?</strong>.</p>\n<p>The following example illustrates this regular expression. Of the nine digits in the input string, five match the pattern and four (<code>95</code>, <code>929</code>, <code>9129</code>, and <code>9919</code>) do not.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">string pattern = @&quot;\\b91*9*\\b&quot;;   \nstring input = &quot;99 95 919 929 9119 9219 999 9919 91119&quot;;\nforeach (Match match in Regex.Matches(input, pattern))\n   Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}.&quot;, match.Value, match.Index);\n\n// The example displays the following output:   \n//       &#39;99&#39; found at position 0.\n//       &#39;919&#39; found at position 6.\n//       &#39;9119&#39; found at position 14.\n//       &#39;999&#39; found at position 24.\n//       &#39;91119&#39; found at position 33.\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Dim pattern As String = &quot;\\b91*9*\\b&quot;   \nDim input As String = &quot;99 95 919 929 9119 9219 999 9919 91119&quot;\nFor Each match As Match In Regex.Matches(input, pattern)\n   Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}.&quot;, match.Value, match.Index)\nNext     \n&#39; The example displays the following output:   \n&#39;       &#39;99&#39; found at position 0.\n&#39;       &#39;919&#39; found at position 6.\n&#39;       &#39;9119&#39; found at position 14.\n&#39;       &#39;999&#39; found at position 24.\n&#39;       &#39;91119&#39; found at position 33.\n</code></pre><p>The regular expression pattern is defined as shown in the following table.</p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>\\b</code></td>\n<td>Start at a word boundary.</td>\n</tr>\n<tr>\n<td><code>91*</code></td>\n<td>Match a &quot;9&quot; followed by zero or more &quot;1&quot; characters.</td>\n</tr>\n<tr>\n<td><code>9*</code></td>\n<td>Match zero or more &quot;9&quot; characters.</td>\n</tr>\n<tr>\n<td><code>\\b</code></td>\n<td>End at a word boundary.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"match-one-or-more-times-\">Match one or more times: +</h3>\n<p>The <strong>+</strong> quantifier matches the preceding element one or more times. It is equivalent to <strong>{1,}</strong>. <strong>+</strong> is a greedy quantifier whose lazy equivalent is <strong>+?</strong>.</p>\n<p>For example, the regular expression <code>\\ban+\\w*?\\b</code> tries to match entire words that begin with the letter <code>a</code> followed by one or more instances of the letter <code>n</code>. The following example illustrates this regular expression. The regular expression matches the words <code>an</code>, <code>annual</code>, <code>announcement</code>, and <code>antique</code>, and correctly fails to match <code>autumn</code> and <code>all</code>.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">string pattern = @&quot;\\ban+\\w*?\\b&quot;;\n\nstring input = &quot;Autumn is a great time for an annual announcement to all antique collectors.&quot;;\nforeach (Match match in Regex.Matches(input, pattern, RegexOptions.IgnoreCase))\n   Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}.&quot;, match.Value, match.Index);\n\n// The example displays the following output:   \n//       &#39;an&#39; found at position 27.\n//       &#39;annual&#39; found at position 30.\n//       &#39;announcement&#39; found at position 37.\n//       &#39;antique&#39; found at position 57.      \n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Dim pattern As String = &quot;\\ban+\\w*?\\b&quot;\n\nDim input As String = &quot;Autumn is a great time for an annual announcement to all antique collectors.&quot;\nFor Each match As Match In Regex.Matches(input, pattern, RegexOptions.IgnoreCase)\n   Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}.&quot;, match.Value, match.Index)\nNext   \n&#39; The example displays the following output:   \n&#39;       &#39;an&#39; found at position 27.\n&#39;       &#39;annual&#39; found at position 30.\n&#39;       &#39;announcement&#39; found at position 37.\n&#39;       &#39;antique&#39; found at position 57. \n</code></pre><p>The regular expression pattern is defined as shown in the following table.</p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>\\b</code></td>\n<td>Start at a word boundary.</td>\n</tr>\n<tr>\n<td><code>an+</code></td>\n<td>Match an &quot;a&quot; followed by one or more &quot;n&quot; characters.</td>\n</tr>\n<tr>\n<td><code>\\w*?</code></td>\n<td>Match a word character zero or more times, but as few times as possible.</td>\n</tr>\n<tr>\n<td><code>\\b</code></td>\n<td>End at a word boundary.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"match-zero-or-one-time-\">Match zero or one time: ?</h3>\n<p>The <strong>?</strong> quantifier matches the preceding element zero or one time. It is equivalent to <strong>{0,1}</strong>. <strong>?</strong> is a greedy quantifier whose lazy equivalent is <strong>??</strong>.</p>\n<p>For example, the regular expression <code>\\ban?\\b</code> tries to match entire words that begin with the letter <code>a</code> followed by zero or one instances of the letter <code>n</code>. In other words, it tries to match the words <code>a</code> and <code>an</code>. The following example illustrates this regular expression.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">string pattern = @&quot;\\ban?\\b&quot;;\nstring input = &quot;An amiable animal with a large snount and an animated nose.&quot;;\nforeach (Match match in Regex.Matches(input, pattern, RegexOptions.IgnoreCase))\n   Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}.&quot;, match.Value, match.Index);\n\n// The example displays the following output:   \n//        &#39;An&#39; found at position 0.\n//        &#39;a&#39; found at position 23.\n//        &#39;an&#39; found at position 42.\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Dim pattern As String = &quot;\\ban?\\b&quot;\nDim input As String = &quot;An amiable animal with a large snount and an animated nose.&quot;\nFor Each match As Match In Regex.Matches(input, pattern, RegexOptions.IgnoreCase)\n   Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}.&quot;, match.Value, match.Index)\nNext  \n&#39; The example displays the following output:   \n&#39;       &#39;An&#39; found at position 0.\n&#39;       &#39;a&#39; found at position 23.\n&#39;       &#39;an&#39; found at position 42.\n</code></pre><p>The regular expression pattern is defined as shown in the following table.</p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>\\b</code></td>\n<td>Start at a word boundary.</td>\n</tr>\n<tr>\n<td><code>an?</code></td>\n<td>Match an &quot;a&quot; followed by zero or one &quot;n&quot; character.</td>\n</tr>\n<tr>\n<td><code>\\b</code></td>\n<td>End at a word boundary.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"match-exactly-n-times-n\">Match exactly n times: {n}</h3>\n<p>The <strong>{</strong><em>n</em><strong>}</strong> quantifier matches the preceding element exactly <em>n</em> times, where <em>n</em> is any integer. <strong>{</strong><em>n</em><strong>}</strong> is a greedy quantifier whose lazy equivalent is <strong>{</strong><em>n</em><strong>}?</strong>.</p>\n<p>For example, the regular expression <code>\\b\\d+\\,\\d{3}\\b</code> tries to match a word boundary followed by one or more decimal digits followed by three decimal digits followed by a word boundary. The following example illustrates this regular expression. </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">string pattern = @&quot;\\b\\d+\\,\\d{3}\\b&quot;;\nstring input = &quot;Sales totaled 103,524 million in January, &quot; + \n                      &quot;106,971 million in February, but only &quot; + \n                      &quot;943 million in March.&quot;;\nforeach (Match match in Regex.Matches(input, pattern))\n   Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}.&quot;, match.Value, match.Index);\n\n//  The example displays the following output:   \n//        &#39;103,524&#39; found at position 14.\n//        &#39;106,971&#39; found at position 45.\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Dim pattern As String = &quot;\\b\\d+\\,\\d{3}\\b&quot;\nDim input As String = &quot;Sales totaled 103,524 million in January, &quot; + _\n                      &quot;106,971 million in February, but only &quot; + _\n                      &quot;943 million in March.&quot;\nFor Each match As Match In Regex.Matches(input, pattern)\n   Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}.&quot;, match.Value, match.Index)\nNext     \n&#39; The example displays the following output:   \n&#39;       &#39;103,524&#39; found at position 14.\n&#39;       &#39;106,971&#39; found at position 45.\n</code></pre><p>The regular expression pattern is defined as shown in the following table.</p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>\\b</code></td>\n<td>Start at a word boundary.</td>\n</tr>\n<tr>\n<td><code>\\d+</code></td>\n<td>Match one or more decimal digits.</td>\n</tr>\n<tr>\n<td><code>\\,</code></td>\n<td>Match a comma character.</td>\n</tr>\n<tr>\n<td><code>\\d{3}</code></td>\n<td>Match three decimal digits.</td>\n</tr>\n<tr>\n<td><code>\\b</code></td>\n<td>End at a word boundary.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"match-at-least-n-times-n\">Match at least n times: {n,}</h3>\n<p>The <strong>{</strong><em>n</em><strong>,}</strong> quantifier matches the preceding element at least <em>n</em> times, where <em>n</em> is any integer. <strong>{</strong><em>n</em><strong>,}</strong> is a greedy quantifier whose lazy equivalent is <strong>{</strong><em>n</em><strong>}?</strong>.</p>\n<p>For example, the regular expression <code>\\b\\d{2,}\\b\\D+</code> tries to match a word boundary followed by at least two digits followed by a word boundary and a non-digit character. The following example illustrates this regular expression. The regular expression fails to match the phrase &quot;7 days&quot; because it contains just one decimal digit, but it successfully matches the phrases &quot;10 weeks and 300 years&quot;.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">string pattern = @&quot;\\b\\d{2,}\\b\\D+&quot;;   \nstring input = &quot;7 days, 10 weeks, 300 years&quot;;\nforeach (Match match in Regex.Matches(input, pattern))\n   Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}.&quot;, match.Value, match.Index);\n\n//  The example displays the following output:\n//        &#39;10 weeks, &#39; found at position 8.\n// \n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Dim pattern As String = &quot;\\b\\d{2,}\\b\\D+&quot;  \n Dim input As String = &quot;7 days, 10 weeks, 300 years&quot;\nFor Each match As Match In Regex.Matches(input, pattern)\n   Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}.&quot;, match.Value, match.Index)\nNext \n&#39; The example displays the following output:\n&#39;       &#39;10 weeks, &#39; found at position 8.\n&#39;       &#39;300 years&#39; found at position 18.\n      &#39;300 years&#39; found at position 18.\n</code></pre><p>The regular expression pattern is defined as shown in the following table.</p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>\\b</code></td>\n<td>Start at a word boundary.</td>\n</tr>\n<tr>\n<td><code>\\d{2,}</code></td>\n<td>Match at least two decimal digits.</td>\n</tr>\n<tr>\n<td><code>\\b</code></td>\n<td>Match a word boundary.</td>\n</tr>\n<tr>\n<td><code>\\D+</code></td>\n<td>Match at least one non-decimal digit.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"match-between-n-and-m-times-nm\">Match between n and m times: {n,m}</h3>\n<p>The <strong>{</strong><em>n</em><strong>,</strong><em>m</em><strong>}</strong> quantifier matches the preceding element at least <em>n</em> times, but no more than <em>m</em> times, where <em>n</em> and <em>m</em> are integers. <strong>{</strong><em>n</em><strong>,</strong><em>m</em><strong>}</strong> is a greedy quantifier whose lazy equivalent is <strong>{</strong><em>n</em><strong>,</strong><em>m</em><strong>}?</strong>.</p>\n<p>In the following example, the regular expression <code>(00\\s){2,4}</code> tries to match between two and four occurrences of two zero digits followed by a space. Note that the final portion of the input string includes this pattern five times rather than the maximum of four. However, only the initial portion of this substring (up to the space and the fifth pair of zeros) matches the regular expression pattern.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">string pattern = @&quot;(00\\s){2,4}&quot;;\nstring input = &quot;0x00 FF 00 00 18 17 FF 00 00 00 21 00 00 00 00 00&quot;;\nforeach (Match match in Regex.Matches(input, pattern))\n   Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}.&quot;, match.Value, match.Index);\n\n//  The example displays the following output:\n//        &#39;00 00 &#39; found at position 8.\n//        &#39;00 00 00 &#39; found at position 23.\n//        &#39;00 00 00 00 &#39; found at position 35.\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Dim pattern As String = &quot;(00\\s){2,4}&quot;\nDim input As String = &quot;0x00 FF 00 00 18 17 FF 00 00 00 21 00 00 00 00 00&quot;\nFor Each match As Match In Regex.Matches(input, pattern)\n   Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}.&quot;, match.Value, match.Index)\nNext \n&#39; The example displays the following output:\n&#39;       &#39;00 00 &#39; found at position 8.\n&#39;       &#39;00 00 00 &#39; found at position 23.\n&#39;       &#39;00 00 00 00 &#39; found at position 35.\n</code></pre><h3 id=\"match-zero-or-more-times-lazy-match-\">Match zero or more times (lazy match): *?</h3>\n<p>The <strong>*?</strong> quantifier matches the preceding element zero or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier <strong>\\</strong>*.</p>\n<p>In the following example, the regular expression <code>\\b\\w*?oo\\w*?\\b</code> matches all words that contain the string <code>oo</code>. </p>\n<pre class=\"loading\"><code class=\"lang-csharp\"> string pattern = @&quot;\\b\\w*?oo\\w*?\\b&quot;;\n string input = &quot;woof root root rob oof woo woe&quot;;\n foreach (Match match in Regex.Matches(input, pattern, RegexOptions.IgnoreCase))\n    Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}.&quot;, match.Value, match.Index);\n\n //  The example displays the following output:\n//        &#39;woof&#39; found at position 0.\n//        &#39;root&#39; found at position 5.\n//        &#39;root&#39; found at position 10.\n//        &#39;oof&#39; found at position 19.\n//        &#39;woo&#39; found at position 23.\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Dim pattern As String = &quot;\\b\\w*?oo\\w*?\\b&quot;\n Dim input As String = &quot;woof root root rob oof woo woe&quot;\n For Each match As Match In Regex.Matches(input, pattern, RegexOptions.IgnoreCase)\n    Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}.&quot;, match.Value, match.Index)\n Next \n &#39; The example displays the following output:\n&#39;       &#39;woof&#39; found at position 0.\n&#39;       &#39;root&#39; found at position 5.\n&#39;       &#39;root&#39; found at position 10.\n&#39;       &#39;oof&#39; found at position 19.\n&#39;       &#39;woo&#39; found at position 23.\n</code></pre><p>The regular expression pattern is defined as shown in the following table.</p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>\\b</code></td>\n<td>Start at a word boundary.</td>\n</tr>\n<tr>\n<td><code>\\w*?</code></td>\n<td>Match zero or more word characters, but as few characters as possible.</td>\n</tr>\n<tr>\n<td><code>oo</code></td>\n<td>Match the string &quot;oo&quot;.</td>\n</tr>\n<tr>\n<td><code>\\w*?</code></td>\n<td>Match zero or more word characters, but as few characters as possible.</td>\n</tr>\n<tr>\n<td><code>\\b</code></td>\n<td>End on a word boundary.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"match-one-or-more-times-lazy-match-\">Match one or more times (lazy match): +?</h3>\n<p>The <strong>+?</strong> quantifier matches the preceding element one or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier <strong>+</strong>.</p>\n<p>For example, the regular expression <code>\\b\\w+?\\b</code> matches one or more characters separated by word boundaries. The following example illustrates this regular expression.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">string pattern = @&quot;\\b\\w+?\\b&quot;;\nstring input = &quot;Aa Bb Cc Dd Ee Ff&quot;;\nforeach (Match match in Regex.Matches(input, pattern))\n   Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}.&quot;, match.Value, match.Index);\n\n//  The example displays the following output:\n//        &#39;Aa&#39; found at position 0.\n//        &#39;Bb&#39; found at position 3.\n//        &#39;Cc&#39; found at position 6.\n//        &#39;Dd&#39; found at position 9.\n//        &#39;Ee&#39; found at position 12.\n//        &#39;Ff&#39; found at position 15.\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Dim pattern As String = &quot;\\b\\w+?\\b&quot;\n Dim input As String = &quot;Aa Bb Cc Dd Ee Ff&quot;\nFor Each match As Match In Regex.Matches(input, pattern)\n   Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}.&quot;, match.Value, match.Index)\nNext \n&#39; The example displays the following output:\n&#39;       &#39;Aa&#39; found at position 0.\n&#39;       &#39;Bb&#39; found at position 3.\n&#39;       &#39;Cc&#39; found at position 6.\n&#39;       &#39;Dd&#39; found at position 9.\n&#39;       &#39;Ee&#39; found at position 12.\n&#39;       &#39;Ff&#39; found at position 15.\n</code></pre><h3 id=\"match-zero-or-one-time-lazy-match-\">Match zero or one time (lazy match): ??</h3>\n<p>The <strong>??</strong> quantifier matches the preceding element zero or one time, but as few times as possible. It is the lazy counterpart of the greedy quantifier <strong>?</strong>.</p>\n<p>For example, the regular expression <code>^\\s*(System.)??Console.Write(Line)??\\(??</code> attempts to match the strings &quot;Console.Write&quot; or &quot;Console.WriteLine&quot;. The string can also include &quot;System.&quot; before &quot;Console&quot;, and it can be followed by an opening parenthesis. The string must be at the beginning of a line, although it can be preceded by white space. The following example illustrates this regular expression.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">string pattern = @&quot;^\\s*(System.)??Console.Write(Line)??\\(??&quot;;\nstring input = &quot;System.Console.WriteLine(\\&quot;Hello!\\&quot;)\\n&quot; + \n                      &quot;Console.Write(\\&quot;Hello!\\&quot;)\\n&quot; + \n                      &quot;Console.WriteLine(\\&quot;Hello!\\&quot;)\\n&quot; + \n                      &quot;Console.ReadLine()\\n&quot; + \n                      &quot;   Console.WriteLine&quot;;\nforeach (Match match in Regex.Matches(input, pattern, \n                                      RegexOptions.IgnorePatternWhitespace | \n                                      RegexOptions.IgnoreCase | \n                                      RegexOptions.Multiline))\n   Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}.&quot;, match.Value, match.Index);\n\n//  The example displays the following output:\n//        &#39;System.Console.Write&#39; found at position 0.\n//        &#39;Console.Write&#39; found at position 36.\n//        &#39;Console.Write&#39; found at position 61.\n//        &#39;   Console.Write&#39; found at position 110.\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Dim pattern As String = &quot;^\\s*(System.)??Console.Write(Line)??\\(??&quot;\nDim input As String = &quot;System.Console.WriteLine(&quot;&quot;Hello!&quot;&quot;)&quot; + vbCrLf + _\n                      &quot;Console.Write(&quot;&quot;Hello!&quot;&quot;)&quot; + vbCrLf + _\n                      &quot;Console.WriteLine(&quot;&quot;Hello!&quot;&quot;)&quot; + vbCrLf + _\n                      &quot;Console.ReadLine()&quot; + vbCrLf + _\n                      &quot;   Console.WriteLine&quot;\nFor Each match As Match In Regex.Matches(input, pattern, _\n                                         RegexOptions.IgnorePatternWhitespace Or RegexOptions.IgnoreCase Or RegexOptions.MultiLine)\n   Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}.&quot;, match.Value, match.Index)\nNext \n&#39; The example displays the following output:\n&#39;       &#39;System.Console.Write&#39; found at position 0.\n&#39;       &#39;Console.Write&#39; found at position 36.\n&#39;       &#39;Console.Write&#39; found at position 61.\n&#39;       &#39;   Console.Write&#39; found at position 110.\n</code></pre><p>The regular expression pattern is defined as shown in the following table.</p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>^</code></td>\n<td>Match the start of the input stream.</td>\n</tr>\n<tr>\n<td><code>\\s*</code></td>\n<td>Match zero or more white-space characters.</td>\n</tr>\n<tr>\n<td><code>(System.)??</code></td>\n<td>Match zero or one occurrence of the string &quot;System.&quot;.</td>\n</tr>\n<tr>\n<td><code>Console.Write</code></td>\n<td>Match the string &quot;Console.Write&quot;.</td>\n</tr>\n<tr>\n<td><code>(Line)??</code></td>\n<td>Match zero or one occurrence of the string &quot;Line&quot;.</td>\n</tr>\n<tr>\n<td><code>\\(??</code></td>\n<td>Match zero or one occurrence of the opening parenthesis.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"match-exactly-n-times-lazy-match-n\">Match exactly n times (lazy match): {n}?</h3>\n<p>The <strong>{</strong><em>n</em><strong>}?</strong> quantifier matches the preceding element exactly <em>n</em> times, where <em>n</em> is any integer. It is the lazy counterpart of the greedy quantifier <strong>{</strong><em>n</em><strong>}+</strong>.</p>\n<p>In the following example, the regular expression <code>\\b(\\w{3,}?\\.){2}?\\w{3,}?\\b</code> is used to identify a Web site address. Note that it matches &quot;www.microsoft.com&quot; and &quot;msdn.microsoft.com&quot;, but does not match &quot;mywebsite&quot; or &quot;mycompany.com&quot;.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">string pattern = @&quot;\\b(\\w{3,}?\\.){2}?\\w{3,}?\\b&quot;;\nstring input = &quot;www.microsoft.com msdn.microsoft.com mywebsite mycompany.com&quot;;\nforeach (Match match in Regex.Matches(input, pattern))\n   Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}.&quot;, match.Value, match.Index);\n\n//  The example displays the following output:\n//        &#39;www.microsoft.com&#39; found at position 0.\n//        &#39;msdn.microsoft.com&#39; found at position 18.\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Dim pattern As String = &quot;\\b(\\w{3,}?\\.){2}?\\w{3,}?\\b&quot;\n Dim input As String = &quot;www.microsoft.com msdn.microsoft.com mywebsite mycompany.com&quot;\nFor Each match As Match In Regex.Matches(input, pattern)\n   Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}.&quot;, match.Value, match.Index)\nNext     \n&#39; The example displays the following output:\n&#39;       &#39;www.microsoft.com&#39; found at position 0.\n&#39;       &#39;msdn.microsoft.com&#39; found at position 18.\n</code></pre><p>The regular expression pattern is defined as shown in the following table.</p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>\\b</code></td>\n<td>Start at a word boundary.</td>\n</tr>\n<tr>\n<td><code>(\\w{3,}?\\.)</code></td>\n<td>Match at least 3 word characters, but as few characters as possible, followed by a dot or period character. This is the first capturing group.</td>\n</tr>\n<tr>\n<td><code>(\\w{3,}?\\.){2}?</code></td>\n<td>Match the pattern in the first group two times, but as few times as possible.</td>\n</tr>\n<tr>\n<td><code>\\b</code></td>\n<td>End the match on a word boundary.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"match-at-least-n-times-lazy-match-n\">Match at least n times (lazy match): {n,}?</h3>\n<p>The <strong>{</strong><em>n</em><strong>,}?</strong> quantifier matches the preceding element at least <em>n</em> times, where <em>n</em> is any integer, but as few times as possible. It is the lazy counterpart of the greedy quantifier <strong>{</strong><em>n</em><strong>,}</strong>.</p>\n<p>See the example for the <strong>{</strong><em>n</em><strong>}?</strong> quantifier in the previous section for an illustration. The regular expression in that example uses the <strong>{</strong><em>n</em><strong>,}</strong> quantifier to match a string that has at least three characters followed by a period.</p>\n<h3 id=\"match-between-n-and-m-times-lazy-match-nm\">Match between n and m times (lazy match): {n,m}?</h3>\n<p>The <strong>{</strong><em>n</em><strong>,</strong><em>m</em><strong>}?</strong> quantifier matches the preceding element between <em>n</em> and <em>m</em> times, where <em>n</em> and <em>m</em> are integers, but as few times as possible. It is the lazy counterpart of the greedy quantifier <strong>{</strong><em>n</em><strong>,</strong><em>m</em><strong>}</strong>.</p>\n<p>In the following example, the regular expression <code>\\b[A-Z](\\w*\\s+){1,10}?[.!?]</code> matches sentences that contain between one and ten words. It matches all the sentences in the input string except for one sentence that contains 18 words.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">string pattern = @&quot;\\b[A-Z](\\w*?\\s*?){1,10}[.!?]&quot;;\nstring input = &quot;Hi. I am writing a short note. Its purpose is &quot; + \n                      &quot;to test a regular expression that attempts to find &quot; + \n                      &quot;sentences with ten or fewer words. Most sentences &quot; + \n                      &quot;in this note are short.&quot;;\nforeach (Match match in Regex.Matches(input, pattern))\n   Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}.&quot;, match.Value, match.Index);\n\n//  The example displays the following output:\n//        &#39;Hi.&#39; found at position 0.\n//        &#39;I am writing a short note.&#39; found at position 4.\n//        &#39;Most sentences in this note are short.&#39; found at position 132.\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Dim pattern As String = &quot;\\b[A-Z](\\w*\\s?){1,10}?[.!?]&quot;\nDim input As String = &quot;Hi. I am writing a short note. Its purpose is &quot; + _\n                      &quot;to test a regular expression that attempts to find &quot; + _\n                      &quot;sentences with ten or fewer words. Most sentences &quot; + _\n                      &quot;in this note are short.&quot;\nFor Each match As Match In Regex.Matches(input, pattern)\n   Console.WriteLine(&quot;&#39;{0}&#39; found at position {1}.&quot;, match.Value, match.Index)\nNext \n&#39; The example displays the following output:\n&#39;       &#39;Hi.&#39; found at position 0.\n&#39;       &#39;I am writing a short note.&#39; found at position 4.\n&#39;       &#39;Most sentences in this note are short.&#39; found at position 132.\n</code></pre><p>The regular expression pattern is defined as shown in the following table.</p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>\\b</code></td>\n<td>Start at a word boundary.</td>\n</tr>\n<tr>\n<td><code>[A-Z]</code></td>\n<td>Match an uppercase character from A to Z.</td>\n</tr>\n<tr>\n<td><code>(\\w*\\s+)</code></td>\n<td>Match zero or more word characters, followed by one or more white-space characters. This is the first capture group.</td>\n</tr>\n<tr>\n<td><code>{1,10}?</code></td>\n<td>Match the previous pattern between 1 and 10 times, but as few times as possible.</td>\n</tr>\n<tr>\n<td><code>[.!?]</code></td>\n<td>Match any one of the punctuation characters &quot;.&quot;, &quot;!&quot;, or &quot;?&quot;.</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"greedy-and-lazy-quantifiers\">Greedy and lazy quantifiers</h2>\n<p>A number of the quantifiers have two versions: </p>\n<ul>\n<li><p>A greedy version. </p>\n<p>A greedy quantifier tries to match an element as many times as possible. </p>\n</li>\n<li><p>•A non-greedy (or lazy) version. </p>\n<p>A non-greedy quantifier tries to match an element as few times as possible. You can turn a greedy quantifier into a lazy quantifier by simply adding a <strong>?</strong>.</p>\n</li>\n</ul>\n<p>Consider a simple regular expression that is intended to extract the last four digits from a string of numbers such as a credit card number. The version of the regular expression that uses the <strong>\\</strong>* greedy quantifier is <code>\\b.*([0-9]{4})\\b</code>. However, if a string contains two numbers, this regular expression matches the last four digits of the second number only, as the following example shows.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">string greedyPattern = @&quot;\\b.*([0-9]{4})\\b&quot;;\nstring input1 = &quot;1112223333 3992991999&quot;;\nforeach (Match match in Regex.Matches(input1, greedyPattern))\n   Console.WriteLine(&quot;Account ending in ******{0}.&quot;, match.Groups[1].Value);\n\n// The example displays the following output:\n//       Account ending in ******1999.\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Dim greedyPattern As String = &quot;\\b.*([0-9]{4})\\b&quot;\nDim input1 As String = &quot;1112223333 3992991999&quot;\nFor Each match As Match In Regex.Matches(input1, greedypattern)\n   Console.WriteLine(&quot;Account ending in ******{0}.&quot;, match.Groups(1).Value)\nNext\n&#39; The example displays the following output:\n&#39;       Account ending in ******1999.\n</code></pre><p>The regular expression fails to match the first number because the <strong>\\</strong>* quantifier tries to match the previous element as many times as possible in the entire string, and so it finds its match at the end of the string.</p>\n<p>This is not the desired behavior. Instead, you can use the <strong>*?</strong> lazy quantifier to extract digits from both numbers, as the following example shows.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">string lazyPattern = @&quot;\\b.*?([0-9]{4})\\b&quot;;\nstring input2 = &quot;1112223333 3992991999&quot;;\nforeach (Match match in Regex.Matches(input2, lazyPattern))\n   Console.WriteLine(&quot;Account ending in ******{0}.&quot;, match.Groups[1].Value);\n\n// The example displays the following output:\n//       Account ending in ******3333.\n//       Account ending in ******1999.\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Dim lazyPattern As String = &quot;\\b.*?([0-9]{4})\\b&quot;\nDim input2 As String = &quot;1112223333 3992991999&quot;\nFor Each match As Match In Regex.Matches(input2, lazypattern)\n   Console.WriteLine(&quot;Account ending in ******{0}.&quot;, match.Groups(1).Value)\nNext     \n&#39; The example displays the following output:\n&#39;       Account ending in ******3333.\n&#39;       Account ending in ******1999.\n</code></pre><p>In most cases, regular expressions with greedy and lazy quantifiers return the same matches. They most commonly return different results when they are used with the wildcard (<strong>.</strong>) metacharacter, which matches any character. </p>\n<h2 id=\"quantifiers-and-empty-matches\">Quantifiers and empty matches</h2>\n<p>The quantifiers <strong>\\</strong><em>, **+</em><em>, and **{</em><em><em>n</em></em><em>,</em><em><em>m</em></em><em>}</em>* and their lazy counterparts never repeat after an empty match when the minimum number of captures has been found. This rule prevents quantifiers from entering infinite loops on empty subexpression matches when the maximum number of possible group captures is infinite or near infinite.</p>\n<p>For example, the following code shows the result of a call to the <a class=\"xref\" href=\"../../../api/system.text.regularexpressions.regex#System_Text_RegularExpressions_Regex_Match_System_String_\" data-linktype=\"relative-path\">Regex.Match</a> method with the regular expression pattern <code>(a?)*,</code> which matches zero or one &quot;a&quot; character zero or more times. Note that the single capturing group captures each &quot;a&quot; as well as <a class=\"xref\" href=\"../../../api/system.string#System_String_Empty\" data-linktype=\"relative-path\">String.Empty</a>, but that there is no second empty match, because the first empty match causes the quantifier to stop repeating.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\nusing System.Text.RegularExpressions;\n\npublic class Example\n{\n   public static void Main()\n   {\n      string pattern = &quot;(a?)*&quot;;\n      string input = &quot;aaabbb&quot;;\n      Match match = Regex.Match(input, pattern);\n      Console.WriteLine(&quot;Match: &#39;{0}&#39; at index {1}&quot;, \n                        match.Value, match.Index);\n      if (match.Groups.Count &gt; 1) {\n         GroupCollection groups = match.Groups;\n         for (int grpCtr = 1; grpCtr &lt;= groups.Count - 1; grpCtr++) {\n            Console.WriteLine(&quot;   Group {0}: &#39;{1}&#39; at index {2}&quot;, \n                              grpCtr, \n                              groups[grpCtr].Value,\n                              groups[grpCtr].Index);\n            int captureCtr = 0;\n            foreach (Capture capture in groups[grpCtr].Captures) {\n               captureCtr++;\n               Console.WriteLine(&quot;      Capture {0}: &#39;{1}&#39; at index {2}&quot;, \n                                 captureCtr, capture.Value, capture.Index);\n            }\n         } \n      }   \n   }\n}\n// The example displays the following output:\n//       Match: &#39;aaa&#39; at index 0\n//          Group 1: &#39;&#39; at index 3\n//             Capture 1: &#39;a&#39; at index 0\n//             Capture 2: &#39;a&#39; at index 1\n//             Capture 3: &#39;a&#39; at index 2\n//             Capture 4: &#39;&#39; at index 3\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Imports System.Text.RegularExpressions\n\nModule Example\n   Public Sub Main()\n      Dim pattern As String = &quot;(a?)*&quot;\n      Dim input As String = &quot;aaabbb&quot;\n      Dim match As Match = Regex.Match(input, pattern)\n      Console.WriteLine(&quot;Match: &#39;{0}&#39; at index {1}&quot;, \n                        match.Value, match.Index)\n      If match.Groups.Count &gt; 1 Then\n         Dim groups As GroupCollection = match.Groups\n         For grpCtr As Integer = 1 To groups.Count - 1\n            Console.WriteLine(&quot;   Group {0}: &#39;{1}&#39; at index {2}&quot;, \n                              grpCtr, \n                              groups(grpCtr).Value,\n                              groups(grpCtr).Index)\n            Dim captureCtr As Integer = 0\n            For Each capture As Capture In groups(grpCtr).Captures\n               captureCtr += 1\n               Console.WriteLine(&quot;      Capture {0}: &#39;{1}&#39; at index {2}&quot;, \n                                 captureCtr, capture.Value, capture.Index)\n            Next\n         Next \n      End If   \n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       Match: &#39;aaa&#39; at index 0\n&#39;          Group 1: &#39;&#39; at index 3\n&#39;             Capture 1: &#39;a&#39; at index 0\n&#39;             Capture 2: &#39;a&#39; at index 1\n&#39;             Capture 3: &#39;a&#39; at index 2\n&#39;             Capture 4: &#39;&#39; at index 3\n</code></pre><p>To see the practical difference between a capturing group that defines a minimum and a maximum number of captures and one that defines a fixed number of captures, consider the regular expression patterns <code>(a\\1|(?(1)\\1)){0,2}</code> and <code>(a\\1|(?(1)\\1)){2}</code>. Both regular expressions consist of a single capturing group, which is defined as shown in the following table. </p>\n<table>\n<thead>\n<tr>\n<th>Pattern</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>(a\\1</code></td>\n<td>Either match &quot;a&quot; along with the value of the first captured group …</td>\n</tr>\n<tr>\n<td><code>&amp;#124;(?(1)</code></td>\n<td>… or test whether the first captured group has been defined. (Note that the <strong>(?(1)</strong> construct does not define a capturing group.)</td>\n</tr>\n<tr>\n<td><code>\\1))</code></td>\n<td>If the first captured group exists, match its value. If the group does not exist, the group will match <a class=\"xref\" href=\"../../../api/system.string#System_String_Empty\" data-linktype=\"relative-path\">String.Empty</a>.</td>\n</tr>\n</tbody>\n</table>\n<p>The first regular expression tries to match this pattern between zero and two times; the second, exactly two times. Because the first pattern reaches its minimum number of captures with its first capture of <a class=\"xref\" href=\"../../../api/system.string#System_String_Empty\" data-linktype=\"relative-path\">String.Empty</a>, it never repeats to try to match <code>a\\1;</code> the <code>{0,2}</code> quantifier allows only empty matches in the last iteration. In contrast, the second regular expression does match &quot;a&quot; because it evaluates <code>a\\1</code> a second time; the minimum number of iterations, 2, forces the engine to repeat after an empty match.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\nusing System.Text.RegularExpressions;\n\npublic class Example\n{\n   public static void Main()\n   {\n      string pattern, input;\n\n      pattern = @&quot;(a\\1|(?(1)\\1)){0,2}&quot;;\n      input = &quot;aaabbb&quot;; \n\n      Console.WriteLine(&quot;Regex pattern: {0}&quot;, pattern);\n      Match match = Regex.Match(input, pattern);\n      Console.WriteLine(&quot;Match: &#39;{0}&#39; at position {1}.&quot;, \n                        match.Value, match.Index);\n      if (match.Groups.Count &gt; 1) {\n         for (int groupCtr = 1; groupCtr &lt;= match.Groups.Count - 1; groupCtr++)\n         {\n            Group group = match.Groups[groupCtr];         \n            Console.WriteLine(&quot;   Group: {0}: &#39;{1}&#39; at position {2}.&quot;, \n                              groupCtr, group.Value, group.Index);\n            int captureCtr = 0;\n            foreach (Capture capture in group.Captures) {\n               captureCtr++;\n               Console.WriteLine(&quot;      Capture: {0}: &#39;{1}&#39; at position {2}.&quot;, \n                                 captureCtr, capture.Value, capture.Index);\n            }   \n         }\n      }\n      Console.WriteLine();\n\n      pattern = @&quot;(a\\1|(?(1)\\1)){2}&quot;;\n      Console.WriteLine(&quot;Regex pattern: {0}&quot;, pattern);\n      match = Regex.Match(input, pattern);\n         Console.WriteLine(&quot;Matched &#39;{0}&#39; at position {1}.&quot;, \n                           match.Value, match.Index);\n      if (match.Groups.Count &gt; 1) {\n         for (int groupCtr = 1; groupCtr &lt;= match.Groups.Count - 1; groupCtr++)\n         {\n            Group group = match.Groups[groupCtr];         \n            Console.WriteLine(&quot;   Group: {0}: &#39;{1}&#39; at position {2}.&quot;, \n                              groupCtr, group.Value, group.Index);\n            int captureCtr = 0;\n            foreach (Capture capture in group.Captures) {\n               captureCtr++;\n               Console.WriteLine(&quot;      Capture: {0}: &#39;{1}&#39; at position {2}.&quot;, \n                                 captureCtr, capture.Value, capture.Index);\n            }   \n         }\n      }\n   }\n}\n// The example displays the following output:\n//       Regex pattern: (a\\1|(?(1)\\1)){0,2}\n//       Match: &#39;&#39; at position 0.\n//          Group: 1: &#39;&#39; at position 0.\n//             Capture: 1: &#39;&#39; at position 0.\n//       \n//       Regex pattern: (a\\1|(?(1)\\1)){2}\n//       Matched &#39;a&#39; at position 0.\n//          Group: 1: &#39;a&#39; at position 0.\n//             Capture: 1: &#39;&#39; at position 0.\n//             Capture: 2: &#39;a&#39; at position 0.\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Imports System.Text.RegularExpressions\n\nModule Example\n   Public Sub Main()\n      Dim pattern, input As String\n\n      pattern = &quot;(a\\1|(?(1)\\1)){0,2}&quot;\n      input = &quot;aaabbb&quot; \n\n      Console.WriteLine(&quot;Regex pattern: {0}&quot;, pattern)\n      Dim match As Match = Regex.Match(input, pattern)\n      Console.WriteLine(&quot;Match: &#39;{0}&#39; at position {1}.&quot;, \n                        match.Value, match.Index)\n      If match.Groups.Count &gt; 1 Then\n         For groupCtr As Integer = 1 To match.Groups.Count - 1\n            Dim group As Group = match.Groups(groupCtr)         \n            Console.WriteLine(&quot;   Group: {0}: &#39;{1}&#39; at position {2}.&quot;, \n                              groupCtr, group.Value, group.Index)\n            Dim captureCtr As Integer = 0\n            For Each capture As Capture In group.Captures\n               captureCtr += 1\n               Console.WriteLine(&quot;      Capture: {0}: &#39;{1}&#39; at position {2}.&quot;, \n                                 captureCtr, capture.Value, capture.Index)\n            Next   \n         Next\n      End If\n      Console.WriteLine()\n\n      pattern = &quot;(a\\1|(?(1)\\1)){2}&quot;\n      Console.WriteLine(&quot;Regex pattern: {0}&quot;, pattern)\n      match = Regex.Match(input, pattern)\n         Console.WriteLine(&quot;Matched &#39;{0}&#39; at position {1}.&quot;, \n                           match.Value, match.Index)\n      If match.Groups.Count &gt; 1 Then\n         For groupCtr As Integer = 1 To match.Groups.Count - 1\n            Dim group As Group = match.Groups(groupCtr)         \n            Console.WriteLine(&quot;   Group: {0}: &#39;{1}&#39; at position {2}.&quot;, \n                              groupCtr, group.Value, group.Index)\n            Dim captureCtr As Integer = 0\n            For Each capture As Capture In group.Captures\n               captureCtr += 1\n               Console.WriteLine(&quot;      Capture: {0}: &#39;{1}&#39; at position {2}.&quot;, \n                                 captureCtr, capture.Value, capture.Index)\n            Next   \n         Next\n      End If\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       Regex pattern: (a\\1|(?(1)\\1)){0,2}\n&#39;       Match: &#39;&#39; at position 0.\n&#39;          Group: 1: &#39;&#39; at position 0.\n&#39;             Capture: 1: &#39;&#39; at position 0.\n&#39;       \n&#39;       Regex pattern: (a\\1|(?(1)\\1)){2}\n&#39;       Matched &#39;a&#39; at position 0.\n&#39;          Group: 1: &#39;a&#39; at position 0.\n&#39;             Capture: 1: &#39;&#39; at position 0.\n&#39;             Capture: 2: &#39;a&#39; at position 0.\n</code></pre><h2 id=\"see-also\">See also</h2>\n<p><a href=\"quick-ref\" data-linktype=\"relative-path\">Regular expression language - quick reference</a></p>\n<p><a href=\"backtracking\" data-linktype=\"relative-path\">Backtracking in regular expressions</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"shoag\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-all/api/toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"dotnet\">\r\n<meta name=\"ms.assetid\" content=\"8e5124c4-20b5-4c57-ab68-301d1d7311c4\">\r\n<meta name=\"description\" content=\"Quantifiers in regular expressions\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"07/29/2016\">\r\n<meta name=\"ms.technology\" content=\"dotnet-standard\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/standard/base-types/quantifiers.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/standard/base-types/quantifiers.md\">\r\n<meta name=\"document_id\" content=\"05a87727-2f7f-f5f0-d36b-cea028fc00b0\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"shoag","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Quantifiers in regular expressions | Microsoft Docs","ms.devlang":"dotnet","ms.assetid":"8e5124c4-20b5-4c57-ab68-301d1d7311c4","description":"Quantifiers in regular expressions","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"07/29/2016","ms.technology":"dotnet-standard","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"fixed broken anchors (#1194)","commit_sha":"b20713600d7c3ddc31be5885733a1e8910ede8c6","commit_date":"2016-11-02 20:45:13 -0700"},{"author_name":"Steve Hoag","author_email":"shoag@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Porting base type docs take 4 (#1053)","commit_sha":"fb00da6505c9edb6a49d2003ae9bcb8e74c11d6c","commit_date":"2016-10-06 10:32:59 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/standard/base-types/quantifiers.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/standard/base-types/quantifiers.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/standard/base-types/quantifiers.md","document_id":"05a87727-2f7f-f5f0-d36b-cea028fc00b0","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/standard/base-types/quantifiers","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Quantifiers in regular expressions","_op_displayDate":"2016-7-29","_op_displayDate_source":"2016-07-29T00:00:00Z","_op_wordCount":4700,"_op_rawTitle":"<h1 id=\"quantifiers-in-regular-expressions\" sourcefile=\"docs/standard/base-types/quantifiers.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Quantifiers in regular expressions</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/standard/base-types/quantifiers","fileRelativePath":"articles/standard/base-types/quantifiers.html"},"themesRelativePathToOutputRoot":"_themes/"}