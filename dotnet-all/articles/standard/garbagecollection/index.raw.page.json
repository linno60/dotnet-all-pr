{"content":"<div><div class=\"content\">\n<p>Garbage collection is one of most important features of the .NET managed code platform. The garbage collector (GC) manages allocating and releasing memory for you. You do not need to how to allocate and release memory or manage the lifetime of the objects that use that memory. An allocation is made any time you <em>new</em> an object or a value type is boxed. Allocations are typically very fast. When there isn’t enough memory to allocate an object, the GC must collect and dispose of garbage memory to make memory available for new allocations. This process is called “garbage collection”.</p>\n<p>The garbage collector serves as an automatic memory manager. It provides the following benefits:</p>\n<ul>\n<li>Enables you to develop your application without having to free memory.</li>\n<li>Allocates objects on the managed heap efficiently.</li>\n<li>Reclaims objects that are no longer being used, clears their memory, and keeps the memory available for future allocations. Managed objects automatically get clean content to start with, so their constructors do not have to initialize every data field.</li>\n<li>Provides memory safety by making sure that an object cannot use the content of another object.</li>\n</ul>\n<p>The .NET GC is generational and has 3 generations. Each generation has its own heap that it uses for storage of allocated objects. There is a basic principle that most objects are either short lived or long lived. Generation 0 is where objects are first allocated. Objects often don’t live past the first generation, since they are no longer in use (out of scope) by the time the next garbage collection occurs. Generation 0 is quick to collect because its associated heap is small. Generation 1 is really a second chance space. Objects that are short lived but survive the generation 0 collection (often based on coincidental timing) go to generation 1. Generation 1 collections are also quick because its associated heap is also small. The first two heaps remain small because objects are either collected or are promoted to the next generation heap. Generation 2 is where all long lived objects are. The generation 2 heap can grow to be very large, since the objects it contains can survive a long time and there is no generation 3 heap to further promote objects.</p>\n<p>The GC has an additional heap for large objects called the Large Object Heap (LOH). It is reserved for objects that are 85,000 bytes or greater. A byte array (Byte[]) with 85k elements would be an example of a large object. Large objects are not allocated to the generational heaps but are allocated directly to the LOH.</p>\n<p>Generation 2 and LOH collections can take noticeable time for programs that have run for a long time or operate over large amounts of data. Large server programs are known to have heaps in the 10s of GBs. The GC employs a variety of techniques to reduce the amount of time that it blocks program execution. The primary approach is to do as much garbage collection work as possible on a background thread in a way that does not interfere with program execution. The GC also exposes a few ways for developers to influence its behavior, which can be quite useful to improve performance.</p>\n<h2 id=\"related-topics\">Related Topics</h2>\n<table>\n<thead>\n<tr>\n<th>Title</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"gc\" data-linktype=\"relative-path\">Automatic memory management and garbage collection</a></td>\n<td>Introduces the basic concepts of memory management in .NET</td>\n</tr>\n<tr>\n<td><a href=\"fundamentals\" data-linktype=\"relative-path\">Fundamentals of garbage collection</a></td>\n<td>Describes how garbage collection works, how objects are allocated on the managed heap, and other core concepts.</td>\n</tr>\n<tr>\n<td><a href=\"induced\" data-linktype=\"relative-path\">Induced collections</a></td>\n<td>Describes how to make a garbage collection occur.</td>\n</tr>\n<tr>\n<td><a href=\"latency\" data-linktype=\"relative-path\">Latency modes</a></td>\n<td>Describes the modes that determine the intrusiveness of garbage collection.</td>\n</tr>\n<tr>\n<td><a href=\"weak-references\" data-linktype=\"relative-path\">Weak references</a></td>\n<td>Describes features that permit the garbage collector to collect an object while still allowing the application to access that object.</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"reference\">Reference</h2>\n<p><a class=\"xref\" href=\"../../../api/system.gc\" data-linktype=\"relative-path\">System.GC</a></p>\n<p><a class=\"xref\" href=\"../../../api/system.gccollectionmode\" data-linktype=\"relative-path\">System.GCCollectionMode</a></p>\n<p><a class=\"xref\" href=\"../../../api/system.runtime.gclatencymode\" data-linktype=\"relative-path\">System.Runtime.GCLatencyMode</a></p>\n<p><a class=\"xref\" href=\"../../../api/system.runtime.gcsettings\" data-linktype=\"relative-path\">System.Runtime.GCSettings</a></p>\n<p><a class=\"xref\" href=\"../../../api/system.runtime.gcsettings#System_Runtime_GCSettings_LargeObjectHeapCompactionMode\" data-linktype=\"relative-path\">GCSettings.LargeObjectHeapCompactionMode</a></p>\n<p><a class=\"xref\" href=\"../../../api/system.object#System_Object_Finalize\" data-linktype=\"relative-path\">Object.Finalize</a></p>\n<p><a class=\"xref\" href=\"../../../api/system.idisposable\" data-linktype=\"relative-path\">System.IDisposable</a></p>\n<h2 id=\"see-also\">See Also</h2>\n<p><a href=\"unmanaged\" data-linktype=\"relative-path\">Cleaning up unmanaged resources</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"richlander\">\r\n<meta name=\"ms.author\" content=\"mairaw\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc1.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.devlang\" content=\"dotnet\">\r\n<meta name=\"ms.assetid\" content=\"db39a0f5-e363-490f-a7e6-adb9a6ff2a8c\">\r\n<meta name=\"description\" content=\"Garbage Collection\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"06/20/2016\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/ffc0530b2263db0e073f351aac2d539de6701ead/docs/standard/garbagecollection/index.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/standard/garbagecollection/index.md\">\r\n<meta name=\"document_id\" content=\"da23a519-e72b-7a21-2770-529e554fe2c9\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc1.json\">\r\n","rawMetadata":{"author":"richlander","ms.author":"mairaw","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","title":"Garbage Collection | Microsoft Docs","ms.devlang":"dotnet","ms.assetid":"db39a0f5-e363-490f-a7e6-adb9a6ff2a8c","description":"Garbage Collection","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"06/20/2016","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Vedant-Koditkar","author_email":"vedant.koditkar.vk@gmail.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"typos (#1409)","commit_sha":"ffc0530b2263db0e073f351aac2d539de6701ead","commit_date":"2017-01-14 11:55:49 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"fix broken uid links (#985)","commit_sha":"213ce098bcc2b5e31c55e759d895254d5ca33caa","commit_date":"2016-08-30 16:18:59 -0700"},{"author_name":"Steve Hoag","author_email":"shoag@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Porting from MSDN (#975)","commit_sha":"bb50b160a685d494ba47b3ca583f6fc35fa3ef3e","commit_date":"2016-08-29 12:51:05 -0700"},{"author_name":"Maira Wenzel","author_email":"mairaw@users.noreply.github.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Revert \"Bringing back essentials topics\" (#661)","commit_sha":"6d10e1507a2a8040743da29184fa4981ddbf7af3","commit_date":"2016-06-26 17:59:39 -0700"},{"author_name":"Steve Hoag","author_email":"shoag@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Bringing back essentials topics (#659)","commit_sha":"5f3ebe05f34a44b449412c6334e47a9861b36c79","commit_date":"2016-06-26 17:27:32 -0700"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/richlander","display_name":"Rich Lander","id":"2608468"},"contributors":[{"profile_url":"https://github.com/richlander","display_name":"Rich Lander"},{"profile_url":"https://github.com/Vedant-Koditkar","display_name":"Vedant-Koditkar","id":"18693839"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/ffc0530b2263db0e073f351aac2d539de6701ead/docs/standard/garbagecollection/index.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/standard/garbagecollection/index.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/standard/garbagecollection/index.md","document_id":"da23a519-e72b-7a21-2770-529e554fe2c9","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/standard/garbagecollection/index","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Garbage Collection","_op_displayDate":"2016-6-20","_op_displayDate_source":"2016-06-20T00:00:00Z","_op_wordCount":629,"_op_rawTitle":"<h1 id=\"garbage-collection\" sourcefile=\"docs/standard/garbagecollection/index.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Garbage collection</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/standard/garbagecollection/index","fileRelativePath":"articles/standard/garbagecollection/index.html"},"themesRelativePathToOutputRoot":"_themes/"}