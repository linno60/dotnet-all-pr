{"content":"<div><div class=\"content\">\n<p>You implement a <a class=\"xref\" href=\"../../../api/system.idisposable#System_IDisposable_Dispose\" data-linktype=\"relative-path\">Dispose</a> method to release unmanaged resources used by your application. The .NET garbage collector does not allocate or release unmanaged memory. </p>\n<p>The pattern for disposing an object, referred to as a dispose pattern, imposes order on the lifetime of an object. The dispose pattern is used only for objects that access unmanaged resources, such as file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory. This is because the garbage collector is very efficient at reclaiming unused managed objects, but it is unable to reclaim unmanaged objects.</p>\n<p>The dispose pattern has two variations:</p>\n<ul>\n<li>You wrap each unmanaged resource that a type uses in a safe handle (that is, in a class derived from <a class=\"xref\" href=\"../../../api/system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">System.Runtime.InteropServices.SafeHandle</a>). In this case, you implement the <a class=\"xref\" href=\"../../../api/system.idisposable\" data-linktype=\"relative-path\">IDisposable</a> interface and an additional <code>Dispose(Boolean)</code> method. This is the recommended variation and doesn&#39;t require overriding the <a class=\"xref\" href=\"../../../api/system.object#System_Object_Finalize\" data-linktype=\"relative-path\">Object.Finalize</a> method. </li>\n</ul>\n<div class=\"NOTE\"><h5>Note</h5><p>The <a class=\"xref\" href=\"../../../api/microsoft.win32.safehandles\" data-linktype=\"relative-path\">Microsoft.Win32.SafeHandles</a> namespace provides a set of classes derived from <a class=\"xref\" href=\"../../../api/system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a>, which are listed in the <a href=\"#using-safe-handles\" data-linktype=\"self-bookmark\">Using safe handles</a> section. If you can&#39;t find a class that is suitable for releasing your unmanaged resource, you can implement your own subclass of <a class=\"xref\" href=\"../../../api/system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a>. </p>\n</div>\n<ul>\n<li>You implement the <a class=\"xref\" href=\"../../../api/system.idisposable\" data-linktype=\"relative-path\">IDisposable</a> interface and an additional <code>Dispose(Boolean</code>) method, and you also override the <a class=\"xref\" href=\"../../../api/system.object#System_Object_Finalize\" data-linktype=\"relative-path\">Object.Finalize</a> method. You must override <a class=\"xref\" href=\"../../../api/system.object#System_Object_Finalize\" data-linktype=\"relative-path\">Finalize</a> to ensure that unmanaged resources are disposed of if your <a class=\"xref\" href=\"../../../api/system.idisposable#System_IDisposable_Dispose\" data-linktype=\"relative-path\">IDisposable.Dispose</a> implementation is not called by a consumer of your type. If you use the recommended technique discussed in the previous bullet, the <a class=\"xref\" href=\"../../../api/system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">System.Runtime.InteropServices.SafeHandle</a> class does this on your behalf. </li>\n</ul>\n<p>To help ensure that resources are always cleaned up appropriately, a <a class=\"xref\" href=\"../../../api/system.idisposable#System_IDisposable_Dispose\" data-linktype=\"relative-path\">Dispose</a> method should be callable multiple times without throwing an exception. </p>\n<p>The code example provided for the <a class=\"xref\" href=\"../../../api/system.gc#System_GC_KeepAlive_System_Object_\" data-linktype=\"relative-path\">GC.KeepAlive</a> method shows how aggressive garbage collection can cause a finalizer to run while a member of the reclaimed object is still executing. It is a good idea to call the <a class=\"xref\" href=\"../../../api/system.gc#System_GC_KeepAlive_System_Object_\" data-linktype=\"relative-path\">KeepAlive</a> method at the end of a lengthy <code>Dispose</code> method.</p>\n<h2 id=\"dispose-and-disposeboolean\">Dispose() and Dispose(Boolean)</h2>\n<p>The <a class=\"xref\" href=\"../../../api/system.idisposable\" data-linktype=\"relative-path\">IDisposable</a> interface requires the implementation of a single parameterless method, <a class=\"xref\" href=\"../../../api/system.idisposable#System_IDisposable_Dispose\" data-linktype=\"relative-path\">Dispose</a>. However, the dispose pattern requires two <code>Dispose</code> methods to be implemented: </p>\n<ul>\n<li><p>A public non-virtual (<code>NonInheritable</code> in Visual Basic) <a class=\"xref\" href=\"../../../api/system.idisposable#System_IDisposable_Dispose\" data-linktype=\"relative-path\">IDisposable.Dispose</a> implementation that has no parameters.</p>\n</li>\n<li><p>A protected virtual (<code>Overridable</code> in Visual Basic) <code>Dispose</code> method whose signature is:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">protected virtual void Dispose(bool disposing)\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Protected Overridable Sub Dispose(disposing As Boolean)\n</code></pre></li>\n</ul>\n<h3 id=\"the-dispose-overload\">The Dispose() overload</h3>\n<p>Because the public, non-virtual (<code>NonInheritable</code> in Visual Basic), parameterless <code>Dispose</code> method is called by a consumer of the type, its purpose is to free unmanaged resources and to indicate that the finalizer, if one is present, doesn&#39;t have to run. Because of this, it has a standard implementation:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">public void Dispose()\n{\n   // Dispose of unmanaged resources.\n   Dispose(true);\n   // Suppress finalization.\n   GC.SuppressFinalize(this);\n}\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Public Sub Dispose() _\n           Implements IDisposable.Dispose\n   &#39; Dispose of unmanaged resources.\n   Dispose(True)\n   &#39; Suppress finalization.\n   GC.SuppressFinalize(Me)\nEnd Sub\n</code></pre><p>The <code>Dispose</code> method performs all object cleanup, so the garbage collector no longer needs to call the objects&#39; <a class=\"xref\" href=\"../../../api/system.object#System_Object_Finalize\" data-linktype=\"relative-path\">Object.Finalize</a> override. Therefore, the call to the <a class=\"xref\" href=\"../../../api/system.gc#System_GC_SuppressFinalize_System_Object_\" data-linktype=\"relative-path\">GC.SuppressFinalize</a> method prevents the garbage collector from running the finalizer. If the type has no finalizer, the call to <a class=\"xref\" href=\"../../../api/system.gc#System_GC_SuppressFinalize_System_Object_\" data-linktype=\"relative-path\">SuppressFinalize</a> has no effect. Note that the actual work of releasing unmanaged resources is performed by the second overload of the <code>Dispose</code> method.</p>\n<h3 id=\"the-disposeboolean-overload\">The Dispose(Boolean) overload</h3>\n<p>In the second overload, the <em>disposing</em> parameter is a <a class=\"xref\" href=\"../../../api/system.boolean\" data-linktype=\"relative-path\">Boolean</a> that indicates whether the method call comes from a <a class=\"xref\" href=\"../../../api/system.idisposable#System_IDisposable_Dispose\" data-linktype=\"relative-path\">Dispose</a> method (its value is <code>true</code>) or from a finalizer (its value is <code>false</code>). </p>\n<p>The body of the method consists of two blocks of code: </p>\n<ul>\n<li><p>A block that frees unmanaged resources. This block executes regardless of the value of the <em>disposing</em> parameter. </p>\n</li>\n<li><p>A conditional block that frees managed resources. This block executes if the value of <em>disposing</em> is <code>true</code>. The managed resources that it frees can include: </p>\n<p>  <strong>Managed objects that implement IDisposable</strong>. The conditional block can be used to call their <a class=\"xref\" href=\"../../../api/system.idisposable#System_IDisposable_Dispose\" data-linktype=\"relative-path\">Dispose</a> implementation. If you have used a safe handle to wrap your unmanaged resource, you should call the <a class=\"xref\" href=\"../../../api/system.runtime.interopservices.safehandle#System_Runtime_InteropServices_SafeHandle_Dispose_System_Boolean_\" data-linktype=\"relative-path\">SafeHandle.Dispose(Boolean</a> implementation here. </p>\n<p>  <strong>Managed objects that consume large amounts of memory or consume scarce resources.</strong> Freeing these objects explicitly in the <code>Dispose</code> method releases them faster than if they were reclaimed non-deterministically by the garbage collector. </p>\n</li>\n</ul>\n<p>If the method call comes from a finalizer (that is, if <em>disposing</em> is <code>false</code>), only the code that frees unmanaged resources executes. Because the order in which the garbage collector destroys managed objects during finalization is not defined, calling this <code>Dispose</code> overload with a value of <code>false</code> prevents the finalizer from trying to release managed resources that may have already been reclaimed. </p>\n<h2 id=\"implementing-the-dispose-pattern-for-a-base-class\">Implementing the dispose pattern for a base class</h2>\n<p>If you implement the dispose pattern for a base class, you must provide the following: </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p>You should implement this pattern for all base classes that implement <a class=\"xref\" href=\"../../../api/system.idisposable\" data-linktype=\"relative-path\">IDisposable</a> and are not <code>sealed</code>. </p>\n</div>\n<ul>\n<li><p>A <a class=\"xref\" href=\"../../../api/system.idisposable#System_IDisposable_Dispose\" data-linktype=\"relative-path\">Dispose</a> implementation that calls the <code>Dispose(Boolean)</code> method. </p>\n</li>\n<li><p>A <code>Dispose(Boolean)</code> method that performs the actual work of releasing resources. </p>\n</li>\n<li><p>Either a class derived from <a class=\"xref\" href=\"../../../api/system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> that wraps your unmanaged resource (recommended), or an override to the <a class=\"xref\" href=\"../../../api/system.object#System_Object_Finalize\" data-linktype=\"relative-path\">Object.Finalize</a> method. The <a class=\"xref\" href=\"../../../api/system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a>SafeHandle class provides a finalizer that frees you from having to code one. </p>\n</li>\n</ul>\n<p>Here&#39;s the general pattern for implementing the dispose pattern for a base class that uses a safe handle. </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using Microsoft.Win32.SafeHandles;\nusing System;\nusing System.Runtime.InteropServices;\n\nclass BaseClass : IDisposable\n{\n   // Flag: Has Dispose already been called?\n   bool disposed = false;\n   // Instantiate a SafeHandle instance.\n   SafeHandle handle = new SafeFileHandle(IntPtr.Zero, true);\n\n   // Public implementation of Dispose pattern callable by consumers.\n   public void Dispose()\n   { \n      Dispose(true);\n      GC.SuppressFinalize(this);           \n   }\n\n   // Protected implementation of Dispose pattern.\n   protected virtual void Dispose(bool disposing)\n   {\n      if (disposed)\n         return; \n\n      if (disposing) {\n         handle.Dispose();\n         // Free any other managed objects here.\n         //\n      }\n\n      // Free any unmanaged objects here.\n      //\n      disposed = true;\n   }\n}\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Imports Microsoft.Win32.SafeHandles\nImports System.Runtime.InteropServices\n\nClass BaseClass : Implements IDisposable\n   &#39; Flag: Has Dispose already been called?\n   Dim disposed As Boolean = False\n   &#39; Instantiate a SafeHandle instance.\n   Dim handle As SafeHandle = New SafeFileHandle(IntPtr.Zero, True)\n\n   &#39; Public implementation of Dispose pattern callable by consumers.\n   Public Sub Dispose() _\n              Implements IDisposable.Dispose\n      Dispose(True)\n      GC.SuppressFinalize(Me)           \n   End Sub\n\n   &#39; Protected implementation of Dispose pattern.\n   Protected Overridable Sub Dispose(disposing As Boolean)\n      If disposed Then Return\n\n      If disposing Then\n         handle.Dispose()\n         &#39; Free any other managed objects here.\n         &#39;\n      End If\n\n      &#39; Free any unmanaged objects here.\n      &#39;\n      disposed = True\n   End Sub\nEnd Class\n</code></pre><div class=\"NOTE\"><h5>Note</h5><p>The previous example uses a <a class=\"xref\" href=\"../../../api/microsoft.win32.safehandles.safefilehandle\" data-linktype=\"relative-path\">SafeFileHandle</a> object to illustrate the pattern; any object derived from <a class=\"xref\" href=\"../../../api/system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> could be used instead. Note that the example does not properly instantiate its <a class=\"xref\" href=\"../../../api/microsoft.win32.safehandles.safefilehandle\" data-linktype=\"relative-path\">SafeFileHandle</a> object. </p>\n</div>\n<p>Here&#39;s the general pattern for implementing the dispose pattern for a base class that overrides <a class=\"xref\" href=\"../../../api/system.object#System_Object_Finalize\" data-linktype=\"relative-path\">Object.Finalize</a>. </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\n\nclass BaseClass : IDisposable\n{\n   // Flag: Has Dispose already been called?\n   bool disposed = false;\n\n   // Public implementation of Dispose pattern callable by consumers.\n   public void Dispose()\n   { \n      Dispose(true);\n      GC.SuppressFinalize(this);           \n   }\n\n   // Protected implementation of Dispose pattern.\n   protected virtual void Dispose(bool disposing)\n   {\n      if (disposed)\n         return; \n\n      if (disposing) {\n         // Free any other managed objects here.\n         //\n      }\n\n      // Free any unmanaged objects here.\n      //\n      disposed = true;\n   }\n\n   ~BaseClass()\n   {\n      Dispose(false);\n   }\n}\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Class BaseClass : Implements IDisposable\n   &#39; Flag: Has Dispose already been called?\n   Dim disposed As Boolean = False\n\n   &#39; Public implementation of Dispose pattern callable by consumers.\n   Public Sub Dispose() _\n              Implements IDisposable.Dispose\n      Dispose(True)\n      GC.SuppressFinalize(Me)           \n   End Sub\n\n   &#39; Protected implementation of Dispose pattern.\n   Protected Overridable Sub Dispose(disposing As Boolean)\n      If disposed Then Return\n\n      If disposing Then\n         &#39; Free any other managed objects here.\n         &#39;\n      End If\n\n      &#39; Free any unmanaged objects here.\n      &#39;\n      disposed = True\n   End Sub\n\n   Protected Overrides Sub Finalize()\n      Dispose(False)      \n   End Sub\nEnd Class\n</code></pre><div class=\"NOTE\"><h5>Note</h5><p>In C#, you override <a class=\"xref\" href=\"../../../api/system.object#System_Object_Finalize\" data-linktype=\"relative-path\">Object.Finalize</a> by defining a <code>destructor</code>. </p>\n</div>\n<h2 id=\"implementing-the-dispose-pattern-for-a-derived-class\">Implementing the dispose pattern for a derived class</h2>\n<p>A class derived from a class that implements the <a class=\"xref\" href=\"../../../api/system.idisposable\" data-linktype=\"relative-path\">IDisposable</a> interface shouldn&#39;t implement <a class=\"xref\" href=\"../../../api/system.idisposable\" data-linktype=\"relative-path\">IDisposable</a>, because the base class implementation of <a class=\"xref\" href=\"../../../api/system.idisposable#System_IDisposable_Dispose\" data-linktype=\"relative-path\">IDisposable.Dispose</a> is inherited by its derived classes. Instead, to implement the dispose pattern for a derived class, you provide the following: </p>\n<ul>\n<li><p>A <code>protected Dispose(Boolean)</code> method that overrides the base class method and performs the actual work of releasing the resources of the derived class. This method should also call the <code>Dispose(Boolean)</code> method of the base class and pass it a value of <code>true</code> for the <em>disposing</em> argument. </p>\n</li>\n<li><p>Either a class derived from <a class=\"xref\" href=\"../../../api/system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> that wraps your unmanaged resource (recommended), or an override to the <a class=\"xref\" href=\"../../../api/system.object#System_Object_Finalize\" data-linktype=\"relative-path\">Object.Finalize</a> method. The <a class=\"xref\" href=\"../../../api/system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> class provides a finalizer that frees you from having to code one. If you do provide a finalizer, it should call the <code>Dispose(Boolean)</code> overload with a <em>disposing</em> argument of <code>false</code>. </p>\n</li>\n</ul>\n<p>Here&#39;s the general pattern for implementing the dispose pattern for a derived class that uses a safe handle: </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using Microsoft.Win32.SafeHandles;\nusing System;\nusing System.Runtime.InteropServices;\n\nclass DerivedClass : BaseClass\n{\n   // Flag: Has Dispose already been called?\n   bool disposed = false;\n   // Instantiate a SafeHandle instance.\n   SafeHandle handle = new SafeFileHandle(IntPtr.Zero, true);\n\n   // Protected implementation of Dispose pattern.\n   protected override void Dispose(bool disposing)\n   {\n      if (disposed)\n         return; \n\n      if (disposing) {\n         handle.Dispose();\n         // Free any other managed objects here.\n         //\n      }\n\n      // Free any unmanaged objects here.\n      //\n\n      disposed = true;\n      // Call base class implementation.\n      base.Dispose(disposing);\n   }\n}\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Imports Microsoft.Win32.SafeHandles\nImports System.Runtime.InteropServices\n\nClass DerivedClass : Inherits BaseClass \n   &#39; Flag: Has Dispose already been called?\n   Dim disposed As Boolean = False\n   &#39; Instantiate a SafeHandle instance.\n   Dim handle As SafeHandle = New SafeFileHandle(IntPtr.Zero, True)\n\n   &#39; Protected implementation of Dispose pattern.\n   Protected Overrides Sub Dispose(disposing As Boolean)\n      If disposed Then Return\n\n      If disposing Then\n         handle.Dispose()\n         &#39; Free any other managed objects here.\n         &#39;\n      End If\n\n      &#39; Free any unmanaged objects here.\n      &#39;\n      disposed = True\n\n      &#39; Call base class implementation.\n      MyBase.Dispose(disposing)\n   End Sub\nEnd Class\n</code></pre><div class=\"NOTE\"><h5>Note</h5><p>The previous example uses a <a class=\"xref\" href=\"../../../api/microsoft.win32.safehandles.safefilehandle\" data-linktype=\"relative-path\">SafeFileHandle</a> object to illustrate the pattern; any object derived from <a class=\"xref\" href=\"../../../api/system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> could be used instead. Note that the example does not properly instantiate its <a class=\"xref\" href=\"../../../api/microsoft.win32.safehandles.safefilehandle\" data-linktype=\"relative-path\">SafeFileHandle</a> object. </p>\n</div>\n<p>Here&#39;s the general pattern for implementing the dispose pattern for a derived class that overrides <a class=\"xref\" href=\"../../../api/system.object#System_Object_Finalize\" data-linktype=\"relative-path\">Object.Finalize</a>:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\n\nclass DerivedClass : BaseClass\n{\n   // Flag: Has Dispose already been called?\n   bool disposed = false;\n\n   // Protected implementation of Dispose pattern.\n   protected override void Dispose(bool disposing)\n   {\n      if (disposed)\n         return; \n\n      if (disposing) {\n         // Free any other managed objects here.\n         //\n      }\n\n      // Free any unmanaged objects here.\n      //\n      disposed = true;\n\n      // Call the base class implementation.\n      base.Dispose(disposing);\n   }\n\n   ~DerivedClass()\n   {\n      Dispose(false);\n   }\n}\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Class DerivedClass : Inherits BaseClass\n   &#39; Flag: Has Dispose already been called?\n   Dim disposed As Boolean = False\n\n   &#39; Protected implementation of Dispose pattern.\n   Protected Overrides Sub Dispose(disposing As Boolean)\n      If disposed Then Return\n\n      If disposing Then\n         &#39; Free any other managed objects here.\n         &#39;\n      End If\n\n      &#39; Free any unmanaged objects here.\n      &#39;\n      disposed = True\n\n      &#39; Call the base class implementation.\n      MyBase.Dispose(disposing)\n   End Sub\n\n   Protected Overrides Sub Finalize()\n      Dispose(False)\n   End Sub \nEnd Class\n</code></pre><div class=\"NOTE\"><h5>Note</h5><p>In C#, you override <a class=\"xref\" href=\"../../../api/system.object#System_Object_Finalize\" data-linktype=\"relative-path\">Object.Finalize</a> by defining a <code>destructor</code>.</p>\n</div>\n<h2 id=\"using-safe-handles\">Using safe handles</h2>\n<p>Writing code for an object&#39;s finalizer is a complex task that can cause problems if not done correctly. Therefore, we recommend that you construct <a class=\"xref\" href=\"../../../api/system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">System.Runtime.InteropServices.SafeHandle</a> objects instead of implementing a finalizer.</p>\n<p>Classes derived from the <a class=\"xref\" href=\"../../../api/system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">System.Runtime.InteropServices.SafeHandle</a> class simplify object lifetime issues by assigning and releasing handles without interruption. They contain a critical finalizer that is guaranteed to run while an application domain is unloading. The following derived classes in the <a class=\"xref\" href=\"../../../api/microsoft.win32.safehandles\" data-linktype=\"relative-path\">Microsoft.Win32.SafeHandles</a> namespace provide safe handles: </p>\n<ul>\n<li><p>The <a class=\"xref\" href=\"../../../api/microsoft.win32.safehandles.safefilehandle\" data-linktype=\"relative-path\">SafeFileHandle</a>, <a class=\"xref\" href=\"../../../api/microsoft.win32.safehandles.safememorymappedfilehandle\" data-linktype=\"relative-path\">SafeMemoryMappedFileHandle</a>, and <a class=\"xref\" href=\"../../../api/microsoft.win32.safehandles.safepipehandle\" data-linktype=\"relative-path\">SafePipeHandle</a> class, for files, memory mapped files, and pipes. </p>\n</li>\n<li><p>The <a class=\"xref\" href=\"../../../api/microsoft.win32.safehandles.safememorymappedviewhandle\" data-linktype=\"relative-path\">SafeMemoryMappedViewHandle</a> class, for memory views. </p>\n</li>\n<li><p>The <a href=\"https://msdn.microsoft.com/library/microsoft.win32.safehandles.safencryptkeyhandle(v=vs.110).aspx\" data-linktype=\"external\">SafeNCryptKeyHandle</a>, <a href=\"https://msdn.microsoft.com/library/microsoft.win32.safehandles.safencryptproviderhandle(v=vs.110).aspx\" data-linktype=\"external\">SafeNCryptProviderHandle</a>, and <a href=\"https://msdn.microsoft.com/library/microsoft.win32.safehandles.safencryptsecrethandle(v=vs.110).aspx\" data-linktype=\"external\">SafeNCryptSecretHandle</a> classes, for cryptography constructs.</p>\n</li>\n<li><p>The <a class=\"xref\" href=\"../../../api/microsoft.win32.safehandles.saferegistryhandle\" data-linktype=\"relative-path\">SafeRegistryHandle</a> class, for registry keys. </p>\n</li>\n<li><p>The <a class=\"xref\" href=\"../../../api/microsoft.win32.safehandles.safewaithandle\" data-linktype=\"relative-path\">SafeWaitHandle</a> class, for wait handles. </p>\n</li>\n</ul>\n<h2 id=\"using-a-safe-handle-to-implement-the-dispose-pattern-for-a-base-class\">Using a safe handle to implement the dispose pattern for a base class</h2>\n<p>The following example illustrates the dispose pattern for a base class, <code>DisposableStreamResource</code>, that uses a safe handle to encapsulate unmanaged resources. It defines a <code>DisposableResource</code> class that uses a <a class=\"xref\" href=\"../../../api/microsoft.win32.safehandles.safefilehandle\" data-linktype=\"relative-path\">SafeFileHandle</a> to wrap a <a class=\"xref\" href=\"../../../api/system.io.stream\" data-linktype=\"relative-path\">Stream</a> object that represents an open file. The <code>DisposableResource</code> method also includes a single property, <code>Size</code>, that returns the total number of bytes in the file stream. </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using Microsoft.Win32.SafeHandles;\nusing System;\nusing System.IO;\nusing System.Runtime.InteropServices;\n\npublic class DisposableStreamResource : IDisposable\n{\n   // Define constants.\n   protected const uint GENERIC_READ = 0x80000000;\n   protected const uint FILE_SHARE_READ = 0x00000001;\n   protected const uint OPEN_EXISTING = 3;\n   protected const uint FILE_ATTRIBUTE_NORMAL = 0x80;\n   protected IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);\n   private const int INVALID_FILE_SIZE = unchecked((int) 0xFFFFFFFF);\n\n   // Define Windows APIs.\n   [DllImport(&quot;kernel32.dll&quot;, EntryPoint = &quot;CreateFileW&quot;, CharSet = CharSet.Unicode)]\n   protected static extern IntPtr CreateFile (\n                                  string lpFileName, uint dwDesiredAccess, \n                                  uint dwShareMode, IntPtr lpSecurityAttributes, \n                                  uint dwCreationDisposition, uint dwFlagsAndAttributes, \n                                  IntPtr hTemplateFile);\n\n   [DllImport(&quot;kernel32.dll&quot;)]\n   private static extern int GetFileSize(SafeFileHandle hFile, out int lpFileSizeHigh);\n\n   // Define locals.\n   private bool disposed = false;\n   private SafeFileHandle safeHandle; \n   private long bufferSize;\n   private int upperWord;\n\n   public DisposableStreamResource(string filename)\n   {\n      if (filename == null)\n         throw new ArgumentNullException(&quot;The filename cannot be null.&quot;);\n      else if (filename == &quot;&quot;)\n         throw new ArgumentException(&quot;The filename cannot be an empty string.&quot;);\n\n      IntPtr handle = CreateFile(filename, GENERIC_READ, FILE_SHARE_READ,\n                                 IntPtr.Zero, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,\n                                 IntPtr.Zero);\n      if (handle != INVALID_HANDLE_VALUE)\n         safeHandle = new SafeFileHandle(handle, true);\n      else\n         throw new FileNotFoundException(String.Format(&quot;Cannot open &#39;{0}&#39;&quot;, filename));\n\n      // Get file size.\n      bufferSize = GetFileSize(safeHandle, out upperWord); \n      if (bufferSize == INVALID_FILE_SIZE)\n         bufferSize = -1;\n      else if (upperWord &gt; 0) \n         bufferSize = (((long)upperWord) &lt;&lt; 32) + bufferSize;\n   }\n\n   public long Size \n   { get { return bufferSize; } }\n\n   public void Dispose()\n   {\n      Dispose(true);\n      GC.SuppressFinalize(this);\n   }           \n\n   protected virtual void Dispose(bool disposing)\n   {\n      if (disposed) return;\n\n      // Dispose of managed resources here.\n      if (disposing)\n         safeHandle.Dispose();\n\n      // Dispose of any unmanaged resources not wrapped in safe handles.\n\n      disposed = true;\n   }  \n}\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Imports Microsoft.Win32.SafeHandles\nImports System.IO\n\nPublic Class DisposableStreamResource : Implements IDisposable\n   &#39; Define constants.\n   Protected Const GENERIC_READ As UInteger = &amp;H80000000ui\n   Protected Const FILE_SHARE_READ As UInteger = &amp;H0000000i\n   Protected Const OPEN_EXISTING As UInteger = 3\n   Protected Const FILE_ATTRIBUTE_NORMAL As UInteger = &amp;H80\n   Protected INVALID_HANDLE_VALUE As New IntPtr(-1)\n   Private Const INVALID_FILE_SIZE As Integer = &amp;HFFFFFFFF\n\n   &#39; Define Windows APIs.\n   Protected Declare Function CreateFile Lib &quot;kernel32&quot; Alias &quot;CreateFileA&quot; (\n                                         lpFileName As String, dwDesiredAccess As UInt32, \n                                         dwShareMode As UInt32, lpSecurityAttributes As IntPtr, \n                                         dwCreationDisposition As UInt32, dwFlagsAndAttributes As UInt32, \n                                         hTemplateFile As IntPtr) As IntPtr\n   Private Declare Function GetFileSize Lib &quot;kernel32&quot; (hFile As SafeFileHandle, \n                                                        ByRef lpFileSizeHigh As Integer) As Integer\n\n   &#39; Define locals.\n   Private disposed As Boolean = False\n   Private safeHandle As SafeFileHandle \n   Private bufferSize As Long \n   Private upperWord As Integer\n\n   Public Sub New(filename As String)\n      If filename Is Nothing Then\n         Throw New ArgumentNullException(&quot;The filename cannot be null.&quot;)\n      Else If filename = &quot;&quot;\n         Throw New ArgumentException(&quot;The filename cannot be an empty string.&quot;)\n      End If\n\n      Dim handle As IntPtr = CreateFile(filename, GENERIC_READ, FILE_SHARE_READ,\n                                        IntPtr.Zero, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,\n                                        IntPtr.Zero)\n      If handle &lt;&gt; INVALID_HANDLE_VALUE Then\n         safeHandle = New SafeFileHandle(handle, True)\n      Else\n         Throw New FileNotFoundException(String.Format(&quot;Cannot open &#39;{0}&#39;&quot;, filename))\n      End If\n\n      &#39; Get file size.\n      bufferSize = GetFileSize(safeHandle, upperWord) \n      If bufferSize = INVALID_FILE_SIZE Then\n         bufferSize = -1\n      Else If upperWord &gt; 0 Then \n         bufferSize = (CLng(upperWord) &lt;&lt; 32) + bufferSize\n      End If     \n   End Sub\n\n   Public ReadOnly Property Size As Long\n      Get\n         Return bufferSize\n      End Get\n   End Property\n\n   Public Sub Dispose() _\n              Implements IDisposable.Dispose\n      Dispose(True)\n      GC.SuppressFinalize(Me)\n   End Sub           \n\n   Protected Overridable Sub Dispose(disposing As Boolean)\n      If disposed Then Exit Sub\n\n      &#39; Dispose of managed resources here.\n      If disposing Then\n         safeHandle.Dispose()\n      End If\n\n      &#39; Dispose of any unmanaged resources not wrapped in safe handles.\n\n      disposed = True\n   End Sub  \nEnd Class\n</code></pre><h2 id=\"using-a-safe-handle-to-implement-the-dispose-pattern-for-a-derived-class\">Using a safe handle to implement the dispose pattern for a derived class</h2>\n<p>The following example illustrates the dispose pattern for a derived class, <code>DisposableStreamResource2</code>, that inherits from the <code>DisposableStreamResource</code> class presented in the previous example. The class adds an additional method, <code>WriteFileInfo</code>, and uses a <a class=\"xref\" href=\"../../../api/microsoft.win32.safehandles.safefilehandle\" data-linktype=\"relative-path\">SafeFileHandle</a> object to wrap the handle of the writable file. </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using Microsoft.Win32.SafeHandles;\nusing System;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Threading;\n\npublic class DisposableStreamResource2 : DisposableStreamResource\n{\n   // Define additional constants.\n   protected const uint GENERIC_WRITE = 0x40000000; \n   protected const uint OPEN_ALWAYS = 4;\n\n   // Define additional APIs.\n   [DllImport(&quot;kernel32.dll&quot;)]   \n   protected static extern bool WriteFile(\n                                SafeFileHandle safeHandle, string lpBuffer, \n                                int nNumberOfBytesToWrite, out int lpNumberOfBytesWritten,\n                                IntPtr lpOverlapped);\n\n   // Define locals.\n   private bool disposed = false;\n   private string filename;\n   private bool created = false;\n   private SafeFileHandle safeHandle;\n\n   public DisposableStreamResource2(string filename) : base(filename)\n   {\n      this.filename = filename;\n   }\n\n   public void WriteFileInfo()\n   { \n      if (! created) {\n         IntPtr hFile = CreateFile(xref:&quot;.\\FileInfo.txt&quot;, GENERIC_WRITE, 0, \n                                   IntPtr.Zero, OPEN_ALWAYS, \n                                   FILE_ATTRIBUTE_NORMAL, IntPtr.Zero);\n         if (hFile != INVALID_HANDLE_VALUE)\n            safeHandle = new SafeFileHandle(hFile, true);\n         else\n            throw new IOException(&quot;Unable to create output file.&quot;);\n\n         created = true;\n      }\n\n      string output = String.Format(&quot;{0}: {1:N0} bytes\\n&quot;, filename, Size);\n      int bytesWritten;\n      bool result = WriteFile(safeHandle, output, output.Length, out bytesWritten, IntPtr.Zero);                                     \n   }\n\n   protected new virtual void Dispose(bool disposing)\n   {\n      if (disposed) return;\n\n      // Release any managed resources here.\n      if (disposing)\n         safeHandle.Dispose();\n\n      disposed = true;\n\n      // Release any unmanaged resources not wrapped by safe handles here.\n\n      // Call the base class implementation.\n      base.Dispose(true);\n   }\n}\n</code></pre><pre class=\"loading\"><code class=\"lang-vb\">Imports Microsoft.Win32.SafeHandles\nImports System.IO\n\nPublic Class DisposableStreamResource2 : Inherits DisposableStreamResource\n   &#39; Define additional constants.\n   Protected Const GENERIC_WRITE As Integer = &amp;H40000000 \n   Protected Const OPEN_ALWAYS As Integer = 4\n\n   &#39; Define additional APIs.\n   Protected Declare Function WriteFile Lib &quot;kernel32.dll&quot; (\n                              safeHandle As SafeFileHandle, lpBuffer As String, \n                              nNumberOfBytesToWrite As Integer, ByRef lpNumberOfBytesWritten As Integer,\n                              lpOverlapped As Object) As Boolean\n\n   &#39; Define locals.\n   Private disposed As Boolean = False\n   Private filename As String\n   Private created As Boolean = False\n   Private safeHandle As SafeFileHandle\n\n   Public Sub New(filename As String)\n      MyBase.New(filename)\n      Me.filename = filename\n   End Sub\n\n   Public Sub WriteFileInfo() \n      If Not created Then\n         Dim hFile As IntPtr = CreateFile(&quot;.\\FileInfo.txt&quot;, GENERIC_WRITE, 0, \n                                          IntPtr.Zero, OPEN_ALWAYS, \n                                          FILE_ATTRIBUTE_NORMAL, IntPtr.Zero)\n         If hFile &lt;&gt; INVALID_HANDLE_VALUE Then\n            safeHandle = New SafeFileHandle(hFile, True)\n         Else\n            Throw New IOException(&quot;Unable to create output file.&quot;)\n         End If\n         created = True\n      End If\n      Dim output As String = String.Format(&quot;{0}: {1:N0} bytes {2}&quot;, filename, Size, \n                                           vbCrLf)\n      WriteFile(safeHandle, output, output.Length, 0&amp;, Nothing)                                     \n   End Sub\n\n   Protected Overloads Overridable Sub Dispose(disposing As Boolean)\n      If disposed Then Exit Sub\n\n      &#39; Release any managed resources here.\n      If disposing Then\n         safeHandle.Dispose()\n      End If\n\n      disposed = True\n      &#39; Release any unmanaged resources not wrapped by safe handles here.\n\n      &#39; Call the base class implementation.\n      MyBase.Dispose(True)\n   End Sub\nEnd Class\n</code></pre><h2 id=\"see-also\">See also</h2>\n<p><a class=\"xref\" href=\"../../../api/system.gc#System_GC_SuppressFinalize_System_Object_\" data-linktype=\"relative-path\">SuppressFinalize</a></p>\n<p><a class=\"xref\" href=\"../../../api/system.idisposable\" data-linktype=\"relative-path\">IDisposable</a></p>\n<p><a class=\"xref\" href=\"../../../api/system.idisposable#System_IDisposable_Dispose\" data-linktype=\"relative-path\">IDisposable.Dispose</a></p>\n<p><a class=\"xref\" href=\"../../../api/microsoft.win32.safehandles\" data-linktype=\"relative-path\">Microsoft.Win32.SafeHandles</a></p>\n<p><a class=\"xref\" href=\"../../../api/system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">System.Runtime.InteropServices.SafeHandle</a></p>\n<p><a class=\"xref\" href=\"../../../api/system.idisposable#System_IDisposable_Dispose\" data-linktype=\"relative-path\">IDisposable.Dispose</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"shoag\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"ms.devlang\" content=\"dotnet\">\r\n<meta name=\"ms.assetid\" content=\"eca6cdc3-6a14-4296-86fb-1eb2f21455b0\">\r\n<meta name=\"description\" content=\"Implementing a dispose method\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"08/16/2016\">\r\n<meta name=\"ms.technology\" content=\"dotnet-standard\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-04-01 05:46 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/400dfda51d978f35c3995f90840643aaff1b9c13/docs/standard/garbagecollection/implementing-dispose.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/standard/garbagecollection/implementing-dispose.md\">\r\n<meta name=\"document_id\" content=\"ad7a66af-327f-f0dc-074f-d24fbd5118fd\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"shoag","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","uhfHeaderId":"MSDocsHeader-DotNet","title":"Implementing a dispose method | Microsoft Docs","ms.devlang":"dotnet","ms.assetid":"eca6cdc3-6a14-4296-86fb-1eb2f21455b0","description":"Implementing a dispose method","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"08/16/2016","ms.technology":"dotnet-standard","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"tompratt-AQ","author_email":"v-thprat@microsoft.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"Update language identifiers and styleguide. (#1796)","commit_sha":"400dfda51d978f35c3995f90840643aaff1b9c13","commit_date":"2017-03-24 14:01:03 -0700"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Absolute urls and other fixes (#1281)","commit_sha":"f7dffe4885b331cec8d37f3cc5c9163f69c3b4c9","commit_date":"2016-11-22 12:57:26 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"fixed broken anchors (#1194)","commit_sha":"b20713600d7c3ddc31be5885733a1e8910ede8c6","commit_date":"2016-11-02 20:45:13 -0700"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Removing misleading note (#1122)","commit_sha":"4a42f12ca660eb3d233fa3db6ca34c998a8192e0","commit_date":"2016-10-06 09:52:06 -0700"},{"author_name":"Steve Hoag","author_email":"shoag@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"Fixed broken links (#1087)","commit_sha":"e365ecb3bdb70426970e7ecd1c89dcd04b45b40b","commit_date":"2016-10-05 14:03:53 -0400"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"fix broken uid links (#985)","commit_sha":"213ce098bcc2b5e31c55e759d895254d5ca33caa","commit_date":"2016-08-30 16:18:59 -0700"},{"author_name":"Steve Hoag","author_email":"shoag@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Porting from MSDN (#975)","commit_sha":"bb50b160a685d494ba47b3ca583f6fc35fa3ef3e","commit_date":"2016-08-29 12:51:05 -0700"},{"author_name":"Maira Wenzel","author_email":"mairaw@users.noreply.github.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Revert \"Bringing back essentials topics\" (#661)","commit_sha":"6d10e1507a2a8040743da29184fa4981ddbf7af3","commit_date":"2016-06-26 17:59:39 -0700"},{"author_name":"Steve Hoag","author_email":"shoag@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Bringing back essentials topics (#659)","commit_sha":"5f3ebe05f34a44b449412c6334e47a9861b36c79","commit_date":"2016-06-26 17:27:32 -0700"}],"updated_at":"2017-04-01 05:46 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"},{"profile_url":"https://github.com/tompratt-AQ","display_name":"tompratt-AQ","id":"26311438"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"4/1/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/400dfda51d978f35c3995f90840643aaff1b9c13/docs/standard/garbagecollection/implementing-dispose.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/standard/garbagecollection/implementing-dispose.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/standard/garbagecollection/implementing-dispose.md","document_id":"ad7a66af-327f-f0dc-074f-d24fbd5118fd","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/standard/garbagecollection/implementing-dispose","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Implementing a dispose method","_op_displayDate":"2016-8-16","_op_displayDate_source":"2016-08-16T00:00:00Z","_op_wordCount":2958,"_op_rawTitle":"<h1 id=\"implementing-a-dispose-method\" sourcefile=\"docs/standard/garbagecollection/implementing-dispose.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Implementing a dispose method</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/standard/garbagecollection/implementing-dispose","fileRelativePath":"articles/standard/garbagecollection/implementing-dispose.html"},"themesRelativePathToOutputRoot":"_themes/"}