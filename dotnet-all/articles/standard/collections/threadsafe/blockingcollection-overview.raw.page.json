{"content":"<div><div class=\"content\">\n<p><a href=\"https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1\" data-linktype=\"external\">BlockingCollection&lt;T&gt;</a> is a thread-safe collection class that provides the following features:</p>\n<ul>\n<li><p>An implementation of the Producer-Consumer pattern.</p>\n</li>\n<li><p>Thread-safe addition and removal of items from a collection.</p>\n</li>\n<li><p>Optional maximum capacity.</p>\n</li>\n<li><p>Insertion and removal operations that block when collection is empty or full.</p>\n</li>\n<li><p>Insertion and removal &quot;try&quot; operations that do not block or that block up to a specified period of time.</p>\n</li>\n<li><p>Encapsulates any collection type that implements <a href=\"https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1\" data-linktype=\"external\">IProducerConsumerCollection&lt;T&gt;</a>.</p>\n</li>\n<li><p>Cancellation with cancellation tokens.</p>\n</li>\n<li><p>Two kinds of enumeration with <code>foreach</code>: </p>\n<ol>\n<li><p>Read-only enumeration.</p>\n</li>\n<li><p>Enumeration that removes items as they are enumerated.</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"bounding-and-blocking-support\">Bounding and Blocking Support</h2>\n<p><a href=\"https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.BlockingCollection-1\" data-linktype=\"external\">BlockingCollection&lt;T&gt;</a> supports bounding and blocking. Bounding means you can set the maximum capacity of the collection. Bounding is important in certain scenarios because it enables you to control the maximum size of the collection in memory, and it prevents the producing threads from moving too far ahead of the consuming threads.</p>\n<p>Multiple threads or tasks can add items to the collection concurrently, and if the collection reaches its specified maximum capacity, the producing threads will block until an item is removed. Multiple consumers can remove items concurrently, and if the collection becomes empty, the consuming threads will block until a producer adds an item. A producing thread can call <code>CompleteAdding</code> to indicate that no more items will be added. Consumers monitor the <code>IsCompleted</code> property to know when the collection is empty and no more items will be added. The following example shows a simple <code>BlockingCollection</code> with a bounded capacity of 100. A producer task adds items to the collection as long as some external condition is true, and then calls <code>CompleteAdding</code>. The consumer task takes items until the <code>IsCompleted</code> property is true.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">// A bounded collection. It can hold no more \n// than 100 items at once.\nBlockingCollection&lt;Data&gt; dataItems = new BlockingCollection&lt;Data&gt;(100);\n\n\n// A simple blocking consumer with no cancellation.\nTask.Run(() =&gt; \n{\n    while (!dataItems.IsCompleted)\n    {\n\n        Data data = null;\n        // Blocks if number.Count == 0\n        // IOE means that Take() was called on a completed collection.\n        // Some other thread can call CompleteAdding after we pass the\n        // IsCompleted check but before we call Take. \n        // In this example, we can simply catch the exception since the \n        // loop will break on the next iteration.\n        try\n        {\n            data = dataItems.Take();\n        }\n        catch (InvalidOperationException) { }\n\n        if (data != null)\n        {\n            Process(data);\n        }\n    }\n    Console.WriteLine(&quot;\\r\\nNo more items to take.&quot;);\n});\n\n// A simple blocking producer with no cancellation.\nTask.Run(() =&gt;\n{\n    while (moreItemsToAdd)\n    {\n        Data data = GetData();\n        // Blocks if numbers.Count == dataItems.BoundedCapacity\n        dataItems.Add(data);\n    }\n    // Let consumer know we are done.\n    dataItems.CompleteAdding();\n});\n</code></pre><p>For a complete example, see <a href=\"how-to-add-and-take-items\" data-linktype=\"relative-path\">How to: Add and Take Items Individually from a BlockingCollection</a>.</p>\n<h2 id=\"timed-blocking-operations\">Timed Blocking Operations</h2>\n<p>In timed blocking <code>TryAdd</code> and <code>TryTake</code> operations on bounded collections, the method tries to add or take an item. If an item is available it is placed into the variable that was passed in by reference, and the method returns <code>true</code>. If no item is retrieved after a specified time-out period the method returns <code>false</code>. The thread is then free to do some other useful work before trying again to access the collection. For an example of timed blocking access, see the second example in <a href=\"how-to-add-and-take-items\" data-linktype=\"relative-path\">How to: Add and Take Items Individually from a BlockingCollection</a>.</p>\n<h2 id=\"cancelling-add-and-take-operations\">Cancelling Add and Take Operations</h2>\n<p>Add and Take operations are typically performed in a loop. You can cancel a loop by passing in a <code>CancellationToken</code> to the <code>TryAdd</code> or <code>TryTake</code> method, and then checking the value of the token&#39;s <code>IsCancellationRequested</code> property on each iteration. If the value is <code>true</code>, then it is up to you to respond the cancellation request by cleaning up any resources and exiting the loop. The following example shows an overload of <code>TryAdd</code> that takes a cancellation token, and the code that uses it:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">BlockingCollection&lt;string&gt; bc = new BlockingCollection&lt;string&gt;(new ConcurrentBag&lt;string&gt;(), 1000 );\n</code></pre><h2 id=\"specifying-the-collection-type\">Specifying the Collection Type</h2>\n<p>When you create a <code>BlockingCollection&lt;T&gt;;</code>, you can specify not only the bounded capacity but also the type of collection to use. For example, you could specify a <a href=\"https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentQueue-1\" data-linktype=\"external\">ConcurrentQueue&lt;T&gt;</a> for first in-first out (FIFO) behavior, or a <a href=\"https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentStack-1\" data-linktype=\"external\">ConcurrentStack&lt;T&gt;</a> for last in-first out (LIFO) behavior. You can use any collection class that implements the <a href=\"https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.IProducerConsumerCollection-1\" data-linktype=\"external\">IProducerConsumerCollection&lt;T&gt;</a> interface. The default collection type for <code>BlockingCollection&lt;T&gt;</code> is <code>ConcurrentQueue&lt;T&gt;</code>. The following code example shows how to create a <code>BlockingCollection&lt;T&gt;</code> of strings that has a capacity of 1000 and uses a <a href=\"https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent.ConcurrentBag-1\" data-linktype=\"external\">ConcurrentBag&lt;T&gt;</a>:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">BlockingCollection&lt;string&gt; bc = new BlockingCollection&lt;string&gt;(new ConcurrentBag&lt;string&gt;(), 1000 );\n</code></pre><h2 id=\"ienumerable-support\">IEnumerable Support</h2>\n<p><code>BlockingCollection&lt;T&gt;</code> provides a <code>GetConsumingEnumerable</code> method that enables consumers to use a <code>foreach</code> statement to remove items until the collection is completed, which means it is empty and no more items will be added. For more information, see <a href=\"how-to-use-foreach-to-remove\" data-linktype=\"relative-path\">How to: Use ForEach to Remove Items in a BlockingCollection</a>.</p>\n<h2 id=\"using-many-blockingcollections-as-one\">Using Many BlockingCollections As One</h2>\n<p>For scenarios in which a consumer needs to take items from multiple collections simultaneously, you can create arrays of <code>BlockingCollection&lt;T&gt;</code> and use the static methods such as <code>TakeFromAny</code> and <code>AddToAny</code> that will add to or take from any of the collections in the array. If one collection is blocking, the method immediately tries another until it finds one that can perform the operation. For more information, see <a href=\"how-to-use-arrays-of-blockingcollections\" data-linktype=\"relative-path\">How to: Use Arrays of Blocking Collections in a Pipeline</a>.</p>\n<h2 id=\"see-also\">See Also</h2>\n<p><a href=\"https://docs.microsoft.com/dotnet/core/api/System.Collections.Concurrent\" data-linktype=\"external\">System.Collections.Concurrent</a></p>\n<p><a href=\"../index\" data-linktype=\"relative-path\">Collections and Data Structures</a></p>\n<p><a href=\"index\" data-linktype=\"relative-path\">Thread-Safe Collections</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"mairaw\">\r\n<meta name=\"ms.author\" content=\"mairaw\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"dotnet\">\r\n<meta name=\"ms.assetid\" content=\"a1a867de-53c2-49ca-9a1a-e5770a942724\">\r\n<meta name=\"description\" content=\"BlockingCollection Overview\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"06/20/2016\">\r\n<meta name=\"ms.technology\" content=\"dotnet-standard\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/standard/collections/threadsafe/blockingcollection-overview.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/standard/collections/threadsafe/blockingcollection-overview.md\">\r\n<meta name=\"document_id\" content=\"c7422df4-0d67-d996-2a17-b2ea890d5f1f\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../../toc2.json\">\r\n","rawMetadata":{"author":"mairaw","ms.author":"mairaw","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"BlockingCollection Overview | Microsoft Docs","ms.devlang":"dotnet","ms.assetid":"a1a867de-53c2-49ca-9a1a-e5770a942724","description":"BlockingCollection Overview","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"06/20/2016","ms.technology":"dotnet-standard","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@users.noreply.github.com","committer_name":"Rich Lander","comitter_email":"rlander@microsoft.com","message":"fixed generic links (#658)","commit_sha":"e07788926a995b41571be276379ad9285747951d","commit_date":"2016-06-26 16:20:19 -0700"},{"author_name":"Tom Dykstra","author_email":"tdykstra@microsoft.com","committer_name":"Rich Lander","comitter_email":"rlander@microsoft.com","message":"make index.md for collections and threadsafe folders (#635)","commit_sha":"2229d5a150d7d262b2ea42d0b15d7be0e152de47","commit_date":"2016-06-25 13:37:11 -0700"},{"author_name":"Tom Dykstra","author_email":"tdykstra@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"move files for standard section of toc (#615)","commit_sha":"9cf6022fc910bc5418c03c0fa81d9432d85be3b0","commit_date":"2016-06-24 14:14:05 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},"contributors":[{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel"},{"profile_url":"https://github.com/tdykstra","display_name":"Tom Dykstra","id":"1569635"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/standard/collections/threadsafe/blockingcollection-overview.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/standard/collections/threadsafe/blockingcollection-overview.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/standard/collections/threadsafe/blockingcollection-overview.md","document_id":"c7422df4-0d67-d996-2a17-b2ea890d5f1f","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/standard/collections/threadsafe/blockingcollection-overview","toc_asset_id":"articles/toc.json","toc_rel":"../../../toc.json","_op_ogTitle":"BlockingCollection Overview","_op_displayDate":"2016-6-20","_op_displayDate_source":"2016-06-20T00:00:00Z","_op_wordCount":869,"_op_rawTitle":"<h1 id=\"blockingcollection-overview\" sourcefile=\"docs/standard/collections/threadsafe/blockingcollection-overview.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">BlockingCollection Overview</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/standard/collections/threadsafe/blockingcollection-overview","fileRelativePath":"articles/standard/collections/threadsafe/blockingcollection-overview.html"},"themesRelativePathToOutputRoot":"_themes/"}