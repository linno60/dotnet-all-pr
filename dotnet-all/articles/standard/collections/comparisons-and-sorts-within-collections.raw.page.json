{"content":"<div><div class=\"content\">\n<p>The <a href=\"https://docs.microsoft.com/dotnet/core/api/System.Collections\" data-linktype=\"external\">System.Collections</a> classes perform comparisons in almost all the processes involved in managing collections, whether searching for the element to remove or returning the value of a key-and-value pair.</p>\n<p>Collections typically utilize an equality comparer and/or an ordering comparer. Two constructs are used for comparisons. </p>\n<h2 id=\"checking-for-equality\">Checking for equality</h2>\n<p>Methods such as <code>Contains</code>, <code>IndexOf</code>, <code>LastIndexOf</code>, and <code>Remove</code> use an equality comparer for the collection elements. If the collection is generic, items are compared for equality according to the following guidelines:</p>\n<ul>\n<li><p>If type T implements the <a href=\"https://docs.microsoft.com/dotnet/core/api/System.IEquatable-1\" data-linktype=\"external\">IEquatable&lt;T&gt;</a> generic interface, then the equality comparer is the <code>Equals</code> method of that interface.</p>\n</li>\n<li><p>If type T does not implement <code>IEquatable&lt;T&gt;</code>, <code>Object.Equals</code> is used.</p>\n</li>\n</ul>\n<p>In addition, some constructor overloads for dictionary collections accept an <a href=\"https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.IEqualityComparer-1\" data-linktype=\"external\">IEqualityComparer&lt;T&gt;</a> implementation, which is used to compare keys for equality.</p>\n<h2 id=\"determining-sort-order\">Determining sort order</h2>\n<p>Methods such as <code>BinarySearch</code> and <code>Sort</code> use an ordering comparer for the collection elements. The comparisons can be between elements of the collection, or between an element and a specified value. For comparing objects, there is the concept of a default comparer and an explicit comparer. </p>\n<p>The default comparer relies on at least one of the objects being compared to implement the <code>IComparable</code> interface. It is a good practice to implement <code>IComparable</code> on all classes are used as values in a list collection or as keys in a dictionary collection. For a generic collection, equality comparison is determined according to the following:</p>\n<ul>\n<li><p>If type T implements the <a href=\"https://docs.microsoft.com/dotnet/core/api/System.IComparable-1\" data-linktype=\"external\">System.IComparable&lt;T&gt;</a> generic interface, then the default comparer is the <code>CompareTo(T)</code> method of that interface.</p>\n</li>\n<li><p>If type T implements the non-generic <a href=\"https://docs.microsoft.com/dotnet/core/api/System.IComparable\" data-linktype=\"external\">System.IComparable</a> interface, then the default comparer is the <code>CompareTo</code>(Object) method of that interface.</p>\n</li>\n<li><p>If type T doesnâ€™t implement either interface, then there is no default comparer, and a comparer or comparison delegate must be provided explicitly.</p>\n</li>\n</ul>\n<p>To provide explicit comparisons, some methods accept an <code>IComparer</code> implementation as a parameter. For example, the <code>List&lt;T&gt;.Sort</code> method accepts an <a href=\"https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.IComparer-1\" data-linktype=\"external\">System.Collections.Generic.IComparer&lt;T&gt;</a> implementation. </p>\n<h2 id=\"equality-and-sort-example\">Equality and sort example</h2>\n<p>The following code demonstrates an implementation of <a href=\"https://docs.microsoft.com/dotnet/core/api/System.IEquatable-1\" data-linktype=\"external\">IEquatable&lt;T&gt;</a> and <a href=\"https://docs.microsoft.com/dotnet/core/api/System.IComparable-1\" data-linktype=\"external\">IComparable&lt;T&gt;</a> on a simple business object. In addition, when the object is stored in a list and sorted, you will see that calling the <code>Sort()</code> method results in the use of the default comparer for the &#39;Part&#39; type, and the <code>Sort(Comparison&lt;T&gt;)</code> method implemented by using an anonymous method.</p>\n<p>C#</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using System;\nusing System.Collections.Generic;\n// Simple business object. A PartId is used to identify the type of part \n// but the part name can change. \npublic class Part : IEquatable&lt;Part&gt; , IComparable&lt;Part&gt;\n{\n    public string PartName { get; set; }\n\n    public int PartId { get; set; }\n\n    public override string ToString()\n    {\n        return &quot;ID: &quot; + PartId + &quot;   Name: &quot; + PartName;\n    }\n    public override bool Equals(object obj)\n    {\n        if (obj == null) return false;\n        Part objAsPart = obj as Part;\n        if (objAsPart == null) return false;\n        else return Equals(objAsPart);\n    }\n    public int SortByNameAscending(string name1, string name2)\n    {\n\n        return name1.CompareTo(name2);\n    }\n\n    // Default comparer for Part type.\n    public int CompareTo(Part comparePart)\n    {\n          // A null value means that this object is greater.\n        if (comparePart == null)\n            return 1;\n\n        else\n            return this.PartId.CompareTo(comparePart.PartId);\n    }\n    public override int GetHashCode()\n    {\n        return PartId;\n    }\n    public bool Equals(Part other)\n    {\n        if (other == null) return false;\n        return (this.PartId.Equals(other.PartId));\n    }\n    // Should also override == and != operators.\n\n}\npublic class Example\n{\n    public static void Main()\n    {\n        // Create a list of parts.\n        List&lt;Part&gt; parts = new List&lt;Part&gt;();\n\n        // Add parts to the list.\n        parts.Add(new Part() { PartName = &quot;regular seat&quot;, PartId = 1434 });\n        parts.Add(new Part() { PartName= &quot;crank arm&quot;, PartId = 1234 });\n        parts.Add(new Part() { PartName = &quot;shift lever&quot;, PartId = 1634 }); ;\n        // Name intentionally left null.\n        parts.Add(new Part() {  PartId = 1334 });\n        parts.Add(new Part() { PartName = &quot;banana seat&quot;, PartId = 1444 });\n        parts.Add(new Part() { PartName = &quot;cassette&quot;, PartId = 1534 });\n\n\n        // Write out the parts in the list. This will call the overridden \n        // ToString method in the Part class.\n        Console.WriteLine(&quot;\\nBefore sort:&quot;);\n        foreach (Part aPart in parts)\n        {\n            Console.WriteLine(aPart);\n        }\n\n\n        // Call Sort on the list. This will use the \n        // default comparer, which is the Compare method \n        // implemented on Part.\n        parts.Sort();\n\n\n        Console.WriteLine(&quot;\\nAfter sort by part number:&quot;);\n        foreach (Part aPart in parts)\n        {\n            Console.WriteLine(aPart);\n        }\n\n        // This shows calling the Sort(Comparison(T) overload using \n        // an anonymous method for the Comparison delegate. \n        // This method treats null as the lesser of two values.\n        parts.Sort(delegate(Part x, Part y)\n        {\n            if (x.PartName == null &amp;&amp; y.PartName == null) return 0;\n            else if (x.PartName == null) return -1;\n            else if (y.PartName == null) return 1;\n            else return x.PartName.CompareTo(y.PartName);\n        });\n\n        Console.WriteLine(&quot;\\nAfter sort by name:&quot;);\n        foreach (Part aPart in parts)\n        {\n            Console.WriteLine(aPart);\n        }\n\n        /*\n\n            Before sort:\n        ID: 1434   Name: regular seat\n        ID: 1234   Name: crank arm\n        ID: 1634   Name: shift lever\n        ID: 1334   Name:\n        ID: 1444   Name: banana seat\n        ID: 1534   Name: cassette\n\n        After sort by part number:\n        ID: 1234   Name: crank arm\n        ID: 1334   Name:\n        ID: 1434   Name: regular seat\n        ID: 1444   Name: banana seat\n        ID: 1534   Name: cassette\n        ID: 1634   Name: shift lever\n\n        After sort by name:\n        ID: 1334   Name:\n        ID: 1444   Name: banana seat\n        ID: 1534   Name: cassette\n        ID: 1234   Name: crank arm\n        ID: 1434   Name: regular seat\n        ID: 1634   Name: shift lever\n\n         */\n\n    }\n}\n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p><a href=\"https://docs.microsoft.com/dotnet/core/api/System.Collections.IComparer\" data-linktype=\"external\">IComparer</a></p>\n<p><a href=\"https://docs.microsoft.com/dotnet/core/api/System.IEquatable-1\" data-linktype=\"external\">IEquatable&lt;T&gt;</a></p>\n<p><a href=\"https://docs.microsoft.com/dotnet/core/api/System.Collections.Generic.IComparer-1\" data-linktype=\"external\">IComparer&lt;T&gt;</a></p>\n<p><a href=\"https://docs.microsoft.com/dotnet/core/api/System.IComparable\" data-linktype=\"external\">IComparable</a></p>\n<p><a href=\"https://docs.microsoft.com/dotnet/core/api/System.IComparable-1\" data-linktype=\"external\">IComparable&lt;T&gt;</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"mairaw\">\r\n<meta name=\"ms.author\" content=\"mairaw\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"dotnet\">\r\n<meta name=\"ms.assetid\" content=\"c7b7c005-628d-427a-91ad-af0c3958c00e\">\r\n<meta name=\"description\" content=\"Comparisons and Sorts Within Collections\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"06/20/2016\">\r\n<meta name=\"ms.technology\" content=\"dotnet-standard\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/standard/collections/comparisons-and-sorts-within-collections.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/standard/collections/comparisons-and-sorts-within-collections.md\">\r\n<meta name=\"document_id\" content=\"2eee2dcb-7e96-d700-2b5a-c37446b2a2f1\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"mairaw","ms.author":"mairaw","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Comparisons and Sorts Within Collections | Microsoft Docs","ms.devlang":"dotnet","ms.assetid":"c7b7c005-628d-427a-91ad-af0c3958c00e","description":"Comparisons and Sorts Within Collections","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"06/20/2016","ms.technology":"dotnet-standard","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@users.noreply.github.com","committer_name":"Rich Lander","comitter_email":"rlander@microsoft.com","message":"fixed generic links (#658)","commit_sha":"e07788926a995b41571be276379ad9285747951d","commit_date":"2016-06-26 16:20:19 -0700"},{"author_name":"Tom Dykstra","author_email":"tdykstra@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"move files for standard section of toc (#615)","commit_sha":"9cf6022fc910bc5418c03c0fa81d9432d85be3b0","commit_date":"2016-06-24 14:14:05 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},"contributors":[{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel"},{"profile_url":"https://github.com/tdykstra","display_name":"Tom Dykstra","id":"1569635"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/standard/collections/comparisons-and-sorts-within-collections.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/standard/collections/comparisons-and-sorts-within-collections.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/standard/collections/comparisons-and-sorts-within-collections.md","document_id":"2eee2dcb-7e96-d700-2b5a-c37446b2a2f1","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/standard/collections/comparisons-and-sorts-within-collections","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Comparisons and Sorts Within Collections","_op_displayDate":"2016-6-20","_op_displayDate_source":"2016-06-20T00:00:00Z","_op_wordCount":873,"_op_rawTitle":"<h1 id=\"comparisons-and-sorts-within-collections\" sourcefile=\"docs/standard/collections/comparisons-and-sorts-within-collections.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Comparisons and Sorts Within Collections</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/standard/collections/comparisons-and-sorts-within-collections","fileRelativePath":"articles/standard/collections/comparisons-and-sorts-within-collections.html"},"themesRelativePathToOutputRoot":"_themes/"}