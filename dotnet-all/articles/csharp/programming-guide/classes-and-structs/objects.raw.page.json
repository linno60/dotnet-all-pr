{"content":"<div><div class=\"content\">\n<p>A class or struct definition is like a blueprint that specifies what the type can do. An object is basically a block of memory that has been allocated and configured according to the blueprint. A program may create many objects of the same class. Objects are also called instances, and they can be stored in either a named variable or in an array or collection. Client code is the code that uses these variables to call the methods and access the public properties of the object. In an object-oriented language such as C#, a typical program consists of multiple objects interacting dynamically.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Static types behave differently than what is described here. For more information, see <a href=\"static-classes-and-static-class-members\" data-linktype=\"relative-path\">Static Classes and Static Class Members</a>.  </p>\n</div>\n<h2 id=\"struct-instances-vs-class-instances\">Struct Instances vs. Class Instances</h2>\n<p> Because classes are reference types, a variable of a class object holds a reference to the address of the object on the managed heap. If a second object of the same type is assigned to the first object, then both variables refer to the object at that address. This point is discussed in more detail later in this topic.  </p>\n<p> Instances of classes are created by using the <a href=\"../../language-reference/keywords/new-operator\" data-linktype=\"relative-path\">new operator</a>. In the following example, <code>Person</code> is the type and <code>person1</code> and <code>person 2</code> are instances, or objects, of that type.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideStatements#30\">        public class Person\n        {\n            public string Name { get; set; }\n            public int Age { get; set; }\n            public Person(string name, int age)\n            {\n                Name = name;\n                Age = age;\n            }\n            //Other properties, methods, events...\n        }\n\n        class Program\n        {\n            static void Main()\n            {\n                Person person1 = new Person(&quot;Leopold&quot;, 6);\n                Console.WriteLine(&quot;person1 Name = {0} Age = {1}&quot;, person1.Name, person1.Age);\n\n                // Declare  new person, assign person1 to it.\n                Person person2 = person1;\n\n                //Change the name of person2, and person1 also changes.\n                person2.Name = &quot;Molly&quot;;\n                person2.Age = 16;\n\n                Console.WriteLine(&quot;person2 Name = {0} Age = {1}&quot;, person2.Name, person2.Age);\n                Console.WriteLine(&quot;person1 Name = {0} Age = {1}&quot;, person1.Name, person1.Age);\n\n                // Keep the console open in debug mode.\n                Console.WriteLine(&quot;Press any key to exit.&quot;);\n                Console.ReadKey();\n\n            }\n        }\n        /*\n            Output:\n            person1 Name = Leopold Age = 6\n            person2 Name = Molly Age = 16\n            person1 Name = Molly Age = 16\n        */\n</code></pre><p> Because structs are value types, a variable of a struct object holds a copy of the entire object. Instances of structs can also be created by using the <code>new</code> operator, but this is not required, as shown in the following example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideStatements#31\">        public struct Person\n        {\n            public string Name;\n            public int Age;\n            public Person(string name, int age)\n            {\n                Name = name;\n                Age = age;\n            }\n        }\n\n        public class Application\n        {\n            static void Main()\n            {\n                // Create  struct instance and initialize by using &quot;new&quot;.\n                // Memory is allocated on thread stack.\n                Person p1 = new Person(&quot;Alex&quot;, 9);\n                Console.WriteLine(&quot;p1 Name = {0} Age = {1}&quot;, p1.Name, p1.Age);\n\n                // Create  new struct object. Note that  struct can be initialized\n                // without using &quot;new&quot;.\n                Person p2 = p1;\n\n                // Assign values to p2 members.\n                p2.Name = &quot;Spencer&quot;;\n                p2.Age = 7;\n                Console.WriteLine(&quot;p2 Name = {0} Age = {1}&quot;, p2.Name, p2.Age);\n\n                // p1 values remain unchanged because p2 is  copy.\n                Console.WriteLine(&quot;p1 Name = {0} Age = {1}&quot;, p1.Name, p1.Age);\n\n                // Keep the console open in debug mode.\n                Console.WriteLine(&quot;Press any key to exit.&quot;);\n                Console.ReadKey();\n            }\n        }\n        /*\n          Output:\n            p1 Name = Alex Age = 9\n            p2 Name = Spencer Age = 7\n            p1 Name = Alex Age = 9\n        */\n</code></pre><p> The memory for both <code>p1</code> and <code>p2</code> is allocated on the thread stack. That memory is reclaimed along with the type or method in which it is declared. This is one reason why structs are copied on assignment. By contrast, the memory that is allocated for a class instance is automatically reclaimed (garbage collected) by the common language runtime when all references to the object have gone out of scope. It is not possible to deterministically destroy a class object like you can in C++. For more information about garbage collection in the .NET Framework, see <a href=\"../../../standard/garbagecollection/index\" data-linktype=\"relative-path\">Garbage Collection</a>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The allocation and deallocation of memory on the managed heap is highly optimized in the common language runtime. In most cases there is no significant difference in the performance cost of allocating a class instance on the heap versus allocating a struct instance on the stack.  </p>\n</div>\n<h2 id=\"object-identity-vs-value-equality\">Object Identity vs. Value Equality</h2>\n<p> When you compare two objects for equality, you must first distinguish whether you want to know whether the two variables represent the same object in memory, or whether the values of one or more of their fields are equivalent. If you are intending to compare values, you must consider whether the objects are instances of value types (structs) or reference types (classes, delegates, arrays).  </p>\n<ul>\n<li><p>To determine whether two class instances refer to the same location in memory (which means that they have the same <em>identity</em>), use the static <a class=\"xref\" href=\"../../../../api/system.object#System_Object_Equals_\" data-linktype=\"relative-path\">Equals</a> method. (<a class=\"xref\" href=\"../../../../api/system.object\" data-linktype=\"relative-path\">System.Object</a> is the implicit base class for all value types and reference types, including user-defined structs and classes.)  </p>\n</li>\n<li><p>To determine whether the instance fields in two struct instances have the same values, use the <a class=\"xref\" href=\"../../../../api/system.valuetype#System_ValueType_Equals_\" data-linktype=\"relative-path\">Equals</a> method. Because all structs implicitly inherit from <a class=\"xref\" href=\"../../../../api/system.valuetype\" data-linktype=\"relative-path\">System.ValueType</a>, you call the method directly on your object as shown in the following example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideStatements#32\">            // Person is defined in the previous example.\n\n            //public struct Person\n            //{\n            //    public string Name;\n            //    public int Age;\n            //    public Person(string name, int age)\n            //    {\n            //        Name = name;\n            //        Age = age;\n            //    }\n            //}\n\n            Person p1 = new Person(&quot;Wallace&quot;, 75);\n            Person p2;\n            p2.Name = &quot;Wallace&quot;;\n            p2.Age = 75;\n\n            if (p2.Equals(p1))\n                Console.WriteLine(&quot;p2 and p1 have the same values.&quot;);\n\n            // Output: p2 and p1 have the same values.\n</code></pre><p>The <a class=\"xref\" href=\"../../../../api/system.valuetype\" data-linktype=\"relative-path\">System.ValueType</a> implementation of <code>Equals</code> uses reflection because it must be able to determine what the fields are in any struct. When creating your own structs, override the <code>Equals</code> method to provide an efficient equality algorithm that is specific to your type.  </p>\n</li>\n<li><p>To determine whether the values of the fields in two class instances are equal, you might be able to use the <a class=\"xref\" href=\"../../../../api/system.object#System_Object_Equals_\" data-linktype=\"relative-path\">Equals</a> method or the <a href=\"../../language-reference/operators/equality-comparison-operator\" data-linktype=\"relative-path\">== operator</a>. However, only use them if the class has overridden or overloaded them to provide a custom definition of what &quot;equality&quot; means for objects of that type. The class might also implement the <a class=\"xref\" href=\"../../../../api/system.iequatable-1\" data-linktype=\"relative-path\">IEquatable&lt;T&gt;</a> interface or the <a class=\"xref\" href=\"../../../../api/system.collections.generic.iequalitycomparer-1\" data-linktype=\"relative-path\">IEqualityComparer&lt;T&gt;</a> interface. Both interfaces provide methods that can be used to test value equality. When designing your own classes that override <code>Equals</code>, make sure to follow the guidelines stated in <a href=\"../statements-expressions-operators/how-to-define-value-equality-for-a-type\" data-linktype=\"relative-path\">How to: Define Value Equality for a Type</a> and <a class=\"xref\" href=\"../../../../api/system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">System.Object.Equals(Object)</a>.  </p>\n</li>\n</ul>\n<h2 id=\"related-sections\">Related Sections</h2>\n<p> For more information:  </p>\n<ul>\n<li><p><a href=\"classes\" data-linktype=\"relative-path\">Classes</a>  </p>\n</li>\n<li><p><a href=\"structs\" data-linktype=\"relative-path\">Structs</a>  </p>\n</li>\n<li><p><a href=\"constructors\" data-linktype=\"relative-path\">Constructors</a>  </p>\n</li>\n<li><p><a href=\"destructors\" data-linktype=\"relative-path\">Destructors</a>  </p>\n</li>\n<li><p><a href=\"../events/index\" data-linktype=\"relative-path\">Events</a>  </p>\n</li>\n</ul>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../index\" data-linktype=\"relative-path\">C# Programming Guide</a><br> <a href=\"../../language-reference/keywords/object\" data-linktype=\"relative-path\">object</a><br> <a href=\"inheritance\" data-linktype=\"relative-path\">Inheritance</a><br> <a href=\"../../language-reference/keywords/class\" data-linktype=\"relative-path\">class</a><br> <a href=\"../../language-reference/keywords/struct\" data-linktype=\"relative-path\">struct</a><br> <a href=\"../../language-reference/keywords/new-operator\" data-linktype=\"relative-path\">new Operator</a><br> <a href=\"http://msdn.microsoft.com/library/53c57c96-83e1-4ee3-9543-9ac832671a89\" data-linktype=\"external\">Common Type System</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc.json\">\r\n<meta name=\"ms.assetid\" content=\"af4a5230-fbf3-4eea-95e1-8b883c2f845c\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"26\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-21 01:42 AM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/classes-and-structs/objects.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/csharp/programming-guide/classes-and-structs/objects.md\">\r\n<meta name=\"document_id\" content=\"fa338e2c-f30f-33ae-b404-c8e34b754211\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Objects (C# Programming Guide) | Microsoft Docs","ms.assetid":"af4a5230-fbf3-4eea-95e1-8b883c2f845c","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":26,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["objects [C#], about objects","variables [C#]"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2017-03-21 01:42 AM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"3/21/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/classes-and-structs/objects.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/csharp/programming-guide/classes-and-structs/objects.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/classes-and-structs/objects.md","document_id":"fa338e2c-f30f-33ae-b404-c8e34b754211","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/programming-guide/classes-and-structs/objects","toc_asset_id":"articles/csharp/programming-guide/classes-and-structs/toc.json","toc_rel":"toc.json","_op_ogTitle":"Objects (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":1089,"_op_rawTitle":"<h1 id=\"objects-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/classes-and-structs/objects.md\" sourcestartlinenumber=\"37\" sourceendlinenumber=\"37\">Objects (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/programming-guide/classes-and-structs/objects","fileRelativePath":"articles/csharp/programming-guide/classes-and-structs/objects.html"},"themesRelativePathToOutputRoot":"_themes/"}