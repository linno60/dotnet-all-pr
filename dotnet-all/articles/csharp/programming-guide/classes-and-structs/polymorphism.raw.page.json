{"content":"<div><div class=\"content\">\n<p>Polymorphism is often referred to as the third pillar of object-oriented programming, after encapsulation and inheritance. Polymorphism is a Greek word that means &quot;many-shaped&quot; and it has two distinct aspects:  </p>\n<ul>\n<li><p>At run time, objects of a derived class may be treated as objects of a base class in places such as method parameters and collections or arrays. When this occurs, the object&#39;s declared type is no longer identical to its run-time type.  </p>\n</li>\n<li><p>Base classes may define and implement <a href=\"../../language-reference/keywords/virtual\" data-linktype=\"relative-path\">virtual</a><em>methods</em>, and derived classes can <a href=\"../../language-reference/keywords/override\" data-linktype=\"relative-path\">override</a> them, which means they provide their own definition and implementation. At run-time, when client code calls the method, the CLR looks up the run-time type of the object, and invokes that override of the virtual method. Thus in your source code you can call a method on a base class, and cause a derived class&#39;s version of the method to be executed.  </p>\n<p>Virtual methods enable you to work with groups of related objects in a uniform way. For example, suppose you have a drawing application that enables a user to create various kinds of shapes on a drawing surface. You do not know at compile time which specific types of shapes the user will create. However, the application has to keep track of all the various types of shapes that are created, and it has to update them in response to user mouse actions. You can use polymorphism to solve this problem in two basic steps:  </p>\n</li>\n</ul>\n<ol>\n<li><p>Create a class hierarchy in which each specific shape class derives from a common base class.  </p>\n</li>\n<li><p>Use a virtual method to invoke the appropriate method on any derived class through a single call to the base class method.  </p>\n<p>First, create a base class called <code>Shape</code>, and derived classes such as <code>Rectangle</code>, <code>Circle</code>, and <code>Triangle</code>. Give the <code>Shape</code> class a virtual method called <code>Draw</code>, and override it in each derived class to draw the particular shape that the class represents. Create a <code>List&lt;Shape&gt;</code> object and add a Circle, Triangle and Rectangle to it. To update the drawing surface, use a <a href=\"../../language-reference/keywords/foreach-in\" data-linktype=\"relative-path\">foreach</a> loop to iterate through the list and call the <code>Draw</code> method on each <code>Shape</code> object in the list. Even though each object in the list has a declared type of <code>Shape</code>, it is the run-time type (the overridden version of the method in each derived class) that will be invoked.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideInheritance#50\">    public class Shape\n    {\n        // A few example members\n        public int X { get; private set; }\n        public int Y { get; private set; }\n        public int Height { get; set; }\n        public int Width { get; set; }\n       \n        // Virtual method\n        public virtual void Draw()\n        {\n            Console.WriteLine(&quot;Performing base class drawing tasks&quot;);\n        }\n    }\n\n    class Circle : Shape\n    {\n        public override void Draw()\n        {\n            // Code to draw a circle...\n            Console.WriteLine(&quot;Drawing a circle&quot;);\n            base.Draw();\n        }\n    }\n    class Rectangle : Shape\n    {\n        public override void Draw()\n        {\n            // Code to draw a rectangle...\n            Console.WriteLine(&quot;Drawing a rectangle&quot;);\n            base.Draw();\n        }\n    }\n    class Triangle : Shape\n    {\n        public override void Draw()\n        {\n            // Code to draw a triangle...\n            Console.WriteLine(&quot;Drawing a triangle&quot;);\n            base.Draw();\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // Polymorphism at work #1: a Rectangle, Triangle and Circle\n            // can all be used whereever a Shape is expected. No cast is\n            // required because an implicit conversion exists from a derived \n            // class to its base class.\n            System.Collections.Generic.List&lt;Shape&gt; shapes = new System.Collections.Generic.List&lt;Shape&gt;();\n            shapes.Add(new Rectangle());\n            shapes.Add(new Triangle());\n            shapes.Add(new Circle());\n\n            // Polymorphism at work #2: the virtual method Draw is\n            // invoked on each of the derived classes, not the base class.\n            foreach (Shape s in shapes)\n            {\n                s.Draw();\n            }\n\n            // Keep the console open in debug mode.\n            Console.WriteLine(&quot;Press any key to exit.&quot;);\n            Console.ReadKey();\n        }\n\n    }\n\n    /* Output:\n        Drawing a rectangle\n        Performing base class drawing tasks\n        Drawing a triangle\n        Performing base class drawing tasks\n        Drawing a circle\n        Performing base class drawing tasks\n     */\n</code></pre><p>In C#, every type is polymorphic because all types, including user-defined types, inherit from <a class=\"xref\" href=\"../../../../api/system.object\" data-linktype=\"relative-path\">Object</a>.  </p>\n</li>\n</ol>\n<h2 id=\"polymorphism-overview\">Polymorphism Overview</h2>\n<h3 id=\"virtual-members\">Virtual Members</h3>\n<p> When a derived class inherits from a base class, it gains all the methods, fields, properties and events of the base class. The designer of the derived class can choose whether to  </p>\n<ul>\n<li><p>override virtual members in the base class,  </p>\n</li>\n<li><p>inherit the closest base class method without overriding it  </p>\n</li>\n<li><p>define new non-virtual implementation of those members that hide the base class implementations  </p>\n<p>A derived class can override a base class member only if the base class member is declared as <a href=\"../../language-reference/keywords/virtual\" data-linktype=\"relative-path\">virtual</a> or <a href=\"../../language-reference/keywords/abstract\" data-linktype=\"relative-path\">abstract</a>. The derived member must use the <a href=\"../../language-reference/keywords/override\" data-linktype=\"relative-path\">override</a> keyword to explicitly indicate that the method is intended to participate in virtual invocation. The following code provides an example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideInheritance#20\">    public class BaseClass\n    {\n        public virtual void DoWork() { }\n        public virtual int WorkProperty\n        {\n            get { return 0; }\n        }\n    }\n    public class DerivedClass : BaseClass\n    {\n        public override void DoWork() { }\n        public override int WorkProperty\n        {\n            get { return 0; }\n        }\n    }\n</code></pre><p>Fields cannot be virtual; only methods, properties, events and indexers can be virtual. When a derived class overrides a virtual member, that member is called even when an instance of that class is being accessed as an instance of the base class. The following code provides an example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideInheritance#21\">        DerivedClass B = new DerivedClass();\n        B.DoWork();  // Calls the new method.\n\n        BaseClass A = (BaseClass)B;\n        A.DoWork();  // Also calls the new method.\n</code></pre><p>Virtual methods and properties enable derived classes to extend a base class without needing to use the base class implementation of a method. For more information, see <a href=\"versioning-with-the-override-and-new-keywords\" data-linktype=\"relative-path\">Versioning with the Override and New Keywords</a>. An interface provides another way to define a method or set of methods whose implementation is left to derived classes. For more information, see <a href=\"../interfaces/index\" data-linktype=\"relative-path\">Interfaces</a>.  </p>\n</li>\n</ul>\n<h3 id=\"hiding-base-class-members-with-new-members\">Hiding Base Class Members with New Members</h3>\n<p> If you want your derived member to have the same name as a member in a base class, but you do not want it to participate in virtual invocation, you can use the <a href=\"../../language-reference/keywords/new\" data-linktype=\"relative-path\">new</a> keyword. The <code>new</code> keyword is put before the return type of a class member that is being replaced. The following code provides an example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideInheritance#18\">    public class BaseClass\n    {\n        public void DoWork() { WorkField++; }\n        public int WorkField;\n        public int WorkProperty\n        {\n            get { return 0; }\n        }\n    }\n\n    public class DerivedClass : BaseClass\n    {\n        public new void DoWork() { WorkField++; }\n        public new int WorkField;\n        public new int WorkProperty\n        {\n            get { return 0; }\n        }\n    }\n</code></pre><p> Hidden base class members can still be accessed from client code by casting the instance of the derived class to an instance of the base class. For example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideInheritance#19\">        DerivedClass B = new DerivedClass();\n        B.DoWork();  // Calls the new method.\n\n        BaseClass A = (BaseClass)B;\n        A.DoWork();  // Calls the old method.\n</code></pre><h3 id=\"preventing-derived-classes-from-overriding-virtual-members\">Preventing Derived Classes from Overriding Virtual Members</h3>\n<p> Virtual members remain virtual indefinitely, regardless of how many classes have been declared between the virtual member and the class that originally declared it. If class A declares a virtual member, and class B derives from A, and class C derives from B, class C inherits the virtual member, and has the option to override it, regardless of whether class B declared an override for that member. The following code provides an example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideInheritance#22\">    public class A\n    {\n        public virtual void DoWork() { }\n    }\n    public class B : A\n    {\n        public override void DoWork() { }\n    }\n</code></pre><p> A derived class can stop virtual inheritance by declaring an override as <a href=\"../../language-reference/keywords/sealed\" data-linktype=\"relative-path\">sealed</a>. This requires putting the <code>sealed</code> keyword before the <code>override</code> keyword in the class member declaration. The following code provides an example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideInheritance#24\">        public class C : B\n        {\n            public sealed override void DoWork() { }\n        }\n</code></pre><p> In the previous example, the method <code>DoWork</code> is no longer virtual to any class derived from C. It is still virtual for instances of C, even if they are cast to type B or type A. Sealed methods can be replaced by derived classes by using the <code>new</code> keyword, as the following example shows:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideInheritance#25\">    public class D : C\n    {\n        public new void DoWork() { }\n    }\n</code></pre><p> In this case, if <code>DoWork</code> is called on D using a variable of type D, the new <code>DoWork</code> is called. If a variable of type C, B, or A is used to access an instance of D, a call to <code>DoWork</code> will follow the rules of virtual inheritance, routing those calls to the implementation of <code>DoWork</code> on class C.  </p>\n<h3 id=\"accessing-base-class-virtual-members-from-derived-classes\">Accessing Base Class Virtual Members from Derived Classes</h3>\n<p> A derived class that has replaced or overridden a method or property can still access the method or property on the base class using the base keyword. The following code provides an example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideInheritance#26\">        public class Base\n        {\n            public virtual void DoWork() {/*...*/ }\n        }\n        public class Derived : Base\n        {\n            public override void DoWork()\n            {\n                //Perform Derived&#39;s work here\n                //...\n                // Call DoWork on base class\n                base.DoWork();\n            }\n        }\n</code></pre><p> For more information, see <a href=\"../../language-reference/keywords/base\" data-linktype=\"relative-path\">base</a>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> It is recommended that virtual members use <code>base</code> to call the base class implementation of that member in their own implementation. Letting the base class behavior occur enables the derived class to concentrate on implementing behavior specific to the derived class. If the base class implementation is not called, it is up to the derived class to make their behavior compatible with the behavior of the base class.  </p>\n</div>\n<h2 id=\"in-this-section\">In This Section</h2>\n<ul>\n<li><p><a href=\"versioning-with-the-override-and-new-keywords\" data-linktype=\"relative-path\">Versioning with the Override and New Keywords</a>  </p>\n</li>\n<li><p><a href=\"knowing-when-to-use-override-and-new-keywords\" data-linktype=\"relative-path\">Knowing When to Use Override and New Keywords</a>  </p>\n</li>\n<li><p><a href=\"how-to-override-the-tostring-method\" data-linktype=\"relative-path\">How to: Override the ToString Method</a>  </p>\n</li>\n</ul>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../index\" data-linktype=\"relative-path\">C# Programming Guide</a><br> <a href=\"../index\" data-linktype=\"relative-path\">C# Programming Guide</a><br> <a href=\"inheritance\" data-linktype=\"relative-path\">Inheritance</a><br> <a href=\"abstract-and-sealed-classes-and-class-members\" data-linktype=\"relative-path\">Abstract and Sealed Classes and Class Members</a><br> <a href=\"methods\" data-linktype=\"relative-path\">Methods</a><br> <a href=\"../events/index\" data-linktype=\"relative-path\">Events</a><br> <a href=\"properties\" data-linktype=\"relative-path\">Properties</a><br> <a href=\"../indexers/index\" data-linktype=\"relative-path\">Indexers</a><br> <a href=\"../types/index\" data-linktype=\"relative-path\">Types</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"toc2.json\">\r\n<meta name=\"ms.assetid\" content=\"086af969-29a5-4ce8-a993-0b7d53839dab\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"31\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/classes-and-structs/polymorphism.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/classes-and-structs/polymorphism.md\">\r\n<meta name=\"document_id\" content=\"7b415465-f6f5-158f-37ed-fa9c784479f9\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Polymorphism (C# Programming Guide) | Microsoft Docs","ms.assetid":"086af969-29a5-4ce8-a993-0b7d53839dab","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":31,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["C# language, polymorphism","polymorphism [C#]"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/classes-and-structs/polymorphism.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/classes-and-structs/polymorphism.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/classes-and-structs/polymorphism.md","document_id":"7b415465-f6f5-158f-37ed-fa9c784479f9","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/classes-and-structs/polymorphism","toc_asset_id":"articles/csharp/programming-guide/classes-and-structs/toc.json","toc_rel":"toc.json","_op_ogTitle":"Polymorphism (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":1576,"_op_rawTitle":"<h1 id=\"polymorphism-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/classes-and-structs/polymorphism.md\" sourcestartlinenumber=\"37\" sourceendlinenumber=\"37\">Polymorphism (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/classes-and-structs/polymorphism","fileRelativePath":"articles/csharp/programming-guide/classes-and-structs/polymorphism.html"},"themesRelativePathToOutputRoot":"_themes/"}