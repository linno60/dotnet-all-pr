{"content":"<div><div class=\"content\">\n<p>Destructors are used to destruct instances of classes.  </p>\n<h2 id=\"remarks\">Remarks</h2>\n<ul>\n<li><p>Destructors cannot be defined in structs. They are only used with classes.  </p>\n</li>\n<li><p>A class can only have one destructor.  </p>\n</li>\n<li><p>Destructors cannot be inherited or overloaded.  </p>\n</li>\n<li><p>Destructors cannot be called. They are invoked automatically.  </p>\n</li>\n<li><p>A destructor does not take modifiers or have parameters.  </p>\n<p>For example, the following is a declaration of a destructor for the class <code>Car</code>:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideObjects#86\">    class Car\n    {\n        ~Car()  // destructor\n        {\n            // cleanup statements...\n        }\n    }\n</code></pre><p>The destructor implicitly calls <a class=\"xref\" href=\"../../../../api/system.object#System_Object_Finalize_\" data-linktype=\"relative-path\">Finalize</a> on the base class of the object. Therefore, the previous destructor code is implicitly translated to the following code:  </p>\n</li>\n</ul>\n<pre class=\"loading\"><code>protected override void Finalize()  \n{  \n    try  \n    {  \n        // Cleanup statements...  \n    }  \n    finally  \n    {  \n        base.Finalize();  \n    }  \n}  \n</code></pre><p> This means that the <code>Finalize</code> method is called recursively for all instances in the inheritance chain, from the most-derived to the least-derived.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Empty destructors should not be used. When a class contains a destructor, an entry is created in the <code>Finalize</code> queue. When the destructor is called, the garbage collector is invoked to process the queue. If the destructor is empty, this just causes a needless loss of performance.  </p>\n</div>\n<p> The programmer has no control over when the destructor is called because this is determined by the garbage collector. The garbage collector checks for objects that are no longer being used by the application. If it considers an object eligible for destruction, it calls the destructor (if any) and reclaims the memory used to store the object. Destructors are also called when the program exits.  </p>\n<p> It is possible to force garbage collection by calling <a class=\"xref\" href=\"../../../../api/system.gc#System_GC_Collect_\" data-linktype=\"relative-path\">Collect</a>, but most of the time, this should be avoided because it may create performance issues.  </p>\n<h2 id=\"using-destructors-to-release-resources\">Using Destructors to Release Resources</h2>\n<p> In general, C# does not require as much memory management as is needed when you develop with a language that does not target a runtime with garbage collection. This is because the .NET Framework garbage collector implicitly manages the allocation and release of memory for your objects. However, when your application encapsulates unmanaged resources such as windows, files, and network connections, you should use destructors to free those resources. When the object is eligible for destruction, the garbage collector runs the <code>Finalize</code> method of the object.  </p>\n<h2 id=\"explicit-release-of-resources\">Explicit Release of Resources</h2>\n<p> If your application is using an expensive external resource, we also recommend that you provide a way to explicitly release the resource before the garbage collector frees the object. You do this by implementing a <code>Dispose</code> method from the <a class=\"xref\" href=\"../../../../api/system.idisposable\" data-linktype=\"relative-path\">IDisposable</a> interface that performs the necessary cleanup for the object. This can considerably improve the performance of the application. Even with this explicit control over resources, the destructor becomes a safeguard to clean up resources if the call to the <code>Dispose</code> method failed.  </p>\n<p> For more details about cleaning up resources, see the following topics:  </p>\n<ul>\n<li><p><a href=\"http://msdn.microsoft.com/library/a17b0066-71c2-4ba4-9822-8e19332fc213\" data-linktype=\"external\">Cleaning Up Unmanaged Resources</a>  </p>\n</li>\n<li><p><a href=\"http://msdn.microsoft.com/library/eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9\" data-linktype=\"external\">Implementing a Dispose Method</a>  </p>\n</li>\n<li><p><a href=\"../../language-reference/keywords/using-statement\" data-linktype=\"relative-path\">using Statement</a>  </p>\n</li>\n</ul>\n<h2 id=\"example\">Example</h2>\n<p> The following example creates three classes that make a chain of inheritance. The class <code>First</code> is the base class, <code>Second</code> is derived from <code>First</code>, and <code>Third</code> is derived from <code>Second</code>. All three have destructors. In <code>Main()</code>, an instance of the most-derived class is created. When the program runs, notice that the destructors for the three classes are called automatically, and in order, from the most-derived to the least-derived.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideObjects#85\">    class First\n    {\n        ~First()\n        {\n            System.Diagnostics.Trace.WriteLine(&quot;First&#39;s destructor is called.&quot;);\n        }\n    }\n\n    class Second : First\n    {\n        ~Second()\n        {\n            System.Diagnostics.Trace.WriteLine(&quot;Second&#39;s destructor is called.&quot;);\n        }\n    }\n\n    class Third : Second\n    {\n        ~Third()\n        {\n            System.Diagnostics.Trace.WriteLine(&quot;Third&#39;s destructor is called.&quot;);\n        }\n    }\n\n    class TestDestructors\n    {\n        static void Main()\n        {\n            Third t = new Third();\n        }\n\n    }\n    /* Output (to VS Output Window):\n        Third&#39;s destructor is called.\n        Second&#39;s destructor is called.\n        First&#39;s destructor is called.\n    */\n</code></pre><h2 id=\"c-language-specification\">C# Language Specification</h2>\n<p> For more information, see the <a href=\"../../language-reference/language-specification\" data-linktype=\"relative-path\">C# Language Specification</a>. The language specification is the definitive source for C# syntax and usage.  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a class=\"xref\" href=\"../../../../api/system.idisposable\" data-linktype=\"relative-path\">IDisposable</a><br> <a href=\"../index\" data-linktype=\"relative-path\">C# Programming Guide</a><br> <a href=\"constructors\" data-linktype=\"relative-path\">Constructors</a><br> <a href=\"../../../standard/garbagecollection/index\" data-linktype=\"relative-path\">Garbage Collection</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"ms.assetid\" content=\"1ae6e46d-a4b1-4a49-abe5-b97f53d9e049\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"24\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/classes-and-structs/destructors.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/classes-and-structs/destructors.md\">\r\n<meta name=\"document_id\" content=\"df360bb8-6eca-9f4f-315e-4bf29dfe3226\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Destructors (C# Programming Guide) | Microsoft Docs","ms.assetid":"1ae6e46d-a4b1-4a49-abe5-b97f53d9e049","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":24,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["~ [C#], in destructors","C# language, destructors","destructors [C#]"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/classes-and-structs/destructors.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/classes-and-structs/destructors.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/classes-and-structs/destructors.md","document_id":"df360bb8-6eca-9f4f-315e-4bf29dfe3226","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/classes-and-structs/destructors","toc_asset_id":"articles/csharp/programming-guide/classes-and-structs/toc.json","toc_rel":"toc.json","_op_ogTitle":"Destructors (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":640,"_op_rawTitle":"<h1 id=\"destructors-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/classes-and-structs/destructors.md\" sourcestartlinenumber=\"38\" sourceendlinenumber=\"38\">Destructors (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/classes-and-structs/destructors","fileRelativePath":"articles/csharp/programming-guide/classes-and-structs/destructors.html"},"themesRelativePathToOutputRoot":"_themes/"}