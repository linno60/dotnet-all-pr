{"content":"<div><div class=\"content\">\n<p>A method is a code block that contains a series of statements. A program causes the statements to be executed by calling the method and specifying any required method arguments. In C#, every executed instruction is performed in the context of a method. The Main method is the entry point for every C# application and it is called by the common language runtime (CLR) when the program is started.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> This topic discusses named methods. For information about anonymous functions, see <a href=\"../statements-expressions-operators/anonymous-functions\" data-linktype=\"relative-path\">Anonymous Functions</a>.  </p>\n</div>\n<h2 id=\"method-signatures\">Method Signatures</h2>\n<p> Methods are declared in a <a href=\"../../language-reference/keywords/class\" data-linktype=\"relative-path\">class</a> or <a href=\"../../language-reference/keywords/struct\" data-linktype=\"relative-path\">struct</a> by specifying the access level such as <code>public</code> or <code>private</code>, optional modifiers such as <code>abstract</code> or <code>sealed</code>, the return value, the name of the method, and any method parameters. These parts together are the signature of the method.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> A return type of a method is not part of the signature of the method for the purposes of method overloading. However, it is part of the signature of the method when determining the compatibility between a delegate and the method that it points to.  </p>\n</div>\n<p> Method parameters are enclosed in parentheses and are separated by commas. Empty parentheses indicate that the method requires no parameters. This class contains three methods:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideObjects#40\">abstract class Motorcycle\n{\n    // Anyone can call this.\n    public void StartEngine() {/* Method statements here */ }\n\n    // Only derived classes can call this.\n    protected void AddGas(int gallons) { /* Method statements here */ }\n\n    // Derived classes can override the base class implementation.\n    public virtual int Drive(int miles, int speed) { /* Method statements here */ return 1; }\n\n    // Derived classes must implement this.\n    public abstract double GetTopSpeed(); \n}\n</code></pre><h2 id=\"method-access\">Method Access</h2>\n<p> Calling a method on an object is like accessing a field. After the object name, add a period, the name of the method, and parentheses. Arguments are listed within the parentheses, and are separated by commas. The methods of the <code>Motorcycle</code> class can therefore be called as in the following example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideObjects#41\">class TestMotorcycle : Motorcycle\n{\n\n    public override double GetTopSpeed()\n    {\n        return 108.4;\n    }\n\n    static void Main()\n    {\n        \n        TestMotorcycle moto = new TestMotorcycle();\n\n        moto.StartEngine();\n        moto.AddGas(15);\n        moto.Drive(5, 20);\n        double speed = moto.GetTopSpeed();\n        Console.WriteLine(&quot;My top speed is {0}&quot;, speed);            \n    }\n}\n</code></pre><h2 id=\"method-parameters-vs-arguments\">Method Parameters vs. Arguments</h2>\n<p> The method definition specifies the names and types of any parameters that are required. When calling code calls the method, it provides concrete values called arguments for each parameter. The arguments must be compatible with the parameter type but the argument name (if any) used in the calling code does not have to be the same as the parameter named defined in the method. For example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideObjects#74\">public void Caller()\n{\n    int numA = 4;\n    // Call with an int variable.\n    int productA = Square(numA);\n\n    int numB = 32;\n    // Call with another int variable.\n    int productB = Square(numB);\n\n    // Call with an integer literal.\n    int productC = Square(12);\n\n    // Call with an expression that evaulates to int.\n    productC = Square(productA * 3);\n}\n\nint Square(int i)\n{\n    // Store input argument in a local variable.\n    int input = i;\n    return input * input;\n}\n</code></pre><h2 id=\"passing-by-reference-vs-passing-by-value\">Passing by Reference vs. Passing by Value</h2>\n<p> By default, when a value type is passed to a method, a copy is passed instead of the object itself. Therefore, changes to the argument have no effect on the original copy in the calling method. You can pass a value-type by reference by using the ref keyword. For more information, see <a href=\"passing-value-type-parameters\" data-linktype=\"relative-path\">Passing Value-Type Parameters</a>. For a list of built-in value types, see <a href=\"../../language-reference/keywords/value-types-table\" data-linktype=\"relative-path\">Value Types Table</a>.  </p>\n<p> When an object of a reference type is passed to a method, a reference to the object is passed. That is, the method receives not the object itself but an argument that indicates the location of the object. If you change a member of the object by using this reference, the change is reflected in the argument in the calling method, even if you pass the object by value.  </p>\n<p> You create a reference type by using the <code>class</code> keyword, as the following example shows.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideObjects#42\">public class SampleRefType\n{\n    public int value;\n}\n</code></pre><p> Now, if you pass an object that is based on this type to a method, a reference to the object is passed. The following example passes an object of type <code>SampleRefType</code> to method <code>ModifyObject</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideObjects#75\">public static void TestRefType()\n{\n    SampleRefType rt = new SampleRefType();\n    rt.value = 44;\n    ModifyObject(rt);\n    Console.WriteLine(rt.value);\n}\nstatic void ModifyObject(SampleRefType obj)\n{\n    obj.value = 33;\n}\n</code></pre><p> The example does essentially the same thing as the previous example in that it passes an argument by value to a method. But, because a reference type is used, the result is different. The modification that is made in <code>ModifyObject</code> to the <code>value</code> field of the parameter, <code>obj</code>, also changes the <code>value</code> field of the argument, <code>rt</code>, in the <code>TestRefType</code> method. The <code>TestRefType</code> method displays 33 as the output.  </p>\n<p> For more information about how to pass reference types by reference and by value, see <a href=\"passing-reference-type-parameters\" data-linktype=\"relative-path\">Passing Reference-Type Parameters</a> and <a href=\"../../language-reference/keywords/reference-types\" data-linktype=\"relative-path\">Reference Types</a>.  </p>\n<h2 id=\"return-values\">Return Values</h2>\n<p> Methods can return a value to the caller. If the return type, the type listed before the method name, is not <code>void</code>, the method can return the value by using the <code>return</code> keyword. A statement with the <code>return</code> keyword followed by a value that matches the return type will return that value to the method caller. The <code>return</code> keyword also stops the execution of the method. If the return type is <code>void</code>, a <code>return</code> statement without a value is still useful to stop the execution of the method. Without the <code>return</code> keyword, the method will stop executing when it reaches the end of the code block. Methods with a non-void return type are required to use the <code>return</code> keyword to return a value. For example, these two methods use the <code>return</code> keyword to return integers:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideObjects#44\">class SimpleMath\n{\n    public int AddTwoNumbers(int number1, int number2)\n    {\n        return number1 + number2;\n    }\n\n    public int SquareANumber(int number)\n    {\n        return number * number;\n    }\n}\n</code></pre><p> To use a value returned from a method, the calling method can use the method call itself anywhere a value of the same type would be sufficient. You can also assign the return value to a variable. For example, the following two code examples accomplish the same goal:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideObjects#45\">int result = obj.AddTwoNumbers(1, 2);\nresult = obj.SquareANumber(result);\n// The result is 9.\nConsole.WriteLine(result);\n</code></pre><pre><code class=\"lang-cs\" name=\"csProgGuideObjects#46\">result = obj.SquareANumber(obj.AddTwoNumbers(1, 2));\n// The result is 9.\nConsole.WriteLine(result);\n</code></pre><p> Using a local variable, in this case, <code>result</code>, to store a value is optional. It may help the readability of the code, or it may be necessary if you need to store the original value of the argument for the entire scope of the method.  </p>\n<p> Returning a multi-dimensional array from a method, M, that modifies the array&#39;s contents is not necessary if the calling function passed the array into M.  You may return the resulting array from M for good style or functional flow of values, but it is not necessary.  The reason you do not need to return the modified array is that C# passes all reference types by value, and the value of an array reference is the pointer to the array. In the method M, any changes to the array&#39;s contents are observable by any code that has a reference to the array, as shown in the following example.  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">static void Main(string[] args)  \n        {  \n            int[,] matrix = new int[2, 2];  \n            FillMatrix(matrix);  \n            // matrix is now full of -1  \n        }  \n\n        public static void FillMatrix(int[,] matrix)  \n        {  \n            for (int i = 0; i &lt; matrix.GetLength(0); i++)  \n            {  \n                for (int j = 0; j &lt; matrix.GetLength(1); j++)  \n                {  \n                    matrix[i, j] = -1;  \n                }  \n            }  \n        }  \n</code></pre><p> For more information, see <a href=\"../../language-reference/keywords/return\" data-linktype=\"relative-path\">return</a>.  </p>\n<h2 id=\"async-methods\">Async Methods</h2>\n<p> By using the async feature, you can invoke asynchronous methods without using explicit callbacks or manually splitting your code across multiple methods or lambda expressions. The async feature was introduced Visual Studio 2012.  </p>\n<p> If you mark a method with the <a href=\"../../language-reference/keywords/async\" data-linktype=\"relative-path\">async</a> modifier, you can use the <a href=\"../../language-reference/keywords/await\" data-linktype=\"relative-path\">await</a> operator in the method. When control reaches an await expression in the async method, control returns to the caller, and progress in the method is suspended until the awaited task completes. When the task is complete, execution can resume in the method.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> An async method returns to the caller when either it encounters the first awaited object thatâ€™s not yet complete or it gets to the end of the async method, whichever occurs first.  </p>\n</div>\n<p> An async method can have a return type of <a class=\"xref\" href=\"../../../../api/system.threading.tasks.task-1\" data-linktype=\"relative-path\">Task&lt;TResult&gt;</a>, <a class=\"xref\" href=\"../../../../api/system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a>, or void. The void return type is used primarily to define event handlers, where a void return type is required. An async method that returns void can&#39;t be awaited, and the caller of a void-returning method can&#39;t catch exceptions that the method throws.  </p>\n<p> In the following example, <code>DelayAsync</code> is an async method that has a return type of <a class=\"xref\" href=\"../../../../api/system.threading.tasks.task-1\" data-linktype=\"relative-path\">Task&lt;TResult&gt;</a>. <code>DelayAsync</code> has a <code>return</code> statement that returns an integer. Therefore the method declaration of <code>DelayAsync</code> must have a return type of <code>Task&lt;int&gt;</code>. Because the return type is <code>Task&lt;int&gt;</code>, the evaluation of the <code>await</code> expression in <code>DoSomethingAsync</code> produces an integer as the following statement demonstrates: <code>int result = await delayTask</code>.  </p>\n<p> The <code>startButton_Click</code> method is an example of an async method that has a return type of void. Because <code>DoSomethingAsync</code> is an async method, the task for the call to <code>DoSomethingAsync</code> must be awaited, as the following statement shows: <code>await DoSomethingAsync();</code>. The <code>startButton_Click</code> method must be defined with the <code>async</code> modifier because the method has an <code>await</code> expression.  </p>\n<pre><code class=\"lang-cs\" name=\"csAsyncMethod#2\">// using System.Diagnostics;\n// using System.Threading.Tasks;\n\n// This Click event is marked with the async modifier.\nprivate async void startButton_Click(object sender, RoutedEventArgs e)\n{\n    await DoSomethingAsync();\n}\n\nprivate async Task DoSomethingAsync()\n{\n    Task&lt;int&gt; delayTask = DelayAsync();\n    int result = await delayTask;\n\n    // The previous two statements may be combined into\n    // the following statement.\n    //int result = await DelayAsync();\n\n    Debug.WriteLine(&quot;Result: &quot; + result);\n}\n\nprivate async Task&lt;int&gt; DelayAsync()\n{\n    await Task.Delay(100);\n    return 5;\n}\n\n// Output:\n//  Result: 5\n</code></pre><p> An async method can&#39;t declare any <a href=\"../../language-reference/keywords/ref\" data-linktype=\"relative-path\">ref</a> or <a href=\"../../language-reference/keywords/out\" data-linktype=\"relative-path\">out</a> parameters, but it can call methods that have such parameters.  </p>\n<p> For more information about async methods, see <a href=\"../concepts/async/index\" data-linktype=\"relative-path\">Asynchronous Programming with async and await</a>, <a href=\"../concepts/async/control-flow-in-async-programs\" data-linktype=\"relative-path\">Control Flow in Async Programs</a>, and <a href=\"../concepts/async/async-return-types\" data-linktype=\"relative-path\">Async Return Types</a>.  </p>\n<h2 id=\"expression-body-definitions\">Expression Body Definitions</h2>\n<p> It is common to have method definitions that simply return immediately with the result of an expression, or that have a single statement as the body of the method.  There is a syntax shortcut for defining such methods using <code>=&gt;</code>:  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">public Point Move(int dx, int dy) =&gt; new Point(x + dx, y + dy);   \npublic void Print() =&gt; Console.WriteLine(First + &quot; &quot; + Last);  \n// Works with operators, properties, and indexers too.  \npublic static Complex operator +(Complex a, Complex b) =&gt; a.Add(b);  \npublic string Name =&gt; First + &quot; &quot; + Last;   \npublic Customer this[long id] =&gt; store.LookupCustomer(id);  \n</code></pre><p> If the method returns <code>void</code> or is an async method, then the body of the method must be a statement expression (same as with lambdas).  For properties and indexers, they must be read only, and you do not use the <code>get</code> accessor keyword.  </p>\n<h2 id=\"iterators\">Iterators</h2>\n<p> An iterator performs a custom iteration over a collection, such as a list or an array. An iterator uses the <a href=\"../../language-reference/keywords/yield\" data-linktype=\"relative-path\">yield return</a> statement to return each element one at a time. When a <a href=\"../../language-reference/keywords/yield\" data-linktype=\"relative-path\">yield return</a> statement is reached, the current location in code is remembered. Execution is restarted from that location when the iterator is called the next time.  </p>\n<p> You call an iterator from client code by using a <a href=\"../../language-reference/keywords/foreach-in\" data-linktype=\"relative-path\">foreach</a> statement.  </p>\n<p> The return type of an iterator can be <a class=\"xref\" href=\"../../../../api/system.collections.ienumerable\" data-linktype=\"relative-path\">IEnumerable</a>, <a class=\"xref\" href=\"../../../../api/system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable&lt;T&gt;</a>, <a class=\"xref\" href=\"../../../../api/system.collections.ienumerator\" data-linktype=\"relative-path\">IEnumerator</a>, or <a class=\"xref\" href=\"../../../../api/system.collections.generic.ienumerator-1\" data-linktype=\"relative-path\">IEnumerator&lt;T&gt;</a>.  </p>\n<p> For more information, see <a href=\"http://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7\" data-linktype=\"external\">Iterators</a>.  </p>\n<h2 id=\"c-language-specification\">C# Language Specification</h2>\n<p>For more information, see the <a href=\"../../language-reference/language-specification\" data-linktype=\"relative-path\">C# Language Specification</a>. The language specification is the definitive source for C# syntax and usage.</p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../index\" data-linktype=\"relative-path\">C# Programming Guide</a><br> <a href=\"index\" data-linktype=\"relative-path\">Classes and Structs</a><br> <a href=\"access-modifiers\" data-linktype=\"relative-path\">Access Modifiers</a><br> <a href=\"static-classes-and-static-class-members\" data-linktype=\"relative-path\">Static Classes and Static Class Members</a><br> <a href=\"inheritance\" data-linktype=\"relative-path\">Inheritance</a><br> <a href=\"abstract-and-sealed-classes-and-class-members\" data-linktype=\"relative-path\">Abstract and Sealed Classes and Class Members</a><br> <a href=\"../../language-reference/keywords/params\" data-linktype=\"relative-path\">params</a><br> <a href=\"../../language-reference/keywords/return\" data-linktype=\"relative-path\">return</a><br> <a href=\"../../language-reference/keywords/out\" data-linktype=\"relative-path\">out</a><br> <a href=\"../../language-reference/keywords/ref\" data-linktype=\"relative-path\">ref</a><br> <a href=\"passing-parameters\" data-linktype=\"relative-path\">Passing Parameters</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"ms.assetid\" content=\"cc738f07-e8cd-4683-9585-9f40c0667c37\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"41\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"translation.priority.mt\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.mt\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.mt\" content=\"pt-br\">\r\n<meta name=\"translation.priority.mt\" content=\"tr-tr\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/3115359729431ecbcc16058612da59b85621fa0f/docs/csharp/programming-guide/classes-and-structs/methods.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/classes-and-structs/methods.md\">\r\n<meta name=\"document_id\" content=\"0d76c79e-9964-ef19-148e-4f61b95086ae\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Methods (C# Programming Guide) | Microsoft Docs","ms.assetid":"cc738f07-e8cd-4683-9585-9f40c0667c37","translation.priority.ht":["de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","ru-ru","zh-cn","zh-tw"],"caps.latest.revision":41,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["methods [C#]","C# language, methods"],"translation.priority.mt":["cs-cz","pl-pl","pt-br","tr-tr"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize the C# Guide TOC (#1318)","commit_sha":"3115359729431ecbcc16058612da59b85621fa0f","commit_date":"2017-01-23 23:20:14 -0500"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/3115359729431ecbcc16058612da59b85621fa0f/docs/csharp/programming-guide/classes-and-structs/methods.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/classes-and-structs/methods.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/classes-and-structs/methods.md","document_id":"0d76c79e-9964-ef19-148e-4f61b95086ae","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/classes-and-structs/methods","toc_asset_id":"articles/csharp/programming-guide/classes-and-structs/toc.json","toc_rel":"toc.json","_op_ogTitle":"Methods (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":1971,"_op_rawTitle":"<h1 id=\"methods-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/classes-and-structs/methods.md\" sourcestartlinenumber=\"38\" sourceendlinenumber=\"38\">Methods (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/classes-and-structs/methods","fileRelativePath":"articles/csharp/programming-guide/classes-and-structs/methods.html"},"themesRelativePathToOutputRoot":"_themes/"}