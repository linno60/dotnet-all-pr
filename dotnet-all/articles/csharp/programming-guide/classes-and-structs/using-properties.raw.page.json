{"content":"<div><div class=\"content\">\n<p>Properties combine aspects of both fields and methods. To the user of an object, a property appears to be a field, accessing the property requires the same syntax. To the implementer of a class, a property is one or two code blocks, representing a <a href=\"../../language-reference/keywords/get\" data-linktype=\"relative-path\">get</a> accessor and/or a <a href=\"../../language-reference/keywords/set\" data-linktype=\"relative-path\">set</a> accessor. The code block for the <code>get</code> accessor is executed when the property is read; the code block for the <code>set</code> accessor is executed when the property is assigned a new value. A property without a <code>set</code> accessor is considered read-only. A property without a <code>get</code> accessor is considered write-only. A property that has both accessors is read-write.  </p>\n<p> Unlike fields, properties are not classified as variables. Therefore, you cannot pass a property as a <a href=\"../../language-reference/keywords/ref\" data-linktype=\"relative-path\">ref</a> or <a href=\"../../language-reference/keywords/out\" data-linktype=\"relative-path\">out</a> parameter.  </p>\n<p> Properties have many uses: they can validate data before allowing a change; they can transparently expose data on a class where that data is actually retrieved from some other source, such as a database; they can take an action when data is changed, such as raising an event, or changing the value of other fields.  </p>\n<p> Properties are declared in the class block by specifying the access level of the field, followed by the type of the property, followed by the name of the property, and followed by a code block that declares a <code>get</code>-accessor and/or a <code>set</code> accessor. For example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideProperties#7\">        public class Date\n        {\n            private int month = 7;  // Backing store\n\n            public int Month\n            {\n                get\n                {\n                    return month;\n                }\n                set\n                {\n                    if ((value &gt; 0) &amp;&amp; (value &lt; 13))\n                    {\n                        month = value;\n                    }\n                }\n            }\n        }\n</code></pre><p> In this example, <code>Month</code> is declared as a property so that the <code>set</code> accessor can make sure that the <code>Month</code> value is set between 1 and 12. The <code>Month</code> property uses a private field to track the actual value. The real location of a property&#39;s data is often referred to as the property&#39;s &quot;backing store.&quot; It is common for properties to use private fields as a backing store. The field is marked private in order to make sure that it can only be changed by calling the property. For more information about public and private access restrictions, see <a href=\"access-modifiers\" data-linktype=\"relative-path\">Access Modifiers</a>.  </p>\n<p> Auto-implemented properties provide simplified syntax for simple property declarations. For more information, see <a href=\"auto-implemented-properties\" data-linktype=\"relative-path\">Auto-Implemented Properties</a>.  </p>\n<h2 id=\"the-get-accessor\">The get Accessor</h2>\n<p> The body of the <code>get</code> accessor resembles that of a method. It must return a value of the property type. The execution of the <code>get</code> accessor is equivalent to reading the value of the field. For example, when you are returning the private variable from the <code>get</code> accessor and optimizations are enabled, the call to the <code>get</code> accessor method is inlined by the compiler so there is no method-call overhead. However, a virtual <code>get</code> accessor method cannot be inlined because the compiler does not know at compile-time which method may actually be called at run time. The following is a <code>get</code> accessor that returns the value of a private field <code>name</code>:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideProperties#8\">        class Person\n        {\n            private string name;  // the name field\n            public string Name    // the Name property\n            {\n                get\n                {\n                    return name;\n                }\n            }\n        }\n</code></pre><p> When you reference the property, except as the target of an assignment, the <code>get</code> accessor is invoked to read the value of the property. For example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideProperties#9\">                Person person = new Person();\n                //...\n\n                System.Console.Write(person.Name);  // the get accessor is invoked here\n</code></pre><p> The <code>get</code> accessor must end in a <a href=\"../../language-reference/keywords/return\" data-linktype=\"relative-path\">return</a> or <a href=\"../../language-reference/keywords/throw\" data-linktype=\"relative-path\">throw</a> statement, and control cannot flow off the accessor body.  </p>\n<p> It is a bad programming style to change the state of the object by using the <code>get</code> accessor. For example, the following accessor produces the side effect of changing the state of the object every time that the <code>number</code> field is accessed.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideProperties#10\">        private int number;\n        public int Number\n        {\n            get\n            {\n                return number++;   // Don&#39;t do this\n            }\n        }\n</code></pre><p> The <code>get</code> accessor can be used to return the field value or to compute it and return it. For example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideProperties#11\">        class Employee\n        {\n            private string name;\n            public string Name\n            {\n                get\n                {\n                    return name != null ? name : &quot;NA&quot;;\n                }\n            }\n        }\n</code></pre><p> In the previous code segment, if you do not assign a value to the <code>Name</code> property, it will return the value NA.  </p>\n<h2 id=\"the-set-accessor\">The set Accessor</h2>\n<p> The <code>set</code> accessor resembles a method whose return type is <a href=\"../../language-reference/keywords/void\" data-linktype=\"relative-path\">void</a>. It uses an implicit parameter called <code>value</code>, whose type is the type of the property. In the following example, a <code>set</code> accessor is added to the <code>Name</code> property:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideProperties#12\">        class Person\n        {\n            private string name;  // the name field\n            public string Name    // the Name property\n            {\n                get\n                {\n                    return name;\n                }\n                set\n                {\n                    name = value;\n                }\n            }\n        }\n</code></pre><p> When you assign a value to the property, the <code>set</code> accessor is invoked by using an argument that provides the new value. For example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideProperties#13\">                Person person = new Person();\n                person.Name = &quot;Joe&quot;;  // the set accessor is invoked here                \n\n                System.Console.Write(person.Name);  // the get accessor is invoked here\n</code></pre><p> It is an error to use the implicit parameter name, <code>value</code>, for a local variable declaration in a <code>set</code> accessor.  </p>\n<h2 id=\"remarks\">Remarks</h2>\n<p> Properties can be marked as <code>public</code>, <code>private</code>, <code>protected</code>, <code>internal</code>, or <code>protected internal</code>. These access modifiers define how users of the class can access the property. The <code>get</code> and <code>set</code> accessors for the same property may have different access modifiers. For example, the <code>get</code> may be <code>public</code> to allow read-only access from outside the type, and the <code>set</code> may be <code>private</code> or <code>protected</code>. For more information, see <a href=\"access-modifiers\" data-linktype=\"relative-path\">Access Modifiers</a>.  </p>\n<p> A property may be declared as a static property by using the <code>static</code> keyword. This makes the property available to callers at any time, even if no instance of the class exists. For more information, see <a href=\"static-classes-and-static-class-members\" data-linktype=\"relative-path\">Static Classes and Static Class Members</a>.  </p>\n<p> A property may be marked as a virtual property by using the <a href=\"../../language-reference/keywords/virtual\" data-linktype=\"relative-path\">virtual</a> keyword. This enables derived classes to override the property behavior by using the <a href=\"../../language-reference/keywords/override\" data-linktype=\"relative-path\">override</a> keyword. For more information about these options, see <a href=\"inheritance\" data-linktype=\"relative-path\">Inheritance</a>.  </p>\n<p> A property overriding a virtual property can also be <a href=\"../../language-reference/keywords/sealed\" data-linktype=\"relative-path\">sealed</a>, specifying that for derived classes it is no longer virtual. Lastly, a property can be declared <a href=\"../../language-reference/keywords/abstract\" data-linktype=\"relative-path\">abstract</a>. This means that there is no implementation in the class, and derived classes must write their own implementation. For more information about these options, see <a href=\"abstract-and-sealed-classes-and-class-members\" data-linktype=\"relative-path\">Abstract and Sealed Classes and Class Members</a>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> It is an error to use a <a href=\"../../language-reference/keywords/virtual\" data-linktype=\"relative-path\">virtual</a>, <a href=\"../../language-reference/keywords/abstract\" data-linktype=\"relative-path\">abstract</a>, or <a href=\"../../language-reference/keywords/override\" data-linktype=\"relative-path\">override</a> modifier on an accessor of a <a href=\"../../language-reference/keywords/static\" data-linktype=\"relative-path\">static</a> property.  </p>\n</div>\n<h2 id=\"example\">Example</h2>\n<p> This example demonstrates instance, static, and read-only properties. It accepts the name of the employee from the keyboard, increments <code>NumberOfEmployees</code> by 1, and displays the Employee name and number.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideProperties#2\">        public class Employee\n        {\n            public static int NumberOfEmployees;\n            private static int counter;\n            private string name;\n\n            // A read-write instance property:\n            public string Name\n            {\n                get { return name; }\n                set { name = value; }\n            }\n\n            // A read-only static property:\n            public static int Counter\n            {\n                get { return counter; }\n            }\n\n            // A Constructor:\n            public Employee()\n            {\n                // Calculate the employee&#39;s number:\n                counter = ++counter + NumberOfEmployees;\n            }\n        }\n\n        class TestEmployee\n        {\n            static void Main()\n            {\n                Employee.NumberOfEmployees = 107;\n                Employee e1 = new Employee();\n                e1.Name = &quot;Claude Vige&quot;;\n\n                System.Console.WriteLine(&quot;Employee number: {0}&quot;, Employee.Counter);\n                System.Console.WriteLine(&quot;Employee name: {0}&quot;, e1.Name);\n            }\n        }\n        /* Output:\n            Employee number: 108\n            Employee name: Claude Vige\n        */\n</code></pre><h2 id=\"example-1\">Example</h2>\n<p> This example demonstrates how to access a property in a base class that is hidden by another property that has the same name in a derived class.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideProperties#3\">        public class Employee\n        {\n            private string name;\n            public string Name\n            {\n                get { return name; }\n                set { name = value; }\n            }\n        }\n\n        public class Manager : Employee\n        {\n            private string name;\n\n            // Notice the use of the new modifier:\n            public new string Name\n            {\n                get { return name; }\n                set { name = value + &quot;, Manager&quot;; }\n            }\n        }\n\n        class TestHiding\n        {\n            static void Main()\n            {\n                Manager m1 = new Manager();\n\n                // Derived class property.\n                m1.Name = &quot;John&quot;;\n\n                // Base class property.\n                ((Employee)m1).Name = &quot;Mary&quot;;\n\n                System.Console.WriteLine(&quot;Name in the derived class is: {0}&quot;, m1.Name);\n                System.Console.WriteLine(&quot;Name in the base class is: {0}&quot;, ((Employee)m1).Name);\n            }\n        }\n        /* Output:\n            Name in the derived class is: John, Manager\n            Name in the base class is: Mary\n        */\n</code></pre><p> The following are important points in the previous example:  </p>\n<ul>\n<li><p>The property <code>Name</code> in the derived class hides the property <code>Name</code> in the base class. In such a case, the <code>new</code> modifier is used in the declaration of the property in the derived class:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideProperties#4\">            public new string Name\n</code></pre></li>\n<li><p>The cast <code>(Employee)</code> is used to access the hidden property in the base class:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideProperties#5\">                ((Employee)m1).Name = &quot;Mary&quot;;\n</code></pre><p> For more information about hiding members, see the <a href=\"../../language-reference/keywords/new-modifier\" data-linktype=\"relative-path\">new Modifier</a>.  </p>\n</li>\n</ul>\n<h2 id=\"example-2\">Example</h2>\n<p> In this example, two classes, <code>Cube</code> and <code>Square</code>, implement an abstract class, <code>Shape</code>, and override its abstract <code>Area</code> property. Note the use of the <a href=\"../../language-reference/keywords/override\" data-linktype=\"relative-path\">override</a> modifier on the properties. The program accepts the side as an input and calculates the areas for the square and cube. It also accepts the area as an input and calculates the corresponding side for the square and cube.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideProperties#6\">        abstract class Shape\n        {\n            public abstract double Area\n            {\n                get;\n                set;\n            }\n        }\n\n        class Square : Shape\n        {\n            public double side;\n\n            public Square(double s)  //constructor\n            {\n                side = s;\n            }\n\n            public override double Area\n            {\n                get\n                {\n                    return side * side;\n                }\n                set\n                {\n                    side = System.Math.Sqrt(value);\n                }\n            }\n        }\n\n        class Cube : Shape\n        {\n            public double side;\n\n            public Cube(double s)\n            {\n                side = s;\n            }\n\n            public override double Area\n            {\n                get\n                {\n                    return 6 * side * side;\n                }\n                set\n                {\n                    side = System.Math.Sqrt(value / 6);\n                }\n            }\n        }\n\n        class TestShapes\n        {\n            static void Main()\n            {\n                // Input the side:\n                System.Console.Write(&quot;Enter the side: &quot;);\n                double side = double.Parse(System.Console.ReadLine());\n\n                // Compute the areas:\n                Square s = new Square(side);\n                Cube c = new Cube(side);\n\n                // Display the results:\n                System.Console.WriteLine(&quot;Area of the square = {0:F2}&quot;, s.Area);\n                System.Console.WriteLine(&quot;Area of the cube = {0:F2}&quot;, c.Area);\n                System.Console.WriteLine();\n\n                // Input the area:\n                System.Console.Write(&quot;Enter the area: &quot;);\n                double area = double.Parse(System.Console.ReadLine());\n\n                // Compute the sides:\n                s.Area = area;\n                c.Area = area;\n\n                // Display the results:\n                System.Console.WriteLine(&quot;Side of the square = {0:F2}&quot;, s.side);\n                System.Console.WriteLine(&quot;Side of the cube = {0:F2}&quot;, c.side);\n            }\n        }\n        /* Example Output:\n            Enter the side: 4\n            Area of the square = 16.00\n            Area of the cube = 96.00\n\n            Enter the area: 24\n            Side of the square = 4.90\n            Side of the cube = 2.00\n        */\n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../index\" data-linktype=\"relative-path\">C# Programming Guide</a><br> <a href=\"properties\" data-linktype=\"relative-path\">Properties</a><br> <a href=\"interface-properties\" data-linktype=\"relative-path\">Interface Properties</a><br> <a href=\"auto-implemented-properties\" data-linktype=\"relative-path\">Auto-Implemented Properties</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc2.json\">\r\n<meta name=\"ms.assetid\" content=\"f7f67b05-0983-4cdb-96af-1855d24c967c\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"24\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/classes-and-structs/using-properties.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/classes-and-structs/using-properties.md\">\r\n<meta name=\"document_id\" content=\"69ca7aae-ae7e-286f-06a1-8f8e2bc64a92\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Using Properties (C# Programming Guide) | Microsoft Docs","ms.assetid":"f7f67b05-0983-4cdb-96af-1855d24c967c","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":24,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["set accessor [C#]","get accessor [C#]","properties [C#], about properties"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/classes-and-structs/using-properties.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/classes-and-structs/using-properties.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/classes-and-structs/using-properties.md","document_id":"69ca7aae-ae7e-286f-06a1-8f8e2bc64a92","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/programming-guide/classes-and-structs/using-properties","toc_asset_id":"articles/csharp/programming-guide/classes-and-structs/toc.json","toc_rel":"toc.json","_op_ogTitle":"Using Properties (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":1725,"_op_rawTitle":"<h1 id=\"using-properties-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/classes-and-structs/using-properties.md\" sourcestartlinenumber=\"38\" sourceendlinenumber=\"38\">Using Properties (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/programming-guide/classes-and-structs/using-properties","fileRelativePath":"articles/csharp/programming-guide/classes-and-structs/using-properties.html"},"themesRelativePathToOutputRoot":"_themes/"}