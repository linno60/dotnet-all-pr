{"content":"<div><div class=\"content\">\n<p>Extension methods enable you to &quot;add&quot; methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type. Extension methods are a special kind of static method, but they are called as if they were instance methods on the extended type. For client code written in C# and Visual Basic, there is no apparent difference between calling an extension method and the methods that are actually defined in a type.  </p>\n<p> The most common extension methods are the LINQ standard query operators that add query functionality to the existing <a class=\"xref\" href=\"../../../../api/system.collections.ienumerable\" data-linktype=\"relative-path\">System.Collections.IEnumerable</a> and <a class=\"xref\" href=\"../../../../api/system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">System.Collections.Generic.IEnumerable&lt;T&gt;</a> types. To use the standard query operators, first bring them into scope with a <code>using System.Linq</code> directive. Then any type that implements <a class=\"xref\" href=\"../../../../api/system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable&lt;T&gt;</a> appears to have instance methods such as <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/bb341740(v=vs.110).aspx\" data-linktype=\"external\">GroupBy</a>, <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/bb343617(v=vs.110).aspx\" data-linktype=\"external\">OrderBy</a>, <a class=\"xref\" href=\"../../../../api/system.linq.enumerable#System_Linq_Enumerable_Average_\" data-linktype=\"relative-path\">Average</a>, and so on. You can see these additional methods in IntelliSense statement completion when you type &quot;dot&quot; after an instance of an <a class=\"xref\" href=\"../../../../api/system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable&lt;T&gt;</a> type such as <a class=\"xref\" href=\"../../../../api/system.collections.generic.list-1\" data-linktype=\"relative-path\">List&lt;T&gt;</a> or <a class=\"xref\" href=\"../../../../api/system.array\" data-linktype=\"relative-path\">Array</a>.  </p>\n<p> The following example shows how to call the standard query operator <code>OrderBy</code> method on an array of integers. The expression in parentheses is a lambda expression. Many standard query operators take lambda expressions as parameters, but this is not a requirement for extension methods. For more information, see <a href=\"../statements-expressions-operators/lambda-expressions\" data-linktype=\"relative-path\">Lambda Expressions</a>.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideExtensionMethods#3\">class ExtensionMethods2    \n{\n    \n    static void Main()\n    {            \n        int[] ints = { 10, 45, 15, 39, 21, 26 };\n        var result = ints.OrderBy(g =&gt; g);\n        foreach (var i in result)\n        {\n            System.Console.Write(i + &quot; &quot;);\n        }           \n    }        \n}\n//Output: 10 15 21 26 39 45\n</code></pre><p> Extension methods are defined as static methods but are called by using instance method syntax. Their first parameter specifies which type the method operates on, and the parameter is preceded by the <a href=\"../../language-reference/keywords/this\" data-linktype=\"relative-path\">this</a> modifier. Extension methods are only in scope when you explicitly import the namespace into your source code with a <code>using</code> directive.  </p>\n<p> The following example shows an extension method defined for the <a class=\"xref\" href=\"../../../../api/system.string\" data-linktype=\"relative-path\">System.String</a> class. Note that it is defined inside a non-nested, non-generic static class:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideExtensionMethods#4\">namespace ExtensionMethods\n{\n    public static class MyExtensions\n    {\n        public static int WordCount(this String str)\n        {\n            return str.Split(new char[] { &#39; &#39;, &#39;.&#39;, &#39;?&#39; }, \n                             StringSplitOptions.RemoveEmptyEntries).Length;\n        }\n    }   \n}\n</code></pre><p> The <code>WordCount</code> extension method can be brought into scope with this <code>using</code> directive:  </p>\n<pre class=\"loading\"><code>using ExtensionMethods;  \n</code></pre><p> And it can be called from an application by using this syntax:  </p>\n<pre class=\"loading\"><code>string s = &quot;Hello Extension Methods&quot;;  \nint i = s.WordCount();  \n</code></pre><p> In your code you invoke the extension method with instance method syntax. However, the intermediate language (IL) generated by the compiler translates your code into a call on the static method. Therefore, the principle of encapsulation is not really being violated. In fact, extension methods cannot access private variables in the type they are extending.  </p>\n<p> For more information, see <a href=\"how-to-implement-and-call-a-custom-extension-method\" data-linktype=\"relative-path\">How to: Implement and Call a Custom  Extension Method</a>.  </p>\n<p> In general, you will probably be calling extension methods far more often than implementing your own. Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code. To enable extension methods for a particular type, just add a <code>using</code> directive for the namespace in which the methods are defined. For example, to use the standard query operators, add this <code>using</code> directive to your code:  </p>\n<pre class=\"loading\"><code>using System.Linq;  \n</code></pre><p> (You may also have to add a reference to System.Core.dll.) You will notice that the standard query operators now appear in IntelliSense as additional methods available for most <a class=\"xref\" href=\"../../../../api/system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable&lt;T&gt;</a> types.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Although standard query operators do not appear in IntelliSense for <a class=\"xref\" href=\"../../../../api/system.string\" data-linktype=\"relative-path\">String</a>, they are still available.  </p>\n</div>\n<h2 id=\"binding-extension-methods-at-compile-time\">Binding Extension Methods at Compile Time</h2>\n<p> You can use extension methods to extend a class or interface, but not to override them. An extension method with the same name and signature as an interface or class method will never be called. At compile time, extension methods always have lower priority than instance methods defined in the type itself. In other words, if a type has a method named <code>Process(int i)</code>, and you have an extension method with the same signature, the compiler will always bind to the instance method. When the compiler encounters a method invocation, it first looks for a match in the type&#39;s instance methods. If no match is found, it will search for any extension methods that are defined for the type, and bind to the first extension method that it finds. The following example demonstrates how the compiler determines which extension method or instance method to bind to.  </p>\n<h2 id=\"example\">Example</h2>\n<p> The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method. The static class <code>Extensions</code> contains extension methods defined for any type that implements <code>IMyInterface</code>. Classes <code>A</code>, <code>B</code>, and <code>C</code> all implement the interface.  </p>\n<p> The <code>MethodB</code> extension method is never called because its name and signature exactly match methods already implemented by the classes.  </p>\n<p> When the compiler cannot find an instance method with a matching signature, it will bind to a matching extension method if one exists.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideExtensionMethods#5\">// Define an interface named IMyInterface.\nnamespace DefineIMyInterface\n{\n    using System;\n\n    public interface IMyInterface\n    {\n        // Any class that implements IMyInterface must define a method\n        // that matches the following signature.\n        void MethodB();\n    }\n}\n\n\n// Define extension methods for IMyInterface.\nnamespace Extensions\n{\n    using System;\n    using DefineIMyInterface;\n\n    // The following extension methods can be accessed by instances of any \n    // class that implements IMyInterface.\n    public static class Extension\n    {\n        public static void MethodA(this IMyInterface myInterface, int i)\n        {\n            Console.WriteLine\n                (&quot;Extension.MethodA(this IMyInterface myInterface, int i)&quot;);\n        }\n\n        public static void MethodA(this IMyInterface myInterface, string s)\n        {\n            Console.WriteLine\n                (&quot;Extension.MethodA(this IMyInterface myInterface, string s)&quot;);\n        }\n\n        // This method is never called in ExtensionMethodsDemo1, because each \n        // of the three classes A, B, and C implements a method named MethodB\n        // that has a matching signature.\n        public static void MethodB(this IMyInterface myInterface)\n        {\n            Console.WriteLine\n                (&quot;Extension.MethodB(this IMyInterface myInterface)&quot;);\n        }\n    }\n}\n\n\n// Define three classes that implement IMyInterface, and then use them to test\n// the extension methods.\nnamespace ExtensionMethodsDemo1\n{\n    using System;\n    using Extensions;\n    using DefineIMyInterface;\n\n    class A : IMyInterface\n    {\n        public void MethodB() { Console.WriteLine(&quot;A.MethodB()&quot;); }\n    }\n\n    class B : IMyInterface\n    {\n        public void MethodB() { Console.WriteLine(&quot;B.MethodB()&quot;); }\n        public void MethodA(int i) { Console.WriteLine(&quot;B.MethodA(int i)&quot;); }\n    }\n\n    class C : IMyInterface\n    {\n        public void MethodB() { Console.WriteLine(&quot;C.MethodB()&quot;); }\n        public void MethodA(object obj)\n        {\n            Console.WriteLine(&quot;C.MethodA(object obj)&quot;);\n        }\n    }\n\n    class ExtMethodDemo\n    {\n        static void Main(string[] args)\n        {\n            // Declare an instance of class A, class B, and class C.\n            A a = new A();\n            B b = new B();\n            C c = new C();\n\n            // For a, b, and c, call the following methods:\n            //      -- MethodA with an int argument\n            //      -- MethodA with a string argument\n            //      -- MethodB with no argument.\n\n            // A contains no MethodA, so each call to MethodA resolves to \n            // the extension method that has a matching signature.\n            a.MethodA(1);           // Extension.MethodA(object, int)\n            a.MethodA(&quot;hello&quot;);     // Extension.MethodA(object, string)\n\n            // A has a method that matches the signature of the following call\n            // to MethodB.\n            a.MethodB();            // A.MethodB()\n\n            // B has methods that match the signatures of the following\n            // method calls.\n            b.MethodA(1);           // B.MethodA(int)\n            b.MethodB();            // B.MethodB()\n\n            // B has no matching method for the following call, but \n            // class Extension does.\n            b.MethodA(&quot;hello&quot;);     // Extension.MethodA(object, string)\n\n            // C contains an instance method that matches each of the following\n            // method calls.\n            c.MethodA(1);           // C.MethodA(object)\n            c.MethodA(&quot;hello&quot;);     // C.MethodA(object)\n            c.MethodB();            // C.MethodB()\n        }\n    }\n}\n/* Output:\n    Extension.MethodA(this IMyInterface myInterface, int i)\n    Extension.MethodA(this IMyInterface myInterface, string s)\n    A.MethodB()\n    B.MethodA(int i)\n    B.MethodB()\n    Extension.MethodA(this IMyInterface myInterface, string s)\n    C.MethodA(object obj)\n    C.MethodA(object obj)\n    C.MethodB()\n */\n</code></pre><h2 id=\"general-guidelines\">General Guidelines</h2>\n<p> In general, we recommend that you implement extension methods sparingly and only when you have to. Whenever possible, client code that must extend an existing type should do so by creating a new type derived from the existing type. For more information, see <a href=\"inheritance\" data-linktype=\"relative-path\">Inheritance</a>.  </p>\n<p> When using an extension method to extend a type whose source code you cannot change, you run the risk that a change in the implementation of the type will cause your extension method to break.  </p>\n<p> If you do implement extension methods for a given type, remember the followingpoints:  </p>\n<ul>\n<li><p>An extension method will never be called if it has the same signature as a method defined in the type.  </p>\n</li>\n<li><p>Extension methods are brought into scope at the namespace level. For example, if you have multiple static classes that contain extension methods in a single namespace named <code>Extensions</code>, they will all be brought into scope by the <code>using Extensions;</code> directive.  </p>\n</li>\n</ul>\n<p> For a class library that you implemented, you shouldn&#39;t use extension methods to avoid incrementing the version number of an assembly. If you want to add significant functionality to a library for which you own the source code, you should follow the standard .NET Framework guidelines for assembly versioning. For more information, see <a href=\"https://msdn.microsoft.com/library/51ket42z\" data-linktype=\"external\">Assembly Versioning</a>.  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../index\" data-linktype=\"relative-path\">C# Programming Guide</a><br> <a href=\"http://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364\" data-linktype=\"external\">Parallel Programming Samples (these include many example extension methods)</a><br> <a href=\"../statements-expressions-operators/lambda-expressions\" data-linktype=\"relative-path\">Lambda Expressions</a><br> <a href=\"http://msdn.microsoft.com/library/24cda21e-8af8-4632-b519-c404a839b9b2\" data-linktype=\"external\">Standard Query Operators Overview</a><br> <a href=\"http://go.microsoft.com/fwlink/?LinkId=112385\" data-linktype=\"external\">Conversion rules for Instance parameters and their impact</a><br> <a href=\"http://go.microsoft.com/fwlink/?LinkId=112386\" data-linktype=\"external\">Extension methods Interoperability between languages</a><br> <a href=\"http://go.microsoft.com/fwlink/?LinkId=112387\" data-linktype=\"external\">Extension methods and Curried Delegates</a><br> <a href=\"http://go.microsoft.com/fwlink/?LinkId=112388\" data-linktype=\"external\">Extension method Binding and Error reporting</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc1.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.assetid\" content=\"175ce3ff-9bbf-4e64-8421-faeb81a0bb51\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"35\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/classes-and-structs/extension-methods.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/classes-and-structs/extension-methods.md\">\r\n<meta name=\"document_id\" content=\"b6694b6d-5c5f-7745-94ff-0552dcab581f\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc1.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","title":"Extension Methods (C# Programming Guide) | Microsoft Docs","ms.assetid":"175ce3ff-9bbf-4e64-8421-faeb81a0bb51","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":35,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["methods [C#], adding to existing types","extension methods [C#]","methods [C#], extension"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/classes-and-structs/extension-methods.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/classes-and-structs/extension-methods.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/classes-and-structs/extension-methods.md","document_id":"b6694b6d-5c5f-7745-94ff-0552dcab581f","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/classes-and-structs/extension-methods","toc_asset_id":"articles/csharp/programming-guide/classes-and-structs/toc.json","toc_rel":"toc.json","_op_ogTitle":"Extension Methods (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":1502,"_op_rawTitle":"<h1 id=\"extension-methods-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/classes-and-structs/extension-methods.md\" sourcestartlinenumber=\"38\" sourceendlinenumber=\"38\">Extension Methods (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/classes-and-structs/extension-methods","fileRelativePath":"articles/csharp/programming-guide/classes-and-structs/extension-methods.html"},"themesRelativePathToOutputRoot":"_themes/"}