{"content":"<div><div class=\"content\">\n<p>Inheritance, together with encapsulation and polymorphism, is one of the three primary characteristics of object-oriented programming. Inheritance enables you to create new classes that reuse, extend, and modify the behavior that is defined in other classes. The class whose members are inherited is called the <em>base class</em>, and the class that inherits those members is called the <em>derived class</em>. A derived class can have only one direct base class. However, inheritance is transitive. If ClassC is derived from ClassB, and ClassB is derived from ClassA, ClassC inherits the members declared in ClassB and ClassA.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Structs do not support inheritance, but they can implement interfaces. For more information, see <a href=\"../interfaces/index\" data-linktype=\"relative-path\">Interfaces</a>.  </p>\n</div>\n<p> Conceptually, a derived class is a specialization of the base class. For example, if you have a base class <code>Animal</code>, you might have one derived class that is named <code>Mammal</code> and another derived class that is named <code>Reptile</code>. A <code>Mammal</code> is an <code>Animal</code>, and a <code>Reptile</code> is an <code>Animal</code>, but each derived class represents different specializations of the base class.  </p>\n<p> When you define a class to derive from another class, the derived class implicitly gains all the members of the base class, except for its constructors and destructors. The derived class can thereby reuse the code in the base class without having to re-implement it. In the derived class, you can add more members. In this manner, the derived class extends the functionality of the base class.  </p>\n<p> The following illustration shows a class <code>WorkItem</code> that represents an item of work in some business process. Like all classes, it derives from <a class=\"xref\" href=\"../../../../api/system.object\" data-linktype=\"relative-path\">System.Object</a> and inherits all its methods. <code>WorkItem</code> adds five members of its own. These include a constructor, because constructors are not inherited. Class <code>ChangeRequest</code> inherits from <code>WorkItem</code> and represents a particular kind of work item. <code>ChangeRequest</code> adds two more members to the members that it inherits from <code>WorkItem</code> and from <a class=\"xref\" href=\"../../../../api/system.object\" data-linktype=\"relative-path\">Object</a>. It must add its own constructor, and it also adds <code>originalItemID</code>. Property <code>originalItemID</code> enables the <code>ChangeRequest</code> instance to be associated with the original <code>WorkItem</code> to which the change request applies.  </p>\n<p> <img src=\"media/class_inheritance.png\" alt=\"Class Inheritance\" title=\"Class_Inheritance\" data-linktype=\"relative-path\"><br>Class inheritance  </p>\n<p> The following example shows how the class relationships demonstrated in the previous illustration are expressed in C#. The example also shows how <code>WorkItem</code> overrides the virtual method <a class=\"xref\" href=\"../../../../api/system.object#System_Object_ToString_\" data-linktype=\"relative-path\">ToString</a>, and how the <code>ChangeRequest</code> class inherits the <code>WorkItem</code> implementation of the method.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideInheritance#49\">        // WorkItem implicitly inherits from the Object class.\n        public class WorkItem\n        {\n            // Static field currentID stores the job ID of the last WorkItem that\n            // has been created.\n            private static int currentID;\n\n            //Properties.\n            protected int ID { get; set; }\n            protected string Title { get; set; }\n            protected string Description { get; set; }\n            protected TimeSpan jobLength { get; set; }\n\n            // Default constructor. If a derived class does not invoke a base-\n            // class constructor explicitly, the default constructor is called\n            // implicitly. \n            public WorkItem()\n            {\n                ID = 0;\n                Title = &quot;Default title&quot;;\n                Description = &quot;Default description.&quot;;\n                jobLength = new TimeSpan();\n            }\n\n            // Instance constructor that has three parameters.\n            public WorkItem(string title, string desc, TimeSpan joblen)\n            {\n                this.ID = GetNextID();\n                this.Title = title;\n                this.Description = desc;\n                this.jobLength = joblen;\n            }\n\n            // Static constructor to initialize the static member, currentID. This\n            // constructor is called one time, automatically, before any instance\n            // of WorkItem or ChangeRequest is created, or currentID is referenced.\n            static WorkItem()\n            {\n                currentID = 0;\n            }\n\n\n            protected int GetNextID()\n            {\n                // currentID is a static field. It is incremented each time a new\n                // instance of WorkItem is created.\n                return ++currentID;\n            }\n\n            // Method Update enables you to update the title and job length of an\n            // existing WorkItem object.\n            public void Update(string title, TimeSpan joblen)\n            {\n                this.Title = title;\n                this.jobLength = joblen;\n            }\n\n            // Virtual method override of the ToString method that is inherited\n            // from System.Object.\n            public override string ToString()\n            {\n                return String.Format(&quot;{0} - {1}&quot;, this.ID, this.Title);\n            }\n        }\n\n        // ChangeRequest derives from WorkItem and adds a property (originalItemID) \n        // and two constructors.\n        public class ChangeRequest : WorkItem\n        {\n            protected int originalItemID { get; set; }\n\n            // Constructors. Because neither constructor calls a base-class \n            // constructor explicitly, the default constructor in the base class\n            // is called implicitly. The base class must contain a default \n            // constructor.\n\n            // Default constructor for the derived class.\n            public ChangeRequest() { }\n\n            // Instance constructor that has four parameters.\n            public ChangeRequest(string title, string desc, TimeSpan jobLen,\n                                 int originalID)\n            {\n                // The following properties and the GetNexID method are inherited \n                // from WorkItem.\n                this.ID = GetNextID();\n                this.Title = title;\n                this.Description = desc;\n                this.jobLength = jobLen;\n\n                // Property originalItemId is a member of ChangeRequest, but not \n                // of WorkItem.\n                this.originalItemID = originalID;\n            }\n        }\n\n        class Program\n        {\n            static void Main()\n            {\n                // Create an instance of WorkItem by using the constructor in the \n                // base class that takes three arguments.\n                WorkItem item = new WorkItem(&quot;Fix Bugs&quot;,\n                                             &quot;Fix all bugs in my code branch&quot;,\n                                             new TimeSpan(3, 4, 0, 0));\n\n                // Create an instance of ChangeRequest by using the constructor in\n                // the derived class that takes four arguments.\n                ChangeRequest change = new ChangeRequest(&quot;Change Base Class Design&quot;,\n                                                         &quot;Add members to the class&quot;,\n                                                         new TimeSpan(4, 0, 0),\n                                                         1);\n\n                // Use the ToString method defined in WorkItem.\n                Console.WriteLine(item.ToString());\n\n                // Use the inherited Update method to change the title of the \n                // ChangeRequest object.\n                change.Update(&quot;Change the Design of the Base Class&quot;,\n                    new TimeSpan(4, 0, 0));\n\n                // ChangeRequest inherits WorkItem&#39;s override of ToString.\n                Console.WriteLine(change.ToString());\n\n                // Keep the console open in debug mode.\n                Console.WriteLine(&quot;Press any key to exit.&quot;);\n                Console.ReadKey();\n            }\n        }\n        /* Output:\n            1 - Fix Bugs\n            2 - Change the Design of the Base Class\n        */\n</code></pre><h2 id=\"abstract-and-virtual-methods\">Abstract and Virtual Methods</h2>\n<p> When a base class declares a method as <a href=\"../../language-reference/keywords/virtual\" data-linktype=\"relative-path\">virtual</a>, a derived class can <a href=\"../../language-reference/keywords/override\" data-linktype=\"relative-path\">override</a> the method with its own implementation. If a base class declares a member as <a href=\"../../language-reference/keywords/abstract\" data-linktype=\"relative-path\">abstract</a>, that method must be overridden in any non-abstract class that directly inherits from that class. If a derived class is itself abstract, it inherits abstract members without implementing them. Abstract and virtual members are the basis for polymorphism, which is the second primary characteristic of object-oriented programming. For more information, see <a href=\"polymorphism\" data-linktype=\"relative-path\">Polymorphism</a>.  </p>\n<h2 id=\"abstract-base-classes\">Abstract Base Classes</h2>\n<p> You can declare a class as <a href=\"../../language-reference/keywords/abstract\" data-linktype=\"relative-path\">abstract</a> if you want to prevent direct instantiation by using the <a href=\"../../language-reference/keywords/new\" data-linktype=\"relative-path\">new</a> keyword. If you do this, the class can be used only if a new class is derived from it. An abstract class can contain one or more method signatures that themselves are declared as abstract. These signatures specify the parameters and return value but have no implementation (method body). An abstract class does not have to contain abstract members; however, if a class does contain an abstract member, the class itself must be declared as abstract. Derived classes that are not abstract themselves must provide the implementation for any abstract methods from an abstract base class. For more information, see <a href=\"abstract-and-sealed-classes-and-class-members\" data-linktype=\"relative-path\">Abstract and Sealed Classes and Class Members</a>.  </p>\n<h2 id=\"interfaces\">Interfaces</h2>\n<p> An <em>interface</em> is a reference type that is somewhat similar to an abstract base class that consists of only abstract members. When a class implements an interface, it must provide an implementation for all the members of the interface. A class can implement multiple interfaces even though it can derive from only a single direct base class.  </p>\n<p> Interfaces are used to define specific capabilities for classes that do not necessarily have an &quot;is a&quot; relationship. For example, the <a class=\"xref\" href=\"../../../../api/system.iequatable-1\" data-linktype=\"relative-path\">System.IEquatable&lt;T&gt;</a> interface can be implemented by any class or struct that has to enable client code to determine whether two objects of the type are equivalent (however the type defines equivalence). <a class=\"xref\" href=\"../../../../api/system.iequatable-1\" data-linktype=\"relative-path\">IEquatable&lt;T&gt;</a> does not imply the same kind of &quot;is a&quot; relationship that exists between a base class and a derived class (for example, a <code>Mammal</code> is an <code>Animal</code>). For more information, see <a href=\"../interfaces/index\" data-linktype=\"relative-path\">Interfaces</a>.  </p>\n<h2 id=\"preventing-further-derivation\">Preventing Further Derivation</h2>\n<p> A class can prevent other classes from inheriting from it, or from any of its members, by declaring itself or the member as <a href=\"../../language-reference/keywords/sealed\" data-linktype=\"relative-path\">sealed</a>. For more information, see <a href=\"abstract-and-sealed-classes-and-class-members\" data-linktype=\"relative-path\">Abstract and Sealed Classes and Class Members</a>.  </p>\n<h2 id=\"derived-class-hiding-of-base-class-members\">Derived Class Hiding of Base Class Members</h2>\n<p> A derived class can hide base class members by declaring members with the same name and signature. The <a href=\"../../language-reference/keywords/new\" data-linktype=\"relative-path\">new</a> modifier can be used to explicitly indicate that the member is not intended to be an override of the base member. The use of <a href=\"../../language-reference/keywords/new\" data-linktype=\"relative-path\">new</a> is not required, but a compiler warning will be generated if <a href=\"../../language-reference/keywords/new\" data-linktype=\"relative-path\">new</a> is not used. For more information, see <a href=\"versioning-with-the-override-and-new-keywords\" data-linktype=\"relative-path\">Versioning with the Override and New Keywords</a> and <a href=\"knowing-when-to-use-override-and-new-keywords\" data-linktype=\"relative-path\">Knowing When to Use Override and New Keywords</a>.  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../index\" data-linktype=\"relative-path\">C# Programming Guide</a><br> <a href=\"index\" data-linktype=\"relative-path\">Classes and Structs</a><br> <a href=\"../../language-reference/keywords/class\" data-linktype=\"relative-path\">class</a><br> <a href=\"../../language-reference/keywords/struct\" data-linktype=\"relative-path\">struct</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet/toc2.json\">\r\n<meta name=\"ms.assetid\" content=\"81d64ee4-50f9-4d6c-a8dc-257c348d2eea\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"38\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/a780a11d8dd238187eb82933359bbb151bb3c333/docs/csharp/programming-guide/classes-and-structs/inheritance.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/classes-and-structs/inheritance.md\">\r\n<meta name=\"document_id\" content=\"758e9215-d952-958e-0ec2-5523bd0aa2b6\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Inheritance (C# Programming Guide) | Microsoft Docs","ms.assetid":"81d64ee4-50f9-4d6c-a8dc-257c348d2eea","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":38,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["abstract methods [C#]","abstract classes [C#]","inheritance [C#]","derived classes [C#]","virtual methods [C#]","C# language, inheritance"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Ron Petrusha","author_email":"ronpet@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Merge pull request #1316 from rpetrusha/inheritance","commit_sha":"a780a11d8dd238187eb82933359bbb151bb3c333","commit_date":"2016-12-14 13:03:30 -0800"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Addressed additional comments","commit_sha":"19940ead1425b191756a856368061e67c4f597b6","commit_date":"2016-12-13 14:42:34 -0800"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Additional changes to inheritance in programming guide.","commit_sha":"25164fa1da74eac409a87b09c07578f940c6625f","commit_date":"2016-12-09 16:45:05 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/rpetrusha","display_name":"rpetrusha","id":"10886961"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/a780a11d8dd238187eb82933359bbb151bb3c333/docs/csharp/programming-guide/classes-and-structs/inheritance.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/classes-and-structs/inheritance.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/classes-and-structs/inheritance.md","document_id":"758e9215-d952-958e-0ec2-5523bd0aa2b6","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/classes-and-structs/inheritance","toc_asset_id":"articles/csharp/programming-guide/classes-and-structs/toc.json","toc_rel":"toc.json","_op_ogTitle":"Inheritance (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":1407,"_op_rawTitle":"<h1 id=\"inheritance-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/classes-and-structs/inheritance.md\" sourcestartlinenumber=\"41\" sourceendlinenumber=\"41\">Inheritance (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/classes-and-structs/inheritance","fileRelativePath":"articles/csharp/programming-guide/classes-and-structs/inheritance.html"},"themesRelativePathToOutputRoot":"_themes/"}