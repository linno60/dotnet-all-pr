{"content":"<div><div class=\"content\">\n<p>An <em>expression</em> is a sequence of one or more operands and zero or more operators that can be evaluated to a single value, object, method, or namespace. Expressions can consist of a literal value, a method invocation, an operator and its operands, or a <em>simple name</em>. Simple names can be the name of a variable, type member, method parameter, namespace or type.  </p>\n<p> Expressions can use operators that in turn use other expressions as parameters, or method calls whose parameters are in turn other method calls, so expressions can range from simple to very complex. Following are two examples of expressions:  </p>\n<pre class=\"loading\"><code>((x &lt; 10) &amp;&amp; ( x &gt; 5)) || ((x &gt; 20) &amp;&amp; (x &lt; 25))   \nSystem.Convert.ToInt32(&quot;35&quot;)  \n</code></pre><h2 id=\"expression-values\">Expression Values</h2>\n<p> In most of the contexts in which expressions are used, for example in statements or method parameters, the expression is expected to evaluate to some value. If x and y are integers, the expression <code>x + y</code> evaluates to a numeric value. The expression <code>new MyClass()</code> evaluates to a reference to a new instance of a <code>MyClass</code> object. The expression <code>myClass.ToString()</code> evaluates to a string because that is the return type of the method. However, although a namespace name is classified as an expression, it does not evaluate to a value and therefore can never be the final result of any expression. You cannot pass a namespace name to a method parameter, or use it in a new expression, or assign it to a variable. You can only use it as a sub-expression in a larger expression. The same is true for types (as distinct from <a class=\"xref\" href=\"../../../../api/system.type\" data-linktype=\"relative-path\">System.Type</a> objects), method group names (as distinct from specific methods), and event <a href=\"../../language-reference/keywords/add\" data-linktype=\"relative-path\">add</a> and <a href=\"../../language-reference/keywords/remove\" data-linktype=\"relative-path\">remove</a> accessors.  </p>\n<p> Every value has an associated type. For example, if x and y are both variables of type <code>int</code>, the value of the expression <code>x + y</code> is also typed as <code>int</code>. If the value is assigned to a variable of a different type, or if x and y are different types, the rules of type conversion are applied. For more information about how such conversions work, see <a href=\"../types/casting-and-type-conversions\" data-linktype=\"relative-path\">Casting and Type Conversions</a>.  </p>\n<h2 id=\"overflows\">Overflows</h2>\n<p> Numeric expressions may cause overflows if the value is larger than the maximum value of the value&#39;s type. For more information, see <a href=\"../../language-reference/keywords/checked-and-unchecked\" data-linktype=\"relative-path\">Checked and Unchecked</a> and <a href=\"../../language-reference/keywords/explicit-numeric-conversions-table\" data-linktype=\"relative-path\">Explicit Numeric Conversions Table</a>.  </p>\n<h2 id=\"operator-precedence-and-associativity\">Operator Precedence and Associativity</h2>\n<p> The manner in which an expression is evaluated is governed by the rules of associativity and operator precedence. For more information, see <a href=\"operators\" data-linktype=\"relative-path\">Operators</a>.  </p>\n<p> Most expressions, except assignment expressions and method invocation expressions, must be embedded in a statement. For more information, see <a href=\"statements\" data-linktype=\"relative-path\">Statements</a>.  </p>\n<h2 id=\"literals-and-simple-names\">Literals and Simple Names</h2>\n<p> The two simplest types of expressions are literals and simple names. A literal is a constant value that has no name. For example, in the following code example, both <code>5</code> and <code>&quot;Hello World&quot;</code> are literal values:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideStatements#2\">// Expression statements.\nint i = 5;\nstring s = &quot;Hello World&quot;;\n</code></pre><p> For more information on literals, see <a href=\"../../language-reference/keywords/types\" data-linktype=\"relative-path\">Types</a>.  </p>\n<p> In the preceding example, both <code>i</code> and <code>s</code> are simple names that identify local variables. When those variables are used in an expression, the variable name evaluates to the value that is currently stored in the variable&#39;s location in memory. This is shown in the following example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideStatements#3\">int num = 5;\nSystem.Console.WriteLine(num); // Output: 5\nnum = 6;\nSystem.Console.WriteLine(num); // Output: 6            \n</code></pre><h2 id=\"invocation-expressions\">Invocation Expressions</h2>\n<p> In the following code example, the call to <code>DoWork</code> is an invocation expression.  </p>\n<pre class=\"loading\"><code>DoWork();  \n</code></pre><p> A method invocation requires the name of the method, either as a name as in the previous example, or as the result of another expression, followed by parenthesis and any method parameters. For more information, see <a href=\"../classes-and-structs/methods\" data-linktype=\"relative-path\">Methods</a>. A delegate invocation uses the name of a delegate and method parameters in parenthesis. For more information, see <a href=\"../delegates/index\" data-linktype=\"relative-path\">Delegates</a>. Method invocations and delegate invocations evaluate to the return value of the method, if the method returns a value. Methods that return void cannot be used in place of a value in an expression.  </p>\n<h2 id=\"query-expressions\">Query Expressions</h2>\n<p> The same rules for expressions in general apply to query expressions. For more information, see <a href=\"../linq-query-expressions/index\" data-linktype=\"relative-path\">LINQ Query Expressions</a>.  </p>\n<h2 id=\"lambda-expressions\">Lambda Expressions</h2>\n<p> Lambda expressions represent &quot;inline methods&quot; that have no name but can have input parameters and multiple statements. They are used extensively in LINQ to pass arguments to methods. Lambda expressions are compiled to either delegates or expression trees depending on the context in which they are used. For more information, see <a href=\"lambda-expressions\" data-linktype=\"relative-path\">Lambda Expressions</a>.  </p>\n<h2 id=\"expression-trees\">Expression Trees</h2>\n<p> Expression trees enable expressions to be represented as data structures. They are used extensively by LINQ providers to translate query expressions into code that is meaningful in some other context, such as a SQL database. For more information, see <a href=\"http://msdn.microsoft.com/library/fb1d3ed8-d5b0-4211-a71f-dd271529294b\" data-linktype=\"external\">Expression Trees</a>.  </p>\n<h2 id=\"remarks\">Remarks</h2>\n<p> Whenever a variable, object property, or object indexer access is identified from an expression, the value of that item is used as the value of the expression. An expression can be placed anywhere in C# where a value or object is required, as long as the expression ultimately evaluates to the required type.  </p>\n<h2 id=\"featured-book-chapter\">Featured Book Chapter</h2>\n<p> <a href=\"http://go.microsoft.com/fwlink/?LinkId=221228\" data-linktype=\"external\">Variables and Expressions</a> in <a href=\"http://go.microsoft.com/fwlink/?LinkId=221214\" data-linktype=\"external\">Beginning Visual C# 2010</a>  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../index\" data-linktype=\"relative-path\">C# Programming Guide</a><br> <a href=\"../classes-and-structs/methods\" data-linktype=\"relative-path\">Methods</a><br> <a href=\"../delegates/index\" data-linktype=\"relative-path\">Delegates</a><br> <a href=\"operators\" data-linktype=\"relative-path\">Operators</a><br> <a href=\"../types/index\" data-linktype=\"relative-path\">Types</a><br> <a href=\"../linq-query-expressions/index\" data-linktype=\"relative-path\">LINQ Query Expressions</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"ms.assetid\" content=\"c7d8feb0-0e58-4f94-8bf6-4d070550a832\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"22\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/statements-expressions-operators/expressions.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/statements-expressions-operators/expressions.md\">\r\n<meta name=\"document_id\" content=\"550f06f3-f6de-c306-4f63-64cdf8ecef2e\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Expressions (C# Programming Guide) | Microsoft Docs","ms.assetid":"c7d8feb0-0e58-4f94-8bf6-4d070550a832","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":22,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["expressions [C#]","C# language, expressions"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/statements-expressions-operators/expressions.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/statements-expressions-operators/expressions.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/statements-expressions-operators/expressions.md","document_id":"550f06f3-f6de-c306-4f63-64cdf8ecef2e","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/statements-expressions-operators/expressions","toc_asset_id":"articles/csharp/programming-guide/statements-expressions-operators/toc.json","toc_rel":"toc.json","_op_ogTitle":"Expressions (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":850,"_op_rawTitle":"<h1 id=\"expressions-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/statements-expressions-operators/expressions.md\" sourcestartlinenumber=\"37\" sourceendlinenumber=\"37\">Expressions (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/statements-expressions-operators/expressions","fileRelativePath":"articles/csharp/programming-guide/statements-expressions-operators/expressions.html"},"themesRelativePathToOutputRoot":"_themes/"}