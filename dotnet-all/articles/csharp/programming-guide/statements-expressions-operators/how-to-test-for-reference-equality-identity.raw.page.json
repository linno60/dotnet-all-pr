{"content":"<div><div class=\"content\">\n<p>You do not have to implement any custom logic to support reference equality comparisons in your types. This functionality is provided for all types by the static <a class=\"xref\" href=\"../../../../api/system.object#System_Object_ReferenceEquals_\" data-linktype=\"relative-path\">ReferenceEquals</a> method.  </p>\n<p> The following example shows how to determine whether two variables have <em>reference equality</em>, which means that they refer to the same object in memory.  </p>\n<p> The example also shows why <a class=\"xref\" href=\"../../../../api/system.object#System_Object_ReferenceEquals_\" data-linktype=\"relative-path\">ReferenceEquals</a> always returns <code>false</code> for value types and why you should not use  <a class=\"xref\" href=\"../../../../api/system.object#System_Object_ReferenceEquals_\" data-linktype=\"relative-path\">ReferenceEquals</a> to determine string equality.  </p>\n<h2 id=\"example\">Example</h2>\n<pre><code class=\"lang-cs\" name=\"csProgGuideObjects#90\">namespace TestReferenceEquality\n{\n    struct TestStruct\n    {\n        public int Num { get; private set; }\n        public string Name { get; private set; }\n\n        public TestStruct(int i, string s) : this()\n        {\n            Num = i;\n            Name = s;\n        }\n    }\n\n    class TestClass\n    {\n        public int Num { get; set; }\n        public string Name { get; set; }\n    }\n\n    class Program\n    {\n        static void Main()\n        {\n            // Demonstrate reference equality with reference types.\n            #region ReferenceTypes\n\n            // Create two reference type instances that have identical values.\n            TestClass tcA = new TestClass() { Num = 1, Name = &quot;New TestClass&quot; };\n            TestClass tcB = new TestClass() { Num = 1, Name = &quot;New TestClass&quot; };\n\n            Console.WriteLine(&quot;ReferenceEquals(tcA, tcB) = {0}&quot;,\n                                Object.ReferenceEquals(tcA, tcB)); // false\n\n            // After assignment, tcB and tcA refer to the same object. \n            // They now have reference equality. \n            tcB = tcA;\n            Console.WriteLine(&quot;After asignment: ReferenceEquals(tcA, tcB) = {0}&quot;,\n                                Object.ReferenceEquals(tcA, tcB)); // true\n\n            // Changes made to tcA are reflected in tcB. Therefore, objects\n            // that have reference equality also have value equality.\n            tcA.Num = 42;\n            tcA.Name = &quot;TestClass 42&quot;;\n            Console.WriteLine(&quot;tcB.Name = {0} tcB.Num: {1}&quot;, tcB.Name, tcB.Num);\n            #endregion\n\n            // Demonstrate that two value type instances never have reference equality.\n            #region ValueTypes\n\n            TestStruct tsC = new TestStruct( 1, &quot;TestStruct 1&quot;);\n\n            // Value types are copied on assignment. tsD and tsC have \n            // the same values but are not the same object.\n            TestStruct tsD = tsC;\n            Console.WriteLine(&quot;After asignment: ReferenceEquals(tsC, tsD) = {0}&quot;,\n                                Object.ReferenceEquals(tsC, tsD)); // false\n            #endregion\n\n            #region stringRefEquality\n            // Constant strings within the same assembly are always interned by the runtime.\n            // This means they are stored in the same location in memory. Therefore, \n            // the two strings have reference equality although no assignment takes place.\n            string strA = &quot;Hello world!&quot;;\n            string strB = &quot;Hello world!&quot;;\n            Console.WriteLine(&quot;ReferenceEquals(strA, strB) = {0}&quot;,\n                             Object.ReferenceEquals(strA, strB)); // true\n\n            // After a new string is assigned to strA, strA and strB\n            // are no longer interned and no longer have reference equality.\n            strA = &quot;Goodbye world!&quot;;\n            Console.WriteLine(&quot;strA = \\&quot;{0}\\&quot; strB = \\&quot;{1}\\&quot;&quot;, strA, strB);\n            \n            Console.WriteLine(&quot;After strA changes, ReferenceEquals(strA, strB) = {0}&quot;,\n                            Object.ReferenceEquals(strA, strB)); // false\n            \n            // A string that is created at runtime cannot be interned.\n            StringBuilder sb = new StringBuilder(&quot;Hello world!&quot;);\n            string stringC = sb.ToString(); \n            // False:\n            Console.WriteLine(&quot;ReferenceEquals(stringC, strB) = {0}&quot;,\n                            Object.ReferenceEquals(stringC, strB));\n\n            // The string class overloads the == operator to perform an equality comparison.\n            Console.WriteLine(&quot;stringC == strB = {0}&quot;, stringC == strB); // true\n\n            #endregion\n\n            // Keep the console open in debug mode.\n            Console.WriteLine(&quot;Press any key to exit.&quot;);\n            Console.ReadKey();\n        }\n    }\n}\n\n/* Output:\n    ReferenceEquals(tcA, tcB) = False\n    After asignment: ReferenceEquals(tcA, tcB) = True\n    tcB.Name = TestClass 42 tcB.Num: 42\n    After asignment: ReferenceEquals(tsC, tsD) = False\n    ReferenceEquals(strA, strB) = True\n    strA = &quot;Goodbye world!&quot; strB = &quot;Hello world!&quot;\n    After strA changes, ReferenceEquals(strA, strB) = False\n*/\n</code></pre><p> The implementation of <code>Equals</code> in the <a class=\"xref\" href=\"../../../../api/system.object\" data-linktype=\"relative-path\">System.Object</a> universal base class also performs a reference equality check, but it is best not to use this because, if a class happens to override the method, the results might not be what you expect. The same is true for the <code>==</code> and <code>!=</code> operators. When they are operating on reference types, the default behavior of == and <code>!=</code> is to perform a reference equality check. However, derived classes can overload the operator to perform a value equality check. To minimize the potential for error, it is best to always use <a class=\"xref\" href=\"../../../../api/system.object#System_Object_ReferenceEquals_\" data-linktype=\"relative-path\">ReferenceEquals</a> when you have to determine whether two objects have reference equality.  </p>\n<p> Constant strings within the same assembly are always interned by the runtime. That is, only one instance of each unique literal string is maintained. However, the runtime does not guarantee that strings created at runtime are interned, nor does it guarantee that two equal constant strings in different assemblies are interned.  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"equality-comparisons\" data-linktype=\"relative-path\">Equality Comparisons</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"ms.assetid\" content=\"91307fda-267b-4fd2-a338-2aada39ee791\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"13\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/statements-expressions-operators/how-to-test-for-reference-equality-identity.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/statements-expressions-operators/how-to-test-for-reference-equality-identity.md\">\r\n<meta name=\"document_id\" content=\"0bb671e3-ae72-2177-5cc6-3fa5dbca2936\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","uhfHeaderId":"MSDocsHeader-DotNet","title":"How to: Test for Reference Equality (Identity) (C# Programming Guide) | Microsoft Docs","ms.assetid":"91307fda-267b-4fd2-a338-2aada39ee791","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":13,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["object identity [C#]","reference equality [C#]"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/statements-expressions-operators/how-to-test-for-reference-equality-identity.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/statements-expressions-operators/how-to-test-for-reference-equality-identity.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/statements-expressions-operators/how-to-test-for-reference-equality-identity.md","document_id":"0bb671e3-ae72-2177-5cc6-3fa5dbca2936","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/statements-expressions-operators/how-to-test-for-reference-equality-identity","toc_asset_id":"articles/csharp/programming-guide/statements-expressions-operators/toc.json","toc_rel":"toc.json","_op_ogTitle":"How to: Test for Reference Equality (Identity) (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":693,"_op_rawTitle":"<h1 id=\"how-to-test-for-reference-equality-identity-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/statements-expressions-operators/how-to-test-for-reference-equality-identity.md\" sourcestartlinenumber=\"37\" sourceendlinenumber=\"37\">How to: Test for Reference Equality (Identity) (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/statements-expressions-operators/how-to-test-for-reference-equality-identity","fileRelativePath":"articles/csharp/programming-guide/statements-expressions-operators/how-to-test-for-reference-equality-identity.html"},"themesRelativePathToOutputRoot":"_themes/"}