{"content":"<div><div class=\"content\">\n<p>When you define a class or struct, you decide whether it makes sense to create a custom definition of value equality (or equivalence) for the type. Typically, you implement value equality when objects of the type are expected to be added to a collection of some sort, or when their primary purpose is to store a set of fields or properties. You can base your definition of value equality on a comparison of all the fields and properties in the type, or you can base the definition on a subset. But in either case, and in both classes and structs, your implementation should follow the five guarantees of equivalence:  </p>\n<ol>\n<li><p>x.<code>Equals</code>(x) returns <code>true.</code> This is called the reflexive property.  </p>\n</li>\n<li><p>x.<code>Equals</code>(y) returns the same value as y.<code>Equals</code>(x). This is called the symmetric property.  </p>\n</li>\n<li><p>if (x.<code>Equals</code>(y) &amp;&amp; y.<code>Equals</code>(z)) returns <code>true</code>, then x.<code>Equals</code>(z) returns <code>true</code>. This is called the transitive property.  </p>\n</li>\n<li><p>Successive invocations of x.<code>Equals</code>(y) return the same value as long as the objects referenced by x and y are not modified.  </p>\n</li>\n<li><p>x.<code>Equals</code>(null) returns <code>false</code>. However, null.Equals(null) throws an exception; it does not obey rule number two above.  </p>\n</li>\n</ol>\n<p> Any struct that you define already has a default implementation of value equality that it inherits from the <a class=\"xref\" href=\"../../../../api/system.valuetype\" data-linktype=\"relative-path\">System.ValueType</a> override of the <a class=\"xref\" href=\"../../../../api/system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">System.Object.Equals(Object)</a> method. This implementation uses reflection to examine all the fields and properties in the type. Although this implementation produces correct results, it is relatively slow compared to a custom implementation that you write specifically for the type.  </p>\n<p> The implementation details for value equality are different for classes and structs. However, both classes and structs require the same basic steps for implementing equality:  </p>\n<ol>\n<li><p>Override the <a href=\"../../language-reference/keywords/virtual\" data-linktype=\"relative-path\">virtual</a> <a class=\"xref\" href=\"../../../../api/system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">System.Object.Equals(Object)</a> method. In most cases, your implementation of <code>bool Equals( object obj )</code> should just call into the type-specific <code>Equals</code> method that is the implementation of the <a class=\"xref\" href=\"../../../../api/system.iequatable-1\" data-linktype=\"relative-path\">System.IEquatable&lt;T&gt;</a> interface. (See step 2.)  </p>\n</li>\n<li><p>Implement the <a class=\"xref\" href=\"../../../../api/system.iequatable-1\" data-linktype=\"relative-path\">System.IEquatable&lt;T&gt;</a> interface by providing a type-specific <code>Equals</code> method. This is where the actual equivalence comparison is performed. For example, you might decide to define equality by comparing only one or two fields in your type. Do not throw exceptions from <code>Equals</code>. For classes only: This method should examine only fields that are declared in the class. It should call <code>base.Equals</code> to examine fields that are in the base class. (Do not do this if the type inherits directly from <a class=\"xref\" href=\"../../../../api/system.object\" data-linktype=\"relative-path\">Object</a>, because the <a class=\"xref\" href=\"../../../../api/system.object\" data-linktype=\"relative-path\">Object</a> implementation of <a class=\"xref\" href=\"../../../../api/system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">System.Object.Equals(Object)</a> performs a reference equality check.)  </p>\n</li>\n<li><p>Optional but recommended: Overload the <a href=\"../../language-reference/operators/equality-comparison-operator\" data-linktype=\"relative-path\">==</a> and <a href=\"../../language-reference/operators/not-equal-operator\" data-linktype=\"relative-path\">!=</a> operators.  </p>\n</li>\n<li><p>Override <a class=\"xref\" href=\"../../../../api/system.object#System_Object_GetHashCode_\" data-linktype=\"relative-path\">GetHashCode</a> so that two objects that have value equality produce the same hash code.  </p>\n</li>\n<li><p>Optional: To support definitions for &quot;greater than&quot; or &quot;less than,&quot; implement the <a class=\"xref\" href=\"../../../../api/system.icomparable-1\" data-linktype=\"relative-path\">IComparable&lt;T&gt;</a> interface for your type, and also overload the <a href=\"../../language-reference/operators/less-than-equal-operator\" data-linktype=\"relative-path\">&lt;=</a> and <a href=\"../../language-reference/operators/greater-than-equal-operator\" data-linktype=\"relative-path\">&gt;=</a> operators.  </p>\n</li>\n</ol>\n<p> The first example that follows shows a class implementation. The second example shows a struct implementation.  </p>\n<h2 id=\"example\">Example</h2>\n<p> The following example shows how to implement value equality in a class (reference type).  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideStatements#19\">\n\nnamespace ValueEquality\n{\n    using System;\n    class TwoDPoint : IEquatable&lt;TwoDPoint&gt;\n    {\n        // Readonly auto-implemented properties.\n        public int X { get; private set; }\n        public int Y { get; private set; }\n\n        // Set the properties in the constructor.\n        public TwoDPoint(int x, int y)\n        {\n            if ((x &lt; 1) || (x &gt; 2000) || (y &lt; 1) || (y &gt; 2000))\n            {\n                throw new System.ArgumentException(&quot;Point must be in range 1 - 2000&quot;);\n            }\n            this.X = x;\n            this.Y = y;\n        }\n\n        public override bool Equals(object obj)\n        {\n            return this.Equals(obj as TwoDPoint);\n        }\n\n        public bool Equals(TwoDPoint p)\n        {\n            // If parameter is null, return false.\n            if (Object.ReferenceEquals(p, null))\n            {\n                return false;\n            }\n\n            // Optimization for a common success case.\n            if (Object.ReferenceEquals(this, p))\n            {\n                return true;\n            }\n\n            // If run-time types are not exactly the same, return false.\n            if (this.GetType() != p.GetType())\n            {\n                return false;\n            }\n\n            // Return true if the fields match.\n            // Note that the base class is not invoked because it is\n            // System.Object, which defines Equals as reference equality.\n            return (X == p.X) &amp;&amp; (Y == p.Y);\n        }\n\n        public override int GetHashCode()\n        {\n            return X * 0x00010000 + Y;\n        }\n\n        public static bool operator ==(TwoDPoint lhs, TwoDPoint rhs)\n        {\n            // Check for null on left side.\n            if (Object.ReferenceEquals(lhs, null))\n            {\n                if (Object.ReferenceEquals(rhs, null))\n                {\n                    // null == null = true.\n                    return true;\n                }\n\n                // Only the left side is null.\n                return false;\n            }\n            // Equals handles case of null on right side.\n            return lhs.Equals(rhs);\n        }\n\n        public static bool operator !=(TwoDPoint lhs, TwoDPoint rhs)\n        {\n            return !(lhs == rhs);\n        }\n    }\n\n    // For the sake of simplicity, assume a ThreeDPoint IS a TwoDPoint.\n    class ThreeDPoint : TwoDPoint, IEquatable&lt;ThreeDPoint&gt;\n    {\n        public int Z { get; private set; }\n\n        public ThreeDPoint(int x, int y, int z)\n            : base(x, y)\n        {\n            if ((z &lt; 1) || (z &gt; 2000))\n            {\n                throw new System.ArgumentException(&quot;Point must be in range 1 - 2000&quot;);\n            }    \n            this.Z = z;\n        }\n\n        public override bool Equals(object obj)\n        {\n            return this.Equals(obj as ThreeDPoint);\n        }\n\n        public bool Equals(ThreeDPoint p)\n        {\n            // If parameter is null, return false.\n            if (Object.ReferenceEquals(p, null))\n            {\n                return false;\n            }\n\n            // Optimization for a common success case.\n            if (Object.ReferenceEquals(this, p))\n            {\n                return true;\n            }\n\n            // Check properties that this class declares.\n            if (Z == p.Z)\n            {\n                // Let base class check its own fields \n                // and do the run-time type comparison.\n                return base.Equals((TwoDPoint)p);\n            }\n            else\n            {\n                return false;\n            }    \n        }\n\n        public override int GetHashCode()\n        {\n            return (X * 0x100000) + (Y * 0x1000) + Z;\n        }\n\n        public static bool operator ==(ThreeDPoint lhs, ThreeDPoint rhs)\n        {\n            // Check for null.\n            if (Object.ReferenceEquals(lhs, null))\n            {\n                if (Object.ReferenceEquals(rhs, null))\n                {\n                    // null == null = true.\n                    return true;\n                }\n\n                // Only the left side is null.\n                return false;\n            }\n            // Equals handles the case of null on right side.\n            return lhs.Equals(rhs);\n        }\n\n        public static bool operator !=(ThreeDPoint lhs, ThreeDPoint rhs)\n        {\n            return !(lhs == rhs);\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            ThreeDPoint pointA = new ThreeDPoint(3, 4, 5);\n            ThreeDPoint pointB = new ThreeDPoint(3, 4, 5);\n            ThreeDPoint pointC = null;\n            int i = 5;\n\n            Console.WriteLine(&quot;pointA.Equals(pointB) = {0}&quot;, pointA.Equals(pointB));\n            Console.WriteLine(&quot;pointA == pointB = {0}&quot;, pointA == pointB);\n            Console.WriteLine(&quot;null comparison = {0}&quot;, pointA.Equals(pointC));\n            Console.WriteLine(&quot;Compare to some other type = {0}&quot;, pointA.Equals(i));\n\n            TwoDPoint pointD = null;\n            TwoDPoint pointE = null;\n\n\n\n            Console.WriteLine(&quot;Two null TwoDPoints are equal: {0}&quot;, pointD == pointE);\n\n            pointE = new TwoDPoint(3, 4);\n            Console.WriteLine(&quot;(pointE == pointA) = {0}&quot;, pointE == pointA);\n            Console.WriteLine(&quot;(pointA == pointE) = {0}&quot;, pointA == pointE);\n            Console.WriteLine(&quot;(pointA != pointE) = {0}&quot;, pointA != pointE);\n\n            System.Collections.ArrayList list = new System.Collections.ArrayList();\n            list.Add(new ThreeDPoint(3, 4, 5));\n            Console.WriteLine(&quot;pointE.Equals(list[0]): {0}&quot;, pointE.Equals(list[0]));\n\n            // Keep the console window open in debug mode.\n            System.Console.WriteLine(&quot;Press any key to exit.&quot;);\n            System.Console.ReadKey();\n        }\n    }\n\n    /* Output:\n        pointA.Equals(pointB) = True\n        pointA == pointB = True\n        null comparison = False\n        Compare to some other type = False\n        Two null TwoDPoints are equal: True\n        (pointE == pointA) = False\n        (pointA == pointE) = False\n        (pointA != pointE) = True\n        pointE.Equals(list[0]): False\n    */\n}\n</code></pre><p> On classes (reference types), the default implementation of both <a class=\"xref\" href=\"../../../../api/system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">System.Object.Equals(Object)</a> methods performs a reference equality comparison, not a value equality check. When an implementer overrides the virtual method, the purpose is to give it value equality semantics.  </p>\n<p> The <code>==</code> and <code>!=</code> operators can be used with classes even if the class does not overload them. However, the default behavior is to perform a reference equality check. In a class, if you overload the <code>Equals</code> method, you should overload the <code>==</code> and <code>!=</code> operators, but it is not required.  </p>\n<h2 id=\"example-1\">Example</h2>\n<p> The following example shows how to implement value equality in a struct (value type):  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideStatements#20\">    struct TwoDPoint : IEquatable&lt;TwoDPoint&gt;\n    {\n        // Read/write auto-implemented properties.\n        public int X { get; private set; }\n        public int Y { get; private set; }\n\n        public TwoDPoint(int x, int y)\n            : this()\n        {\n            X = x;\n            Y = x;\n        }\n\n        public override bool Equals(object obj)\n        {\n            if (obj is TwoDPoint)\n            {\n                return this.Equals((TwoDPoint)obj);\n            }\n            return false;\n        }\n\n        public bool Equals(TwoDPoint p)\n        {\n            return (X == p.X) &amp;&amp; (Y == p.Y);\n        }\n\n        public override int GetHashCode()\n        {\n            return X ^ Y;\n        }\n\n        public static bool operator ==(TwoDPoint lhs, TwoDPoint rhs)\n        {\n            return lhs.Equals(rhs);\n        }\n\n        public static bool operator !=(TwoDPoint lhs, TwoDPoint rhs)\n        {\n            return !(lhs.Equals(rhs));\n        }\n    }\n\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            TwoDPoint pointA = new TwoDPoint(3, 4);\n            TwoDPoint pointB = new TwoDPoint(3, 4);\n            int i = 5;\n\n            // Compare using virtual Equals, static Equals, and == and != operators.\n            // True:\n            Console.WriteLine(&quot;pointA.Equals(pointB) = {0}&quot;, pointA.Equals(pointB));\n            // True:\n            Console.WriteLine(&quot;pointA == pointB = {0}&quot;, pointA == pointB);\n            // True:\n            Console.WriteLine(&quot;Object.Equals(pointA, pointB) = {0}&quot;, Object.Equals(pointA, pointB));\n            // False:\n            Console.WriteLine(&quot;pointA.Equals(null) = {0}&quot;, pointA.Equals(null));\n            // False:\n            Console.WriteLine(&quot;(pointA == null) = {0}&quot;, pointA == null);\n            // True:\n            Console.WriteLine(&quot;(pointA != null) = {0}&quot;, pointA != null);\n            // False:\n            Console.WriteLine(&quot;pointA.Equals(i) = {0}&quot;, pointA.Equals(i));\n            // CS0019:\n            // Console.WriteLine(&quot;pointA == i = {0}&quot;, pointA == i); \n\n            // Compare unboxed to boxed.\n            System.Collections.ArrayList list = new System.Collections.ArrayList();\n            list.Add(new TwoDPoint(3, 4));\n            // True:\n            Console.WriteLine(&quot;pointE.Equals(list[0]): {0}&quot;, pointA.Equals(list[0]));\n\n\n            // Compare nullable to nullable and to non-nullable.\n            TwoDPoint? pointC = null;\n            TwoDPoint? pointD = null;\n            // False:\n            Console.WriteLine(&quot;pointA == (pointC = null) = {0}&quot;, pointA == pointC);\n            // True:\n            Console.WriteLine(&quot;pointC == pointD = {0}&quot;, pointC == pointD);\n\n            TwoDPoint temp = new TwoDPoint(3, 4);\n            pointC = temp;\n            // True:\n            Console.WriteLine(&quot;pointA == (pointC = 3,4) = {0}&quot;, pointA == pointC);\n\n            pointD = temp;\n            // True:\n            Console.WriteLine(&quot;pointD == (pointC = 3,4) = {0}&quot;, pointD == pointC);\n\n            // Keep the console window open in debug mode.\n            System.Console.WriteLine(&quot;Press any key to exit.&quot;);\n            System.Console.ReadKey();\n        }\n    }\n\n    /* Output:\n        pointA.Equals(pointB) = True\n        pointA == pointB = True\n        Object.Equals(pointA, pointB) = True\n        pointA.Equals(null) = False\n        (pointA == null) = False\n        (pointA != null) = True\n        pointA.Equals(i) = False\n        pointE.Equals(list[0]): True\n        pointA == (pointC = null) = False\n        pointC == pointD = True\n        pointA == (pointC = 3,4) = True\n        pointD == (pointC = 3,4) = True\n    */\n}\n</code></pre><p> For structs, the default implementation of <a class=\"xref\" href=\"../../../../api/system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">System.Object.Equals(Object)</a> (which is the overridden version in <a class=\"xref\" href=\"../../../../api/system.valuetype\" data-linktype=\"relative-path\">System.ValueType</a>) performs a value equality check by using reflection to compare the values of every field in the type. When an implementer overrides the virtual <code>Equals</code> method in a struct, the purpose is to provide a more efficient means of performing the value equality check and optionally to base the comparison on some subset of the struct&#39;s field or properties.  </p>\n<p> The <a href=\"../../language-reference/operators/equality-comparison-operator\" data-linktype=\"relative-path\">==</a> and <a href=\"../../language-reference/operators/not-equal-operator\" data-linktype=\"relative-path\">!=</a> operators cannot operate on a struct unless the struct explicitly overloads them.  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"equality-comparisons\" data-linktype=\"relative-path\">Equality Comparisons</a><br> <a href=\"../index\" data-linktype=\"relative-path\">C# Programming Guide</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"ms.assetid\" content=\"4084581e-b931-498b-9534-cf7ef5b68690\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"15\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/e2d15b9142db8b4733c79718c061d561d725c5ab/docs/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type.md\">\r\n<meta name=\"document_id\" content=\"450a0024-24fb-c068-b5ed-df42d75d25d9\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"How to: Define Value Equality for a Type (C# Programming Guide) | Microsoft Docs","ms.assetid":"4084581e-b931-498b-9534-cf7ef5b68690","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":15,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["overriding Equals method [C#]","object equivalence [C#]","Equals method [C#] , overriding","value equality [C#]","equivalence [C#]"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Quintus Marais","author_email":"quintus.marais@opsi.co.za","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Add missing space","commit_sha":"e2d15b9142db8b4733c79718c061d561d725c5ab","commit_date":"2017-01-13 08:53:08 +0200"},{"author_name":"Quintus Marais","author_email":"quintus.marais@opsi.co.za","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Fix a typo (missed space)","commit_sha":"07564c6ab563b8e4498253640a2560c5d1612cb6","commit_date":"2017-01-12 13:57:12 +0200"},{"author_name":"Robert C. Seacord","author_email":"rcseacord@gmail.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"Update how-to-define-value-equality-for-a-type.md (#1349)","commit_sha":"ac32b4934fcdfee3c8d9d9f09e4f5cec95de8d61","commit_date":"2016-12-21 14:30:54 -0500"},{"author_name":"Robert C. Seacord","author_email":"rcseacord@gmail.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update how-to-define-value-equality-for-a-type.md","commit_sha":"43a4cb95bbf0204d61292d6b1b792e3f34122398","commit_date":"2016-12-21 09:50:49 -0500"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/quintusm","display_name":"Quintus Marais","id":"1206483"},{"profile_url":"https://github.com/rcseacord","display_name":"Robert C. Seacord","id":"3037076"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/e2d15b9142db8b4733c79718c061d561d725c5ab/docs/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type.md","document_id":"450a0024-24fb-c068-b5ed-df42d75d25d9","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type","toc_asset_id":"articles/csharp/programming-guide/statements-expressions-operators/toc.json","toc_rel":"toc.json","_op_ogTitle":"How to: Define Value Equality for a Type (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":1703,"_op_rawTitle":"<h1 id=\"how-to-define-value-equality-for-a-type-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type.md\" sourcestartlinenumber=\"40\" sourceendlinenumber=\"40\">How to: Define Value Equality for a Type (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type","fileRelativePath":"articles/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type.html"},"themesRelativePathToOutputRoot":"_themes/"}