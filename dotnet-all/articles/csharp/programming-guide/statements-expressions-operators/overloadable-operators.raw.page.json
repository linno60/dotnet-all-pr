{"content":"<div><div class=\"content\">\n<p>C# allows user-defined types to overload operators by defining static member functions using the <a href=\"../../language-reference/keywords/operator\" data-linktype=\"relative-path\">operator</a> keyword. Not all operators can be overloaded, however, and others have restrictions, as listed in this table:  </p>\n<table>\n<thead>\n<tr>\n<th>Operators</th>\n<th>Overloadability</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"../../language-reference/operators/addition-operator\" data-linktype=\"relative-path\">+</a>, <a href=\"../../language-reference/operators/subtraction-operator\" data-linktype=\"relative-path\">-</a>, <a href=\"../../language-reference/operators/logical-negation-operator\" data-linktype=\"relative-path\">!</a>, <a href=\"../../language-reference/operators/bitwise-complement-operator\" data-linktype=\"relative-path\">~</a>, <a href=\"../../language-reference/operators/increment-operator\" data-linktype=\"relative-path\">++</a>, <a href=\"../../language-reference/operators/decrement-operator\" data-linktype=\"relative-path\">--</a>, <a href=\"../../language-reference/keywords/true\" data-linktype=\"relative-path\">true</a>, <a href=\"../../language-reference/keywords/false\" data-linktype=\"relative-path\">false</a></td>\n<td>These unary operators can be overloaded.</td>\n</tr>\n<tr>\n<td><a href=\"../../language-reference/operators/addition-operator\" data-linktype=\"relative-path\">+</a>, <a href=\"../../language-reference/operators/subtraction-operator\" data-linktype=\"relative-path\">-</a>, <a href=\"../../language-reference/operators/multiplication-operator\" data-linktype=\"relative-path\">*</a>, <a href=\"../../language-reference/operators/division-operator\" data-linktype=\"relative-path\">/</a>, <a href=\"../../language-reference/operators/modulus-operator\" data-linktype=\"relative-path\">%</a>, <a href=\"../../language-reference/operators/and-operator\" data-linktype=\"relative-path\">&amp;</a>, <a href=\"../../language-reference/operators/or-operator\" data-linktype=\"relative-path\">&#124;</a>, <a href=\"../../language-reference/operators/xor-operator\" data-linktype=\"relative-path\">^</a>, <a href=\"../../language-reference/operators/left-shift-operator\" data-linktype=\"relative-path\">&lt;&lt;</a>, <a href=\"../../language-reference/operators/right-shift-operator\" data-linktype=\"relative-path\">&gt;&gt;</a></td>\n<td>These binary operators can be overloaded.</td>\n</tr>\n<tr>\n<td><a href=\"../../language-reference/operators/equality-comparison-operator\" data-linktype=\"relative-path\">==</a>, <a href=\"../../language-reference/operators/not-equal-operator\" data-linktype=\"relative-path\">!=</a>, <a href=\"../../language-reference/operators/less-than-operator\" data-linktype=\"relative-path\">&lt;</a>, <a href=\"../../language-reference/operators/greater-than-operator\" data-linktype=\"relative-path\">&gt;</a>, <a href=\"../../language-reference/operators/less-than-equal-operator\" data-linktype=\"relative-path\">&lt;=</a>, <a href=\"../../language-reference/operators/greater-than-equal-operator\" data-linktype=\"relative-path\">&gt;=</a></td>\n<td>The comparison operators can be overloaded (but see the note that follows this table).</td>\n</tr>\n<tr>\n<td><a href=\"../../language-reference/operators/conditional-and-operator\" data-linktype=\"relative-path\">&amp;&amp;</a>, <a href=\"../../language-reference/operators/conditional-or-operator\" data-linktype=\"relative-path\">&#124;&#124;</a></td>\n<td>The conditional logical operators cannot be overloaded, but they are evaluated using <code>&amp;</code> and <code>&amp;#124;</code>, which can be overloaded.</td>\n</tr>\n<tr>\n<td><a href=\"../../language-reference/operators/index-operator\" data-linktype=\"relative-path\">&#91;&#93;</a></td>\n<td>The array indexing operator cannot be overloaded, but you can define indexers.</td>\n</tr>\n<tr>\n<td><a href=\"../../language-reference/operators/invocation-operator\" data-linktype=\"relative-path\">(T)x</a></td>\n<td>The cast operator cannot be overloaded, but you can define new conversion operators (see <a href=\"../../language-reference/keywords/explicit\" data-linktype=\"relative-path\">explicit</a> and <a href=\"../../language-reference/keywords/implicit\" data-linktype=\"relative-path\">implicit</a>).</td>\n</tr>\n<tr>\n<td><a href=\"../../language-reference/operators/addition-assignment-operator\" data-linktype=\"relative-path\">+=</a>, <a href=\"../../language-reference/operators/subtraction-assignment-operator\" data-linktype=\"relative-path\">-=</a>, <a href=\"../../language-reference/operators/multiplication-assignment-operator\" data-linktype=\"relative-path\">*=</a>, <a href=\"../../language-reference/operators/division-assignment-operator\" data-linktype=\"relative-path\">/=</a>, <a href=\"../../language-reference/operators/modulus-assignment-operator\" data-linktype=\"relative-path\">%=</a>, <a href=\"../../language-reference/operators/and-assignment-operator\" data-linktype=\"relative-path\">&amp;=</a>, <a href=\"../../language-reference/operators/or-assignment-operator\" data-linktype=\"relative-path\">&#124;=</a>, <a href=\"../../language-reference/operators/xor-assignment-operator\" data-linktype=\"relative-path\">^=</a>, <a href=\"../../language-reference/operators/left-shift-assignment-operator\" data-linktype=\"relative-path\">&lt;&lt;=</a>, <a href=\"../../language-reference/operators/right-shift-assignment-operator\" data-linktype=\"relative-path\">&gt;&gt;=</a></td>\n<td>Assignment operators cannot be overloaded, but <code>+=</code>, for example, is evaluated using <code>+</code>, which can be overloaded.</td>\n</tr>\n<tr>\n<td><a href=\"../../language-reference/operators/assignment-operator\" data-linktype=\"relative-path\">=</a>, <a href=\"../../language-reference/operators/member-access-operator\" data-linktype=\"relative-path\">.</a>, <a href=\"../../language-reference/operators/conditional-operator\" data-linktype=\"relative-path\">?:</a>, <a href=\"../../language-reference/operators/null-conditional-operator\" data-linktype=\"relative-path\">??</a>, <a href=\"../../language-reference/operators/dereference-operator\" data-linktype=\"relative-path\">-&gt;</a>, <a href=\"../../language-reference/operators/lambda-operator\" data-linktype=\"relative-path\">=&gt;</a>, <a href=\"../../language-reference/operators/invocation-operator\" data-linktype=\"relative-path\">f(x)</a>, <a href=\"../../language-reference/keywords/as\" data-linktype=\"relative-path\">as</a>, <a href=\"../../language-reference/keywords/checked\" data-linktype=\"relative-path\">checked</a>, <a href=\"../../language-reference/keywords/unchecked\" data-linktype=\"relative-path\">unchecked</a>, <a href=\"../generics/default-keyword-in-generic-code\" data-linktype=\"relative-path\">default</a>, <a href=\"anonymous-methods\" data-linktype=\"relative-path\">delegate</a>, <a href=\"../../language-reference/keywords/is\" data-linktype=\"relative-path\">is</a>, <a href=\"../../language-reference/keywords/new\" data-linktype=\"relative-path\">new</a>, <a href=\"../../language-reference/keywords/sizeof\" data-linktype=\"relative-path\">sizeof</a>, <a href=\"../../language-reference/keywords/typeof\" data-linktype=\"relative-path\">typeof</a></td>\n<td>These operators cannot be overloaded.</td>\n</tr>\n</tbody>\n</table>\n<div class=\"NOTE\"><h5>Note</h5><p> The comparison operators, if overloaded, must be overloaded in pairs; that is, if <code>==</code> is overloaded, <code>!=</code> must also be overloaded. The reverse is also true, and similar for <code>&lt;</code> and <code>&gt;</code>, and for <code>&lt;=</code> and <code>&gt;=</code>.  </p>\n</div>\n<p> To overload an operator on a custom class requires creating a method on the class with the correct signature. The method must be named &quot;operator X&quot; where X is the name or symbol of the operator being overloaded. Unary operators have one parameter, and binary operators have two parameters. In each case, one parameter must be the same type as the class or struct that declares the operator.  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">public static Complex operator +(Complex c1, Complex c2)  \n    {  \n        Return new Complex(c1.real + c2.real, c1.imaginary + c2.imaginary);  \n    }  \n</code></pre><p> It is common to have definitions that simply return immediately with the result of an expression.  There is a syntax shortcut using <code>=&gt;</code> for these situations.  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">public static Complex operator +(Complex c1, Complex c2) =&gt;  \n        new Complex(c1.real + c2.real, c1.imaginary + c2.imaginary);  \n\n    // Override ToString() to display a complex number   \n    // in the traditional format:  \n    public override string ToString() =&gt; $&quot;{this.real} + {this.imaginary}&quot;;  \n</code></pre><p> For more information, see <a href=\"how-to-use-operator-overloading-to-create-a-complex-number-class\" data-linktype=\"relative-path\">How to: Use Operator Overloading to Create a Complex Number Class</a>.  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../index\" data-linktype=\"relative-path\">C# Programming Guide</a><br> <a href=\"index\" data-linktype=\"relative-path\">Statements, Expressions, and Operators</a><br> <a href=\"operators\" data-linktype=\"relative-path\">Operators</a><br> <a href=\"../../language-reference/operators/index\" data-linktype=\"relative-path\">C# Operators</a><br> <a href=\"http://go.microsoft.com/fwlink/?LinkId=112383\" data-linktype=\"external\">Why are overloaded operators always static in C#?</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet/toc2.json\">\r\n<meta name=\"ms.assetid\" content=\"390d9d01-79fc-40ab-9ed3-0bf448da1b6a\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"18\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/c954064337e3e77cbd09e61c64aa67a3c450743a/docs/csharp/programming-guide/statements-expressions-operators/overloadable-operators.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/statements-expressions-operators/overloadable-operators.md\">\r\n<meta name=\"document_id\" content=\"b8fcb9dc-b62d-b07f-ab44-e252b435fd2d\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Overloadable Operators (C# Programming Guide) | Microsoft Docs","ms.assetid":"390d9d01-79fc-40ab-9ed3-0bf448da1b6a","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":18,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["C# language, operator overloading","operator overloading [C#]"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Petr Onderka","author_email":"gsvick@gmail.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"Fixed C# operator titles (#1388)","commit_sha":"c954064337e3e77cbd09e61c64aa67a3c450743a","commit_date":"2017-01-06 11:27:09 -0500"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/svick","display_name":"Petr Onderka","id":"287848"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/c954064337e3e77cbd09e61c64aa67a3c450743a/docs/csharp/programming-guide/statements-expressions-operators/overloadable-operators.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/statements-expressions-operators/overloadable-operators.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/statements-expressions-operators/overloadable-operators.md","document_id":"b8fcb9dc-b62d-b07f-ab44-e252b435fd2d","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/statements-expressions-operators/overloadable-operators","toc_asset_id":"articles/csharp/programming-guide/statements-expressions-operators/toc.json","toc_rel":"toc.json","_op_ogTitle":"Overloadable Operators (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":402,"_op_rawTitle":"<h1 id=\"overloadable-operators-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/statements-expressions-operators/overloadable-operators.md\" sourcestartlinenumber=\"37\" sourceendlinenumber=\"37\">Overloadable Operators (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/statements-expressions-operators/overloadable-operators","fileRelativePath":"articles/csharp/programming-guide/statements-expressions-operators/overloadable-operators.html"},"themesRelativePathToOutputRoot":"_themes/"}