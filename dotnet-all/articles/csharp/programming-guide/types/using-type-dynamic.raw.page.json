{"content":"<div><div class=\"content\">\n<p>Visual C# 2010 introduces a new type, <code>dynamic</code>. The type is a static type, but an object of type <code>dynamic</code> bypasses static type checking. In most cases, it functions like it has type <code>object</code>. At compile time, an element that is typed as <code>dynamic</code> is assumed to support any operation. Therefore, you do not have to be concerned about whether the object gets its value from a COM API, from a dynamic language such as IronPython, from the HTML Document Object Model (DOM), from reflection, or from somewhere else in the program. However, if the code is not valid, errors are caught at run time.  </p>\n<p> For example, if instance method <code>exampleMethod1</code> in the following code has only one parameter, the compiler recognizes that the first call to the method, <code>ec.exampleMethod1(10, 4)</code>, is not valid because it contains two arguments. The call causes a compiler error. The second call to the method, <code>dynamic_ec.exampleMethod1(10, 4)</code>, is not checked by the compiler because the type of <code>dynamic_ec</code> is <code>dynamic</code>. Therefore, no compiler error is reported. However, the error does not escape notice indefinitely. It is caught at run time and causes a run-time exception.  </p>\n<pre><code class=\"lang-cs\" name=\"CsProgGuideTypes#50\">static void Main(string[] args)\n{\n    ExampleClass ec = new ExampleClass();\n    // The following call to exampleMethod1 causes a compiler error \n    // if exampleMethod1 has only one parameter. Uncomment the line\n    // to see the error.\n    //ec.exampleMethod1(10, 4);\n\n    dynamic dynamic_ec = new ExampleClass();\n    // The following line is not identified as an error by the\n    // compiler, but it causes a run-time exception.\n    dynamic_ec.exampleMethod1(10, 4);\n\n    // The following calls also do not cause compiler errors, whether \n    // appropriate methods exist or not.\n    dynamic_ec.someMethod(&quot;some argument&quot;, 7, null);\n    dynamic_ec.nonexistentMethod();\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"CsProgGuideTypes#56\">class ExampleClass\n{\n    public ExampleClass() { }\n    public ExampleClass(int v) { }\n\n    public void exampleMethod1(int i) { }\n\n    public void exampleMethod2(string str) { }\n}\n</code></pre><p> The role of the compiler in these examples is to package together information about what each statement is proposing to do to the object or expression that is typed as <code>dynamic</code>. At run time, the stored information is examined, and any statement that is not valid causes a run-time exception.  </p>\n<p> The result of most dynamic operations is itself <code>dynamic</code>. For example, if you rest the mouse pointer over the use of <code>testSum</code> in the following example, IntelliSense displays the type <strong>(local variable) dynamic testSum</strong>.  </p>\n<pre><code class=\"lang-cs\" name=\"CsProgGuideTypes#51\">dynamic d = 1;\nvar testSum = d + 3;\n// Rest the mouse pointer over testSum in the following statement.\nSystem.Console.WriteLine(testSum);\n</code></pre><p> Operations in which the result is not <code>dynamic</code> include conversions from <code>dynamic</code> to another type, and constructor calls that include arguments of type <code>dynamic</code>. For example, the type of <code>testInstance</code> in the following declaration is <code>ExampleClass</code>, not <code>dynamic</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"CsProgGuideTypes#52\">var testInstance = new ExampleClass(d);\n</code></pre><p> Conversion examples are shown in the following section, &quot;Conversions.&quot;  </p>\n<h2 id=\"conversions\">Conversions</h2>\n<p> Conversions between dynamic objects and other types are easy. This enables the developer to switch between dynamic and non-dynamic behavior.  </p>\n<p> Any object can be converted to dynamic type implicitly, as shown in the following examples.  </p>\n<pre><code class=\"lang-cs\" name=\"CsProgGuideTypes#53\">dynamic d1 = 7;\ndynamic d2 = &quot;a string&quot;;\ndynamic d3 = System.DateTime.Today;\ndynamic d4 = System.Diagnostics.Process.GetProcesses();\n</code></pre><p> Conversely, an implicit conversion can be dynamically applied to any expression of type <code>dynamic</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"CsProgGuideTypes#54\">int i = d1;\nstring str = d2;\nDateTime dt = d3;\nSystem.Diagnostics.Process[] procs = d4;\n</code></pre><h2 id=\"overload-resolution-with-arguments-of-type-dynamic\">Overload Resolution with Arguments of Type dynamic</h2>\n<p> Overload resolution occurs at run time instead of at compile time if one or more of the arguments in a method call have the type <code>dynamic</code>, or if the receiver of the method call is of type <code>dynamic</code>. In the following example, if the only accessible <code>exampleMethod2</code> method is defined to take a string argument, sending <code>d1</code> as the argument does not cause a compiler error, but it does cause a run-time exception. Overload resolution fails at run time because the run-time type of <code>d1</code> is <code>int</code>, and <code>exampleMethod2</code> requires a string.  </p>\n<pre><code class=\"lang-cs\" name=\"CsProgGuideTypes#55\">// Valid.\nec.exampleMethod2(&quot;a string&quot;);\n\n// The following statement does not cause a compiler error, even though ec is not\n// dynamic. A run-time exception is raised because the run-time type of d1 is int.\nec.exampleMethod2(d1);\n// The following statement does cause a compiler error.\n//ec.exampleMethod2(7);\n</code></pre><h2 id=\"dynamic-language-runtime\">Dynamic Language Runtime</h2>\n<p> The dynamic language runtime (DLR) is a new API in .NET Framework 4. It provides the infrastructure that supports the <code>dynamic</code> type in C#, and also the implementation of dynamic programming languages such as IronPython and IronRuby. For more information about the DLR, see <a href=\"http://msdn.microsoft.com/library/f769a271-8aff-4bea-bfab-6160217ce23d\" data-linktype=\"external\">Dynamic Language Runtime Overview</a>.  </p>\n<h2 id=\"com-interop\">COM Interop</h2>\n<p> Visual C# 2010 includes several features that improve the experience of interoperating with COM APIs such as the Office Automation APIs. Among the improvements are the use of the <code>dynamic</code> type, and of <a href=\"../classes-and-structs/named-and-optional-arguments\" data-linktype=\"relative-path\">named and optional arguments</a>.  </p>\n<p> Many COM methods allow for variation in argument types and return type by designating the types as <code>object</code>. This has necessitated explicit casting of the values to coordinate with strongly typed variables in C#. If you compile by using the <a href=\"../../language-reference/compiler-options/link-compiler-option\" data-linktype=\"relative-path\">/link (C# Compiler Options)</a> option, the introduction of the <code>dynamic</code> type enables you to treat the occurrences of <code>object</code> in COM signatures as if they were of type <code>dynamic</code>, and thereby to avoid much of the casting. For example, the following statements contrast how you access a cell in a Microsoft Office Excel spreadsheet with the <code>dynamic</code> type and without the <code>dynamic</code> type.  </p>\n<pre><code class=\"lang-cs\" name=\"csOfficeWalkthrough#12\">// Before the introduction of dynamic.\n((Excel.Range)excelApp.Cells[1, 1]).Value2 = &quot;Name&quot;;\nExcel.Range range2008 = (Excel.Range)excelApp.Cells[1, 1];\n</code></pre><pre><code class=\"lang-cs\" name=\"csOfficeWalkthrough#13\">// After the introduction of dynamic, the access to the Value property and\n// the conversion to Excel.Range are handled by the run-time COM binder.\nexcelApp.Cells[1, 1].Value = &quot;Name&quot;;\nExcel.Range range2010 = excelApp.Cells[1, 1];\n</code></pre><h2 id=\"related-topics\">Related Topics</h2>\n<table>\n<thead>\n<tr>\n<th>Title</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"../../language-reference/keywords/dynamic\" data-linktype=\"relative-path\">dynamic</a></td>\n<td>Describes the usage of the <code>dynamic</code> keyword.</td>\n</tr>\n<tr>\n<td><a href=\"http://msdn.microsoft.com/library/f769a271-8aff-4bea-bfab-6160217ce23d\" data-linktype=\"external\">Dynamic Language Runtime Overview</a></td>\n<td>Provides an overview of the DLR, which is a runtime environment that adds a set of services for dynamic languages to the common language runtime (CLR).</td>\n</tr>\n<tr>\n<td><a href=\"walkthrough-creating-and-using-dynamic-objects\" data-linktype=\"relative-path\">Walkthrough: Creating and Using Dynamic Objects</a></td>\n<td>Provides step-by-step instructions for creating a custom dynamic object and for creating a project that accesses an <code>IronPython</code> library.</td>\n</tr>\n<tr>\n<td><a href=\"../interop/how-to-access-office-onterop-objects\" data-linktype=\"relative-path\">How to: Access Office Interop Objects by Using Visual C# Features</a></td>\n<td>Demonstrates how to create a project that uses named and optional arguments, the <code>dynamic</code> type, and other enhancements that simplify access to Office API objects.</td>\n</tr>\n</tbody>\n</table>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc1.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.assetid\" content=\"3828989d-c967-4a51-b948-857ebc8fdf26\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"30\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/types/using-type-dynamic.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/types/using-type-dynamic.md\">\r\n<meta name=\"document_id\" content=\"fba5f45a-511d-b337-0da4-e1d0878880cf\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc1.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","title":"Using Type dynamic (C# Programming Guide) | Microsoft Docs","ms.assetid":"3828989d-c967-4a51-b948-857ebc8fdf26","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":30,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["dynamic [C#], about dynamic type","dynamic type [C#]"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/types/using-type-dynamic.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/types/using-type-dynamic.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/types/using-type-dynamic.md","document_id":"fba5f45a-511d-b337-0da4-e1d0878880cf","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/types/using-type-dynamic","toc_asset_id":"articles/csharp/programming-guide/types/toc.json","toc_rel":"toc.json","_op_ogTitle":"Using Type dynamic (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":1033,"_op_rawTitle":"<h1 id=\"using-type-dynamic-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/types/using-type-dynamic.md\" sourcestartlinenumber=\"37\" sourceendlinenumber=\"37\">Using Type dynamic (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/types/using-type-dynamic","fileRelativePath":"articles/csharp/programming-guide/types/using-type-dynamic.html"},"themesRelativePathToOutputRoot":"_themes/"}