{"content":"<div><div class=\"content\">\n<p>Boxing is the process of converting a <a href=\"../../language-reference/keywords/value-types\" data-linktype=\"relative-path\">value type</a> to the type <code>object</code> or to any interface type implemented by this value type. When the CLR boxes a value type, it wraps the value inside a System.Object and stores it on the managed heap. Unboxing extracts the value type from the object. Boxing is implicit; unboxing is explicit. The concept of boxing and unboxing underlies the C# unified view of the type system in which a value of any type can be treated as an object.  </p>\n<p> In the following example, the integer variable <code>i</code> is <em>boxed</em> and assigned to object <code>o</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideTypes#14\">int i = 123;\n// The following line boxes i.\nobject o = i;  \n</code></pre><p> The object <code>o</code> can then be unboxed and assigned to integer variable <code>i</code>:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideTypes#15\">o = 123;\ni = (int)o;  // unboxing\n</code></pre><p> The following examples illustrate how boxing is used in C#.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideTypes#47\">// String.Concat example.\n// String.Concat has many versions. Rest the mouse pointer on \n// Concat in the following statement to verify that the version\n// that is used here takes three object arguments. Both 42 and\n// true must be boxed.\nConsole.WriteLine(String.Concat(&quot;Answer&quot;, 42, true));\n\n\n// List example.\n// Create a list of objects to hold a heterogeneous collection \n// of elements.\nList&lt;object&gt; mixedList = new List&lt;object&gt;();\n\n// Add a string element to the list. \nmixedList.Add(&quot;First Group:&quot;);\n\n// Add some integers to the list. \nfor (int j = 1; j &lt; 5; j++)\n{\n    // Rest the mouse pointer over j to verify that you are adding\n    // an int to a list of objects. Each element j is boxed when \n    // you add j to mixedList.\n    mixedList.Add(j);\n}\n\n// Add another string and more integers.\nmixedList.Add(&quot;Second Group:&quot;);\nfor (int j = 5; j &lt; 10; j++)\n{\n    mixedList.Add(j);\n}\n\n// Display the elements in the list. Declare the loop variable by \n// using var, so that the compiler assigns its type.\nforeach (var item in mixedList)\n{\n    // Rest the mouse pointer over item to verify that the elements\n    // of mixedList are objects.\n    Console.WriteLine(item);\n}\n\n// The following loop sums the squares of the first group of boxed\n// integers in mixedList. The list elements are objects, and cannot\n// be multiplied or added to the sum until they are unboxed. The\n// unboxing must be done explicitly.\nvar sum = 0;\nfor (var j = 1; j &lt; 5; j++)\n{\n    // The following statement causes a compiler error: Operator \n    // &#39;*&#39; cannot be applied to operands of type &#39;object&#39; and\n    // &#39;object&#39;. \n    //sum += mixedList[j] * mixedList[j]);\n\n    // After the list elements are unboxed, the computation does \n    // not cause a compiler error.\n    sum += (int)mixedList[j] * (int)mixedList[j];\n}\n\n// The sum displayed is 30, the sum of 1 + 4 + 9 + 16.\nConsole.WriteLine(&quot;Sum: &quot; + sum);\n\n// Output:\n// Answer42True\n// First Group:\n// 1\n// 2\n// 3\n// 4\n// Second Group:\n// 5\n// 6\n// 7\n// 8\n// 9\n// Sum: 30\n</code></pre><h2 id=\"performance\">Performance</h2>\n<p> In relation to simple assignments, boxing and unboxing are computationally expensive processes. When a value type is boxed, a new object must be allocated and constructed. To a lesser degree, the cast required for unboxing is also expensive computationally. For more information, see <a href=\"https://msdn.microsoft.com/library/ms173196(VS.110).aspx\" data-linktype=\"external\">Performance</a>.  </p>\n<h2 id=\"boxing\">Boxing</h2>\n<p> Boxing is used to store value types in the garbage-collected heap. Boxing is an implicit conversion of a <a href=\"../../language-reference/keywords/value-types\" data-linktype=\"relative-path\">value type</a> to the type <code>object</code> or to any interface type implemented by this value type. Boxing a value type allocates an object instance on the heap and copies the value into the new object.  </p>\n<p> Consider the following declaration of a value-type variable:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideTypes#17\">int i = 123;\n</code></pre><p> The following statement implicitly applies the boxing operation on the variable <code>i</code>:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideTypes#18\">// Boxing copies the value of i into object o.\nobject o = i;  \n</code></pre><p> The result of this statement is creating an object reference <code>o</code>, on the stack, that references a value of the type <code>int</code>, on the heap. This value is a copy of the value-type value assigned to the variable <code>i</code>. The difference between the two variables, <code>i</code> and <code>o</code>, is illustrated in the following figure.  </p>\n<p> <img src=\"media/vcboxingconversion.gif\" alt=\"BoxingConversion graphic\" title=\"vcBoxingConversion\" data-linktype=\"relative-path\"><br>Boxing Conversion  </p>\n<p> It is also possible to perform the boxing explicitly as in the following example, but explicit boxing is never required:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideTypes#19\">int i = 123;\nobject o = (object)i;  // explicit boxing\n</code></pre><h2 id=\"description\">Description</h2>\n<p> This example converts an integer variable <code>i</code> to an object <code>o</code> by using boxing. Then, the value stored in the variable <code>i</code> is changed from <code>123</code> to <code>456</code>. The example shows that the original value type and the boxed object use separate memory locations, and therefore can store different values.  </p>\n<h2 id=\"example\">Example</h2>\n<pre><code class=\"lang-cs\" name=\"csProgGuideTypes#16\">class TestBoxing\n{\n    static void Main()\n    {\n        int i = 123;\n\n        // Boxing copies the value of i into object o.\n        object o = i;  \n\n        // Change the value of i.\n        i = 456;  \n\n        // The change in i does not effect the value stored in o.\n        System.Console.WriteLine(&quot;The value-type value = {0}&quot;, i);\n        System.Console.WriteLine(&quot;The object-type value = {0}&quot;, o);\n    }\n}\n/* Output:\n    The value-type value = 456\n    The object-type value = 123\n*/\n</code></pre><h2 id=\"unboxing\">Unboxing</h2>\n<p> Unboxing is an explicit conversion from the type <code>object</code> to a <a href=\"../../language-reference/keywords/value-types\" data-linktype=\"relative-path\">value type</a> or from an interface type to a value type that implements the interface. An unboxing operation consists of:  </p>\n<ul>\n<li><p>Checking the object instance to make sure that it is a boxed value of the given value type.  </p>\n</li>\n<li><p>Copying the value from the instance into the value-type variable.  </p>\n<p>The following statements demonstrate both boxing and unboxing operations:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideTypes#21\">int i = 123;      // a value type\nobject o = i;     // boxing\nint j = (int)o;   // unboxing\n</code></pre><p>The following figure demonstrates the result of the previous statements.  </p>\n<p><img src=\"media/vcunboxingconversion.gif\" alt=\"UnBoxing Conversion graphic\" title=\"vcUnBoxingConversion\" data-linktype=\"relative-path\"><br>Unboxing Conversion  </p>\n<p>For the unboxing of value types to succeed at run time, the item being unboxed must be a reference to an object that was previously created by boxing an instance of that value type. Attempting to unbox <code>null</code> causes a <a class=\"xref\" href=\"../../../../api/system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a>. Attempting to unbox a reference to an incompatible value type causes an <a class=\"xref\" href=\"../../../../api/system.invalidcastexception\" data-linktype=\"relative-path\">InvalidCastException</a>.  </p>\n</li>\n</ul>\n<h2 id=\"example-1\">Example</h2>\n<p> The following example demonstrates a case of invalid unboxing and the resulting <code>InvalidCastException</code>. Using <code>try</code> and <code>catch</code>, an error message is displayed when the error occurs.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideTypes#20\">class TestUnboxing\n{\n    static void Main()\n    {\n        int i = 123;\n        object o = i;  // implicit boxing\n\n        try\n        {\n            int j = (short)o;  // attempt to unbox\n\n            System.Console.WriteLine(&quot;Unboxing OK.&quot;);\n        }\n        catch (System.InvalidCastException e)\n        {\n            System.Console.WriteLine(&quot;{0} Error: Incorrect unboxing.&quot;, e.Message);\n        }\n    }\n}\n</code></pre><p> This program outputs:  </p>\n<p> <code>Specified cast is not valid. Error: Incorrect unboxing.</code>  </p>\n<p> If you change the statement:  </p>\n<pre class=\"loading\"><code>int j = (short) o;  \n</code></pre><p> to:  </p>\n<pre class=\"loading\"><code>int j = (int) o;  \n</code></pre><p> the conversion will be performed, and you will get the output:  </p>\n<p> <code>Unboxing OK.</code>  </p>\n<h2 id=\"c-language-specification\">C# Language Specification</h2>\n<p>For more information, see the <a href=\"../../language-reference/language-specification\" data-linktype=\"relative-path\">C# Language Specification</a>. The language specification is the definitive source for C# syntax and usage.</p>\n<h2 id=\"related-sections\">Related Sections</h2>\n<p> For more information:  </p>\n<ul>\n<li><p><a href=\"../../language-reference/keywords/reference-types\" data-linktype=\"relative-path\">Reference Types</a>  </p>\n</li>\n<li><p><a href=\"../../language-reference/keywords/value-types\" data-linktype=\"relative-path\">Value Types</a>  </p>\n</li>\n</ul>\n<h2 id=\"c-language-specification-1\">C# Language Specification</h2>\n<p>For more information, see the <a href=\"../../language-reference/language-specification\" data-linktype=\"relative-path\">C# Language Specification</a>. The language specification is the definitive source for C# syntax and usage.</p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../index\" data-linktype=\"relative-path\">C# Programming Guide</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"ms.assetid\" content=\"8da9bbf4-bce9-4b08-b2e5-f64c11c56514\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"34\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"translation.priority.mt\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.mt\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.mt\" content=\"pt-br\">\r\n<meta name=\"translation.priority.mt\" content=\"tr-tr\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/types/boxing-and-unboxing.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/types/boxing-and-unboxing.md\">\r\n<meta name=\"document_id\" content=\"6559322c-a554-da37-c8c0-b6baa25eb5c0\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","uhfHeaderId":"MSDocsHeader-DotNet","title":"Boxing and Unboxing (C# Programming Guide) | Microsoft Docs","ms.assetid":"8da9bbf4-bce9-4b08-b2e5-f64c11c56514","f1_keywords":["cs.boxing"],"translation.priority.ht":["de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","ru-ru","zh-cn","zh-tw"],"caps.latest.revision":34,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["C# language, boxing","C# language, unboxing","unboxing [C#]","boxing [C#]"],"translation.priority.mt":["cs-cz","pl-pl","pt-br","tr-tr"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/types/boxing-and-unboxing.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/types/boxing-and-unboxing.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/types/boxing-and-unboxing.md","document_id":"6559322c-a554-da37-c8c0-b6baa25eb5c0","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/types/boxing-and-unboxing","toc_asset_id":"articles/csharp/programming-guide/types/toc.json","toc_rel":"toc.json","_op_ogTitle":"Boxing and Unboxing (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":1172,"_op_rawTitle":"<h1 id=\"boxing-and-unboxing-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/types/boxing-and-unboxing.md\" sourcestartlinenumber=\"42\" sourceendlinenumber=\"42\">Boxing and Unboxing (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/types/boxing-and-unboxing","fileRelativePath":"articles/csharp/programming-guide/types/boxing-and-unboxing.html"},"themesRelativePathToOutputRoot":"_themes/"}