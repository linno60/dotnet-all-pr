{"content":"<div><div class=\"content\">\n<p>The phrase &quot;iterate a directory tree&quot; means to access each file in each nested subdirectory under a specified root folder, to any depth. You do not necessarily have to open each file. You can just retrieve the name of the file or subdirectory as a <code>string</code>, or you can retrieve additional information in the form of a <a class=\"xref\" href=\"../../../../api/system.io.fileinfo\" data-linktype=\"relative-path\">System.IO.FileInfo</a> or <a class=\"xref\" href=\"../../../../api/system.io.directoryinfo\" data-linktype=\"relative-path\">System.IO.DirectoryInfo</a> object.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> In Windows, the terms &quot;directory&quot; and &quot;folder&quot; are used interchangeably. Most documentation and user interface text uses the term &quot;folder,&quot; but the .NET Framework class library uses the term &quot;directory.&quot;  </p>\n</div>\n<p> In the simplest case, in which you know for certain that you have access permissions for all directories under a specified root, you can use the <code>System.IO.SearchOption.AllDirectories</code> flag. This flag returns all the nested subdirectories that match the specified pattern. The following example shows how to use this flag.  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">root.GetDirectories(&quot;*.*&quot;, System.IO.SearchOption.AllDirectories);  \n</code></pre><p> The weakness in this approach is that if any one of the subdirectories under the specified root causes a <a class=\"xref\" href=\"../../../../api/system.io.directorynotfoundexception\" data-linktype=\"relative-path\">DirectoryNotFoundException</a> or <a class=\"xref\" href=\"../../../../api/system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a>, the whole method fails and returns no directories. The same is true when you use the <a class=\"xref\" href=\"../../../../api/system.io.directoryinfo#System_IO_DirectoryInfo_GetFiles_\" data-linktype=\"relative-path\">GetFiles</a> method. If you have to handle these exceptions on specific subfolders, you must manually walk the directory tree, as shown in the following examples.  </p>\n<p> When you manually walk a directory tree, you can handle the subdirectories first (<em>pre-order traversal</em>), or the files first (<em>post-order traversal</em>). If you perform a pre-order traversal, you walk the whole tree under the current folder before iterating through the files that are directly in that folder itself. The examples later in this document perform post-order traversal, but you can easily modify them to perform pre-order traversal.  </p>\n<p> Another option is whether to use recursion or a stack-based traversal. The examples later in this document show both approaches.  </p>\n<p> If you have to perform a variety of operations on files and folders, you can modularize these examples by refactoring the operation into separate functions that you can invoke by using a single delegate.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> NTFS file systems can contain <em>reparse points</em> in the form of <em>junction points</em>, <em>symbolic links</em>, and <em>hard links</em>. The .NET Framework methods such as <a class=\"xref\" href=\"../../../../api/system.io.directoryinfo#System_IO_DirectoryInfo_GetFiles_\" data-linktype=\"relative-path\">GetFiles</a> and <a class=\"xref\" href=\"../../../../api/system.io.directoryinfo#System_IO_DirectoryInfo_GetDirectories_\" data-linktype=\"relative-path\">GetDirectories</a> will not return any subdirectories under a reparse point. This behavior guards against the risk of entering into an infinite loop when two reparse points refer to each other. In general, you should use extreme caution when you deal with reparse points to ensure that you do not unintentionally modify or delete files. If you require precise control over reparse points, use platform invoke or native code to call the appropriate Win32 file system methods directly.  </p>\n</div>\n<h2 id=\"example\">Example</h2>\n<p> The following example shows how to walk a directory tree by using recursion. The recursive approach is elegant but has the potential to cause a stack overflow exception if the directory tree is large and deeply nested.  </p>\n<p> The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only. You should modify this code to meet your specific requirements. See the comments in the code for more information.  </p>\n<pre><code class=\"lang-cs\" name=\"csFilesandFolders#1\">public class RecursiveFileSearch\n{\n    static System.Collections.Specialized.StringCollection log = new System.Collections.Specialized.StringCollection();\n\n    static void Main()\n    {\n        // Start with drives if you have to search the entire computer.\n        string[] drives = System.Environment.GetLogicalDrives();\n\n        foreach (string dr in drives)\n        {\n            System.IO.DriveInfo di = new System.IO.DriveInfo(dr);\n\n            // Here we skip the drive if it is not ready to be read. This\n            // is not necessarily the appropriate action in all scenarios.\n            if (!di.IsReady)\n            {\n                Console.WriteLine(&quot;The drive {0} could not be read&quot;, di.Name);\n                continue;\n            }\n            System.IO.DirectoryInfo rootDir = di.RootDirectory;\n            WalkDirectoryTree(rootDir);\n        }\n\n        // Write out all the files that could not be processed.\n        Console.WriteLine(&quot;Files with restricted access:&quot;);\n        foreach (string s in log)\n        {\n            Console.WriteLine(s);\n        }\n        // Keep the console window open in debug mode.\n        Console.WriteLine(&quot;Press any key&quot;);\n        Console.ReadKey();\n    }\n\n    static void WalkDirectoryTree(System.IO.DirectoryInfo root)\n    {\n        System.IO.FileInfo[] files = null;\n        System.IO.DirectoryInfo[] subDirs = null;\n\n        // First, process all the files directly under this folder\n        try\n        {\n            files = root.GetFiles(&quot;*.*&quot;);\n        }\n        // This is thrown if even one of the files requires permissions greater\n        // than the application provides.\n        catch (UnauthorizedAccessException e)\n        {\n            // This code just writes out the message and continues to recurse.\n            // You may decide to do something different here. For example, you\n            // can try to elevate your privileges and access the file again.\n            log.Add(e.Message);\n        }\n\n        catch (System.IO.DirectoryNotFoundException e)\n        {\n            Console.WriteLine(e.Message);\n        }\n        \n        if (files != null)\n        {\n            foreach (System.IO.FileInfo fi in files)\n            {\n                // In this example, we only access the existing FileInfo object. If we\n                // want to open, delete or modify the file, then\n                // a try-catch block is required here to handle the case\n                // where the file has been deleted since the call to TraverseTree().\n                Console.WriteLine(fi.FullName);\n            }\n\n            // Now find all the subdirectories under this directory.\n            subDirs = root.GetDirectories();\n\n            foreach (System.IO.DirectoryInfo dirInfo in subDirs)\n            {\n                // Resursive call for each subdirectory.\n                WalkDirectoryTree(dirInfo);\n            }\n        }            \n    }\n}\n</code></pre><h2 id=\"example-1\">Example</h2>\n<p> The following example shows how to iterate through files and folders in a directory tree without using recursion. This technique uses the generic <a class=\"xref\" href=\"../../../../api/system.collections.generic.stack-1\" data-linktype=\"relative-path\">Stack&lt;T&gt;</a> collection type, which is a last in first out (LIFO) stack.  </p>\n<p> The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only. You should modify this code to meet your specific requirements. See the comments in the code for more information.  </p>\n<pre><code class=\"lang-cs\" name=\"csFilesandFolders#2\">public class StackBasedIteration\n{\n    static void Main(string[] args)\n    {\n        // Specify the starting folder on the command line, or in \n        // Visual Studio in the Project &gt; Properties &gt; Debug pane.\n        TraverseTree(args[0]);\n\n        Console.WriteLine(&quot;Press any key&quot;);\n        Console.ReadKey();\n    }\n\n    public static void TraverseTree(string root)\n    {\n        // Data structure to hold names of subfolders to be\n        // examined for files.\n        Stack&lt;string&gt; dirs = new Stack&lt;string&gt;(20);\n\n        if (!System.IO.Directory.Exists(root))\n        {\n            throw new ArgumentException();\n        }\n        dirs.Push(root);\n\n        while (dirs.Count &gt; 0)\n        {\n            string currentDir = dirs.Pop();\n            string[] subDirs;\n            try\n            {\n                subDirs = System.IO.Directory.GetDirectories(currentDir);\n            }\n            // An UnauthorizedAccessException exception will be thrown if we do not have\n            // discovery permission on a folder or file. It may or may not be acceptable \n            // to ignore the exception and continue enumerating the remaining files and \n            // folders. It is also possible (but unlikely) that a DirectoryNotFound exception \n            // will be raised. This will happen if currentDir has been deleted by\n            // another application or thread after our call to Directory.Exists. The \n            // choice of which exceptions to catch depends entirely on the specific task \n            // you are intending to perform and also on how much you know with certainty \n            // about the systems on which this code will run.\n            catch (UnauthorizedAccessException e)\n            {                    \n                Console.WriteLine(e.Message);\n                continue;\n            }\n            catch (System.IO.DirectoryNotFoundException e)\n            {\n                Console.WriteLine(e.Message);\n                continue;\n            }\n\n            string[] files = null;\n            try\n            {\n                files = System.IO.Directory.GetFiles(currentDir);\n            }\n\n            catch (UnauthorizedAccessException e)\n            {\n                \n                Console.WriteLine(e.Message);\n                continue;\n            }\n\n            catch (System.IO.DirectoryNotFoundException e)\n            {\n                Console.WriteLine(e.Message);\n                continue;\n            }\n            // Perform the required action on each file here.\n            // Modify this block to perform your required task.\n            foreach (string file in files)\n            {\n                try\n                {\n                    // Perform whatever action is required in your scenario.\n                    System.IO.FileInfo fi = new System.IO.FileInfo(file);\n                    Console.WriteLine(&quot;{0}: {1}, {2}&quot;, fi.Name, fi.Length, fi.CreationTime);\n                }\n                catch (System.IO.FileNotFoundException e)\n                {\n                    // If file was deleted by a separate application\n                    //  or thread since the call to TraverseTree()\n                    // then just continue.\n                    Console.WriteLine(e.Message);\n                    continue;\n                }\n            }\n\n            // Push the subdirectories onto the stack for traversal.\n            // This could also be done before handing the files.\n            foreach (string str in subDirs)\n                dirs.Push(str);\n        }\n    }\n}\n</code></pre><p> It is generally too time-consuming to test every folder to determine whether your application has permission to open it. Therefore, the code example just encloses that part of the operation in a <code>try/catch</code> block. You can modify the <code>catch</code> block so that when you are denied access to a folder, you try to elevate your permissions and then access it again. As a rule, only catch those exceptions that you can handle without leaving your application in an unknown state.  </p>\n<p> If you must store the contents of a directory tree, either in memory or on disk, the best option is to store only the <a class=\"xref\" href=\"../../../../api/system.io.filesysteminfo#System_IO_FileSystemInfo_FullName_\" data-linktype=\"relative-path\">FullName</a> property (of type <code>string</code>) for each file. You can then use this string to create a new <a class=\"xref\" href=\"../../../../api/system.io.fileinfo\" data-linktype=\"relative-path\">FileInfo</a> or <a class=\"xref\" href=\"../../../../api/system.io.directoryinfo\" data-linktype=\"relative-path\">DirectoryInfo</a> object as necessary, or open any file that requires additional processing.  </p>\n<h2 id=\"robust-programming\">Robust Programming</h2>\n<p> Robust file iteration code must take into account many complexities of the file system. For more information, see <a href=\"http://go.microsoft.com/fwlink/?LinkId=79488\" data-linktype=\"external\">NTFS Technical Reference</a>.  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a class=\"xref\" href=\"../../../../api/system.io\" data-linktype=\"relative-path\">System.IO</a><br> <a href=\"http://msdn.microsoft.com/library/5a5d516c-0279-4a84-ac84-b87f54caa808\" data-linktype=\"external\">LINQ and File Directories</a><br> <a href=\"index\" data-linktype=\"relative-path\">File System and the Registry (C# Programming Guide)</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"ms.assetid\" content=\"c4be4a75-6b1b-46a7-9d38-bab353091ed7\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"10\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/3115359729431ecbcc16058612da59b85621fa0f/docs/csharp/programming-guide/file-system/how-to-iterate-through-a-directory-tree.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/file-system/how-to-iterate-through-a-directory-tree.md\">\r\n<meta name=\"document_id\" content=\"482d86dd-0a35-ece9-4e8e-11aeec94548f\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"How to: Iterate Through a Directory Tree (C# Programming Guide) | Microsoft Docs","ms.assetid":"c4be4a75-6b1b-46a7-9d38-bab353091ed7","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":10,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["iterating through folders [C#]","file iteration [C#]"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize the C# Guide TOC (#1318)","commit_sha":"3115359729431ecbcc16058612da59b85621fa0f","commit_date":"2017-01-23 23:20:14 -0500"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/3115359729431ecbcc16058612da59b85621fa0f/docs/csharp/programming-guide/file-system/how-to-iterate-through-a-directory-tree.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/file-system/how-to-iterate-through-a-directory-tree.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/file-system/how-to-iterate-through-a-directory-tree.md","document_id":"482d86dd-0a35-ece9-4e8e-11aeec94548f","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/file-system/how-to-iterate-through-a-directory-tree","toc_asset_id":"articles/csharp/programming-guide/file-system/toc.json","toc_rel":"toc.json","_op_ogTitle":"How to: Iterate Through a Directory Tree (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":1398,"_op_rawTitle":"<h1 id=\"how-to-iterate-through-a-directory-tree-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/file-system/how-to-iterate-through-a-directory-tree.md\" sourcestartlinenumber=\"37\" sourceendlinenumber=\"37\">How to: Iterate Through a Directory Tree (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/file-system/how-to-iterate-through-a-directory-tree","fileRelativePath":"articles/csharp/programming-guide/file-system/how-to-iterate-through-a-directory-tree.html"},"themesRelativePathToOutputRoot":"_themes/"}