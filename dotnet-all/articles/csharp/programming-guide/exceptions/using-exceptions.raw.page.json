{"content":"<div><div class=\"content\">\n<p>In C#, errors in the program at run time are propagated through the program by using a mechanism called exceptions. Exceptions are thrown by code that encounters an error and caught by code that can correct the error. Exceptions can be thrown by the .NET Framework common language runtime (CLR) or by code in a program. Once an exception is thrown, it propagates up the call stack until a <code>catch</code> statement for the exception is found. Uncaught exceptions are handled by a generic exception handler provided by the system that displays a dialog box.  </p>\n<p> Exceptions are represented by classes derived from <a class=\"xref\" href=\"../../../../api/system.exception\" data-linktype=\"relative-path\">Exception</a>. This class identifies the type of exception and contains properties that have details about the exception. Throwing an exception involves creating an instance of an exception-derived class, optionally configuring properties of the exception, and then throwing the object by using the <code>throw</code> keyword. For example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideExceptions#1\">\n        class CustomException : Exception\n        {\n            public CustomException(string message)\n            {\n               \n            }\n \n        }\n        private static void TestThrow()\n        {\n            CustomException ex =\n                new CustomException(&quot;Custom exception in TestThrow()&quot;);\n\n            throw ex;\n        }\n</code></pre><p> After an exception is thrown, the runtime checks the current statement to see whether it is within a <code>try</code> block. If it is, any <code>catch</code> blocks associated with the <code>try</code> block are checked to see whether they can catch the exception. <code>Catch</code> blocks typically specify exception types; if the type of the <code>catch</code> block is the same type as the exception, or a base class of the exception, the <code>catch</code> block can handle the method. For example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideExceptions#2\">        static void TestCatch()\n        {\n            try\n            {\n                TestThrow();\n            }\n            catch (CustomException ex)\n            {\n                System.Console.WriteLine(ex.ToString());\n            }\n        }\n</code></pre><p> If the statement that throws an exception is not within a <code>try</code> block or if the <code>try</code> block that encloses it has no matching <code>catch</code> block, the runtime checks the calling method for a <code>try</code> statement and <code>catch</code> blocks. The runtime continues up the calling stack, searching for a compatible <code>catch</code> block. After the <code>catch</code> block is found and executed, control is passed to the next statement after that <code>catch</code> block.  </p>\n<p> A <code>try</code> statement can contain more than one <code>catch</code> block. The first <code>catch</code> statement that can handle the exception is executed; any following <code>catch</code> statements, even if they are compatible, are ignored. Therefore, catch blocks should always be ordered from most specific (or most-derived) to least specific. For example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideExceptions#3\">        static void TestCatch2()\n        {\n            System.IO.StreamWriter sw = null;\n            try\n            {\n                sw = new System.IO.StreamWriter(@&quot;C:\\test\\test.txt&quot;);\n                sw.WriteLine(&quot;Hello&quot;);\n            }\n\n            catch (System.IO.FileNotFoundException ex)\n            {\n                // Put the more specific exception first.\n                System.Console.WriteLine(ex.ToString());  \n            }\n\n            catch (System.IO.IOException ex)\n            {\n                // Put the less specific exception last.\n                System.Console.WriteLine(ex.ToString());  \n            }\n            finally \n            {\n                sw.Close();\n            }\n\n            System.Console.WriteLine(&quot;Done&quot;); \n        }\n</code></pre><p> Before the <code>catch</code> block is executed, the runtime checks for <code>finally</code> blocks. <code>Finally</code> blocks enable the programmer to clean up any ambiguous state that could be left over from an aborted <code>try</code> block, or to release any external resources (such as graphics handles, database connections or file streams) without waiting for the garbage collector in the runtime to finalize the objects. For example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideExceptions#4\">        static void TestFinally()\n        {\n            System.IO.FileStream file = null;\n            //Change the path to something that works on your machine.\n            System.IO.FileInfo fileInfo = new System.IO.FileInfo(@&quot;C:\\file.txt&quot;);\n\n            try\n            {\n                file = fileInfo.OpenWrite();\n                file.WriteByte(0xF);\n            }\n            finally\n            {\n                // Closing the file allows you to reopen it immediately - otherwise IOException is thrown.\n                if (file != null)\n                {\n                    file.Close();\n                }\n            }\n\n            try\n            {\n                file = fileInfo.OpenWrite();\n                System.Console.WriteLine(&quot;OpenWrite() succeeded&quot;);\n            }\n            catch (System.IO.IOException)\n            {\n                System.Console.WriteLine(&quot;OpenWrite() failed&quot;);\n            }\n        }\n</code></pre><p> If <code>WriteByte()</code> threw an exception, the code in the second <code>try</code> block that tries to reopen the file would fail if <code>file.Close()</code> is not called, and the file would remain locked. Because <code>finally</code> blocks are executed even if an exception is thrown, the <code>finally</code> block in the previous example allows for the file to be closed correctly and helps avoid an error.  </p>\n<p> If no compatible <code>catch</code> block is found on the call stack after an exception is thrown, one of three things occurs:  </p>\n<ul>\n<li><p>If the exception is within a destructor, the destructor is aborted and the base destructor, if any, is called.  </p>\n</li>\n<li><p>If the call stack contains a static constructor, or a static field initializer, a <a class=\"xref\" href=\"../../../../api/system.typeinitializationexception\" data-linktype=\"relative-path\">TypeInitializationException</a> is thrown, with the original exception assigned to the <a class=\"xref\" href=\"../../../../api/system.exception#System_Exception_InnerException_\" data-linktype=\"relative-path\">InnerException</a> property of the new exception.  </p>\n</li>\n<li><p>If the start of the thread is reached, the thread is terminated.  </p>\n</li>\n</ul>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../index\" data-linktype=\"relative-path\">C# Programming Guide</a><br> <a href=\"index\" data-linktype=\"relative-path\">Exceptions and Exception Handling</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc.json\">\r\n<meta name=\"ms.assetid\" content=\"71472c62-320a-470a-97d2-67995180389d\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"15\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-21 01:42 AM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/3115359729431ecbcc16058612da59b85621fa0f/docs/csharp/programming-guide/exceptions/using-exceptions.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/csharp/programming-guide/exceptions/using-exceptions.md\">\r\n<meta name=\"document_id\" content=\"b63cc702-4149-e48f-274b-c3426fb42156\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Using Exceptions (C# Programming Guide) | Microsoft Docs","ms.assetid":"71472c62-320a-470a-97d2-67995180389d","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":15,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["exception handling [C#], about exception handling","exceptions [C#], about exceptions"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize the C# Guide TOC (#1318)","commit_sha":"3115359729431ecbcc16058612da59b85621fa0f","commit_date":"2017-01-23 23:20:14 -0500"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2017-03-21 01:42 AM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"3/21/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/3115359729431ecbcc16058612da59b85621fa0f/docs/csharp/programming-guide/exceptions/using-exceptions.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/csharp/programming-guide/exceptions/using-exceptions.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/exceptions/using-exceptions.md","document_id":"b63cc702-4149-e48f-274b-c3426fb42156","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/programming-guide/exceptions/using-exceptions","toc_asset_id":"articles/csharp/programming-guide/exceptions/toc.json","toc_rel":"toc.json","_op_ogTitle":"Using Exceptions (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":716,"_op_rawTitle":"<h1 id=\"using-exceptions-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/exceptions/using-exceptions.md\" sourcestartlinenumber=\"37\" sourceendlinenumber=\"37\">Using Exceptions (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/programming-guide/exceptions/using-exceptions","fileRelativePath":"articles/csharp/programming-guide/exceptions/using-exceptions.html"},"themesRelativePathToOutputRoot":"_themes/"}