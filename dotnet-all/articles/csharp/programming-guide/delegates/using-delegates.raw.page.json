{"content":"<div><div class=\"content\">\n<p>A <a href=\"../../language-reference/keywords/delegate\" data-linktype=\"relative-path\">delegate</a> is a type that safely encapsulates a method, similar to a function pointer in C and C++. Unlike C function pointers, delegates are object-oriented, type safe, and secure. The type of a delegate is defined by the name of the delegate. The following example declares a delegate named <code>Del</code> that can encapsulate a method that takes a <a href=\"../../language-reference/keywords/string\" data-linktype=\"relative-path\">string</a> as an argument and returns <a href=\"../../language-reference/keywords/void\" data-linktype=\"relative-path\">void</a>:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideDelegates#21\">        public delegate void Del(string message);\n</code></pre><p> A delegate object is normally constructed by providing the name of the method the delegate will wrap, or with an <a href=\"../statements-expressions-operators/anonymous-methods\" data-linktype=\"relative-path\">anonymous Method</a>. Once a delegate is instantiated, a method call made to the delegate will be passed by the delegate to that method. The parameters passed to the delegate by the caller are passed to the method, and the return value, if any, from the method is returned to the caller by the delegate. This is known as invoking the delegate. An instantiated delegate can be invoked as if it were the wrapped method itself. For example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideDelegates#22\">        // Create a method for a delegate.\n        public static void DelegateMethod(string message)\n        {\n            System.Console.WriteLine(message);\n        }\n</code></pre><pre><code class=\"lang-cs\" name=\"csProgGuideDelegates#23\">            // Instantiate the delegate.\n            Del handler = DelegateMethod;\n\n            // Call the delegate.\n            handler(&quot;Hello World&quot;);\n</code></pre><p> Delegate types are derived from the <a class=\"xref\" href=\"../../../../api/system.delegate\" data-linktype=\"relative-path\">Delegate</a> class in the .NET Framework. Delegate types are <a href=\"../../language-reference/keywords/sealed\" data-linktype=\"relative-path\">sealed</a>—they cannot be derived from— and it is not possible to derive custom classes from <a class=\"xref\" href=\"../../../../api/system.delegate\" data-linktype=\"relative-path\">Delegate</a>. Because the instantiated delegate is an object, it can be passed as a parameter, or assigned to a property. This allows a method to accept a delegate as a parameter, and call the delegate at some later time. This is known as an asynchronous callback, and is a common method of notifying a caller when a long process has completed. When a delegate is used in this fashion, the code using the delegate does not need any knowledge of the implementation of the method being used. The functionality is similar to the encapsulation interfaces provide.  </p>\n<p> Another common use of callbacks is defining a custom comparison method and passing that delegate to a sort method. It allows the caller&#39;s code to become part of the sort algorithm. The following example method uses the <code>Del</code> type as a parameter:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideDelegates#24\">        public void MethodWithCallback(int param1, int param2, Del callback)\n        {\n            callback(&quot;The number is: &quot; + (param1 + param2).ToString());\n        }\n</code></pre><p> You can then pass the delegate created above to that method:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideDelegates#25\">            MethodWithCallback(1, 2, handler);\n</code></pre><p> and receive the following output to the console:  </p>\n<p> <code>The number is: 3</code>  </p>\n<p> Using the delegate as an abstraction, <code>MethodWithCallback</code> does not need to call the console directly—it does not have to be designed with a console in mind. What <code>MethodWithCallback</code> does is simply prepare a string and pass the string to another method. This is especially powerful since a delegated method can use any number of parameters.  </p>\n<p> When a delegate is constructed to wrap an instance method, the delegate references both the instance and the method. A delegate has no knowledge of the instance type aside from the method it wraps, so a delegate can refer to any type of object as long as there is a method on that object that matches the delegate signature. When a delegate is constructed to wrap a static method, it only references the method. Consider the following declarations:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideDelegates#26\">    public class MethodClass\n    {\n        public void Method1(string message) { }\n        public void Method2(string message) { }\n    }\n</code></pre><p> Along with the static <code>DelegateMethod</code> shown previously, we now have three methods that can be wrapped by a <code>Del</code> instance.  </p>\n<p> A delegate can call more than one method when invoked. This is referred to as multicasting. To add an extra method to the delegate&#39;s list of methods—the invocation list—simply requires adding two delegates using the addition or addition assignment operators (&#39;+&#39; or &#39;+=&#39;). For example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideDelegates#27\">            MethodClass obj = new MethodClass();\n            Del d1 = obj.Method1;\n            Del d2 = obj.Method2;\n            Del d3 = DelegateMethod;\n\n            //Both types of assignment are valid.\n            Del allMethodsDelegate = d1 + d2;\n            allMethodsDelegate += d3;\n</code></pre><p> At this point <code>allMethodsDelegate</code> contains three methods in its invocation list—<code>Method1</code>, <code>Method2</code>, and <code>DelegateMethod</code>. The original three delegates, <code>d1</code>, <code>d2</code>, and <code>d3</code>, remain unchanged. When <code>allMethodsDelegate</code> is invoked, all three methods are called in order. If the delegate uses reference parameters, the reference is passed sequentially to each of the three methods in turn, and any changes by one method are visible to the next method. When any of the methods throws an exception that is not caught within the method, that exception is passed to the caller of the delegate and no subsequent methods in the invocation list are called. If the delegate has a return value and/or out parameters, it returns the return value and parameters of the last method invoked. To remove a method from the invocation list, use the decrement or decrement assignment operator (&#39;-&#39; or &#39;-=&#39;). For example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideDelegates#28\">            //remove Method1\n            allMethodsDelegate -= d1;\n\n            // copy AllMethodsDelegate while removing d2\n            Del oneMethodDelegate = allMethodsDelegate - d2;\n</code></pre><p> Because delegate types are derived from <code>System.Delegate</code>, the methods and properties defined by that class can be called on the delegate. For example, to find the number of methods in a delegate&#39;s invocation list, you may write:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideDelegates#29\">            int invocationCount = d1.GetInvocationList().GetLength(0);\n</code></pre><p> Delegates with more than one method in their invocation list derive from <a class=\"xref\" href=\"../../../../api/system.multicastdelegate\" data-linktype=\"relative-path\">MulticastDelegate</a>, which is a subclass of <code>System.Delegate</code>. The above code works in either case because both classes support <code>GetInvocationList</code>.  </p>\n<p> Multicast delegates are used extensively in event handling. Event source objects send event notifications to recipient objects that have registered to receive that event. To register for an event, the recipient creates a method designed to handle the event, then creates a delegate for that method and passes the delegate to the event source. The source calls the delegate when the event occurs. The delegate then calls the event handling method on the recipient, delivering the event data. The delegate type for a given event is defined by the event source. For more, see <a href=\"../events/index\" data-linktype=\"relative-path\">Events</a>.  </p>\n<p> Comparing delegates of two different types assigned at compile-time will result in a compilation error. If the delegate instances are statically of the type <code>System.Delegate</code>, then the comparison is allowed, but will return false at run time. For example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideDelegates#30\">    delegate void Delegate1();\n    delegate void Delegate2();\n\n    static void method(Delegate1 d, Delegate2 e, System.Delegate f)\n    {\n        // Compile-time error.\n        //Console.WriteLine(d == e);\n\n        // OK at compile-time. False if the run-time type of f \n        // is not the same as that of d.\n        System.Console.WriteLine(d == f);\n    }\n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../index\" data-linktype=\"relative-path\">C# Programming Guide</a><br> <a href=\"index\" data-linktype=\"relative-path\">Delegates</a><br> <a href=\"http://msdn.microsoft.com/library/e6acad03-93e0-4efb-a158-8696d5eb4ecf\" data-linktype=\"external\">Using Variance in Delegates</a><br> <a href=\"http://msdn.microsoft.com/library/e3b98197-6c5b-4e55-9c6e-9739b60645ca\" data-linktype=\"external\">Variance in Delegates</a><br> <a href=\"http://msdn.microsoft.com/library/e69c4f39-09aa-4c6d-a752-08cc767d8290\" data-linktype=\"external\">Using Variance for Func and Action Generic Delegates</a><br> <a href=\"../events/index\" data-linktype=\"relative-path\">Events</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet/toc2.json\">\r\n<meta name=\"ms.assetid\" content=\"99a2fc27-a32e-4a34-921c-e65497520eec\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"18\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/delegates/using-delegates.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/delegates/using-delegates.md\">\r\n<meta name=\"document_id\" content=\"e602dd6e-f773-bf55-763f-61c3538e371e\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Using Delegates (C# Programming Guide) | Microsoft Docs","ms.assetid":"99a2fc27-a32e-4a34-921c-e65497520eec","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":18,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["delegates [C#], how to use"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/delegates/using-delegates.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/delegates/using-delegates.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/delegates/using-delegates.md","document_id":"e602dd6e-f773-bf55-763f-61c3538e371e","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/delegates/using-delegates","toc_asset_id":"articles/csharp/programming-guide/delegates/toc.json","toc_rel":"toc.json","_op_ogTitle":"Using Delegates (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":1087,"_op_rawTitle":"<h1 id=\"using-delegates-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/delegates/using-delegates.md\" sourcestartlinenumber=\"36\" sourceendlinenumber=\"36\">Using Delegates (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/delegates/using-delegates","fileRelativePath":"articles/csharp/programming-guide/delegates/using-delegates.html"},"themesRelativePathToOutputRoot":"_themes/"}