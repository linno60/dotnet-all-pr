{"content":"<div><div class=\"content\">\n<p>You can declare generic type parameters in interfaces as covariant or contravariant. <em>Covariance</em> allows interface methods to have more derived return types than that defined by the generic type parameters. <em>Contravariance</em> allows interface methods to have argument types that are less derived than that specified by the generic parameters. A generic interface that has covariant or contravariant generic type parameters is called <em>variant</em>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> .NET Framework 4 introduced variance support for several existing generic interfaces. For the list of the variant interfaces in the .NET Framework, see <a href=\"variance-in-generic-interfaces\" data-linktype=\"relative-path\">Variance in Generic Interfaces (C#)</a>.  </p>\n</div>\n<h2 id=\"declaring-variant-generic-interfaces\">Declaring Variant Generic Interfaces</h2>\n<p> You can declare variant generic interfaces by using the <code>in</code> and <code>out</code> keywords for generic type parameters.  </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> <code>ref</code> and <code>out</code> parameters in C# cannot be variant. Value types also do not support variance.  </p>\n</div>\n<p> You can declare a generic type parameter covariant by using the <code>out</code> keyword. The covariant type must satisfy the following conditions:  </p>\n<ul>\n<li><p>The type is used only as a return type of interface methods and not used as a type of method arguments. This is illustrated in the following example, in which the type <code>R</code> is declared covariant.  </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">interface ICovariant&lt;out R&gt;  \n{  \n    R GetSomething();  \n    // The following statement generates a compiler error.  \n    // void SetSometing(R sampleArg);  \n\n}  \n</code></pre><p> There is one exception to this rule. If you have a contravariant generic delegate as a method parameter, you can use the type as a generic type parameter for the delegate. This is illustrated by the type <code>R</code> in the following example. For more information, see <a href=\"variance-in-delegates\" data-linktype=\"relative-path\">Variance in Delegates (C#)</a> and <a href=\"using-variance-for-func-and-action-generic-delegates\" data-linktype=\"relative-path\">Using Variance for Func and Action Generic Delegates (C#)</a>.  </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">interface ICovariant&lt;out R&gt;  \n{  \n    void DoSomething(Action&lt;R&gt; callback);  \n}  \n</code></pre></li>\n<li><p>The type is not used as a generic constraint for the interface methods. This is illustrated in the following code.  </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">interface ICovariant&lt;out R&gt;  \n{  \n    // The following statement generates a compiler error  \n    // because you can use only contravariant or invariant types  \n    // in generic contstraints.  \n    // void DoSomething&lt;T&gt;() where T : R;  \n}  \n</code></pre><p>You can declare a generic type parameter contravariant by using the <code>in</code> keyword. The contravariant type can be used only as a type of method arguments and not as a return type of interface methods. The contravariant type can also be used for generic constraints. The following code shows how to declare a contravariant interface and use a generic constraint for one of its methods.  </p>\n</li>\n</ul>\n<pre class=\"loading\"><code class=\"lang-csharp\">interface IContravariant&lt;in A&gt;  \n{  \n    void SetSomething(A sampleArg);  \n    void DoSomething&lt;T&gt;() where T : A;  \n    // The following statement generates a compiler error.  \n    // A GetSomething();              \n}  \n</code></pre><p> It is also possible to support both covariance and contravariance in the same interface, but for different type parameters, as shown in the following code example.  </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">interface IVariant&lt;out R, in A&gt;  \n{  \n    R GetSomething();  \n    void SetSomething(A sampleArg);  \n    R GetSetSometings(A sampleArg);  \n}  \n</code></pre><h2 id=\"implementing-variant-generic-interfaces\">Implementing Variant Generic Interfaces</h2>\n<p> You implement variant generic interfaces in classes by using the same syntax that is used for invariant interfaces. The following code example shows how to implement a covariant interface in a generic class.  </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">interface ICovariant&lt;out R&gt;  \n{  \n    R GetSomething();  \n}  \nclass SampleImplementation&lt;R&gt; : ICovariant&lt;R&gt;  \n{  \n    public R GetSomething()  \n    {  \n        // Some code.  \n        return default(R);  \n    }  \n}  \n</code></pre><p> Classes that implement variant interfaces are invariant. For example, consider the following code.  </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">// The interface is covariant.  \nICovariant&lt;Button&gt; ibutton = new SampleImplementation&lt;Button&gt;();  \nICovariant&lt;Object&gt; iobj = ibutton;  \n\n// The class is invariant.  \nSampleImplementation&lt;Button&gt; button = new SampleImplementation&lt;Button&gt;();  \n// The following statement generates a compiler error  \n// because classes are invariant.  \n// SampleImplementation&lt;Object&gt; obj = button;  \n</code></pre><h2 id=\"extending-variant-generic-interfaces\">Extending Variant Generic Interfaces</h2>\n<p> When you extend a variant generic interface, you have to use the <code>in</code> and <code>out</code> keywords to explicitly specify whether the derived interface supports variance. The compiler does not infer the variance from the interface that is being extended. For example, consider the following interfaces.  </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">nterface ICovariant&lt;out T&gt; { }  \ninterface IInvariant&lt;T&gt; : ICovariant&lt;T&gt; { }  \ninterface IExtCovariant&lt;out T&gt; : ICovariant&lt;T&gt; { }  \n</code></pre><p> In the <code>IInvariant&lt;T&gt;</code> interface, the generic type parameter <code>T</code> is invariant, whereas in <code>IExtCovariant&lt;out T&gt;</code> the type parameter is covariant, although both interfaces extend the same interface. The same rule is applied to contravariant generic type parameters.  </p>\n<p> You can create an interface that extends both the interface where the generic type parameter <code>T</code> is covariant and the interface where it is contravariant if in the extending interface the generic type parameter <code>T</code> is invariant. This is illustrated in the following code example.  </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">interface ICovariant&lt;out T&gt; { }  \ninterface IContravariant&lt;in T&gt; { }  \ninterface IInvariant&lt;T&gt; : ICovariant&lt;T&gt;, IContravariant&lt;T&gt; { }  \n</code></pre><p> However, if a generic type parameter <code>T</code> is declared covariant in one interface, you cannot declare it contravariant in the extending interface, or vice versa. This is illustrated in the following code example.  </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">interface ICovariant&lt;out T&gt; { }  \n// The following statement generates a compiler error.  \n// interface ICoContraVariant&lt;in T&gt; : ICovariant&lt;T&gt; { }  \n</code></pre><h3 id=\"avoiding-ambiguity\">Avoiding Ambiguity</h3>\n<p> When you implement variant generic interfaces, variance can sometimes lead to ambiguity. This should be avoided.  </p>\n<p> For example, if you explicitly implement the same variant generic interface with different generic type parameters in one class, it can create ambiguity. The compiler does not produce an error in this case, but it is not specified which interface implementation will be chosen at runtime. This could lead to subtle bugs in your code. Consider the following code example.  </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">// Simple class hierarchy.  \nclass Animal { }  \nclass Cat : Animal { }  \nclass Dog : Animal { }  \n\n// This class introduces ambiguity  \n// because IEnumerable&lt;out T&gt; is covariant.  \nclass Pets : IEnumerable&lt;Cat&gt;, IEnumerable&lt;Dog&gt;  \n{  \n    IEnumerator&lt;Cat&gt; IEnumerable&lt;Cat&gt;.GetEnumerator()  \n    {  \n        Console.WriteLine(&quot;Cat&quot;);  \n        // Some code.  \n        return null;  \n    }  \n\n    IEnumerator IEnumerable.GetEnumerator()  \n    {  \n        // Some code.  \n        return null;  \n    }  \n\n    IEnumerator&lt;Dog&gt; IEnumerable&lt;Dog&gt;.GetEnumerator()  \n    {  \n        Console.WriteLine(&quot;Dog&quot;);  \n        // Some code.  \n        return null;  \n    }  \n}  \nclass Program  \n{  \n    public static void Test()  \n    {  \n        IEnumerable&lt;Animal&gt; pets = new Pets();  \n        pets.GetEnumerator();  \n    }  \n}  \n</code></pre><p> In this example, it is unspecified how the <code>pets.GetEnumerator</code> method chooses between <code>Cat</code> and <code>Dog</code>. This could cause problems in your code.  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"variance-in-generic-interfaces\" data-linktype=\"relative-path\">Variance in Generic Interfaces (C#)</a><br> <a href=\"using-variance-for-func-and-action-generic-delegates\" data-linktype=\"relative-path\">Using Variance for Func and Action Generic Delegates (C#)</a></p>\n</div></div>","outputRootRelativePath":"../../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"ms.suite\" content=\"\">\r\n<meta name=\"ms.custom\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"30330ec4-9df2-4838-a535-6c406d0ed4df\">\r\n<meta name=\"caps.latest.revision\" content=\"3\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"translation.priority.mt\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.mt\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.mt\" content=\"pt-br\">\r\n<meta name=\"translation.priority.mt\" content=\"tr-tr\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"ms.reviewer\" content=\"\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-04-01 05:46 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/400dfda51d978f35c3995f90840643aaff1b9c13/docs/csharp/programming-guide/concepts/covariance-contravariance/creating-variant-generic-interfaces.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/concepts/covariance-contravariance/creating-variant-generic-interfaces.md\">\r\n<meta name=\"document_id\" content=\"269c6097-0c69-8cf4-86ee-103b0ef9e09c\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","uhfHeaderId":"MSDocsHeader-DotNet","title":"Creating Variant Generic Interfaces (C#) | Microsoft Docs","ms.suite":"","ms.custom":"","ms.assetid":"30330ec4-9df2-4838-a535-6c406d0ed4df","caps.latest.revision":3,"ms.topic":"article","dev_langs":["csharp"],"translation.priority.mt":["cs-cz","pl-pl","pt-br","tr-tr"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","ms.reviewer":"","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"tompratt-AQ","author_email":"v-thprat@microsoft.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"Update language identifiers and styleguide. (#1796)","commit_sha":"400dfda51d978f35c3995f90840643aaff1b9c13","commit_date":"2017-03-24 14:01:03 -0700"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2017-04-01 05:46 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/tompratt-AQ","display_name":"tompratt-AQ","id":"26311438"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"4/1/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/400dfda51d978f35c3995f90840643aaff1b9c13/docs/csharp/programming-guide/concepts/covariance-contravariance/creating-variant-generic-interfaces.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/concepts/covariance-contravariance/creating-variant-generic-interfaces.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/concepts/covariance-contravariance/creating-variant-generic-interfaces.md","document_id":"269c6097-0c69-8cf4-86ee-103b0ef9e09c","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/concepts/covariance-contravariance/creating-variant-generic-interfaces","toc_asset_id":"articles/csharp/programming-guide/concepts/covariance-contravariance/toc.json","toc_rel":"toc.json","_op_ogTitle":"Creating Variant Generic Interfaces (C#)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":983,"_op_rawTitle":"<h1 id=\"creating-variant-generic-interfaces-c\" sourcefile=\"docs/csharp/programming-guide/concepts/covariance-contravariance/creating-variant-generic-interfaces.md\" sourcestartlinenumber=\"25\" sourceendlinenumber=\"25\">Creating Variant Generic Interfaces (C#)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/concepts/covariance-contravariance/creating-variant-generic-interfaces","fileRelativePath":"articles/csharp/programming-guide/concepts/covariance-contravariance/creating-variant-generic-interfaces.html"},"themesRelativePathToOutputRoot":"_themes/"}