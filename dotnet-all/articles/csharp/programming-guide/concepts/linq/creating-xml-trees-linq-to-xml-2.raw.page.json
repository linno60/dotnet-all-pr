{"content":"<div><div class=\"content\">\n<p>This section provides information about creating XML trees in C#.  </p>\n<p> For information about using the results of LINQ queries as the content for an <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>, see <a href=\"functional-construction-linq-to-xml\" data-linktype=\"relative-path\">Functional Construction (LINQ to XML) (C#)</a>.  </p>\n<h2 id=\"constructing-elements\">Constructing Elements</h2>\n<p> The signatures of the <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a> and <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xattribute\" data-linktype=\"relative-path\">XAttribute</a> constructors let you pass the contents of the element or attribute as arguments to the constructor. Because one of the constructors takes a variable number of arguments, you can pass any number of child elements. Of course, each of those child elements can contain their own child elements. For any element, you can add any number of attributes.  </p>\n<p> When adding <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> (including <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>) or <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xattribute\" data-linktype=\"relative-path\">XAttribute</a> objects, if the new content has no parent, the objects are simply attached to the XML tree. If the new content already is parented, and is part of another XML tree, the new content is cloned, and the newly cloned content is attached to the XML tree. The last example in this topic demonstrates this.  </p>\n<p> To create a <code>contacts</code><a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>, you could use the following code:  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">XElement contacts =  \n    new XElement(&quot;Contacts&quot;,  \n        new XElement(&quot;Contact&quot;,  \n            new XElement(&quot;Name&quot;, &quot;Patrick Hines&quot;),   \n            new XElement(&quot;Phone&quot;, &quot;206-555-0144&quot;),  \n            new XElement(&quot;Address&quot;,  \n                new XElement(&quot;Street1&quot;, &quot;123 Main St&quot;),  \n                new XElement(&quot;City&quot;, &quot;Mercer Island&quot;),  \n                new XElement(&quot;State&quot;, &quot;WA&quot;),  \n                new XElement(&quot;Postal&quot;, &quot;68042&quot;)  \n            )  \n        )  \n    );  \n</code></pre><p> If indented properly, the code to construct <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a> objects closely resembles the structure of the underlying XML.  </p>\n<h2 id=\"xelement-constructors\">XElement Constructors</h2>\n<p> The <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a> class uses the following constructors for functional construction. Note that there are some other constructors for <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>, but because they are not used for functional construction they are not listed here.  </p>\n<table>\n<thead>\n<tr>\n<th>Constructor</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>XElement(XName name, object content)</code></td>\n<td>Creates an <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>. The <code>name</code> parameter specifies the name of the element; <code>content</code> specifies the content of the element.</td>\n</tr>\n<tr>\n<td><code>XElement(XName name)</code></td>\n<td>Creates an <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a> with its <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xname\" data-linktype=\"relative-path\">XName</a> initialized to the specified name.</td>\n</tr>\n<tr>\n<td><code>XElement(XName name, params object[] content)</code></td>\n<td>Creates an <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a> with its <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xname\" data-linktype=\"relative-path\">XName</a> initialized to the specified name. The attributes and/or child elements are created from the contents of the parameter list.</td>\n</tr>\n</tbody>\n</table>\n<p> The <code>content</code> parameter is extremely flexible. It supports any type of object that is a valid child of an <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>. The following rules apply to different types of objects passed in this parameter:  </p>\n<ul>\n<li><p>A string is added as text content.  </p>\n</li>\n<li><p>An <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a> is added as a child element.  </p>\n</li>\n<li><p>An <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xattribute\" data-linktype=\"relative-path\">XAttribute</a> is added as an attribute.  </p>\n</li>\n<li><p>An <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xprocessinginstruction\" data-linktype=\"relative-path\">XProcessingInstruction</a>, <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xcomment\" data-linktype=\"relative-path\">XComment</a>, or <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xtext\" data-linktype=\"relative-path\">XText</a> is added as child content.  </p>\n</li>\n<li><p>An <a class=\"xref\" href=\"../../../../../api/system.collections.ienumerable\" data-linktype=\"relative-path\">IEnumerable</a> is enumerated, and these rules are applied recursively to the results.  </p>\n</li>\n<li><p>For any other type, its <code>ToString</code> method is called and the result is added as text content.  </p>\n</li>\n</ul>\n<h3 id=\"creating-an-xelement-with-content\">Creating an XElement with Content</h3>\n<p> You can create an <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a> that contains simple content with a single method call. To do this, specify the content as the second parameter, as follows:  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">XElement n = new XElement(&quot;Customer&quot;, &quot;Adventure Works&quot;);  \nConsole.WriteLine(n);  \n</code></pre><p> This example produces the following output:  </p>\n<pre class=\"loading\"><code class=\"lang-xml\">&lt;Customer&gt;Adventure Works&lt;/Customer&gt;  \n</code></pre><p> You can pass any type of object as the content. For example, the following code creates an element that contains a floating point number as content:  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">XElement n = new XElement(&quot;Cost&quot;, 324.50);  \nConsole.WriteLine(n);  \n</code></pre><p> This example produces the following output:  </p>\n<pre class=\"loading\"><code class=\"lang-xml\">&lt;Cost&gt;324.5&lt;/Cost&gt;  \n</code></pre><p> The floating point number is boxed and passed in to the constructor. The boxed number is converted to a string and used as the content of the element.  </p>\n<h3 id=\"creating-an-xelement-with-a-child-element\">Creating an XElement with a Child Element</h3>\n<p> If you pass an instance of the <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a> class for the content argument, the constructor creates an element with a child element:  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">XElement shippingUnit = new XElement(&quot;ShippingUnit&quot;,  \n    new XElement(&quot;Cost&quot;, 324.50)  \n);  \nConsole.WriteLine(shippingUnit);  \n</code></pre><p> This example produces the following output:  </p>\n<pre class=\"loading\"><code class=\"lang-xml\">&lt;ShippingUnit&gt;  \n  &lt;Cost&gt;324.5&lt;/Cost&gt;  \n&lt;/ShippingUnit&gt;  \n</code></pre><h3 id=\"creating-an-xelement-with-multiple-child-elements\">Creating an XElement with Multiple Child Elements</h3>\n<p> You can pass in a number of <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a> objects for the content. Each of the <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a> objects is included as a child element.  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">XElement address = new XElement(&quot;Address&quot;,  \n    new XElement(&quot;Street1&quot;, &quot;123 Main St&quot;),  \n    new XElement(&quot;City&quot;, &quot;Mercer Island&quot;),  \n    new XElement(&quot;State&quot;, &quot;WA&quot;),  \n    new XElement(&quot;Postal&quot;, &quot;68042&quot;)  \n);  \nConsole.WriteLine(address);  \n</code></pre><p> This example produces the following output:  </p>\n<pre class=\"loading\"><code class=\"lang-xml\">&lt;Address&gt;  \n  &lt;Street1&gt;123 Main St&lt;/Street1&gt;  \n  &lt;City&gt;Mercer Island&lt;/City&gt;  \n  &lt;State&gt;WA&lt;/State&gt;  \n  &lt;Postal&gt;68042&lt;/Postal&gt;  \n&lt;/Address&gt;  \n</code></pre><p> By extending the above example, you can create an entire XML tree, as follows:  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">XElement contacts =  \n    new XElement(&quot;Contacts&quot;,  \n        new XElement(&quot;Contact&quot;,  \n            new XElement(&quot;Name&quot;, &quot;Patrick Hines&quot;),                                                   \n            new XElement(&quot;Phone&quot;, &quot;206-555-0144&quot;),  \n            new XElement(&quot;Address&quot;,  \n                new XElement(&quot;Street1&quot;, &quot;123 Main St&quot;),  \n                new XElement(&quot;City&quot;, &quot;Mercer Island&quot;),  \n                new XElement(&quot;State&quot;, &quot;WA&quot;),  \n                new XElement(&quot;Postal&quot;, &quot;68042&quot;)  \n            )  \n        )  \n    );  \nConsole.WriteLine(contacts);  \n</code></pre><p> This example produces the following output:  </p>\n<pre class=\"loading\"><code class=\"lang-xml\">&lt;Contacts&gt;  \n  &lt;Contact&gt;  \n    &lt;Name&gt;Patrick Hines&lt;/Name&gt;  \n    &lt;Phone&gt;206-555-0144&lt;/Phone&gt;  \n    &lt;Address&gt;  \n      &lt;Street1&gt;123 Main St&lt;/Street1&gt;  \n      &lt;City&gt;Mercer Island&lt;/City&gt;  \n      &lt;State&gt;WA&lt;/State&gt;  \n      &lt;Postal&gt;68042&lt;/Postal&gt;  \n    &lt;/Address&gt;  \n  &lt;/Contact&gt;  \n&lt;/Contacts&gt;  \n</code></pre><h3 id=\"creating-an-empty-element\">Creating an Empty Element</h3>\n<p> To create an empty <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>, you do not pass any content to the constructor. The following example creates an empty element:  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">XElement n = new XElement(&quot;Customer&quot;);  \nConsole.WriteLine(n);  \n</code></pre><p> This example produces the following output:  </p>\n<pre class=\"loading\"><code class=\"lang-xml\">&lt;Customer /&gt;  \n</code></pre><h3 id=\"attaching-vs-cloning\">Attaching vs. Cloning</h3>\n<p> As mentioned previously, when adding <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> (including <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>) or <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xattribute\" data-linktype=\"relative-path\">XAttribute</a> objects, if the new content has no parent, the objects are simply attached to the XML tree. If the new content already is parented and is part of another XML tree, the new content is cloned, and the newly cloned content is attached to the XML tree.  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">// Create a tree with a child element.  \nXElement xmlTree1 = new XElement(&quot;Root&quot;,  \n    new XElement(&quot;Child1&quot;, 1)  \n);  \n\n// Create an element that is not parented.  \nXElement child2 = new XElement(&quot;Child2&quot;, 2);  \n\n// Create a tree and add Child1 and Child2 to it.  \nXElement xmlTree2 = new XElement(&quot;Root&quot;,  \n    xmlTree1.Element(&quot;Child1&quot;),  \n    child2  \n);  \n\n// Compare Child1 identity.  \nConsole.WriteLine(&quot;Child1 was {0}&quot;,  \n    xmlTree1.Element(&quot;Child1&quot;) == xmlTree2.Element(&quot;Child1&quot;) ?  \n    &quot;attached&quot; : &quot;cloned&quot;);  \n\n// Compare Child2 identity.  \nConsole.WriteLine(&quot;Child2 was {0}&quot;,  \n    child2 == xmlTree2.Element(&quot;Child2&quot;) ?  \n    &quot;attached&quot; : &quot;cloned&quot;);  \n</code></pre><p> This example produces the following output:  </p>\n<pre class=\"loading\"><code>Child1 was cloned  \nChild2 was attached  \n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"creating-xml-trees\" data-linktype=\"relative-path\">Creating XML Trees (C#)</a></p>\n</div></div>","outputRootRelativePath":"../../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet/toc2.json\">\r\n<meta name=\"ms.suite\" content=\"\">\r\n<meta name=\"ms.custom\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"cc74234a-0bac-4327-9c8c-5a2ead15b595\">\r\n<meta name=\"caps.latest.revision\" content=\"3\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"translation.priority.mt\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.mt\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.mt\" content=\"pt-br\">\r\n<meta name=\"translation.priority.mt\" content=\"tr-tr\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"ms.reviewer\" content=\"\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/concepts/linq/creating-xml-trees-linq-to-xml-2.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/concepts/linq/creating-xml-trees-linq-to-xml-2.md\">\r\n<meta name=\"document_id\" content=\"d7783183-4884-025f-0532-357c2a0b3caf\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Creating XML Trees in C# (LINQ to XML) | Microsoft Docs","ms.suite":"","ms.custom":"","ms.assetid":"cc74234a-0bac-4327-9c8c-5a2ead15b595","caps.latest.revision":3,"ms.topic":"article","dev_langs":["csharp"],"translation.priority.mt":["cs-cz","pl-pl","pt-br","tr-tr"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","ms.reviewer":"","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/concepts/linq/creating-xml-trees-linq-to-xml-2.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/concepts/linq/creating-xml-trees-linq-to-xml-2.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/concepts/linq/creating-xml-trees-linq-to-xml-2.md","document_id":"d7783183-4884-025f-0532-357c2a0b3caf","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/concepts/linq/creating-xml-trees-linq-to-xml-2","toc_asset_id":"articles/csharp/programming-guide/concepts/linq/toc.json","toc_rel":"toc.json","_op_ogTitle":"Creating XML Trees in C# (LINQ to XML)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":873,"_op_rawTitle":"<h1 id=\"creating-xml-trees-in-c-linq-to-xml\" sourcefile=\"docs/csharp/programming-guide/concepts/linq/creating-xml-trees-linq-to-xml-2.md\" sourcestartlinenumber=\"25\" sourceendlinenumber=\"25\">Creating XML Trees in C# (LINQ to XML)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/concepts/linq/creating-xml-trees-linq-to-xml-2","fileRelativePath":"articles/csharp/programming-guide/concepts/linq/creating-xml-trees-linq-to-xml-2.html"},"themesRelativePathToOutputRoot":"_themes/"}