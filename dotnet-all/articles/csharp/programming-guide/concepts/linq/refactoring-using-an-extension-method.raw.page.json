{"content":"<div><div class=\"content\">\n<p>This example builds on the previous example, <a href=\"retrieving-the-text-of-the-paragraphs\" data-linktype=\"relative-path\">Retrieving the Text of the Paragraphs (C#)</a>, by refactoring the concatenation of strings using a pure function that is implemented as an extension method.  </p>\n<p> The previous example used the <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/bb336183(v=vs.110).aspx\" data-linktype=\"external\">Aggregate</a> standard query operator to concatenate multiple strings into one string. However, it is more convenient to write an extension method to do this, because the resulting query smaller and more simple.  </p>\n<h2 id=\"example\">Example</h2>\n<p> This example processes a WordprocessingML document, retrieving the paragraphs, the style of each paragraph, and the text of each paragraph. This example builds on the previous examples in this tutorial.  </p>\n<p> The example contains multiple overloads of the <code>StringConcatenate</code> method.  </p>\n<p> You can find instructions for creating the source document for this example in <a href=\"creating-the-source-office-open-xml-document\" data-linktype=\"relative-path\">Creating the Source Office Open XML Document (C#)</a>.  </p>\n<p> This example uses classes from the WindowsBase assembly. It uses types in the <a class=\"xref\" href=\"../../../../../api/system.io.packaging\" data-linktype=\"relative-path\">System.IO.Packaging</a> namespace.  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">public static class LocalExtensions  \n{  \n    public static string StringConcatenate(this IEnumerable&lt;string&gt; source)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (string s in source)  \n            sb.Append(s);  \n        return sb.ToString();  \n    }  \n\n    public static string StringConcatenate&lt;T&gt;(this IEnumerable&lt;T&gt; source,  \n        Func&lt;T, string&gt; func)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (T item in source)  \n            sb.Append(func(item));  \n        return sb.ToString();  \n    }  \n\n    public static string StringConcatenate(this IEnumerable&lt;string&gt; source, string separator)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (string s in source)  \n            sb.Append(s).Append(separator);  \n        return sb.ToString();  \n    }  \n\n    public static string StringConcatenate&lt;T&gt;(this IEnumerable&lt;T&gt; source,  \n        Func&lt;T, string&gt; func, string separator)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (T item in source)  \n            sb.Append(func(item)).Append(separator);  \n        return sb.ToString();  \n    }  \n}  \n</code></pre><h2 id=\"example-1\">Example</h2>\n<p> There are four overloads of the <code>StringConcatenate</code> method. One overload simply takes a collection of strings and returns a single string. Another overload can take a collection of any type, and a delegate that projects from a singleton of the collection to a string. There are two more overloads that allow you to specify a separator string.  </p>\n<p> The following code uses all four overloads.  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">string[] numbers = { &quot;one&quot;, &quot;two&quot;, &quot;three&quot; };  \n\nConsole.WriteLine(&quot;{0}&quot;, numbers.StringConcatenate());  \nConsole.WriteLine(&quot;{0}&quot;, numbers.StringConcatenate(&quot;:&quot;));  \n\nint[] intNumbers = { 1, 2, 3 };  \nConsole.WriteLine(&quot;{0}&quot;, intNumbers.StringConcatenate(i =&gt; i.ToString()));  \nConsole.WriteLine(&quot;{0}&quot;, intNumbers.StringConcatenate(i =&gt; i.ToString(), &quot;:&quot;));  \n</code></pre><p> This example produces the following output:  </p>\n<pre class=\"loading\"><code>onetwothree  \none:two:three:  \n123  \n1:2:3:  \n</code></pre><h2 id=\"example-2\">Example</h2>\n<p> Now, the example can be modified to take advantage of the new extension method:  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">public static class LocalExtensions  \n{  \n    public static string StringConcatenate(this IEnumerable&lt;string&gt; source)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (string s in source)  \n            sb.Append(s);  \n        return sb.ToString();  \n    }  \n\n    public static string StringConcatenate&lt;T&gt;(this IEnumerable&lt;T&gt; source,  \n        Func&lt;T, string&gt; func)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (T item in source)  \n            sb.Append(func(item));  \n        return sb.ToString();  \n    }  \n\n    public static string StringConcatenate(this IEnumerable&lt;string&gt; source, string separator)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (string s in source)  \n            sb.Append(s).Append(separator);  \n        return sb.ToString();  \n    }  \n\n    public static string StringConcatenate&lt;T&gt;(this IEnumerable&lt;T&gt; source,  \n        Func&lt;T, string&gt; func, string separator)  \n    {  \n        StringBuilder sb = new StringBuilder();  \n        foreach (T item in source)  \n            sb.Append(func(item)).Append(separator);  \n        return sb.ToString();  \n    }  \n}  \n\nclass Program  \n{  \n    static void Main(string[] args)  \n    {  \n        const string fileName = &quot;SampleDoc.docx&quot;;  \n\n        const string documentRelationshipType =  \n          &quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument&quot;;  \n        const string stylesRelationshipType =  \n          &quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles&quot;;  \n        const string wordmlNamespace =  \n          &quot;http://schemas.openxmlformats.org/wordprocessingml/2006/main&quot;;  \n        XNamespace w = wordmlNamespace;  \n\n        XDocument xDoc = null;  \n        XDocument styleDoc = null;  \n\n        using (Package wdPackage = Package.Open(fileName, FileMode.Open, FileAccess.Read))  \n        {  \n            PackageRelationship docPackageRelationship =  \n              wdPackage.GetRelationshipsByType(documentRelationshipType).FirstOrDefault();  \n            if (docPackageRelationship != null)  \n            {  \n                Uri documentUri = PackUriHelper.ResolvePartUri(new Uri(&quot;/&quot;, UriKind.Relative),  \n                  docPackageRelationship.TargetUri);  \n                PackagePart documentPart = wdPackage.GetPart(documentUri);  \n\n                //  Load the document XML in the part into an XDocument instance.  \n                xDoc = XDocument.Load(XmlReader.Create(documentPart.GetStream()));  \n\n                //  Find the styles part. There will only be one.  \n                PackageRelationship styleRelation =  \n                  documentPart.GetRelationshipsByType(stylesRelationshipType).FirstOrDefault();  \n                if (styleRelation != null)  \n                {  \n                    Uri styleUri =  \n                      PackUriHelper.ResolvePartUri(documentUri, styleRelation.TargetUri);  \n                    PackagePart stylePart = wdPackage.GetPart(styleUri);  \n\n                    //  Load the style XML in the part into an XDocument instance.  \n                    styleDoc = XDocument.Load(XmlReader.Create(stylePart.GetStream()));  \n                }  \n            }  \n        }  \n\n        string defaultStyle =  \n            (string)(  \n                from style in styleDoc.Root.Elements(w + &quot;style&quot;)  \n                where (string)style.Attribute(w + &quot;type&quot;) == &quot;paragraph&quot; &amp;&amp;  \n                      (string)style.Attribute(w + &quot;default&quot;) == &quot;1&quot;  \n                select style  \n            ).First().Attribute(w + &quot;styleId&quot;);  \n\n        // Find all paragraphs in the document.  \n        var paragraphs =  \n            from para in xDoc  \n                         .Root  \n                         .Element(w + &quot;body&quot;)  \n                         .Descendants(w + &quot;p&quot;)  \n            let styleNode = para  \n                            .Elements(w + &quot;pPr&quot;)  \n                            .Elements(w + &quot;pStyle&quot;)  \n                            .FirstOrDefault()  \n            select new  \n            {  \n                ParagraphNode = para,  \n                StyleName = styleNode != null ?  \n                    (string)styleNode.Attribute(w + &quot;val&quot;) :  \n                    defaultStyle  \n            };  \n\n        // Retrieve the text of each paragraph.  \n        var paraWithText =  \n            from para in paragraphs  \n            select new  \n            {  \n                ParagraphNode = para.ParagraphNode,  \n                StyleName = para.StyleName,  \n                Text = para  \n                       .ParagraphNode  \n                       .Elements(w + &quot;r&quot;)  \n                       .Elements(w + &quot;t&quot;)  \n                       .StringConcatenate(e =&gt; (string)e)  \n            };  \n\n        foreach (var p in paraWithText)  \n            Console.WriteLine(&quot;StyleName:{0} &gt;{1}&lt;&quot;, p.StyleName, p.Text);  \n    }  \n}  \n</code></pre><p> This example produces the following output when applied to the document described in <a href=\"creating-the-source-office-open-xml-document\" data-linktype=\"relative-path\">Creating the Source Office Open XML Document (C#)</a>.  </p>\n<pre class=\"loading\"><code>StyleName:Heading1 &gt;Parsing WordprocessingML with LINQ to XML&lt;  \nStyleName:Normal &gt;&lt;  \nStyleName:Normal &gt;The following example prints to the console.&lt;  \nStyleName:Normal &gt;&lt;  \nStyleName:Code &gt;using System;&lt;  \nStyleName:Code &gt;&lt;  \nStyleName:Code &gt;class Program {&lt;  \nStyleName:Code &gt;    public static void (string[] args) {&lt;  \nStyleName:Code &gt;        Console.WriteLine(&quot;Hello World&quot;);&lt;  \nStyleName:Code &gt;    }&lt;  \nStyleName:Code &gt;}&lt;  \nStyleName:Normal &gt;&lt;  \nStyleName:Normal &gt;This example produces the following output:&lt;  \nStyleName:Normal &gt;&lt;  \nStyleName:Code &gt;Hello World&lt;  \n</code></pre><p> Note that this refactoring is a variant of refactoring into a pure function. The next topic will introduce the idea of factoring into pure functions in more detail.  </p>\n<h2 id=\"next-steps\">Next Steps</h2>\n<p> The next example shows how to refactor this code in another way, by using pure functions:  </p>\n<ul>\n<li><a href=\"../../../../visual-basic/programming-guide/concepts/linq/refactoring-using-a-pure-function\" data-linktype=\"relative-path\">Refactoring Using a Pure Function (Visual Basic)</a>  </li>\n</ul>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"tutorial-manipulating-content-in-a-wordprocessingml-document\" data-linktype=\"relative-path\">Tutorial: Manipulating Content in a WordprocessingML Document (C#)</a><br> <a href=\"refactoring-into-pure-functions\" data-linktype=\"relative-path\">Refactoring Into Pure Functions (C#)</a></p>\n</div></div>","outputRootRelativePath":"../../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-all/api/toc2.json\">\r\n<meta name=\"ms.suite\" content=\"\">\r\n<meta name=\"ms.custom\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"c5fc123d-af10-4a2f-b8e4-db921efb2639\">\r\n<meta name=\"caps.latest.revision\" content=\"3\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"ms.reviewer\" content=\"\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/concepts/linq/refactoring-using-an-extension-method.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/concepts/linq/refactoring-using-an-extension-method.md\">\r\n<meta name=\"document_id\" content=\"b21aca99-a0c7-3231-4809-f2c5481d4788\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Refactoring Using an Extension Method (C#) | Microsoft Docs","ms.suite":"","ms.custom":"","ms.assetid":"c5fc123d-af10-4a2f-b8e4-db921efb2639","caps.latest.revision":3,"ms.topic":"article","dev_langs":["csharp"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","ms.reviewer":"","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/concepts/linq/refactoring-using-an-extension-method.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/concepts/linq/refactoring-using-an-extension-method.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/concepts/linq/refactoring-using-an-extension-method.md","document_id":"b21aca99-a0c7-3231-4809-f2c5481d4788","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/programming-guide/concepts/linq/refactoring-using-an-extension-method","toc_asset_id":"articles/csharp/programming-guide/concepts/linq/toc.json","toc_rel":"toc.json","_op_ogTitle":"Refactoring Using an Extension Method (C#)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":861,"_op_rawTitle":"<h1 id=\"refactoring-using-an-extension-method-c\" sourcefile=\"docs/csharp/programming-guide/concepts/linq/refactoring-using-an-extension-method.md\" sourcestartlinenumber=\"20\" sourceendlinenumber=\"20\">Refactoring Using an Extension Method (C#)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/programming-guide/concepts/linq/refactoring-using-an-extension-method","fileRelativePath":"articles/csharp/programming-guide/concepts/linq/refactoring-using-an-extension-method.html"},"themesRelativePathToOutputRoot":"_themes/"}