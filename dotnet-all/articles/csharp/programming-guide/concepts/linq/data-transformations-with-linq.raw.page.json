{"content":"<div><div class=\"content\">\n<p>Language-Integrated Query (LINQ) is not only about retrieving data. It is also a powerful tool for transforming data. By using a LINQ query, you can use a source sequence as input and modify it in many ways to create a new output sequence. You can modify the sequence itself without modifying the elements themselves by sorting and grouping. But perhaps the most powerful feature of LINQ queries is the ability to create new types. This is accomplished in the <a href=\"../../../language-reference/keywords/select-clause\" data-linktype=\"relative-path\">select</a> clause. For example, you can perform the following tasks:  </p>\n<ul>\n<li><p>Merge multiple input sequences into a single output sequence that has a new type.  </p>\n</li>\n<li><p>Create output sequences whose elements consist of only one or several properties of each element in the source sequence.  </p>\n</li>\n<li><p>Create output sequences whose elements consist of the results of operations performed on the source data.  </p>\n</li>\n<li><p>Create output sequences in a different format. For example, you can transform data from SQL rows or text files into XML.  </p>\n<p>These are just several examples. Of course, these transformations can be combined in various ways in the same query. Furthermore, the output sequence of one query can be used as the input sequence for a new query.  </p>\n</li>\n</ul>\n<h2 id=\"joining-multiple-inputs-into-one-output-sequence\">Joining Multiple Inputs into One Output Sequence</h2>\n<p> You can use a LINQ query to create an output sequence that contains elements from more than one input sequence. The following example shows how to combine two in-memory data structures, but the same principles can be applied to combine data from XML or SQL or DataSet sources. Assume the following two class types:  </p>\n<pre><code class=\"lang-cs\" name=\"CsLINQGettingStarted#7\">    class Student\n    {\n        public string First { get; set; }\n        public string Last {get; set;}\n        public int ID { get; set; }\n        public string Street { get; set; }\n        public string City { get; set; }\n        public List&lt;int&gt; Scores;\n    }\n\n    class Teacher\n    {\n        public string First { get; set; }\n        public string Last { get; set; }\n        public int ID { get; set; } \n        public string City { get; set; }\n    }\n</code></pre><p> The following example shows the query:  </p>\n<pre><code class=\"lang-cs\" name=\"CSLinqGettingStarted#8\">    class DataTransformations\n    {\n        static void Main()\n        {\n            // Create the first data source.\n            List&lt;Student&gt; students = new List&lt;Student&gt;()\n            {\n                new Student {First=&quot;Svetlana&quot;,\n                    Last=&quot;Omelchenko&quot;, \n                    ID=111, \n                    Street=&quot;123 Main Street&quot;,\n                    City=&quot;Seattle&quot;,\n                    Scores= new List&lt;int&gt; {97, 92, 81, 60}},\n                new Student {First=&quot;Claire&quot;,\n                    Last=&quot;O’Donnell&quot;, \n                    ID=112,\n                    Street=&quot;124 Main Street&quot;,\n                    City=&quot;Redmond&quot;,\n                    Scores= new List&lt;int&gt; {75, 84, 91, 39}},\n                new Student {First=&quot;Sven&quot;,\n                    Last=&quot;Mortensen&quot;,\n                    ID=113,\n                    Street=&quot;125 Main Street&quot;,\n                    City=&quot;Lake City&quot;,\n                    Scores= new List&lt;int&gt; {88, 94, 65, 91}},\n            };\n\n            // Create the second data source.\n            List&lt;Teacher&gt; teachers = new List&lt;Teacher&gt;()\n            {                \n                new Teacher {First=&quot;Ann&quot;, Last=&quot;Beebe&quot;, ID=945, City = &quot;Seattle&quot;},\n                new Teacher {First=&quot;Alex&quot;, Last=&quot;Robinson&quot;, ID=956, City = &quot;Redmond&quot;},\n                new Teacher {First=&quot;Michiyo&quot;, Last=&quot;Sato&quot;, ID=972, City = &quot;Tacoma&quot;}\n            };\n            \n            // Create the query.\n            var peopleInSeattle = (from student in students\n                        where student.City == &quot;Seattle&quot;\n                        select student.Last)\n                        .Concat(from teacher in teachers\n                                where teacher.City == &quot;Seattle&quot;\n                                select teacher.Last);\n\n            Console.WriteLine(&quot;The following students and teachers live in Seattle:&quot;);\n            // Execute the query.\n            foreach (var person in peopleInSeattle)\n            {\n                Console.WriteLine(person);\n            }\n            \n            Console.WriteLine(&quot;Press any key to exit.&quot;);\n            Console.ReadKey();\n        }\n    }\n    /* Output:\n        The following students and teachers live in Seattle:\n        Omelchenko\n        Beebe\n     */\n</code></pre><p> For more information, see <a href=\"../../../language-reference/keywords/join-clause\" data-linktype=\"relative-path\">join clause</a> and <a href=\"../../../language-reference/keywords/select-clause\" data-linktype=\"relative-path\">select clause</a>.  </p>\n<h2 id=\"selecting-a-subset-of-each-source-element\">Selecting a Subset of each Source Element</h2>\n<p> There are two primary ways to select a subset of each element in the source sequence:  </p>\n<ol>\n<li><p>To select just one member of the source element, use the dot operation. In the following example, assume that a <code>Customer</code> object contains several public properties including a string named <code>City</code>. When executed, this query will produce an output sequence of strings.  </p>\n<pre class=\"loading\"><code>var query = from cust in Customers  \n            select cust.City;  \n</code></pre></li>\n<li><p>To create elements that contain more than one property from the source element, you can use an object initializer with either a named object or an anonymous type. The following example shows the use of an anonymous type to encapsulate two properties from each <code>Customer</code> element:  </p>\n<pre class=\"loading\"><code>var query = from cust in Customer  \n            select new {Name = cust.Name, City = cust.City};  \n</code></pre><p>For more information, see <a href=\"../../classes-and-structs/object-and-collection-initializers\" data-linktype=\"relative-path\">Object and Collection Initializers</a> and <a href=\"../../classes-and-structs/anonymous-types\" data-linktype=\"relative-path\">Anonymous Types</a>.  </p>\n</li>\n</ol>\n<h2 id=\"transforming-in-memory-objects-into-xml\">Transforming in-Memory Objects into XML</h2>\n<p> LINQ queries make it easy to transform data between in-memory data structures, SQL databases, ADO.NET Datasets and XML streams or documents. The following example transforms objects in an in-memory data structure into XML elements.  </p>\n<pre><code class=\"lang-cs\" name=\"CsLINQGettingStarted#9\">    class XMLTransform\n    {\n        static void Main()\n        {            \n            // Create the data source by using a collection initializer.\n            // The Student class was defined previously in this topic.\n            List&lt;Student&gt; students = new List&lt;Student&gt;()\n            {\n                new Student {First=&quot;Svetlana&quot;, Last=&quot;Omelchenko&quot;, ID=111, Scores = new List&lt;int&gt;{97, 92, 81, 60}},\n                new Student {First=&quot;Claire&quot;, Last=&quot;O’Donnell&quot;, ID=112, Scores = new List&lt;int&gt;{75, 84, 91, 39}},\n                new Student {First=&quot;Sven&quot;, Last=&quot;Mortensen&quot;, ID=113, Scores = new List&lt;int&gt;{88, 94, 65, 91}},\n            };\n\n            // Create the query.\n            var studentsToXML = new XElement(&quot;Root&quot;,\n                from student in students\n                let x = String.Format(&quot;{0},{1},{2},{3}&quot;, student.Scores[0],\n                        student.Scores[1], student.Scores[2], student.Scores[3])\n                select new XElement(&quot;student&quot;,\n                           new XElement(&quot;First&quot;, student.First),\n                           new XElement(&quot;Last&quot;, student.Last),\n                           new XElement(&quot;Scores&quot;, x)\n                        ) // end &quot;student&quot;\n                    ); // end &quot;Root&quot;\n\n            // Execute the query.\n            Console.WriteLine(studentsToXML);\n\n            // Keep the console open in debug mode.\n            Console.WriteLine(&quot;Press any key to exit.&quot;);\n            Console.ReadKey();\n        }\n    }\n</code></pre><p> The code produces the following XML output:  </p>\n<pre class=\"loading\"><code>&lt; Root&gt;  \n  &lt;student&gt;  \n    &lt;First&gt;Svetlana&lt;/First&gt;  \n    &lt;Last&gt;Omelchenko&lt;/Last&gt;  \n    &lt;Scores&gt;97,92,81,60&lt;/Scores&gt;  \n  &lt;/student&gt;  \n  &lt;student&gt;  \n    &lt;First&gt;Claire&lt;/First&gt;  \n    &lt;Last&gt;O&#39;Donnell&lt;/Last&gt;  \n    &lt;Scores&gt;75,84,91,39&lt;/Scores&gt;  \n  &lt;/student&gt;  \n  &lt;student&gt;  \n    &lt;First&gt;Sven&lt;/First&gt;  \n    &lt;Last&gt;Mortensen&lt;/Last&gt;  \n    &lt;Scores&gt;88,94,65,91&lt;/Scores&gt;  \n  &lt;/student&gt;  \n&lt;/Root&gt;  \n</code></pre><p> For more information, see <a href=\"creating-xml-trees-linq-to-xml-2\" data-linktype=\"relative-path\">Creating XML Trees in C# (LINQ to XML)</a>.  </p>\n<h2 id=\"performing-operations-on-source-elements\">Performing Operations on Source Elements</h2>\n<p> An output sequence might not contain any elements or element properties from the source sequence. The output might instead be a sequence of values that is computed by using the source elements as input arguments. The following simple query, when it is executed, outputs a sequence of strings whose values represent a calculation based on the source sequence of elements of type <code>double</code>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Calling methods in query expressions is not supported if the query will be translated into some other domain. For example, you cannot call an ordinary C# method in LINQ to SQL because SQL Server has no context for it. However, you can map stored procedures to methods and call those. For more information, see <a href=\"http://msdn.microsoft.com/library/4d23dd7a-a85f-44ff-a717-af7d0950c0fc\" data-linktype=\"external\">Stored Procedures</a>.  </p>\n</div>\n<pre><code class=\"lang-cs\" name=\"CsLINQGettingStarted#10\">    class FormatQuery\n    {\n        static void Main()\n        {            \n            // Data source.\n            double[] radii = { 1, 2, 3 };\n\n            // Query.\n            IEnumerable&lt;string&gt; query =\n                from rad in radii\n                select String.Format(&quot;Area = {0}&quot;, (rad * rad) * 3.14);\n\n            // Query execution. \n            foreach (string s in query)\n                Console.WriteLine(s);\n\n            // Keep the console open in debug mode.\n            Console.WriteLine(&quot;Press any key to exit.&quot;);\n            Console.ReadKey();\n        }\n    }\n    /* Output:\n        Area = 3.14\n        Area = 12.56\n        Area = 28.26\n    */\n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"index\" data-linktype=\"relative-path\">Language-Integrated Query (LINQ) (C#)</a><br> <a href=\"https://msdn.microsoft.com/library/bb386976\" data-linktype=\"external\">LINQ to SQL</a><br> <a href=\"http://msdn.microsoft.com/library/743e3755-3ecb-45a2-8d9b-9ed41f0dcf17\" data-linktype=\"external\">LINQ to DataSet</a><br> <a href=\"linq-to-xml\" data-linktype=\"relative-path\">LINQ to XML (C#)</a><br> <a href=\"../../linq-query-expressions/index\" data-linktype=\"relative-path\">LINQ Query Expressions</a><br> <a href=\"../../../language-reference/keywords/select-clause\" data-linktype=\"relative-path\">select clause</a></p>\n</div></div>","outputRootRelativePath":"../../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"toc2.json\">\r\n<meta name=\"ms.suite\" content=\"\">\r\n<meta name=\"ms.custom\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"674eae9e-bc72-4a88-aed3-802b45b25811\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"17\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"translation.priority.mt\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.mt\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.mt\" content=\"pt-br\">\r\n<meta name=\"translation.priority.mt\" content=\"tr-tr\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"ms.reviewer\" content=\"\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/concepts/linq/data-transformations-with-linq.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/concepts/linq/data-transformations-with-linq.md\">\r\n<meta name=\"document_id\" content=\"3ab23e1c-d1e2-0fc8-3906-5e09b479cd03\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Data Transformations with LINQ (C#) | Microsoft Docs","ms.suite":"","ms.custom":"","ms.assetid":"674eae9e-bc72-4a88-aed3-802b45b25811","translation.priority.ht":["de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","ru-ru","zh-cn","zh-tw"],"caps.latest.revision":17,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["LINQ [C#], data transformations","source elements [LINQ in C#]","joining multiple inputs [LINQ in C#]","multiple outputs for one output sequence [LINQ in C#]","subset of source elements [LINQ in C#]","data sources [LINQ in C#], data transformations","data transformations [LINQ in C#]"],"translation.priority.mt":["cs-cz","pl-pl","pt-br","tr-tr"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","ms.reviewer":"","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/concepts/linq/data-transformations-with-linq.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/concepts/linq/data-transformations-with-linq.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/concepts/linq/data-transformations-with-linq.md","document_id":"3ab23e1c-d1e2-0fc8-3906-5e09b479cd03","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/concepts/linq/data-transformations-with-linq","toc_asset_id":"articles/csharp/programming-guide/concepts/linq/toc.json","toc_rel":"toc.json","_op_ogTitle":"Data Transformations with LINQ (C#)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":1089,"_op_rawTitle":"<h1 id=\"data-transformations-with-linq-c\" sourcefile=\"docs/csharp/programming-guide/concepts/linq/data-transformations-with-linq.md\" sourcestartlinenumber=\"43\" sourceendlinenumber=\"43\">Data Transformations with LINQ (C#)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/concepts/linq/data-transformations-with-linq","fileRelativePath":"articles/csharp/programming-guide/concepts/linq/data-transformations-with-linq.html"},"themesRelativePathToOutputRoot":"_themes/"}