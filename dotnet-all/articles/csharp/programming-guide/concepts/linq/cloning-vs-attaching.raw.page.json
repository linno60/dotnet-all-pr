{"content":"<div><div class=\"content\">\n<p>When adding <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> (including <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>) or <a class=\"xref\" href=\"../../../../../api/system.xml.linq.xattribute\" data-linktype=\"relative-path\">XAttribute</a> objects to a new tree, if the new content has no parent, the objects are simply attached to the XML tree. If the new content already is parented, and is part of another XML tree, the new content is cloned. The newly cloned content is then attached to the XML tree.  </p>\n<h2 id=\"example\">Example</h2>\n<p> The following code demonstrates the behavior when you add a parented element to a tree, and when you add an element with no parent to a tree.  </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">// Create a tree with a child element.  \nXElement xmlTree1 = new XElement(&quot;Root&quot;,  \n    new XElement(&quot;Child1&quot;, 1)  \n);  \n\n// Create an element that is not parented.  \nXElement child2 = new XElement(&quot;Child2&quot;, 2);  \n\n// Create a tree and add Child1 and Child2 to it.  \nXElement xmlTree2 = new XElement(&quot;Root&quot;,  \n    xmlTree1.Element(&quot;Child1&quot;),  \n    child2  \n);  \n\n// Compare Child1 identity.  \nConsole.WriteLine(&quot;Child1 was {0}&quot;,  \n    xmlTree1.Element(&quot;Child1&quot;) == xmlTree2.Element(&quot;Child1&quot;) ?  \n    &quot;attached&quot; : &quot;cloned&quot;);  \n\n// Compare Child2 identity.  \nConsole.WriteLine(&quot;Child2 was {0}&quot;,  \n    child2 == xmlTree2.Element(&quot;Child2&quot;) ?  \n    &quot;attached&quot; : &quot;cloned&quot;);  \n</code></pre><p> This example produces the following output:  </p>\n<pre class=\"loading\"><code>Child1 was cloned  \nChild2 was attached  \n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"creating-xml-trees\" data-linktype=\"relative-path\">Creating XML Trees (C#)</a></p>\n</div></div>","outputRootRelativePath":"../../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"ms.suite\" content=\"\">\r\n<meta name=\"ms.custom\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"357c5efa-7b73-4f14-aa67-6bebdba4e7ea\">\r\n<meta name=\"caps.latest.revision\" content=\"3\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"translation.priority.mt\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.mt\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.mt\" content=\"pt-br\">\r\n<meta name=\"translation.priority.mt\" content=\"tr-tr\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"ms.reviewer\" content=\"\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-04-01 05:46 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/400dfda51d978f35c3995f90840643aaff1b9c13/docs/csharp/programming-guide/concepts/linq/cloning-vs-attaching.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/concepts/linq/cloning-vs-attaching.md\">\r\n<meta name=\"document_id\" content=\"90aa57bf-abca-90c2-270d-aa95ce4583c2\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","uhfHeaderId":"MSDocsHeader-DotNet","title":"Cloning vs. Attaching (C#) | Microsoft Docs","ms.suite":"","ms.custom":"","ms.assetid":"357c5efa-7b73-4f14-aa67-6bebdba4e7ea","caps.latest.revision":3,"ms.topic":"article","dev_langs":["csharp"],"translation.priority.mt":["cs-cz","pl-pl","pt-br","tr-tr"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","ms.reviewer":"","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"tompratt-AQ","author_email":"v-thprat@microsoft.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"Update language identifiers and styleguide. (#1796)","commit_sha":"400dfda51d978f35c3995f90840643aaff1b9c13","commit_date":"2017-03-24 14:01:03 -0700"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2017-04-01 05:46 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/tompratt-AQ","display_name":"tompratt-AQ","id":"26311438"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"4/1/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/400dfda51d978f35c3995f90840643aaff1b9c13/docs/csharp/programming-guide/concepts/linq/cloning-vs-attaching.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/concepts/linq/cloning-vs-attaching.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/concepts/linq/cloning-vs-attaching.md","document_id":"90aa57bf-abca-90c2-270d-aa95ce4583c2","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/concepts/linq/cloning-vs-attaching","toc_asset_id":"articles/csharp/programming-guide/concepts/linq/toc.json","toc_rel":"toc.json","_op_ogTitle":"Cloning vs. Attaching (C#)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":173,"_op_rawTitle":"<h1 id=\"cloning-vs-attaching-c\" sourcefile=\"docs/csharp/programming-guide/concepts/linq/cloning-vs-attaching.md\" sourcestartlinenumber=\"25\" sourceendlinenumber=\"25\">Cloning vs. Attaching (C#)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/concepts/linq/cloning-vs-attaching","fileRelativePath":"articles/csharp/programming-guide/concepts/linq/cloning-vs-attaching.html"},"themesRelativePathToOutputRoot":"_themes/"}