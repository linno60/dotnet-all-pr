{"content":"<div><div class=\"content\">\n<p>When you compare strings, you are producing a result that says one string is greater than or less than the other, or that the two strings are equal. The rules by which the result is determined are different depending on whether you are performing <em>ordinal comparison</em> or <em>culture-sensitive comparison</em>. It is important to use the correct kind of comparison for the specific task.  </p>\n<p> Use basic ordinal comparisons when you have to compare or sort the values of two strings without regard to linguistic conventions. A basic ordinal comparison (<code>System.StringComparison.Ordinal</code>) is case-sensitive, which means that the two strings must match character for character: &quot;and&quot; does not equal &quot;And&quot; or &quot;AND&quot;. A frequently-used variation is <code>System.StringComparison.OrdinalIgnoreCase</code>, which will match &quot;and&quot;, &quot;And&quot;, and &quot;AND&quot;. <code>StringComparison.OrdinalIgnoreCase</code> is often used to compare file names, path names, network paths, and any other string whose value does not change based on the locale of the user&#39;s computer. For more information, see <a class=\"xref\" href=\"../../../../api/system.stringcomparison\" data-linktype=\"relative-path\">System.StringComparison</a>.  </p>\n<p> Culture-sensitive comparisons are typically used to compare and sort strings that are input by end users, because the characters and sorting conventions of these strings might vary depending on the locale of the user&#39;s computer. Even strings that contain identical characters might sort differently depending on the culture of the current thread.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> When you compare strings, you should use the methods that explicitly specify what kind of comparison you intend to perform. This makes your code much more maintainable and readable. Whenever possible, use the overloads of the methods of the <a class=\"xref\" href=\"../../../../api/system.string\" data-linktype=\"relative-path\">System.String</a> and <a class=\"xref\" href=\"../../../../api/system.array\" data-linktype=\"relative-path\">System.Array</a> classes that take a <a class=\"xref\" href=\"../../../../api/system.stringcomparison\" data-linktype=\"relative-path\">StringComparison</a> enumeration parameter, so that you can specify which type of comparison to perform. It is best to avoid using the <code>==</code> and <code>!=</code> operators when you compare strings. Also, avoid using the <a class=\"xref\" href=\"../../../../api/system.string#System_String_CompareTo_\" data-linktype=\"relative-path\">CompareTo</a> instance methods because none of the overloads takes a <a class=\"xref\" href=\"../../../../api/system.stringcomparison\" data-linktype=\"relative-path\">StringComparison</a>.  </p>\n</div>\n<h2 id=\"example\">Example</h2>\n<p> The following example shows how to correctly compare strings whose values will not change based on the locale of the user&#39;s computer. In addition, it also demonstrates the <em>string interning</em> feature of C#. When a program declares two or more identical string variables, the compiler stores them all in the same location. By calling the <a class=\"xref\" href=\"../../../../api/system.object#System_Object_ReferenceEquals_\" data-linktype=\"relative-path\">ReferenceEquals</a> method, you can see that the two strings actually refer to the same object in memory. Use the <a class=\"xref\" href=\"../../../../api/system.string#System_String_Copy_\" data-linktype=\"relative-path\">Copy</a> method to avoid interning, as shown in the example.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideStrings#11\">\n            // Internal strings that will never be localized.\n            string root = @&quot;C:\\users&quot;;\n            string root2 = @&quot;C:\\Users&quot;;\n\n            // Use the overload of the Equals method that specifies a StringComparison.\n            // Ordinal is the fastest way to compare two strings.\n            bool result = root.Equals(root2, StringComparison.Ordinal);\n\n            Console.WriteLine(&quot;Ordinal comparison: {0} and {1} are {2}&quot;, root, root2,\n                                result ? &quot;equal.&quot; : &quot;not equal.&quot;);\n\n            // To ignore case means &quot;user&quot; equals &quot;User&quot;. This is the same as using\n            // String.ToUpperInvariant on each string and then performing an ordinal comparison.\n            result = root.Equals(root2, StringComparison.OrdinalIgnoreCase);\n            Console.WriteLine(&quot;Ordinal ignore case: {0} and {1} are {2}&quot;, root, root2,\n                                 result ? &quot;equal.&quot; : &quot;not equal.&quot;);\n\n            // A static method is also available.\n            bool areEqual = String.Equals(root, root2, StringComparison.Ordinal);\n\n\n            // String interning. Are these really two distinct objects?\n            string a = &quot;The computer ate my source code.&quot;;\n            string b = &quot;The computer ate my source code.&quot;;\n\n            // ReferenceEquals returns true if both objects\n            // point to the same location in memory.\n            if (String.ReferenceEquals(a, b))\n                Console.WriteLine(&quot;a and b are interned.&quot;);\n            else\n                Console.WriteLine(&quot;a and b are not interned.&quot;);\n\n            // Use String.Copy method to avoid interning.\n            string c = String.Copy(a);\n\n            if (String.ReferenceEquals(a, c))\n                Console.WriteLine(&quot;a and c are interned.&quot;);\n            else\n                Console.WriteLine(&quot;a and c are not interned.&quot;);\n\n            // Output:\n            // Ordinal comparison: C:\\users and C:\\Users are not equal.\n            // Ordinal ignore case: C:\\users and C:\\Users are equal.\n            // a and b are interned.\n            // a and c are not interned.\n</code></pre><h2 id=\"example-1\">Example</h2>\n<p> The following example shows how to compare strings the preferred way by using the <a class=\"xref\" href=\"../../../../api/system.string\" data-linktype=\"relative-path\">System.String</a> methods that take a <a class=\"xref\" href=\"../../../../api/system.stringcomparison\" data-linktype=\"relative-path\">StringComparison</a> enumeration. Note that the <a class=\"xref\" href=\"../../../../api/system.string#System_String_CompareTo_\" data-linktype=\"relative-path\">CompareTo</a> instance methods are not used here, because none of the overloads takes a <a class=\"xref\" href=\"../../../../api/system.stringcomparison\" data-linktype=\"relative-path\">StringComparison</a>.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideStrings#31\">            // &quot;They dance in the street.&quot;\n            // Linguistically (in Windows), &quot;ss&quot; is equal to \n            // the German essetz: &#39;&#223;&#39; character in both en-US and de-DE cultures.\n            string first = &quot;Sie tanzen in die Stra&#223;e.&quot;; \n            string second = &quot;Sie tanzen in die Strasse.&quot;;\n            \n            Console.WriteLine(&quot;First sentence is {0}&quot;, first);\n            Console.WriteLine(&quot;Second sentence is {0}&quot;, second);\n\n            // Store CultureInfo for the current culture. Note that the original culture\n            // can be set and retrieved on the current thread object.\n            System.Threading.Thread thread = System.Threading.Thread.CurrentThread;\n            System.Globalization.CultureInfo originalCulture = thread.CurrentCulture;\n\n            // Set the culture to en-US.\n            thread.CurrentCulture = new System.Globalization.CultureInfo(&quot;en-US&quot;);\n\n            // For culture-sensitive comparisons, use the String.Compare \n            // overload that takes a StringComparison value.\n            int i = String.Compare(first, second, StringComparison.CurrentCulture);\n            Console.WriteLine(&quot;Comparing in {0} returns {1}.&quot;, originalCulture.Name, i);\n           \n            // Change the current culture to Deutch-Deutchland.\n            thread.CurrentCulture = new System.Globalization.CultureInfo(&quot;de-DE&quot;);\n            i = String.Compare(first, second, StringComparison.CurrentCulture);\n            Console.WriteLine(&quot;Comparing in {0} returns {1}.&quot;, thread.CurrentCulture.Name, i);\n            \n            // For culture-sensitive string equality, use either StringCompare as above\n            // or the String.Equals overload that takes a StringComparison value.\n            thread.CurrentCulture = originalCulture;\n            bool b = String.Equals(first, second, StringComparison.CurrentCulture);\n            Console.WriteLine(&quot;The two strings {0} equal.&quot;, b == true ? &quot;are&quot; : &quot;are not&quot;);\n\n            /*\n             * Output:\n                First sentence is Sie tanzen in die Stra&#223;e.\n                Second sentence is Sie tanzen in die Strasse.\n                Comparing in en-US returns 0.\n                Comparing in de-DE returns 0.\n                The two strings are equal.\n             */\n</code></pre><h2 id=\"example-2\">Example</h2>\n<p> The following example shows how to sort and search for strings in an array in a culture-sensitive manner by using the static <a class=\"xref\" href=\"../../../../api/system.array\" data-linktype=\"relative-path\">Array</a> methods that take a <a class=\"xref\" href=\"../../../../api/system.stringcomparer\" data-linktype=\"relative-path\">System.StringComparer</a> parameter.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideStrings#32\">    class SortStringArrays\n    {\n        static void Main()\n        {\n            \n            string[] lines = new string[]\n            {\n                @&quot;c:\\public\\textfile.txt&quot;,\n                @&quot;c:\\public\\textFile.TXT&quot;,\n                @&quot;c:\\public\\Text.txt&quot;,\n                @&quot;c:\\public\\testfile2.txt&quot;\n            };\n\n            Console.WriteLine(&quot;Non-sorted order:&quot;);\n            foreach (string s in lines)\n            {\n                Console.WriteLine(&quot;   {0}&quot;, s);\n            }\n\n            Console.WriteLine(&quot;\\n\\rSorted order:&quot;);\n\n            // Specify Ordinal to demonstrate the different behavior.\n            Array.Sort(lines, StringComparer.Ordinal);\n\n            foreach (string s in lines)\n            {\n                Console.WriteLine(&quot;   {0}&quot;, s);\n            }\n           \n\n            string searchString = @&quot;c:\\public\\TEXTFILE.TXT&quot;;\n            Console.WriteLine(&quot;Binary search for {0}&quot;, searchString);\n            int result = Array.BinarySearch(lines, searchString, StringComparer.OrdinalIgnoreCase);\n            ShowWhere&lt;string&gt;(lines, result);\n\n            //Console.WriteLine(&quot;{0} {1}&quot;, result &gt; 0 ? &quot;Found&quot; : &quot;Did not find&quot;, searchString);\n\n            // Keep the console window open in debug mode.\n            System.Console.WriteLine(&quot;Press any key to exit.&quot;);\n            System.Console.ReadKey();\n        }\n\n        // Displays where the string was found, or, if not found,\n        // where it would have been located.\n        private static void ShowWhere&lt;T&gt;(T[] array, int index)\n        {\n            if (index &lt; 0)\n            {\n                // If the index is negative, it represents the bitwise\n                // complement of the next larger element in the array.\n                index = ~index;\n\n                Console.Write(&quot;Not found. Sorts between: &quot;);\n\n                if (index == 0)\n                    Console.Write(&quot;beginning of array and &quot;);\n                else\n                    Console.Write(&quot;{0} and &quot;, array[index - 1]);\n\n                if (index == array.Length)\n                    Console.WriteLine(&quot;end of array.&quot;);\n                else\n                    Console.WriteLine(&quot;{0}.&quot;, array[index]);\n            }\n            else\n            {\n                Console.WriteLine(&quot;Found at index {0}.&quot;, index);\n            }\n        }\n\n\n    }\n    /*\n     * Output:\n        Non-sorted order:\n           c:\\public\\textfile.txt\n           c:\\public\\textFile.TXT\n           c:\\public\\Text.txt\n           c:\\public\\testfile2.txt\n\n        Sorted order:\n           c:\\public\\Text.txt\n           c:\\public\\testfile2.txt\n           c:\\public\\textFile.TXT\n           c:\\public\\textfile.txt\n        Binary search for c:\\public\\TEXTFILE.TXT\n        Found at index 2.\n     */\n</code></pre><p> Collection classes such as <a class=\"xref\" href=\"../../../../api/system.collections.hashtable\" data-linktype=\"relative-path\">System.Collections.Hashtable</a>, <a class=\"xref\" href=\"../../../../api/system.collections.generic.dictionary-2\" data-linktype=\"relative-path\">System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;</a>, and <a class=\"xref\" href=\"../../../../api/system.collections.generic.list-1\" data-linktype=\"relative-path\">System.Collections.Generic.List&lt;T&gt;</a> have constructors that take a <a class=\"xref\" href=\"../../../../api/system.stringcomparer\" data-linktype=\"relative-path\">System.StringComparer</a> parameter when the type of the elements or keys is <code>string</code>. In general, you should use these constructors whenever possible, and specify either <code>Ordinal</code> or <code>OrdinalIgnoreCase</code>.  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a class=\"xref\" href=\"../../../../api/system.globalization.cultureinfo\" data-linktype=\"relative-path\">System.Globalization.CultureInfo</a><br> <a class=\"xref\" href=\"../../../../api/system.stringcomparer\" data-linktype=\"relative-path\">System.StringComparer</a><br> <a href=\"index\" data-linktype=\"relative-path\">Strings</a><br> <a href=\"http://msdn.microsoft.com/library/977dc094-fe19-4955-98ec-d2294d04a4ba\" data-linktype=\"external\">Comparing Strings</a><br> <a href=\"https://docs.microsoft.com/visualstudio/ide/globalizing-and-localizing-applications\" data-linktype=\"external\">Globalizing and Localizing Applications</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc2.json\">\r\n<meta name=\"ms.assetid\" content=\"e1268e28-ee98-4695-98e9-92280f1c33c0\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"23\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-21 01:42 AM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/strings/how-to-compare-strings.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/csharp/programming-guide/strings/how-to-compare-strings.md\">\r\n<meta name=\"document_id\" content=\"94d1c603-5f2b-ec46-0f34-3b0076625e53\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"How to: Compare Strings (C# Programming Guide) | Microsoft Docs","ms.assetid":"e1268e28-ee98-4695-98e9-92280f1c33c0","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":23,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["strings [C#], comparison","comparing strings [C#]"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Absolute urls and other fixes (#1281)","commit_sha":"f7dffe4885b331cec8d37f3cc5c9163f69c3b4c9","commit_date":"2016-11-22 12:57:26 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2017-03-21 01:42 AM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"3/21/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/strings/how-to-compare-strings.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/csharp/programming-guide/strings/how-to-compare-strings.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/strings/how-to-compare-strings.md","document_id":"94d1c603-5f2b-ec46-0f34-3b0076625e53","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/programming-guide/strings/how-to-compare-strings","toc_asset_id":"articles/csharp/programming-guide/strings/toc.json","toc_rel":"toc.json","_op_ogTitle":"How to: Compare Strings (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":1145,"_op_rawTitle":"<h1 id=\"how-to-compare-strings-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/strings/how-to-compare-strings.md\" sourcestartlinenumber=\"37\" sourceendlinenumber=\"37\">How to: Compare Strings (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/programming-guide/strings/how-to-compare-strings","fileRelativePath":"articles/csharp/programming-guide/strings/how-to-compare-strings.html"},"themesRelativePathToOutputRoot":"_themes/"}