{"content":"<div><div class=\"content\">\n<p>An <a href=\"../../language-reference/keywords/interface\" data-linktype=\"relative-path\">interface</a> can declare an <a href=\"../../language-reference/keywords/event\" data-linktype=\"relative-path\">event</a>. The following example shows how to implement interface events in a class. Basically the rules are the same as when you implement any interface method or property.  </p>\n<h3 id=\"to-implement-interface-events-in-a-class\">To implement interface events in a class</h3>\n<ul>\n<li><p>Declare the event in your class and then invoke it in the appropriate areas.  </p>\n<pre class=\"loading\"><code>namespace ImplementInterfaceEvents  \n{  \n    public interface IDrawingObject  \n    {  \n        event EventHandler ShapeChanged;  \n    }  \n    public class MyEventArgs : EventArgs   \n    {  \n        // class members  \n    }  \n    public class Shape : IDrawingObject  \n    {  \n        public event EventHandler ShapeChanged;  \n        void ChangeShape()  \n        {  \n            // Do something here before the eventâ€¦  \n\n            OnShapeChanged(new MyEventArgs(/*arguments*/));  \n\n            // or do something here after the event.   \n        }  \n        protected virtual void OnShapeChanged(MyEventArgs e)  \n        {  \n            if(ShapeChanged != null)  \n            {  \n               ShapeChanged(this, e);  \n            }  \n        }  \n    }  \n\n}  \n</code></pre></li>\n</ul>\n<h2 id=\"example\">Example</h2>\n<p> The following example shows how to handle the less-common situation in which your class inherits from two or more interfaces and each interface has an event with the same name. In this situation, you must provide an explicit interface implementation for at least one of the events. When you write an explicit interface implementation for an event, you must also write the <code>add</code> and <code>remove</code> event accessors. Normally these are provided by the compiler, but in this case the compiler cannot provide them.  </p>\n<p> By providing your own accessors, you can specify whether the two events are represented by the same event in your class, or by different events. For example, if the events should be raised at different times according to the interface specifications, you can associate each event with a separate implementation in your class. In the following example, subscribers determine which <code>OnDraw</code> event they will receive by casting the shape reference to either an <code>IShape</code> or an <code>IDrawingObject</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideEvents#10\">namespace WrapTwoInterfaceEvents\n{\n    using System;\n\n    public interface IDrawingObject\n    {\n        // Raise this event before drawing\n        // the object.\n        event EventHandler OnDraw;\n    }\n    public interface IShape\n    {\n        // Raise this event after drawing\n        // the shape.\n        event EventHandler OnDraw;\n    }\n\n\n    // Base class event publisher inherits two\n    // interfaces, each with an OnDraw event\n    public class Shape : IDrawingObject, IShape\n    {\n        // Create an event for each interface event\n        event EventHandler PreDrawEvent;\n        event EventHandler PostDrawEvent;\n\n        object objectLock = new Object();\n\n        // Explicit interface implementation required.\n        // Associate IDrawingObject&#39;s event with\n        // PreDrawEvent\n        event EventHandler IDrawingObject.OnDraw\n        {\n            add\n            {\n                lock (objectLock)\n                {\n                    PreDrawEvent += value;\n                }\n            }\n            remove\n            {\n                lock (objectLock)\n                {\n                    PreDrawEvent -= value;\n                }\n            }\n        }\n        // Explicit interface implementation required.\n        // Associate IShape&#39;s event with\n        // PostDrawEvent\n        event EventHandler IShape.OnDraw\n        {\n            add\n            {\n                lock (objectLock)\n                {\n                    PostDrawEvent += value;\n                }\n            }\n            remove\n            {\n                lock (objectLock)\n                {\n                    PostDrawEvent -= value;\n                }\n            }\n\n\n        }\n\n        // For the sake of simplicity this one method\n        // implements both interfaces. \n        public void Draw()\n        {\n            // Raise IDrawingObject&#39;s event before the object is drawn.\n            EventHandler handler = PreDrawEvent;\n            if (handler != null)\n            {\n                handler(this, new EventArgs());\n            }\n            Console.WriteLine(&quot;Drawing a shape.&quot;);\n\n            // RaiseIShape&#39;s event after the object is drawn.\n            handler = PostDrawEvent;\n            if (handler != null)\n            {\n                handler(this, new EventArgs());\n            }\n        }\n    }\n    public class Subscriber1\n    {\n        // References the shape object as an IDrawingObject\n        public Subscriber1(Shape shape)\n        {\n            IDrawingObject d = (IDrawingObject)shape;\n            d.OnDraw += new EventHandler(d_OnDraw);\n        }\n\n        void d_OnDraw(object sender, EventArgs e)\n        {\n            Console.WriteLine(&quot;Sub1 receives the IDrawingObject event.&quot;);\n        }\n    }\n    // References the shape object as an IShape\n    public class Subscriber2\n    {\n        public Subscriber2(Shape shape)\n        {\n            IShape d = (IShape)shape;\n            d.OnDraw += new EventHandler(d_OnDraw);\n        }\n\n        void d_OnDraw(object sender, EventArgs e)\n        {\n            Console.WriteLine(&quot;Sub2 receives the IShape event.&quot;);\n        }\n    }\n\n\n    public class Program\n    {\n        static void Main(string[] args)\n        {\n            Shape shape = new Shape();\n            Subscriber1 sub = new Subscriber1(shape);\n            Subscriber2 sub2 = new Subscriber2(shape);\n            shape.Draw();\n\n            // Keep the console window open in debug mode.\n            System.Console.WriteLine(&quot;Press any key to exit.&quot;);\n            System.Console.ReadKey();\n        }\n    }\n\n}\n/* Output:\n    Sub1 receives the IDrawingObject event.\n    Drawing a shape.\n    Sub2 receives the IShape event.\n*/\n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../index\" data-linktype=\"relative-path\">C# Programming Guide</a><br> <a href=\"index\" data-linktype=\"relative-path\">Events</a><br> <a href=\"../delegates/index\" data-linktype=\"relative-path\">Delegates</a><br> <a href=\"../interfaces/explicit-interface-implementation\" data-linktype=\"relative-path\">Explicit Interface Implementation</a><br> <a href=\"how-to-raise-base-class-events-in-derived-classes\" data-linktype=\"relative-path\">How to: Raise Base Class Events in Derived Classes</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.assetid\" content=\"63527447-9535-4880-8e95-35e2075827df\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"21\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/events/how-to-implement-interface-events.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/events/how-to-implement-interface-events.md\">\r\n<meta name=\"document_id\" content=\"f7286492-be1a-9316-7a76-38405704c5c4\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","title":"How to: Implement Interface Events (C# Programming Guide) | Microsoft Docs","ms.assetid":"63527447-9535-4880-8e95-35e2075827df","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":21,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["interfaces [C#], event implementation in classes","events [C#], in interfaces"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/events/how-to-implement-interface-events.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/events/how-to-implement-interface-events.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/events/how-to-implement-interface-events.md","document_id":"f7286492-be1a-9316-7a76-38405704c5c4","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/events/how-to-implement-interface-events","toc_asset_id":"articles/csharp/programming-guide/events/toc.json","toc_rel":"toc.json","_op_ogTitle":"How to: Implement Interface Events (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":651,"_op_rawTitle":"<h1 id=\"how-to-implement-interface-events-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/events/how-to-implement-interface-events.md\" sourcestartlinenumber=\"37\" sourceendlinenumber=\"37\">How to: Implement Interface Events (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/programming-guide/events/how-to-implement-interface-events","fileRelativePath":"articles/csharp/programming-guide/events/how-to-implement-interface-events.html"},"themesRelativePathToOutputRoot":"_themes/"}