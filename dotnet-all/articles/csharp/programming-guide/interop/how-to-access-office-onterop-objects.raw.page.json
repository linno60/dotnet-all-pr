{"content":"<div><div class=\"content\">\n<p>Visual C# 2010 introduces new features that simplify access to Office API objects. The new features include named and optional arguments, a new type called <code>dynamic</code>, and the ability to pass arguments to reference parameters in COM methods as if they were value parameters.  </p>\n<p> In this topic you will use the new features to write code that creates and displays a Microsoft Office Excel worksheet. You will then write code to add an Office Word document that contains an icon that is linked to the Excel worksheet.  </p>\n<p> To complete this walkthrough, you must have Microsoft Office Excel 2007 and Microsoft Office Word 2007, or later versions, installed on your computer.  </p>\n<p> If you are using an operating system that is older than Windows Vista, make sure that .NET Framework 2.0 is installed.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p>Your computer might show different names or locations for some of the Visual Studio user interface elements in the following instructions. The Visual Studio edition that you have and the settings that you use determine these elements. For more information, see <a href=\"https://docs.microsoft.com/visualstudio/ide/personalizing-the-visual-studio-ide\" data-linktype=\"external\">Personalizing the IDE</a>.</p>\n</div>\n<h3 id=\"to-create-a-new-console-application\">To create a new console application</h3>\n<ol>\n<li><p>Start Visual Studio.  </p>\n</li>\n<li><p>On the <strong>File</strong> menu, point to <strong>New</strong>, and then click <strong>Project</strong>. The <strong>New Project</strong> dialog box appears.  </p>\n</li>\n<li><p>In the <strong>Installed Templates</strong> pane, expand <strong>Visual C#</strong>, and then click <strong>Windows</strong>.  </p>\n</li>\n<li><p>Look at the top of the <strong>New Project</strong> dialog box to make sure that <strong>.NET Framework 4</strong> (or later version) is selected as a target framework.  </p>\n</li>\n<li><p>In the <strong>Templates</strong> pane, click <strong>Console Application</strong>.  </p>\n</li>\n<li><p>Type a name for your project in the <strong>Name</strong> field.  </p>\n</li>\n<li><p>Click <strong>OK</strong>.  </p>\n<p> The new project appears in <strong>Solution Explorer</strong>.  </p>\n</li>\n</ol>\n<h3 id=\"to-add-references\">To add references</h3>\n<ol>\n<li><p>In <strong>Solution Explorer</strong>, right-click your project&#39;s name and then click <strong>Add Reference</strong>. The <strong>Add Reference</strong> dialog box appears.  </p>\n</li>\n<li><p>On the <strong>Assemblies</strong>  page, select <strong>Microsoft.Office.Interop.Word</strong> in the <strong>Component Name</strong> list, and then hold down the CTRL key and select <strong>Microsoft.Office.Interop.Excel</strong>.  If you do not see the assemblies, you may need to ensure they are installed and displayed (see <a href=\"http://msdn.microsoft.com/library/92948fcc-76c6-4b08-ba63-cab59dd60eb1\" data-linktype=\"external\">How to: Install Office Primary Interop Assemblies</a>)  </p>\n</li>\n<li><p>Click <strong>OK</strong>.  </p>\n</li>\n</ol>\n<h3 id=\"to-add-necessary-using-directives\">To add necessary using directives</h3>\n<ol>\n<li><p>In <strong>Solution Explorer</strong>, right-click the <strong>Program.cs</strong> file and then click <strong>View Code</strong>.  </p>\n</li>\n<li><p>Add the following <code>using</code> directives to the top of the code file.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideOfficeHowTo#1\">using Excel = Microsoft.Office.Interop.Excel;\nusing Word = Microsoft.Office.Interop.Word;\n</code></pre></li>\n</ol>\n<h3 id=\"to-create-a-list-of-bank-accounts\">To create a list of bank accounts</h3>\n<ol>\n<li><p>Paste the following class definition into <strong>Program.cs</strong>, under the <code>Program</code> class.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideOfficeHowTo#2\">    public class Account\n    {\n        public int ID { get; set; }\n        public double Balance { get; set; }\n    }\n</code></pre></li>\n<li><p>Add the following code to the <code>Main</code> method to create a <code>bankAccounts</code> list that contains two accounts.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideOfficeHowTo#3\">            // Create a list of accounts.\n            var bankAccounts = new List&lt;Account&gt; {\n                new Account { \n                              ID = 345678,\n                              Balance = 541.27\n                            },\n                new Account {\n                              ID = 1230221,\n                              Balance = -127.44\n                            }\n            };\n</code></pre></li>\n</ol>\n<h3 id=\"to-declare-a-method-that-exports-account-information-to-excel\">To declare a method that exports account information to Excel</h3>\n<ol>\n<li><p>Add the following method to the <code>Program</code> class to set up an Excel worksheet.  </p>\n<p> Method <a href=\"http://go.microsoft.com/fwlink/?LinkId=210910\" data-linktype=\"external\">Add</a> has an optional parameter for specifying a particular template. Optional parameters, new in Visual C# 2010, enable you to omit the argument for that parameter if you want to use the parameter&#39;s default value. Because no argument is sent in the following code, <code>Add</code> uses the default template and creates a new workbook. The equivalent statement in earlier versions of C# requires a placeholder argument: <code>ExcelApp.Workbooks.Add(Type.Missing)</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideOfficeHowTo#4\">        static void DisplayInExcel(IEnumerable&lt;Account&gt; accounts)\n        {\n            var excelApp = new Excel.Application();\n            // Make the object visible.\n            excelApp.Visible = true;\n\n            // Create a new, empty workbook and add it to the collection returned \n            // by property Workbooks. The new workbook becomes the active workbook.\n            // Add has an optional parameter for specifying a praticular template. \n            // Because no argument is sent in this example, Add creates a new workbook. \n            excelApp.Workbooks.Add();\n\n            // This example uses a single workSheet. The explicit type casting is\n            // removed in a later procedure.\n            Excel._Worksheet workSheet = (Excel.Worksheet)excelApp.ActiveSheet;\n        }\n</code></pre></li>\n<li><p>Add the following code at the end of <code>DisplayInExcel</code>. The code inserts values into the first two columns of the first row of the worksheet.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideOfficeHowTo#5\">            // Establish column headings in cells A1 and B1.\n            workSheet.Cells[1, &quot;A&quot;] = &quot;ID Number&quot;;\n            workSheet.Cells[1, &quot;B&quot;] = &quot;Current Balance&quot;;\n</code></pre></li>\n<li><p>Add the following code at the end of <code>DisplayInExcel</code>. The <code>foreach</code> loop puts the information from the list of accounts into the first two columns of successive rows of the worksheet.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideOfficeHowTo#7\">\n            var row = 1;\n            foreach (var acct in accounts)\n            {\n                row++;\n                workSheet.Cells[row, &quot;A&quot;] = acct.ID;\n                workSheet.Cells[row, &quot;B&quot;] = acct.Balance;\n            }\n</code></pre></li>\n<li><p>Add the following code at the end of <code>DisplayInExcel</code> to adjust the column widths to fit the content.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideOfficeHowTo#13\">            workSheet.Columns[1].AutoFit();\n            workSheet.Columns[2].AutoFit();\n</code></pre><p> Earlier versions of C# require explicit casting for these operations because <code>ExcelApp.Columns[1]</code> returns an <code>Object</code>, and <code>AutoFit</code> is an Excel <a href=\"http://go.microsoft.com/fwlink/?LinkId=210911\" data-linktype=\"external\">Range</a> method. The following lines show the casting.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideOfficeHowTo#14\">            ((Excel.Range)workSheet.Columns[1]).AutoFit();\n            ((Excel.Range)workSheet.Columns[2]).AutoFit();\n</code></pre><p> Visual C# 2010, and later versions, converts the returned <code>Object</code> to <code>dynamic</code> automatically if the assembly is referenced by the <a href=\"../../language-reference/compiler-options/link-compiler-option\" data-linktype=\"relative-path\">/link</a> compiler option or, equivalently, if the Excel <strong>Embed Interop Types</strong> property is set to true. True is the default value for this property.  </p>\n</li>\n</ol>\n<h3 id=\"to-run-the-project\">To run the project</h3>\n<ol>\n<li><p>Add the following line at the end of <code>Main</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideOfficeHowTo#8\">            // Display the list in an Excel spreadsheet.\n            DisplayInExcel(bankAccounts);\n</code></pre></li>\n<li><p>Press CTRL+F5.  </p>\n<p> An Excel worksheet appears that contains the data from the two accounts.  </p>\n</li>\n</ol>\n<h3 id=\"to-add-a-word-document\">To add a Word document</h3>\n<ol>\n<li><p>To illustrate additional ways in which Visual C# 2010, and later versions, enhances Office programming, the following code opens a Word application and creates an icon that links to the Excel worksheet.  </p>\n<p> Paste method <code>CreateIconInWordDoc</code>, provided later in this step, into the <code>Program</code> class. <code>CreateIconInWordDoc</code> uses named and optional arguments to reduce the complexity of the method calls to <a href=\"http://go.microsoft.com/fwlink/?LinkId=210937\" data-linktype=\"external\">Add</a> and <a href=\"http://go.microsoft.com/fwlink/?LinkId=147099\" data-linktype=\"external\">PasteSpecial</a>. These calls incorporate two other new features introduced in Visual C# 2010 that simplify calls to COM methods that have reference parameters. First, you can send arguments to the reference parameters as if they were value parameters. That is, you can send values directly, without creating a variable for each reference parameter. The compiler generates temporary variables to hold the argument values, and discards the variables when you return from the call. Second, you can omit the <code>ref</code> keyword in the argument list.  </p>\n<p> The <code>Add</code> method has four reference parameters, all of which are optional. In Visual C# 2010, or later versions, you can omit arguments for any or all of the parameters if you want to use their default values. In Visual C# 2008 and earlier versions, an argument must be provided for each parameter, and the argument must be a variable because the parameters are reference parameters.  </p>\n<p> The <code>PasteSpecial</code> method inserts the contents of the Clipboard. The method has seven reference parameters, all of which are optional. The following code specifies arguments for two of them: <code>Link</code>, to create a link to the source of the Clipboard contents, and <code>DisplayAsIcon</code>, to display the link as an icon. In Visual C# 2010, you can use named arguments for those two and omit the others. Although these are reference parameters, you do not have to use the <code>ref</code> keyword, or to create variables to send in as arguments. You can send the values directly. In Visual C# 2008 and earlier versions, you must send a variable argument for each reference parameter.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideOfficeHowTo#9\">        static void CreateIconInWordDoc()\n        {\n            var wordApp = new Word.Application();\n            wordApp.Visible = true;\n\n            // The Add method has four reference parameters, all of which are \n            // optional. Visual C# 2010 allows you to omit arguments for them if\n            // the default values are what you want.\n            wordApp.Documents.Add();\n\n            // PasteSpecial has seven reference parameters, all of which are \n            // optional. This example uses named arguments to specify values \n            // for two of the parameters. Although these are reference \n            // parameters, you do not need to use the ref keyword, or to create \n            // variables to send in as arguments. You can send the values directly.\n            wordApp.Selection.PasteSpecial( Link: true, DisplayAsIcon: true);\n        }\n</code></pre><p> In Visual C# 2008 or earlier versions of the language, the following more complex code is required.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideOfficeHowTo#10\">        static void CreateIconInWordDoc2008()\n        {\n            var wordApp = new Word.Application();\n            wordApp.Visible = true;\n\n            // The Add method has four parameters, all of which are optional. \n            // In Visual C# 2008 and earlier versions, an argument has to be sent \n            // for every parameter. Because the parameters are reference  \n            // parameters of type object, you have to create an object variable\n            // for the arguments that represents &#39;no value&#39;. \n\n            object useDefaultValue = Type.Missing;\n\n            wordApp.Documents.Add(ref useDefaultValue, ref useDefaultValue,\n                ref useDefaultValue, ref useDefaultValue);\n\n            // PasteSpecial has seven reference parameters, all of which are\n            // optional. In this example, only two of the parameters require\n            // specified values, but in Visual C# 2008 an argument must be sent\n            // for each parameter. Because the parameters are reference parameters,\n            // you have to contruct variables for the arguments.\n            object link = true;\n            object displayAsIcon = true;\n\n            wordApp.Selection.PasteSpecial( ref useDefaultValue,\n                                            ref link,\n                                            ref useDefaultValue,\n                                            ref displayAsIcon,\n                                            ref useDefaultValue,\n                                            ref useDefaultValue,\n                                            ref useDefaultValue);\n        }\n</code></pre></li>\n<li><p>Add the following statement at the end of <code>Main</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideOfficeHowTo#11\">            // Create a Word document that contains an icon that links to\n            // the spreadsheet.\n            CreateIconInWordDoc();\n</code></pre></li>\n<li><p>Add the following statement at the end of <code>DisplayInExcel</code>. The <code>Copy</code> method adds the worksheet to the Clipboard.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideOfficeHowTo#12\">            // Put the spreadsheet contents on the clipboard. The Copy method has one\n            // optional parameter for specifying a destination. Because no argument  \n            // is sent, the destination is the Clipboard.\n            workSheet.Range[&quot;A1:B3&quot;].Copy();\n</code></pre></li>\n<li><p>Press CTRL+F5.  </p>\n<p> A Word document appears that contains an icon. Double-click the icon to bring the worksheet to the foreground.  </p>\n</li>\n</ol>\n<h3 id=\"to-set-the-embed-interop-types-property\">To set the Embed Interop Types property</h3>\n<ol>\n<li><p>Additional enhancements are possible when you call a COM type that does not require a primary interop assembly (PIA) at run time. Removing the dependency on PIAs results in version independence and easier deployment. For more information about the advantages of programming without PIAs, see <a href=\"http://msdn.microsoft.com/library/b28ec92c-1867-4847-95c0-61adfe095e21\" data-linktype=\"external\">Walkthrough: Embedding Types from Managed Assemblies</a>.  </p>\n<p> In addition, programming is easier because the types that are required and returned by COM methods can be represented by using the type <code>dynamic</code> instead of <code>Object</code>. Variables that have type <code>dynamic</code> are not evaluated until run time, which eliminates the need for explicit casting. For more information, see <a href=\"../types/using-type-dynamic\" data-linktype=\"relative-path\">Using Type dynamic</a>.  </p>\n<p> In Visual C# 2010, embedding type information instead of using PIAs is default behavior. Because of that default, several of the previous examples are simplified because explicit casting is not required. For example, the declaration of <code>worksheet</code> in <code>DisplayInExcel</code> is written as <code>Excel._Worksheet workSheet = excelApp.ActiveSheet</code> rather than <code>Excel._Worksheet workSheet = (Excel.Worksheet)excelApp.ActiveSheet</code>. The calls to <code>AutoFit</code> in the same method also would require explicit casting without the default, because <code>ExcelApp.Columns[1]</code> returns an <code>Object</code>, and <code>AutoFit</code> is an Excel  method. The following code shows the casting.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideOfficeHowTo#14\">            ((Excel.Range)workSheet.Columns[1]).AutoFit();\n            ((Excel.Range)workSheet.Columns[2]).AutoFit();\n</code></pre></li>\n<li><p>To change the default and use PIAs instead of embedding type information, expand the <strong>References</strong> node in <strong>Solution Explorer</strong> and then select <strong>Microsoft.Office.Interop.Excel</strong> or <strong>Microsoft.Office.Interop.Word</strong>.  </p>\n</li>\n<li><p>If you cannot see the <strong>Properties</strong> window, press <strong>F4</strong>.  </p>\n</li>\n<li><p>Find <strong>Embed Interop Types</strong> in the list of properties, and change its value to <strong>False</strong>. Equivalently, you can compile by using the <a href=\"../../language-reference/compiler-options/reference-compiler-option\" data-linktype=\"relative-path\">/reference</a> compiler option instead of <a href=\"../../language-reference/compiler-options/link-compiler-option\" data-linktype=\"relative-path\">/link</a> at a command prompt.  </p>\n</li>\n</ol>\n<h3 id=\"to-add-additional-formatting-to-the-table\">To add additional formatting to the table</h3>\n<ol>\n<li><p>Replace the two calls to <code>AutoFit</code> in <code>DisplayInExcel</code> with the following statement.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideOfficeHowTo#15\">            // Call to AutoFormat in Visual C# 2010.\n            workSheet.Range[&quot;A1&quot;, &quot;B3&quot;].AutoFormat(\n                Excel.XlRangeAutoFormat.xlRangeAutoFormatClassic2);\n</code></pre><p> The <a href=\"http://go.microsoft.com/fwlink/?LinkId=210948\" data-linktype=\"external\">AutoFormat</a> method has seven value parameters, all of which are optional. Named and optional arguments enable you to provide arguments for none, some, or all of them. In the previous statement, an argument is supplied for only one of the parameters, <code>Format</code>. Because <code>Format</code> is the first parameter in the parameter list, you do not have to provide the parameter name. However, the statement might be easier to understand if the parameter name is included, as is shown in the following code.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideOfficeHowTo#16\">            // Call to AutoFormat in Visual C# 2010.\n            workSheet.Range[&quot;A1&quot;, &quot;B3&quot;].AutoFormat(Format:\n                Excel.XlRangeAutoFormat.xlRangeAutoFormatClassic2);\n</code></pre></li>\n<li><p>Press CTRL+F5 to see the result. Other formats are listed in the <a href=\"http://go.microsoft.com/fwlink/?LinkId=210967\" data-linktype=\"external\">XlRangeAutoFormat</a> enumeration.  </p>\n</li>\n<li><p>Compare the statement in step 1 with the following code, which shows the arguments that are required in Visual C# 2008 or earlier versions.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideOfficeHowTo#17\">            // The AutoFormat method has seven optional value parameters. The\n            // following call specifies a value for the first parameter, and uses \n            // the default values for the other six. \n\n            // Call to AutoFormat in Visual C# 2008. This code is not part of the\n            // current solution.\n            excelApp.get_Range(&quot;A1&quot;, &quot;B4&quot;).AutoFormat(Excel.XlRangeAutoFormat.xlRangeAutoFormatTable3, \n                Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing, \n                Type.Missing);\n</code></pre></li>\n</ol>\n<h2 id=\"example\">Example</h2>\n<p> The following code shows the complete example.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideOfficeHowTo#18\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Excel = Microsoft.Office.Interop.Excel;\nusing Word = Microsoft.Office.Interop.Word;\n\n\nnamespace OfficeProgramminWalkthruComplete\n{\n    class Walkthrough\n    {\n        static void Main(string[] args)\n        {\n            // Create a list of accounts.\n            var bankAccounts = new List&lt;Account&gt; \n            {\n                new Account { \n                              ID = 345678,\n                              Balance = 541.27\n                            },\n                new Account {\n                              ID = 1230221,\n                              Balance = -127.44\n                            }\n            };\n\n            // Display the list in an Excel spreadsheet.\n            DisplayInExcel(bankAccounts);\n\n            // Create a Word document that contains an icon that links to\n            // the spreadsheet.\n            CreateIconInWordDoc();\n        }\n\n        static void DisplayInExcel(IEnumerable&lt;Account&gt; accounts)\n        {\n            var excelApp = new Excel.Application();\n            // Make the object visible.\n            excelApp.Visible = true;\n\n            // Create a new, empty workbook and add it to the collection returned \n            // by property Workbooks. The new workbook becomes the active workbook.\n            // Add has an optional parameter for specifying a praticular template. \n            // Because no argument is sent in this example, Add creates a new workbook. \n            excelApp.Workbooks.Add();\n\n            // This example uses a single workSheet. \n            Excel._Worksheet workSheet = excelApp.ActiveSheet;\n\n            // Earlier versions of C# require explicit casting.\n            //Excel._Worksheet workSheet = (Excel.Worksheet)excelApp.ActiveSheet;\n\n            // Establish column headings in cells A1 and B1.\n            workSheet.Cells[1, &quot;A&quot;] = &quot;ID Number&quot;;\n            workSheet.Cells[1, &quot;B&quot;] = &quot;Current Balance&quot;;\n\n            var row = 1;\n            foreach (var acct in accounts)\n            {\n                row++;\n                workSheet.Cells[row, &quot;A&quot;] = acct.ID;\n                workSheet.Cells[row, &quot;B&quot;] = acct.Balance;\n            }\n\n            workSheet.Columns[1].AutoFit();\n            workSheet.Columns[2].AutoFit();\n\n            // Call to AutoFormat in Visual C# 2010. This statement replaces the \n            // two calls to AutoFit.\n            workSheet.Range[&quot;A1&quot;, &quot;B3&quot;].AutoFormat(\n                Excel.XlRangeAutoFormat.xlRangeAutoFormatClassic2);\n\n            // Put the spreadsheet contents on the clipboard. The Copy method has one\n            // optional parameter for specifying a destination. Because no argument  \n            // is sent, the destination is the Clipboard.\n            workSheet.Range[&quot;A1:B3&quot;].Copy();\n        }\n\n        static void CreateIconInWordDoc()\n        {\n            var wordApp = new Word.Application();\n            wordApp.Visible = true;\n\n            // The Add method has four reference parameters, all of which are \n            // optional. Visual C# 2010 allows you to omit arguments for them if\n            // the default values are what you want.\n            wordApp.Documents.Add();\n\n            // PasteSpecial has seven reference parameters, all of which are \n            // optional. This example uses named arguments to specify values \n            // for two of the parameters. Although these are reference \n            // parameters, you do not need to use the ref keyword, or to create \n            // variables to send in as arguments. You can send the values directly.\n            wordApp.Selection.PasteSpecial(Link: true, DisplayAsIcon: true);\n        }\n    }\n\n    public class Account\n    {\n        public int ID { get; set; }\n        public double Balance { get; set; }\n    }\n}\n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p> <a class=\"xref\" href=\"../../../../api/system.type#System_Type_Missing\" data-linktype=\"relative-path\">System.Type.Missing</a><br> <a href=\"../../language-reference/keywords/dynamic\" data-linktype=\"relative-path\">dynamic</a><br> <a href=\"../types/using-type-dynamic\" data-linktype=\"relative-path\">Using Type dynamic</a><br> <a href=\"../classes-and-structs/named-and-optional-arguments\" data-linktype=\"relative-path\">Named and Optional Arguments</a><br> <a href=\"../classes-and-structs/how-to-use-named-and-optional-arguments-in-office-programming\" data-linktype=\"relative-path\">How to: Use Named and Optional Arguments in Office Programming</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc2.json\">\r\n<meta name=\"ms.assetid\" content=\"041b25c2-3512-4e0f-a4ea-ceb2999e4d5e\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"33\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-21 01:42 AM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/interop/how-to-access-office-onterop-objects.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/csharp/programming-guide/interop/how-to-access-office-onterop-objects.md\">\r\n<meta name=\"document_id\" content=\"058b4076-de1d-d2e1-0a38-70ca2471f03b\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"How to: Access Office Interop Objects by Using Visual C# Features (C# Programming Guide) | Microsoft Docs","ms.assetid":"041b25c2-3512-4e0f-a4ea-ceb2999e4d5e","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":33,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["optional parameters [C#], Office programming","named and optional arguments [C#], Office programming","dynamic [C#], Office programming","optional arguments [C#], Office programming","named arguments [C#], Office programming","Office programming [C#]"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2017-03-21 01:42 AM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"3/21/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/interop/how-to-access-office-onterop-objects.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/csharp/programming-guide/interop/how-to-access-office-onterop-objects.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/interop/how-to-access-office-onterop-objects.md","document_id":"058b4076-de1d-d2e1-0a38-70ca2471f03b","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/programming-guide/interop/how-to-access-office-onterop-objects","toc_asset_id":"articles/csharp/programming-guide/interop/toc.json","toc_rel":"toc.json","_op_ogTitle":"How to: Access Office Interop Objects by Using Visual C# Features (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":2479,"_op_rawTitle":"<h1 id=\"how-to-access-office-interop-objects-by-using-visual-c-features-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/interop/how-to-access-office-onterop-objects.md\" sourcestartlinenumber=\"41\" sourceendlinenumber=\"41\">How to: Access Office Interop Objects by Using Visual C# Features (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/programming-guide/interop/how-to-access-office-onterop-objects","fileRelativePath":"articles/csharp/programming-guide/interop/how-to-access-office-onterop-objects.html"},"themesRelativePathToOutputRoot":"_themes/"}