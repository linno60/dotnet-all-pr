{"content":"<div><div class=\"content\">\n<p>The topic describes methods to enable interoperability between C# managed code and unmanaged code.  </p>\n<h2 id=\"platform-invoke\">Platform Invoke</h2>\n<p> <em>Platform invoke</em> is a service that enables managed code to call unmanaged functions that are implemented in dynamic link libraries (DLLs), such as those in the Microsoft Win32 API. It locates and invokes an exported function and marshals its arguments (integers, strings, arrays, structures, and so on) across the interoperation boundary as needed.  </p>\n<p> For more information, see <a href=\"http://msdn.microsoft.com/library/eca7606e-ebfb-4f47-b8d9-289903fdc045\" data-linktype=\"external\">Consuming Unmanaged DLL Functions</a> and <a href=\"how-to-use-platform-invoke-to-play-a-wave-file\" data-linktype=\"relative-path\">How to: Use Platform Invoke to Play a Wave File</a>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The <a href=\"http://msdn.microsoft.com/library/059a624e-f7db-4134-ba9f-08b676050482\" data-linktype=\"external\">Common Language Runtime</a> (CLR) manages access to system resources. Calling unmanaged code that is outside the CLR bypasses this security mechanism, and therefore presents a security risk. For example, unmanaged code might call resources in unmanaged code directly, bypassing CLR security mechanisms. For more information, see <a href=\"http://go.microsoft.com/fwlink/?LinkId=37122\" data-linktype=\"external\">.NET Framework Security</a>.  </p>\n</div>\n<h2 id=\"c-interop\">C++ Interop</h2>\n<p> You can use C++ interop, also known as It Just Works (IJW), to wrap a native C++ class so that it can be consumed by code that is authored in C# or another .NET Framework language. To do this, you write C++ code to wrap a native DLL or COM component. Unlike other .NET Framework languages, Visual C++ has interoperability support that enables managed and unmanaged code to be located in the same application and even in the same file. You then build the C++ code by using the <strong>/clr</strong> compiler switch to produce a managed assembly. Finally, you add a reference to the assembly in your C# project and use the wrapped objects just as you would use other managed classes.  </p>\n<h2 id=\"exposing-com-components-to-c\">Exposing COM Components to C</h2>\n<p> You can consume a COM component from a C# project. The general steps are as follows:  </p>\n<ol>\n<li><p>Locate a COM component to use and register it. Use regsvr32.exe to register or unâ€“register a COM DLL.  </p>\n</li>\n<li><p>Add to the project a reference to the COM component or type library.  </p>\n<p> When you add the reference, Visual Studio uses the <a href=\"http://msdn.microsoft.com/library/ec0a8d63-11b3-4acd-b398-da1e37e97382\" data-linktype=\"external\">Tlbimp.exe (Type Library Importer)</a>, which takes a type library as input, to output a .NET Framework interop assembly. The assembly, also named a runtime callable wrapper (RCW), contains managed classes and interfaces that wrap the COM classes and interfaces that are in the type library. Visual Studio adds to the project a reference to the generated assembly.  </p>\n</li>\n<li><p>Create an instance of a class that is defined in the RCW. This, in turn, creates an instance of the COM object.  </p>\n</li>\n<li><p>Use the object just as you use other managed objects. When the object is reclaimed by garbage collection, the instance of the COM object is also released from memory.  </p>\n<p>For more information, see <a href=\"http://msdn.microsoft.com/library/e78b14f1-e487-43cd-9c6d-1a07483f1730\" data-linktype=\"external\">Exposing COM Components to the .NET Framework</a>.  </p>\n</li>\n</ol>\n<h2 id=\"exposing-c-to-com\">Exposing C# to COM</h2>\n<p> COM clients can consume C# types that have been correctly exposed. The basic steps to expose C# types are as follows:  </p>\n<ol>\n<li><p>Add interop attributes in the C# project.  </p>\n<p> You can make an assembly COM visible by modifying Visual C# project properties. For more information, see <a href=\"https://docs.microsoft.com/visualstudio/ide/reference/assembly-information-dialog-box\" data-linktype=\"external\">Assembly Information Dialog Box</a>.  </p>\n</li>\n<li><p>Generate a COM type library and register it for COM usage.  </p>\n<p> You can modify Visual C# project properties to automatically register the C# assembly for COM interop. Visual Studio uses the <a href=\"http://msdn.microsoft.com/library/e190e342-36ef-4651-a0b4-0e8c2c0281cb\" data-linktype=\"external\">Regasm.exe (Assembly Registration Tool)</a>, using the <code>/tlb</code> command-line switch, which takes a managed assembly as input, to generate a type library. This type library describes the <code>public</code> types in the assembly and adds registry entries so that COM clients can create managed classes.  </p>\n<p>For more information, see <a href=\"http://msdn.microsoft.com/library/e42a65f7-1e61-411f-b09a-aca1bbce24c6\" data-linktype=\"external\">Exposing .NET Framework Components to COM</a> and <a href=\"example-com-class\" data-linktype=\"relative-path\">Example COM Class</a>.  </p>\n</li>\n</ol>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"http://go.microsoft.com/fwlink/?LinkId=99564\" data-linktype=\"external\">Improving Interop Performance</a><br> <a href=\"http://go.microsoft.com/fwlink/?LinkId=112406\" data-linktype=\"external\">Introduction to COM Interop</a><br> <a href=\"http://go.microsoft.com/fwlink/?LinkId=112398\" data-linktype=\"external\">Marshaling between Managed and Unmanaged Code</a><br> <a href=\"https://msdn.microsoft.com/library/sd10k43k\" data-linktype=\"external\">Interoperating with Unmanaged Code</a><br> <a href=\"http://msdn.microsoft.com/en-us/3ada36e5-2390-4d70-b490-6ad8de92f2fb\" data-linktype=\"external\">Advanced COM Interoperability</a><br> <a href=\"../index\" data-linktype=\"relative-path\">C# Programming Guide</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc2.json\">\r\n<meta name=\"ms.assetid\" content=\"c025b2e0-2357-4c27-8461-118f0090aeff\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"43\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/interop/interoperability-overview.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/interop/interoperability-overview.md\">\r\n<meta name=\"document_id\" content=\"4fb60df9-4318-0f67-90b9-6b69d466e101\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Interoperability Overview (C# Programming Guide) | Microsoft Docs","ms.assetid":"c025b2e0-2357-4c27-8461-118f0090aeff","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":43,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["COM interop","C# language, interoperability","C++ Interop","interoperability, about interoperability","platform invoke"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Absolute urls and other fixes (#1281)","commit_sha":"f7dffe4885b331cec8d37f3cc5c9163f69c3b4c9","commit_date":"2016-11-22 12:57:26 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/interop/interoperability-overview.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/interop/interoperability-overview.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/interop/interoperability-overview.md","document_id":"4fb60df9-4318-0f67-90b9-6b69d466e101","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/programming-guide/interop/interoperability-overview","toc_asset_id":"articles/csharp/programming-guide/interop/toc.json","toc_rel":"toc.json","_op_ogTitle":"Interoperability Overview (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":609,"_op_rawTitle":"<h1 id=\"interoperability-overview-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/interop/interoperability-overview.md\" sourcestartlinenumber=\"40\" sourceendlinenumber=\"40\">Interoperability Overview (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/programming-guide/interop/interoperability-overview","fileRelativePath":"articles/csharp/programming-guide/interop/interoperability-overview.html"},"themesRelativePathToOutputRoot":"_themes/"}