{"content":"<div><div class=\"content\">\n<p>An interface contains definitions for a group of related functionalities that a <a href=\"../../language-reference/keywords/class\" data-linktype=\"relative-path\">class</a> or a <a href=\"../../language-reference/keywords/struct\" data-linktype=\"relative-path\">struct</a> can implement.  </p>\n<p> By using interfaces, you can, for example, include behavior from multiple sources in a class. That capability is important in C# because the language doesn&#39;t support multiple inheritance of classes. In addition, you must use an interface if you want to simulate inheritance for structs, because they can&#39;t actually inherit from another struct or class.  </p>\n<p> You define an interface by using the <a href=\"../../language-reference/keywords/interface\" data-linktype=\"relative-path\">interface</a> keyword, as the following example shows.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideInheritance#47\">interface IEquatable&lt;T&gt;\n    {\n        bool Equals(T obj);\n    }\n</code></pre><p> Any class or struct that implements the <a class=\"xref\" href=\"../../../../api/system.iequatable-1\" data-linktype=\"relative-path\">IEquatable&lt;T&gt;</a> interface must contain a definition for an <a class=\"xref\" href=\"../../../../api/system.iequatable-1#System_IEquatable_1_Equals_\" data-linktype=\"relative-path\">Equals</a> method that matches the signature that the interface specifies. As a result, you can count on a class that implements <code>IEquatable&lt;T&gt;</code> to contain an <code>Equals</code> method with which an instance of the class can determine whether it&#39;s equal to another instance of the same class.  </p>\n<p> The definition of <code>IEquatable&lt;T&gt;</code> doesn’t provide an implementation for <code>Equals</code>. The interface defines only the signature. In that way, an interface in C# is similar to an abstract class in which all the methods are abstract. However, a class or struct can implement multiple interfaces, but a class can inherit only a single class, abstract or not. Therefore, by using interfaces, you can include behavior from multiple sources in a class.  </p>\n<p> For more information about abstract classes, see <a href=\"../classes-and-structs/abstract-and-sealed-classes-and-class-members\" data-linktype=\"relative-path\">Abstract and Sealed Classes and Class Members</a>.  </p>\n<p> Interfaces can contain methods, properties, events, indexers, or any combination of those four member types. For links to examples, see <a href=\"index#BKMK_RelatedSections\" data-linktype=\"relative-path\">Related Sections</a>. An interface can&#39;t contain constants, fields, operators, instance constructors, destructors, or types. Interface members are automatically public, and they can&#39;t include any access modifiers. Members also can&#39;t be <a href=\"../../language-reference/keywords/static\" data-linktype=\"relative-path\">static</a>.  </p>\n<p> To implement an interface member, the corresponding member of the implementing class must be public, non-static, and have the same name and signature as the interface member.  </p>\n<p> When a class or struct implements an interface, the class or struct must provide an implementation for all of the members that the interface defines. The interface itself provides no functionality that a class or struct can inherit in the way that it can inherit base class functionality. However, if a base class implements an interface, any class that&#39;s derived from the base class inherits that implementation.  </p>\n<p> The following example shows an implementation of the IEquatable<t\\> interface. The implementing class, <code>Car</code>, must provide an implementation of the <a class=\"xref\" href=\"../../../../api/system.iequatable-1#System_IEquatable_1_Equals_\" data-linktype=\"relative-path\">Equals</a> method.  <p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideInheritance#48\">    public class Car : IEquatable&lt;Car&gt;\n    {\n        public string Make {get; set;}\n        public string Model { get; set; }\n        public string Year { get; set; }\n\n        // Implementation of IEquatable&lt;T&gt; interface\n        public bool Equals(Car car)\n        {\n            if (this.Make == car.Make &amp;&amp;\n                this.Model == car.Model &amp;&amp;\n                this.Year == car.Year)\n            {\n                return true;\n            }\n            else\n                return false;\n        }\n    }\n</code></pre><p> Properties and indexers of a class can define extra accessors for a property or indexer that&#39;s defined in an interface. For example, an interface might declare a property that has a <a href=\"../../language-reference/keywords/get\" data-linktype=\"relative-path\">get</a> accessor. The class that implements the interface can declare the same property with both a <code>get</code> and <a href=\"../../language-reference/keywords/set\" data-linktype=\"relative-path\">set</a> accessor. However, if the property or indexer uses explicit implementation, the accessors must match. For more information about explicit implementation, see <a href=\"explicit-interface-implementation\" data-linktype=\"relative-path\">Explicit Interface Implementation</a> and <a href=\"../classes-and-structs/interface-properties\" data-linktype=\"relative-path\">Interface Properties</a>.  </p>\n<p> Interfaces can implement other interfaces. A class might include an interface multiple times through base classes that it inherits or through interfaces that other interfaces implement. However, the class can provide an implementation of an interface only one time and only if the class declares the interface as part of the definition of the class (<code>class ClassName : InterfaceName</code>). If the interface is inherited because you inherited a base class that implements the interface, the base class provides the implementation of the members of the interface. However, the derived class can reimplement the interface members instead of using the inherited implementation.  </p>\n<p> A base class can also implement interface members by using virtual members. In that case, a derived class can change the interface behavior by overriding the virtual members. For more information about virtual members, see <a href=\"../classes-and-structs/polymorphism\" data-linktype=\"relative-path\">Polymorphism</a>.  </p>\n<h2 id=\"interfaces-summary\">Interfaces Summary</h2>\n<p> An interface has the following properties:  </p>\n<ul>\n<li><p>An interface is like an abstract base class. Any class or struct that implements the interface must implement all its members.  </p>\n</li>\n<li><p>An interface can&#39;t be instantiated directly. Its members are implemented by any class or struct that implements the interface.  </p>\n</li>\n<li><p>Interfaces can contain events, indexers, methods, and properties.  </p>\n</li>\n<li><p>Interfaces contain no implementation of methods.  </p>\n</li>\n<li><p>A class or struct can implement multiple interfaces. A class can inherit a base class and also implement one or more interfaces.  </p>\n</li>\n</ul>\n<h2 id=\"in-this-section\">In This Section</h2>\n<p> <a href=\"explicit-interface-implementation\" data-linktype=\"relative-path\">Explicit Interface Implementation</a><br> Explains how to create a class member that’s specific to an interface.  </p>\n<p> <a href=\"how-to-explicitly-implement-interface-members\" data-linktype=\"relative-path\">How to: Explicitly Implement Interface Members</a><br> Provides an example of how to explicitly implement members of interfaces.  </p>\n<p> <a href=\"how-to-explicitly-implement-members-of-two-interfaces\" data-linktype=\"relative-path\">How to: Explicitly Implement Members of Two Interfaces</a><br> Provides an example of how to explicitly implement members of interfaces with inheritance.  </p>\n<h2 id=\"a-namebkmkrelatedsectionsa-related-sections\"><a name=\"BKMK_RelatedSections\"></a> Related Sections</h2>\n<ul>\n<li><p><a href=\"../classes-and-structs/interface-properties\" data-linktype=\"relative-path\">Interface Properties</a>  </p>\n</li>\n<li><p><a href=\"../indexers/indexers-in-interfaces\" data-linktype=\"relative-path\">Indexers in Interfaces</a>  </p>\n</li>\n<li><p><a href=\"../events/how-to-implement-interface-events\" data-linktype=\"relative-path\">How to:  Implement Interface Events</a>  </p>\n</li>\n<li><p><a href=\"../classes-and-structs/index\" data-linktype=\"relative-path\">Classes and Structs</a>  </p>\n</li>\n<li><p><a href=\"../classes-and-structs/inheritance\" data-linktype=\"relative-path\">Inheritance</a>  </p>\n</li>\n<li><p><a href=\"../classes-and-structs/methods\" data-linktype=\"relative-path\">Methods</a>  </p>\n</li>\n<li><p><a href=\"../classes-and-structs/polymorphism\" data-linktype=\"relative-path\">Polymorphism</a>  </p>\n</li>\n<li><p><a href=\"../classes-and-structs/abstract-and-sealed-classes-and-class-members\" data-linktype=\"relative-path\">Abstract and Sealed Classes and Class Members</a>  </p>\n</li>\n<li><p><a href=\"../classes-and-structs/properties\" data-linktype=\"relative-path\">Properties</a>  </p>\n</li>\n<li><p><a href=\"../events/index\" data-linktype=\"relative-path\">Events</a>  </p>\n</li>\n<li><p><a href=\"../indexers/index\" data-linktype=\"relative-path\">Indexers</a>  </p>\n</li>\n</ul>\n<h2 id=\"featured-book-chapter\">Featured Book Chapter</h2>\n<p> <a href=\"http://msdn.microsoft.com/library/orm-9780596521066-01-13.aspx\" data-linktype=\"external\">Interfaces</a> in <a href=\"http://msdn.microsoft.com/library/orm-9780596521066-01.aspx\" data-linktype=\"external\">Learning C# 3.0: Master the Fundamentals of C# 3.0</a>  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../index\" data-linktype=\"relative-path\">C# Programming Guide</a><br> <a href=\"../classes-and-structs/inheritance\" data-linktype=\"relative-path\">Inheritance</a></p>\n</t\\></div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc2.json\">\r\n<meta name=\"ms.assetid\" content=\"2feda177-ce11-432d-81b4-d50f5f35fd37\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"45\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-21 01:42 AM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/6015a993094fdc0c6651b962ebc9449ccb7dd1c8/docs/csharp/programming-guide/interfaces/index.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/csharp/programming-guide/interfaces/index.md\">\r\n<meta name=\"document_id\" content=\"6266481d-0f9e-8eed-60f2-202cfb33f3f8\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Interfaces (C# Programming Guide) | Microsoft Docs","ms.assetid":"2feda177-ce11-432d-81b4-d50f5f35fd37","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":45,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["interfaces [C#]","C# language, interfaces"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"srikarplus","author_email":"srikarplus@gmail.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update index.md","commit_sha":"6015a993094fdc0c6651b962ebc9449ccb7dd1c8","commit_date":"2017-02-24 05:40:45 +0530"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2017-03-21 01:42 AM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/srikarplus","display_name":"srikarplus","id":"10133174"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"3/21/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/6015a993094fdc0c6651b962ebc9449ccb7dd1c8/docs/csharp/programming-guide/interfaces/index.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/csharp/programming-guide/interfaces/index.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/interfaces/index.md","document_id":"6266481d-0f9e-8eed-60f2-202cfb33f3f8","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/programming-guide/interfaces/index","toc_asset_id":"articles/csharp/programming-guide/interfaces/toc.json","toc_rel":"toc.json","_op_ogTitle":"Interfaces (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":860,"_op_rawTitle":"<h1 id=\"interfaces-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/interfaces/index.md\" sourcestartlinenumber=\"37\" sourceendlinenumber=\"37\">Interfaces (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/programming-guide/interfaces/index","fileRelativePath":"articles/csharp/programming-guide/interfaces/index.html"},"themesRelativePathToOutputRoot":"_themes/"}