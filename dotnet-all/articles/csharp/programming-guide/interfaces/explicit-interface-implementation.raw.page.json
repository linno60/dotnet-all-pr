{"content":"<div><div class=\"content\">\n<p>If a <a href=\"../../language-reference/keywords/class\" data-linktype=\"relative-path\">class</a> implements two interfaces that contain a member with the same signature, then implementing that member on the class will cause both interfaces to use that member as their implementation. In the following example, all the calls to <code>Paint</code> invoke the same method.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideInheritance#39\">class Test \n{\n    static void Main()\n    {\n        SampleClass sc = new SampleClass();\n        IControl ctrl = (IControl)sc;\n        ISurface srfc = (ISurface)sc;\n\n        // The following lines all call the same method.\n        sc.Paint();\n        ctrl.Paint();\n        srfc.Paint();\n    }\n}\n\n\ninterface IControl\n{\n    void Paint();\n}\ninterface ISurface\n{\n    void Paint();\n}\nclass SampleClass : IControl, ISurface\n{\n    // Both ISurface.Paint and IControl.Paint call this method. \n    public void Paint()\n    {\n        Console.WriteLine(&quot;Paint method in SampleClass&quot;);\n    }\n}\n\n// Output:\n// Paint method in SampleClass\n// Paint method in SampleClass\n// Paint method in SampleClass\n</code></pre><p> If the two <a href=\"../../language-reference/keywords/interface\" data-linktype=\"relative-path\">interface</a> members do not perform the same function, however, this can lead to an incorrect implementation of one or both of the interfaces. It is possible to implement an interface member explicitlyâ€”creating a class member that is only called through the interface, and is specific to that interface. This is accomplished by naming the class member with the name of the interface and a period. For example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideInheritance#40\">    public class SampleClass : IControl, ISurface\n    {\n        void IControl.Paint()\n        {\n            System.Console.WriteLine(&quot;IControl.Paint&quot;);\n        }\n        void ISurface.Paint()\n        {\n            System.Console.WriteLine(&quot;ISurface.Paint&quot;);\n        }\n    }\n</code></pre><p> The class member <code>IControl.Paint</code> is only available through the <code>IControl</code> interface, and <code>ISurface.Paint</code> is only available through <code>ISurface</code>. Both method implementations are separate, and neither is available directly on the class. For example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideInheritance#41\">        // Call the Paint methods from Main.\n\n        SampleClass obj = new SampleClass();\n        //obj.Paint();  // Compiler error.\n\n        IControl c = (IControl)obj;\n        c.Paint();  // Calls IControl.Paint on SampleClass.\n\n        ISurface s = (ISurface)obj;\n        s.Paint(); // Calls ISurface.Paint on SampleClass.\n\n        // Output:\n        // IControl.Paint\n        // ISurface.Paint\n</code></pre><p> Explicit implementation is also used to resolve cases where two interfaces each declare different members of the same name such as a property and a method:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideInheritance#42\">    interface ILeft\n    {\n        int P { get;}\n    }\n    interface IRight\n    {\n        int P();\n    }\n</code></pre><p> To implement both interfaces, a class has to use explicit implementation either for the property P, or the method P, or both, to avoid a compiler error. For example:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideInheritance#43\">    class Middle : ILeft, IRight\n    {\n        public int P() { return 0; }\n        int ILeft.P { get { return 0; } }\n    }\n</code></pre><h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../index\" data-linktype=\"relative-path\">C# Programming Guide</a><br> <a href=\"../classes-and-structs/index\" data-linktype=\"relative-path\">Classes and Structs</a><br> <a href=\"index\" data-linktype=\"relative-path\">Interfaces</a><br> <a href=\"../classes-and-structs/inheritance\" data-linktype=\"relative-path\">Inheritance</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc2.json\">\r\n<meta name=\"ms.assetid\" content=\"181c901f-0d4c-4f29-97fc-895079617bf2\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"14\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"translation.priority.mt\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.mt\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.mt\" content=\"pt-br\">\r\n<meta name=\"translation.priority.mt\" content=\"tr-tr\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/interfaces/explicit-interface-implementation.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/interfaces/explicit-interface-implementation.md\">\r\n<meta name=\"document_id\" content=\"692501ff-7ca0-077b-a483-938f7b8cb7bc\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Explicit Interface Implementation (C# Programming Guide) | Microsoft Docs","ms.assetid":"181c901f-0d4c-4f29-97fc-895079617bf2","translation.priority.ht":["de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","ru-ru","zh-cn","zh-tw"],"caps.latest.revision":14,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["explicit interfaces [C#]","interfaces [C#], explicit"],"translation.priority.mt":["cs-cz","pl-pl","pt-br","tr-tr"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/interfaces/explicit-interface-implementation.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/programming-guide/interfaces/explicit-interface-implementation.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/interfaces/explicit-interface-implementation.md","document_id":"692501ff-7ca0-077b-a483-938f7b8cb7bc","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/programming-guide/interfaces/explicit-interface-implementation","toc_asset_id":"articles/csharp/programming-guide/interfaces/toc.json","toc_rel":"toc.json","_op_ogTitle":"Explicit Interface Implementation (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":394,"_op_rawTitle":"<h1 id=\"explicit-interface-implementation-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/interfaces/explicit-interface-implementation.md\" sourcestartlinenumber=\"38\" sourceendlinenumber=\"38\">Explicit Interface Implementation (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/programming-guide/interfaces/explicit-interface-implementation","fileRelativePath":"articles/csharp/programming-guide/interfaces/explicit-interface-implementation.html"},"themesRelativePathToOutputRoot":"_themes/"}