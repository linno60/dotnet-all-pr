{"content":"<div><div class=\"content\">\n<p>It is often useful to define interfaces either for generic collection classes, or for the generic classes that represent items in the collection. The preference for generic classes is to use generic interfaces, such as <a class=\"xref\" href=\"../../../../api/system.icomparable-1\" data-linktype=\"relative-path\">IComparable&lt;T&gt;</a> rather than <a class=\"xref\" href=\"../../../../api/system.icomparable\" data-linktype=\"relative-path\">IComparable</a>, in order to avoid boxing and unboxing operations on value types. The .NET Framework class library defines several generic interfaces for use with the collection classes in the <a class=\"xref\" href=\"../../../../api/system.collections.generic\" data-linktype=\"relative-path\">System.Collections.Generic</a> namespace.  </p>\n<p> When an interface is specified as a constraint on a type parameter, only types that implement the interface can be used. The following code example shows a <code>SortedList&lt;T&gt;</code> class that derives from the <code>GenericList&lt;T&gt;</code> class. For more information, see <a href=\"introduction-to-generics\" data-linktype=\"relative-path\">Introduction to Generics</a>. <code>SortedList&lt;T&gt;</code> adds the constraint <code>where T : IComparable&lt;T&gt;</code>. This enables the <code>BubbleSort</code> method in <code>SortedList&lt;T&gt;</code> to use the generic <a class=\"xref\" href=\"../../../../api/system.icomparable-1#System_IComparable_1_CompareTo_\" data-linktype=\"relative-path\">CompareTo</a> method on list elements. In this example, list elements are a simple class, <code>Person</code>, that implements <code>IComparable&lt;Person&gt;</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideGenerics#29\">//Type parameter T in angle brackets.\npublic class GenericList&lt;T&gt; : System.Collections.Generic.IEnumerable&lt;T&gt;\n{\n    protected Node head;\n    protected Node current = null;\n\n    // Nested class is also generic on T\n    protected class Node\n    {\n        public Node next;\n        private T data;  //T as private member datatype\n\n        public Node(T t)  //T used in non-generic constructor\n        {\n            next = null;\n            data = t;\n        }\n\n        public Node Next\n        {\n            get { return next; }\n            set { next = value; }\n        }\n\n        public T Data  //T as return type of property\n        {\n            get { return data; }\n            set { data = value; }\n        }\n    }\n\n    public GenericList()  //constructor\n    {\n        head = null;\n    }\n\n    public void AddHead(T t)  //T as method parameter type\n    {\n        Node n = new Node(t);\n        n.Next = head;\n        head = n;\n    }\n\n    // Implementation of the iterator\n    public System.Collections.Generic.IEnumerator&lt;T&gt; GetEnumerator()\n    {\n        Node current = head;\n        while (current != null)\n        {\n            yield return current.Data;\n            current = current.Next;\n        }\n    }\n\n    // IEnumerable&lt;T&gt; inherits from IEnumerable, therefore this class \n    // must implement both the generic and non-generic versions of \n    // GetEnumerator. In most cases, the non-generic method can \n    // simply call the generic method.\n    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()\n    {\n        return GetEnumerator();\n    }\n}\n\npublic class SortedList&lt;T&gt; : GenericList&lt;T&gt; where T : System.IComparable&lt;T&gt;\n{\n    // A simple, unoptimized sort algorithm that \n    // orders list elements from lowest to highest:\n\n    public void BubbleSort()\n    {\n        if (null == head || null == head.Next)\n        {\n            return;\n        }\n        bool swapped;\n\n        do\n        {\n            Node previous = null;\n            Node current = head;\n            swapped = false;\n\n            while (current.next != null)\n            {\n                //  Because we need to call this method, the SortedList\n                //  class is constrained on IEnumerable&lt;T&gt;\n                if (current.Data.CompareTo(current.next.Data) &gt; 0)\n                {\n                    Node tmp = current.next;\n                    current.next = current.next.next;\n                    tmp.next = current;\n\n                    if (previous == null)\n                    {\n                        head = tmp;\n                    }\n                    else\n                    {\n                        previous.next = tmp;\n                    }\n                    previous = tmp;\n                    swapped = true;\n                }\n                else\n                {\n                    previous = current;\n                    current = current.next;\n                }\n            }\n        } while (swapped);\n    }\n}\n\n// A simple class that implements IComparable&lt;T&gt; using itself as the \n// type argument. This is a common design pattern in objects that \n// are stored in generic lists.\npublic class Person : System.IComparable&lt;Person&gt;\n{\n    string name;\n    int age;\n\n    public Person(string s, int i)\n    {\n        name = s;\n        age = i;\n    }\n\n    // This will cause list elements to be sorted on age values.\n    public int CompareTo(Person p)\n    {\n        return age - p.age;\n    }\n\n    public override string ToString()\n    {\n        return name + &quot;:&quot; + age;\n    }\n\n    // Must implement Equals.\n    public bool Equals(Person p)\n    {\n        return (this.age == p.age);\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        //Declare and instantiate a new generic SortedList class.\n        //Person is the type argument.\n        SortedList&lt;Person&gt; list = new SortedList&lt;Person&gt;();\n\n        //Create name and age values to initialize Person objects.\n        string[] names = new string[] \n        { \n            &quot;Franscoise&quot;, \n            &quot;Bill&quot;, \n            &quot;Li&quot;, \n            &quot;Sandra&quot;, \n            &quot;Gunnar&quot;, \n            &quot;Alok&quot;, \n            &quot;Hiroyuki&quot;, \n            &quot;Maria&quot;, \n            &quot;Alessandro&quot;, \n            &quot;Raul&quot; \n        };\n\n        int[] ages = new int[] { 45, 19, 28, 23, 18, 9, 108, 72, 30, 35 };\n\n        //Populate the list.\n        for (int x = 0; x &lt; 10; x++)\n        {\n            list.AddHead(new Person(names[x], ages[x]));\n        }\n\n        //Print out unsorted list.\n        foreach (Person p in list)\n        {\n            System.Console.WriteLine(p.ToString());\n        }\n        System.Console.WriteLine(&quot;Done with unsorted list&quot;);\n\n        //Sort the list.\n        list.BubbleSort();\n\n        //Print out sorted list.\n        foreach (Person p in list)\n        {\n            System.Console.WriteLine(p.ToString());\n        }\n        System.Console.WriteLine(&quot;Done with sorted list&quot;);\n    }\n}\n</code></pre><p> Multiple interfaces can be specified as constraints on a single type, as follows:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideGenerics#30\">        class Stack&lt;T&gt; where T : System.IComparable&lt;T&gt;, IEnumerable&lt;T&gt;\n        {\n        }\n</code></pre><p> An interface can define more than one type parameter, as follows:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideGenerics#31\">        interface IDictionary&lt;K, V&gt;\n        {\n        }\n</code></pre><p> The rules of inheritance that apply to classes also apply to interfaces:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideGenerics#32\">        interface IMonth&lt;T&gt; { }\n\n        interface IJanuary     : IMonth&lt;int&gt; { }  //No error\n        interface IFebruary&lt;T&gt; : IMonth&lt;int&gt; { }  //No error\n        interface IMarch&lt;T&gt;    : IMonth&lt;T&gt; { }    //No error\n        //interface IApril&lt;T&gt;  : IMonth&lt;T, U&gt; {}  //Error\n</code></pre><p> Generic interfaces can inherit from non-generic interfaces if the generic interface is contra-variant, which means it only uses its type parameter as a return value. In the .NET Framework class library, <a class=\"xref\" href=\"../../../../api/system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable&lt;T&gt;</a> inherits from <a class=\"xref\" href=\"../../../../api/system.collections.ienumerable\" data-linktype=\"relative-path\">IEnumerable</a> because <a class=\"xref\" href=\"../../../../api/system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable&lt;T&gt;</a> only uses <code>T</code> in the return value of <a class=\"xref\" href=\"../../../../api/system.collections.generic.ienumerable-1#System_Collections_Generic_IEnumerable_1_GetEnumerator_\" data-linktype=\"relative-path\">GetEnumerator</a> and in the <a class=\"xref\" href=\"../../../../api/system.collections.generic.ienumerator-1#System_Collections_Generic_IEnumerator_1_Current_\" data-linktype=\"relative-path\">Current</a> property getter.  </p>\n<p> Concrete classes can implement closed constructed interfaces, as follows:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideGenerics#33\">        interface IBaseInterface&lt;T&gt; { }\n\n        class SampleClass : IBaseInterface&lt;string&gt; { }\n</code></pre><p> Generic classes can implement generic interfaces or closed constructed interfaces as long as the class parameter list supplies all arguments required by the interface, as follows:  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideGenerics#34\">        interface IBaseInterface1&lt;T&gt; { }\n        interface IBaseInterface2&lt;T, U&gt; { }\n\n        class SampleClass1&lt;T&gt; : IBaseInterface1&lt;T&gt; { }          //No error\n        class SampleClass2&lt;T&gt; : IBaseInterface2&lt;T, string&gt; { }  //No error\n</code></pre><p> The rules that control method overloading are the same for methods within generic classes, generic structs, or generic interfaces. For more information, see <a href=\"generic-methods\" data-linktype=\"relative-path\">Generic Methods</a>.  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../index\" data-linktype=\"relative-path\">C# Programming Guide</a><br> <a href=\"introduction-to-generics\" data-linktype=\"relative-path\">Introduction to Generics</a><br> <a href=\"../../language-reference/keywords/interface\" data-linktype=\"relative-path\">interface</a><br> <a href=\"https://msdn.microsoft.com/library/ms172192\" data-linktype=\"external\">Generics</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc2.json\">\r\n<meta name=\"ms.assetid\" content=\"a8fa49a1-6e78-4a09-87e5-84a0b9f5ffbe\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"28\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-21 01:42 AM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/generics/generic-interfaces.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/csharp/programming-guide/generics/generic-interfaces.md\">\r\n<meta name=\"document_id\" content=\"566c8fd5-f399-85f5-abca-28cf6230233b\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Generic Interfaces (C# Programming Guide) | Microsoft Docs","ms.assetid":"a8fa49a1-6e78-4a09-87e5-84a0b9f5ffbe","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":28,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["C# language, generic interfaces","generics [C#], interfaces"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2017-03-21 01:42 AM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"3/21/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/programming-guide/generics/generic-interfaces.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/csharp/programming-guide/generics/generic-interfaces.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/programming-guide/generics/generic-interfaces.md","document_id":"566c8fd5-f399-85f5-abca-28cf6230233b","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/programming-guide/generics/generic-interfaces","toc_asset_id":"articles/csharp/programming-guide/generics/toc.json","toc_rel":"toc.json","_op_ogTitle":"Generic Interfaces (C# Programming Guide)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":915,"_op_rawTitle":"<h1 id=\"generic-interfaces-c-programming-guide\" sourcefile=\"docs/csharp/programming-guide/generics/generic-interfaces.md\" sourcestartlinenumber=\"37\" sourceendlinenumber=\"37\">Generic Interfaces (C# Programming Guide)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/programming-guide/generics/generic-interfaces","fileRelativePath":"articles/csharp/programming-guide/generics/generic-interfaces.html"},"themesRelativePathToOutputRoot":"_themes/"}