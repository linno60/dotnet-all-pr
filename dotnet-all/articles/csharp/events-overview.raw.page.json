{"content":"<div><div class=\"content\">\n<p><a href=\"delegates-patterns\" data-linktype=\"relative-path\">Previous</a></p>\n<p>Events are, like delegates, a <em>late binding</em> mechanism. In fact,\nevents are built on the language support for delegates.</p>\n<p>Events are a way for an object to broadcast (to all interested\ncomponents in the system) that something has happened. Any other\ncomponent can subscribe to the event, and be notified when an event\nis raised.</p>\n<p>You&#39;ve probably used events in some of your programming. Many graphical\nsystems have an event model to report user interaction. These events would\nreport mouse movement, button presses and similar interactions. That&#39;s one\nof the most common, but certainly not the only scenario where events are\nused.</p>\n<p>You can define events that should be raised for your classes. One important\nconsideration when working with events is that there may not be any\nobject registered for a particular event. You must write your code so that\nit does not raise events when no listeners are configured.</p>\n<p>Subscribing to an event also creates a coupling between two objects (the event\nsource, and the event sink). You need to ensure that the event sink unsubscribes\nfrom the event source when no longer interested in events.</p>\n<h2 id=\"design-goals-for-event-support\">Design Goals for Event Support</h2>\n<p>The language design for events targets these goals.</p>\n<p>First, enable very minimal\ncoupling between an event source and an event sink. These two components may\nnot be written by the same organization, and may even be updated on totally\ndifferent schedules.</p>\n<p>Secondly, it should be very simple to subscribe to an event, and to\nunsubscribe from that same event.</p>\n<p>And finally, event sources should support multiple event subscribers. It should\nalso support having no event subscribers attached.</p>\n<p>You can see that the goals for events are very similar to the goals for delegates.\nThat&#39;s why the event language support is built on the delegate language support.</p>\n<h2 id=\"language-support-for-events\">Language Support for Events</h2>\n<p>The syntax for defining events, and subscribing or unsubscribing from events is\nan extension of the syntax for delegates.</p>\n<p>To define an event you use the <code>event</code> keyword:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public event EventHandler&lt;FileListArgs&gt; Progress;\n</code></pre><p>The type of the event (<code>EventHandler&lt;FileListArgs&gt;</code> in this example) must be a\ndelegate type. There are a number of conventions that you should follow\nwhen declaring an event. Typically, the event delegate type has a void return.\nEvent declarations should be a verb, or a verb phrase.\nUse past tense (as in this example) when\nthe event reports something that has happened. Use a present tense verb (for\nexample, <code>Closing</code>) to report something that is about to happen. Often, using\npresent tense indicates that your class supports some kind of customization\nbehavior. One of the most common scenarios is to support cancellation. For example,\na <code>Closing</code> event may include an argument that would indicate if the close\noperation should continue, or not.  Other scenarios may enable callers to modify\nbehavior by updating properties of the event arguments. You may raise an\nevent to indicate a proposed next action an algorithm will take. The event\nhandler may mandate a different action by modifying  properties of the event\nargument.</p>\n<p>When you want to raise the event, you call the event handlers using the delegate invocation\nsyntax:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">Progress?.Invoke(this, new FileListArgs(file));\n</code></pre><p>As discussed in the section on <a href=\"delegates-patterns\" data-linktype=\"relative-path\">delegates</a>, the ?.\noperator makes it easy to ensure that you do not attempt to raise the event\nwhen there are no subscribers to that event.</p>\n<p>You subscribe to an event by using the <code>+=</code> operator:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">EventHandler&lt;FileListArgs&gt; onProgress = (sender, eventArgs) =&gt; \n    Console.WriteLine(eventArgs.FoundFile);\nlister.Progress += OnProgress;\n</code></pre><p>The handler method typically is the prefix &#39;On&#39; followed\nby the event name, as shown above.</p>\n<p>You unsubscribe using the <code>-=</code> operator:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">lister.Progress -= onProgress;\n</code></pre><p>It&#39;s important to note that I declared a local variable for the expression that\nrepresents the event handler. That ensures the unsubscribe removes the handler.\nIf, instead, you used the body of the lambda expression, you are attempting\nto remove a handler that has never been attached, which does nothing.</p>\n<p>In the next article, you&#39;ll learn more about typical event patterns, and\ndifferent variations on this example.</p>\n<p><a href=\"event-pattern\" data-linktype=\"relative-path\">Next</a></p>\n</div></div>","outputRootRelativePath":"../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"9b8d2a00-1584-4a5b-8994-5003d54d8e0c\">\r\n<meta name=\"description\" content=\"Introduction to Events\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"06/20/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/events-overview.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/events-overview.md\">\r\n<meta name=\"document_id\" content=\"df63bf32-d927-fcda-6f07-a441a9a75ee7\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Introduction to Events | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"9b8d2a00-1584-4a5b-8994-5003d54d8e0c","description":"Introduction to Events","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"06/20/2016","ms.technology":"devlang-csharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"update names per naming guidelines. (#1012)","commit_sha":"59cb2f6799814e37aa02ca35e719329a8af49a20","commit_date":"2016-09-08 14:53:56 -0400"},{"author_name":"Petr Onderka","author_email":"gsvick@gmail.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@users.noreply.github.com","message":"Corrected titles and headings (#690)","commit_sha":"17cac6e7690fd2b08d9f5f73060056d14bca13d2","commit_date":"2016-06-28 12:36:36 -0700"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"Rich Lander","comitter_email":"rlander@microsoft.com","message":"Promote csharp from languages (#644)","commit_sha":"2d44b7e04c0fe2ca136ba6dfa9fc3a4368365ec8","commit_date":"2016-06-26 08:30:56 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/svick","display_name":"Petr Onderka","id":"287848"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/events-overview.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/events-overview.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/events-overview.md","document_id":"df63bf32-d927-fcda-6f07-a441a9a75ee7","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/events-overview","toc_asset_id":"articles/toc.json","toc_rel":"../toc.json","_op_ogTitle":"Introduction to Events","_op_displayDate":"2016-6-20","_op_displayDate_source":"2016-06-20T00:00:00Z","_op_wordCount":666,"_op_rawTitle":"<h1 id=\"introduction-to-events\" sourcefile=\"docs/csharp/events-overview.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Introduction to Events</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/events-overview","fileRelativePath":"articles/csharp/events-overview.html"},"themesRelativePathToOutputRoot":"_themes/"}