{"content":"<div><div class=\"content\">\n<p>C# Tuples are types that you define using a lightweight syntax. The advantages\ninclude a simpler syntax, rules for conversions based on number (referred to as &quot;arity&quot;)\nand types of fields, and\nconsistent rules for copies and assignments. As a tradeoff, Tuples do not\nsupport some of the object oriented idioms associated with inheritance. You\ncan get an overview in the section on <a href=\"csharp-7#tuples\" data-linktype=\"relative-path\">Tuples in the What&#39;s new in C# 7</a> topic.</p>\n<p>In this topic, you&#39;ll learn the language rules governing Tuples in C# 7,\ndifferent ways to use them, and initial guidance on working with Tuples.</p>\n<div class=\"NOTE\"><h5>Note</h5><p>The new tuples features require the <code>System.ValueTuple</code> type. For Visual Studio 2017,\nyou must add the NuGet package <a href=\"https://www.nuget.org/packages/System.ValueTuple/\" data-linktype=\"external\">System.ValueTuple</a>, available on the NuGet Gallery.\nWithout this package you may get a compilation error similar to <code>error CS8179: Predefined type &#39;System.ValueTuple``2&#39; is not defined or imported</code>\nor <code>error CS8137: Cannot define a class or member that utilizes tuples because the compiler required type &#39;System.Runtime.CompilerServices.TupleElementNamesAttribute&#39; cannot be found.</code></p>\n</div>\n<p>Let&#39;s start with the reasons for adding new Tuple support. Methods return\na single object. Tuples enable you to package multiple values in that single\nobject more easily. </p>\n<p>The .NET Framework already has generic <code>Tuple</code> classes. These classes,\nhowever, had two major limitations. For one, the <code>Tuple</code> classes named\ntheir fields <code>Item1</code>, <code>Item2</code>, and so on. Those names carry no semantic\ninformation. Using these <code>Tuple</code> types does not enable communicating the\nmeaning of each of the fields. Another concern is that the <code>Tuple</code> classes are\nreference types. Using one of the <code>Tuple</code> types means allocating objects. On hot\npaths, this can have a measurable impact on your application&#39;s performance.</p>\n<p>To avoid those deficiencies, you could create a <code>class</code> or a <code>struct</code>\nto carry multiple fields. Unfortunately, that&#39;s more work for you,\nand it obscures your design intent. Making a <code>struct</code> or <code>class</code> implies\nthat you are defining a type with both data and behavior. Many times, you\nsimply want to store multiple values in a single object.</p>\n<p>The new language features for tuples, combined with a new set of\nclasses in the framework, address these deficiencies. These new tuples\nuse the new <code>ValueTuple</code> generic structs. As the name implies, this type is a <code>struct</code>\ninstead of a <code>class</code>. There are different versions of this struct to support\ntuples with different numbers of fields. New language support provides semantic\nnames for the fields of the tuple type, along with features to make constructing\nor accessing tuple fields easy.</p>\n<p>The language features and the <code>ValueTuple</code> generic structs enforce the rule that\nyou cannot add any behavior (methods) to these tuple types.\nAll the <code>ValueTuple</code> types are <em>mutable structs</em>. Each member field is a\npublic field. That makes them very lightweight. However, that means tuples\nshould not be used where immutability is important.</p>\n<p>Tuples are both simpler and more flexible data containers than <code>class</code> and\n<code>struct</code> types. Let&#39;s explore those differences.</p>\n<h2 id=\"named-and-unnamed-tuples\">Named and unnamed tuples</h2>\n<p>The <code>ValueTuple</code> struct has fields named <code>Item1</code>, <code>Item2</code>, <code>Item3</code> and so on,\nsimiler to the properties defined in the existing <code>Tuple</code> types.\nThese names are the only names you can use for <em>unnamed tuples</em>. When you\ndo not provide any alternative field names to a tuple, you&#39;ve created an\nunnamed tuple:</p>\n<pre><code class=\"lang-csharp\" name=\"UnnamedTuple\" title=\"Unnamed tuple\">var unnamed = (&quot;one&quot;, &quot;two&quot;);\n</code></pre><p>However, when you initialize a tuple, you can use new language features\nthat give better names to each field. Doing so creates a <em>named tuple</em>.\nNamed tuples still have fields named <code>Item1</code>, <code>Item2</code>, <code>Item3</code> and so on.\nBut they also have synonyms for any of those fields that you have named.\nYou create a named tuple by specifying the names for each field. One way\nis to specify the names as part of the tuple initialization:</p>\n<pre><code class=\"lang-csharp\" name=\"NamedTuple\" title=\"Named tuple\">var named = (first: &quot;one&quot;, second: &quot;two&quot;);\n</code></pre><p>These synonyms are handled by the compiler and the language so that you\ncan use named tuples effectively. IDEs and editors can read these semantic names\nusing the Roslyn APIs. This enables you to reference the fields of a named\ntuple by those semantic names anywhere in the same assembly. The compiler\nreplaces the names you&#39;ve defined with <code>Item*</code> equivalents when generating\nthe compiled output. The compiled Microsoft Intermediate Language (MSIL)\ndoes not include the names you&#39;ve given these fields. </p>\n<p>The compiler must communicate those names you created for tuples that\nare returned from public methods or properties. In those cases, the compiler\nadds a <code>TupleElementNames</code> attribute on the method. This attribute contains\na <code>TransformNames</code> list property that contains the names given to each of\nthe fields in the Tuple. </p>\n<div class=\"NOTE\"><h5>Note</h5><p>Development Tools, such as Visual Studio, also read that metadata,\nand provide IntelliSense and other features using the metadata\nfield names.</p>\n</div>\n<p>It is important to understand these underlying fundamentals of\nthe new tuples and the <code>ValueTuple</code> type in order to understand\nthe rules for assigning named tuples to each other.</p>\n<h2 id=\"assignment-and-tuples\">Assignment and tuples</h2>\n<p>The language supports assignment between tuple types that have\nthe same number of fields and the same types for each of those\nfields. Those types must be exact compile-time matches. Other\nconversions are not considered for assignments. Let&#39;s look at the kinds\nof assignments that are allowed between tuple types.</p>\n<p>Consider these variables used in the following examples:</p>\n<pre><code class=\"lang-csharp\" name=\"VariableCreation\" title=\"Variable creation\">// The &#39;arity&#39; and &#39;shape&#39; of all these tuples are compatible. \n// The only difference is the field names being used.\nvar unnamed = (42, &quot;The meaning of life&quot;);\nvar anonymous = (16, &quot;a perfect square&quot;);\nvar named = (Answer: 42, Message: &quot;The meaning of life&quot;);\nvar differentNamed = (SecretConstant: 42, Label: &quot;The meaning of life&quot;);\n</code></pre><p>The first two variables, <code>unnamed</code> and <code>anonymous</code> do not have semantic\nnames provided for the fields. The field names are <code>Item1</code> and <code>Item2</code>.\nThe last two variables, <code>named</code> and <code>differentName</code> have semantic names\ngiven for the fields. Note that these two tuples have different names\nfor the fields.</p>\n<p>All four of these tuples have the same number of fields (referred to as &#39;arity&#39;)\nand the types of those fields are identical. Therefore, all of these\nassignments work:</p>\n<pre><code class=\"lang-csharp\" name=\"VariableAssignment\" title=\"Variable assignment\">// unnamed to named:\nunnamed = named;\n\n// named to unnamed:\nnamed = unnamed;\n// &#39;named&#39; still has fields that can be referred to\n// as &#39;answer&#39;, and &#39;message&#39;:\nConsole.WriteLine($&quot;{named.Answer}, {named.Message}&quot;);\n\n// unnamed to unnamed:\nanonymous = unnamed;\n\n// named tuples.\nnamed = differentNamed;\n// The field names are not assigned. &#39;named&#39; still has \n// fields that can be referred to as &#39;answer&#39; and &#39;message&#39;:\nConsole.WriteLine($&quot;{named.Answer}, {named.Message}&quot;);\n</code></pre><p>Notice that the names of the tuples are not assigned. The values of the\nfields are assigned following the order of the fields in the tuple.</p>\n<p>Tuples of different types or numbers of fields are not assignable:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">// Does not compile.\n// CS0029: Cannot assign Tuple(int,int,int) to Tuple(int, string)\nvar differentShape = (1, 2, 3);\nnamed = differentShape;\n</code></pre><h2 id=\"tuples-as-method-return-values\">Tuples as method return values</h2>\n<p>One of the most common uses for Tuples is as a method return\nvalue. Let&#39;s walk through one example. Consider this method\nthat computes the standard deviation for a sequence of numbers:</p>\n<pre><code class=\"lang-csharp\" name=\"StandardDeviation\" title=\"Compute Standard Deviation\">public static double StandardDeviation(IEnumerable&lt;double&gt; sequence)\n{\n    // Step 1: Compute the Mean:\n    var mean = sequence.Average();\n\n    // Step 2: Compute the square of the differences between each number \n    // and the mean:\n    var squaredMeanDifferences = from n in sequence\n                                 select (n - mean) * (n - mean);\n    // Step 3: Find the mean of those squared differences:\n    var meanOfSquaredDifferences = squaredMeanDifferences.Average();\n\n    // Step 4: Standard Deviation is the square root of that mean:\n    var standardDeviation = Math.Sqrt(meanOfSquaredDifferences);\n    return standardDeviation;\n}\n</code></pre><div class=\"NOTE\"><h5>Note</h5><p>These examples compute the uncorrected sample standard deviation.\nThe corrected sample standard deviation formula would divide\nthe sum of the squared differences from the mean by (N-1) instead\nof N, as the <code>Average</code> extension method does. Consult a statistics\ntext for more details on the differences between these formulas\nfor standard deviation.</p>\n</div>\n<p>This follows the textbook formula for the standard deviation. It produces\nthe correct answer, but it&#39;s a very inefficient implementation. This\nmethod enumerates the sequence twice: Once to produce the average, and\nonce to produce the average of the square of the difference of the average.\n(Remember that LINQ queries are evaluated lazily, so the computation of\nthe differences from the mean and the average of those differences makes\nonly one enumeration.)</p>\n<p>There is an alternative formula that computes standard deviation using\nonly one enumeration of the sequence.  This computation produces two\nvalues as it enumerates the sequence: the sum of all items in the sequence,\nand the sum of the each value squared:</p>\n<pre><code class=\"lang-csharp\" name=\"SumOfSquaresFormula\" title=\"Compute Standard Deviation using the sum of squares\">public static double StandardDeviation(IEnumerable&lt;double&gt; sequence)\n{\n    double sum = 0;\n    double sumOfSquares = 0;\n    double count = 0;\n\n    foreach (var item in sequence)\n    {\n        count++;\n        sum += item;\n        sumOfSquares += item * item;\n    }\n\n    var variance = sumOfSquares - sum * sum / count;\n    return Math.Sqrt(variance / count);\n}\n</code></pre><p>Ths version enumerates the sequence exactly once. But, it&#39;s not very\nreusable code. As you keep working, you&#39;ll find that many different\nstatistical computations use the number of items in the sequence,\nthe sum of the sequence, and the sum \nof the squares of the sequence. Let&#39;s refactor this method and write\na utility method that produces all three of those values.</p>\n<p>This is where tuples come in very useful. </p>\n<p>Let&#39;s update this method so the three values computed during the enumeration\nare stored in a tuple. That creates this version:</p>\n<pre><code class=\"lang-csharp\" name=\"TupleVersion\" title=\"Refactor to use tuples\">public static double StandardDeviation(IEnumerable&lt;double&gt; sequence)\n{\n    var computation = (Count: 0, Sum: 0.0, SumOfSquares: 0.0);\n\n    foreach (var item in sequence)\n    {\n        computation.Count++;\n        computation.Sum += item;\n        computation.SumOfSquares += item * item;\n    }\n\n    var variance = computation.SumOfSquares - computation.Sum * computation.Sum / computation.Count;\n    return Math.Sqrt(variance / computation.Count);\n}\n</code></pre><p>Visual Studio&#39;s Refactoring suport makes it easy to extract the functionality\nfor the core statistics into a private method. That gives you a <code>private static</code>\nmethod that returns the tuple type with the three values of <code>Sum</code>, <code>SumOfSquares</code>, and <code>Count</code>:</p>\n<pre><code class=\"lang-csharp\" name=\"TupleMethodVersion\" title=\"After extracting utility method\">public static double StandardDeviation(IEnumerable&lt;double&gt; sequence)\n{\n    (int Count, double Sum, double SumOfSquares) computation = ComputeSumsAnSumOfSquares(sequence);\n\n    var variance = computation.SumOfSquares - computation.Sum * computation.Sum / computation.Count;\n    return Math.Sqrt(variance / computation.Count);\n}\n\nprivate static (int Count, double Sum, double SumOfSquares) ComputeSumsAnSumOfSquares(IEnumerable&lt;double&gt; sequence)\n{\n    var computation = (count: 0, sum: 0.0, sumOfSquares: 0.0);\n\n    foreach (var item in sequence)\n    {\n        computation.count++;\n        computation.sum += item;\n        computation.sumOfSquares += item * item;\n    }\n\n    return computation;\n}\n</code></pre><p>The language enables a couple more options that you can use, if you want\nto make a few quick edits by hand. First, you can use the <code>var</code>\ndeclaration to initialize the tuple result from the <code>ComputeSumAndSumOfSquares</code>\nmethod call. You can also create three discrete variables inside the\n<code>ComputeSumAndSumOfSquares</code> method. The final version is below:</p>\n<pre><code class=\"lang-csharp\" name=\"CleanedTupleVersion\" title=\"After final cleanup\">public static double StandardDeviation(IEnumerable&lt;double&gt; sequence)\n{\n    var computation = ComputeSumAndSumOfSquares(sequence);\n\n    var variance = computation.SumOfSquares - computation.Sum * computation.Sum / computation.Count;\n    return Math.Sqrt(variance / computation.Count);\n}\n\nprivate static (int Count, double Sum, double SumOfSquares) ComputeSumAndSumOfSquares(IEnumerable&lt;double&gt; sequence)\n{\n    double sum = 0;\n    double sumOfSquares = 0;\n    int count = 0;\n\n    foreach (var item in sequence)\n    {\n        count++;\n        sum += item;\n        sumOfSquares += item * item;\n    }\n\n    return (count, sum, sumOfSquares);\n}\n</code></pre><p>This final version can be used for any method that needs those three\nvalues, or any subset of them.</p>\n<p>The language supports other options in managing the names of the fields\nin these tuple-returning methods.</p>\n<p>You can remove the field names from the return value declaration and\nreturn an unnamed tuple:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">private static (double, double, int) ComputeSumAndSumOfSquares(IEnumerable&lt;double&gt; sequence)\n{\n    double sum = 0;\n    double sumOfSquares = 0;\n    int count = 0;\n\n    foreach (var item in sequence)\n    {\n        count++;\n        sum += item;\n        sumOfSquares += item * item;\n    }\n\n    return (sum, sumOfSquares, count);\n}\n</code></pre><p>You must address the fields of this tuple as <code>Item1</code>, <code>Item2</code>, and <code>Item3</code>.\nIt&#39;s recommended that you provide semantic names to the fields of tuples\nreturned from methods.</p>\n<p>Another idiom where tuples can be very useful is when you are authoring\nLINQ queries where the final result is a projection that contains some, but not\nall, of the properties of the objects being selected.</p>\n<p>You would traditionally project the results of the query into a sequence\nof objects that were an anonymous type. That presented many limitations,\nprimarily because anonymous types could not conveniently be named in the\nreturn type for a method. Alternatives using <code>object</code> or <code>dynamic</code> as the\ntype of the result came with significant performance costs.</p>\n<p>Returning a sequence of a tuple type is easy, and the names and types\nof the fields are available at compile time and through IDE tools.\nFor example, consider a ToDo application. You might define a\nclass similar to the following to represent a single entry in the ToDo list:</p>\n<pre><code class=\"lang-csharp\" name=\"ToDoItem\" title=\"To Do Item\">public class ToDoItem\n{\n    public int ID { get; set; }\n    public bool IsDone { get; set; }\n    public DateTime DueDate { get; set; }\n    public string Title { get; set; }\n    public string Notes { get; set; }    \n}\n</code></pre><p>Your mobile applications may support a compact form of the current ToDo items\nthat only displays the title. That LINQ query would make a projection that\nincludes only the ID and the title. A method that returns a sequence of tuples\nexpresses that design very well:</p>\n<pre><code class=\"lang-csharp\" name=\"QueryReturningTuple\" title=\"Query returning a tuple\">internal IEnumerable&lt;(int ID, string Title)&gt; GetCurrentItemsMobileList()\n{\n    return from item in AllItems\n           where !item.IsDone\n           orderby item.DueDate\n           select (item.ID, item.Title);\n}\n</code></pre><p>The named tuple can be part of the signature. It lets the compiler and IDE\ntools provide static checking that you are using the result correctly. The\nnamed tuple also carries the static type information so there is no need\nto use expensive run time features like reflection or dynamic binding to\nwork with the results.</p>\n<h2 id=\"deconstruction\">Deconstruction</h2>\n<p>You can unpackage all the items in a tuple by <em>deconstructng</em> the tuple\nreturned by a method. There are two different approaches to deconstructing\ntuples.  First, you can explicitly declare the type of each field inside\nparentheses to create discrete variables for each of the fields in the tuple:</p>\n<pre><code class=\"lang-csharp\" name=\"Deconstruct\" title=\"Deconstruct\">public static double StandardDeviation(IEnumerable&lt;double&gt; sequence)\n{\n    (int count, double sum, double sumOfSquares) = ComputeSumAndSumOfSquares(sequence);\n\n    var variance = sumOfSquares - sum * sum / count;\n    return Math.Sqrt(variance / count);\n}\n</code></pre><p>You can also declare implicitly typed variables for each field in a tuple\nby using the <code>var</code> keyword outside the parentheses:</p>\n<pre><code class=\"lang-csharp\" name=\"DeconstructToVar\" title=\"Deconstruct to Var\">public static double StandardDeviation(IEnumerable&lt;double&gt; sequence)\n{\n    var (sum, sumOfSquares, count) = ComputeSumAndSumOfSquares(sequence);\n\n    var variance = sumOfSquares - sum * sum / count;\n    return Math.Sqrt(variance / count);\n}\n</code></pre><p>It is also legal to use the <code>var</code> keyword with any, or all of the variable\ndeclarations inside the parentheses. </p>\n<pre class=\"loading\"><code class=\"lang-csharp\">(double sum, var sumOfSquares, var count) = ComputeSumAndSumOfSquares(sequence);\n</code></pre><p>Note that you cannot use a specific\ntype outside the parentheses, even if every field in the tuple has the\nsame type.</p>\n<h3 id=\"deconstring-user-defined-types\">Deconstring user defined types</h3>\n<p>Any tuple type can be deconstructed as shown above. It&#39;s also easy\nto enable deconstruction on any user defined type (classes, structs, or \neven interfaces).</p>\n<p>The type author can define one or more <code>Deconstruct</code> methods that\nassign values to any number of <code>out</code> variables representing the\ndata elements that make up the type. For example, the following\n<code>Person</code> type defines a <code>Deconstruct</code> method that deconstructs\na person object into the fields representing the first name\nand last name:</p>\n<pre><code class=\"lang-csharp\" name=\"TypeWithDeconstructMethod\" title=\"Type with a deconstruct method\">public class Person\n{\n    public string FirstName { get; }\n    public string LastName { get; }\n\n    public Person(string first, string last)\n    {\n        FirstName = first;\n        LastName = last;\n    }\n\n    public void Deconstruct(out string firstName, out string lastName)\n    {\n        firstName = FirstName;\n        lastName = LastName;\n    }\n}\n</code></pre><p>The deconstruct method enables assignment from a <code>Person</code> to two strings, \nrepresenting the <code>FirstName</code> and <code>LastName</code> properties:</p>\n<pre><code class=\"lang-csharp\" name=\"Deconstruct Type\" title=\"Deconstruct a class type\">var p = new Person(&quot;Althea&quot;, &quot;Goodwin&quot;);\nvar (first, last) = p;\n</code></pre><p>You can enable deconstruction even for types you did not author.\nThe <code>Deconstruct</code> method can be an extension method that unpackages\nthe accessible data members of an object. The example below shows\na <code>Student</code> type, derived from the <code>Person</code> type, and an extension\nmethod that deconstructs a <code>Student</code> into three variables, representing\nthe <code>FirstName</code>, the <code>LastName</code> and the <code>GPA</code>:</p>\n<pre><code class=\"lang-csharp\" name=\"ExtensionDeconstructMethod\" title=\"Type with a deconstruct extension method\">public class Student : Person\n{\n    public double GPA { get; }\n    public Student(string first, string last, double gpa) :\n        base(first, last)\n    {\n        GPA = gpa;\n    }\n}\n\npublic static class Extensions\n{\n    public static void Deconstruct(this Student s, out string first, out string last, out double gpa)\n    {\n        first = s.FirstName;\n        last = s.LastName;\n        gpa = s.GPA;\n    }\n}\n</code></pre><p>A <code>Student</code> object now has two accessible <code>Deconstruct</code> methods: the extension method\ndeclared for <code>Student</code> types, and the member of the <code>Person</code> type. Both are in scope,\nand that enables a <code>Student</code> to be deconstructed into either two variables or three.\nIf you assign a student to three variabless, the first name, last name, and GPA are\nall returned. If you assign a student to two variables, only the first name and \nthe last name are returned.</p>\n<pre><code class=\"lang-csharp\" name=\"Deconstruct extension method\" title=\"Deconstruct a class type using an extension method\">var s1 = new Student(&quot;Cary&quot;, &quot;Totten&quot;, 4.5);\nvar (fName, lName, gpa) = s1;\n</code></pre><p>You should be very careful defining multiple <code>Deconstruct</code> methods in a \nclass or a class hierarchy. Multiple <code>Deconstruct</code> methods that have the\nsame number of <code>out</code> parameters can quickly cause ambiguities. Callers may\nnot be able to easily call the desired <code>Deconstruct</code> method.</p>\n<p>In this example, there is minimal chance for an ambiguious call because the \n<code>Deconstruct</code> method for <code>Person</code> has two output parameters, and the <code>Deconstruct</code>\nmethod for <code>Student</code> has three.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>The new language and library support for named tuples makes it much easier\nto work with designs that use data structures that store multiple fields\nbut do not define behavior, as classes and structs do. It&#39;s\neasy and concise to use tuples for those types. You get all the benefits of\nstatic type checking, without needing to author types using the more\nverbose <code>class</code> or <code>struct</code> syntax. Even so, they are most useful for utility methods\nthat are <code>private</code>, or <code>internal</code>. Create user defined types, either\n<code>class</code> or <code>struct</code> types when your public methods return a value\nthat has multiple fields.</p>\n</div></div>","outputRootRelativePath":"../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"ee8bf7c3-aa3e-4c9e-a5c6-e05cc6138baa\">\r\n<meta name=\"description\" content=\"Learn about unnamed and named tuple types in C#\">\r\n<meta name=\"ms-author\" content=\"wiwagn\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core, C#\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"11/23/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/10681f57ce9da7a824dba0bfa7ca7ef764a5b197/docs/csharp/tuples.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/tuples.md\">\r\n<meta name=\"document_id\" content=\"13e056d3-cb42-7f13-a5c8-135806ce9957\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Tuples | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"ee8bf7c3-aa3e-4c9e-a5c6-e05cc6138baa","description":"Learn about unnamed and named tuple types in C#","ms-author":"wiwagn","keywords":".NET, .NET Core, C#","ms.topic":"article","ms.date":"11/23/2016","ms.technology":"devlang-csharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Aaron Dandy","author_email":"aaron.dandy@live.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Improve note about System.ValueTuple","commit_sha":"10681f57ce9da7a824dba0bfa7ca7ef764a5b197","commit_date":"2017-03-09 15:40:12 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"bringing changes back","commit_sha":"594f8bfc6ab944d56d0249d05b99bb6fc209666c","commit_date":"2017-03-06 12:01:31 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"reverting merge (#1447)","commit_sha":"a8019c9fc25ef458aa555743e61cd83a3beb11ed","commit_date":"2017-01-24 07:04:28 -0800"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Removed RC from Visual Studio 2017 product name","commit_sha":"21de50320db3399a80602b4e862cb54c71043e0d","commit_date":"2017-01-18 12:58:36 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Create detailed article on C# tuples (#1284)","commit_sha":"c48f48654e65345fbc88f391778515627d4e6cff","commit_date":"2016-11-29 17:47:48 -0500"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"New in csharp7 (#1188)","commit_sha":"1442cbafa04d57e7eb864c0697afef01413db168","commit_date":"2016-11-13 15:54:48 -0500"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"renamed repo/fixed headings (#1186)","commit_sha":"15c55a87beb64f265a164db918c7721c7690fadf","commit_date":"2016-10-29 15:23:17 -0400"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Create outlines for csharp 7 (#1115)","commit_sha":"ada1b8f1252962556e42f180046b9b019307622c","commit_date":"2016-10-06 21:10:34 -0400"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/aarondandy","display_name":"Aaron Dandy","id":"404933"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/rpetrusha","display_name":"rpetrusha","id":"10886961"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/10681f57ce9da7a824dba0bfa7ca7ef764a5b197/docs/csharp/tuples.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/tuples.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/tuples.md","document_id":"13e056d3-cb42-7f13-a5c8-135806ce9957","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/tuples","toc_asset_id":"articles/toc.json","toc_rel":"../toc.json","_op_ogTitle":"Tuples","_op_displayDate":"2016-11-23","_op_displayDate_source":"2016-11-23T00:00:00Z","_op_wordCount":2965,"_op_rawTitle":"<h1 id=\"c-tuple-types\" sourcefile=\"docs/csharp/tuples.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">C# Tuple types</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/tuples","fileRelativePath":"articles/csharp/tuples.html"},"themesRelativePathToOutputRoot":"_themes/"}