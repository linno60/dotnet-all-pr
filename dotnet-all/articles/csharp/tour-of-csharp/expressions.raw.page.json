{"content":"<div><div class=\"content\">\n<p><em>Expressions</em> are constructed from <em>operands</em> and <em>operators</em>. The operators of an expression indicate which operations to apply to the operands. Examples of operators include <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and <code>new</code>. Examples of operands include literals, fields, local variables, and expressions.</p>\n<p>When an expression contains multiple operators, the <em>precedence</em> of the operators controls the order in which the individual operators are evaluated. For example, the expression <code>x + y * z</code> is evaluated as <code>x + (y * z)</code> because the <code>*</code> operator has higher precedence than the <code>+</code> operator.</p>\n<p>When an operand occurs between two operators with the same precedence, the <em>associativity</em> of the operators controls the order in which the operations are performed:</p>\n<ul>\n<li>Except for the assignment operators, all binary operators are <em>left-associative</em>, meaning that operations are performed from left to right. For example, <code>x + y + z</code> is evaluated as <code>(x + y) + z</code>.</li>\n<li>The assignment operators and the conditional operator (<code>?:</code>) are <em>right-associative</em>, meaning that operations are performed from right to left. For example, <code>x = y = z</code> is evaluated as <code>x = (y = z)</code>.</li>\n</ul>\n<p>Precedence and associativity can be controlled using parentheses. For example, <code>x + y * z</code> first multiplies <code>y</code> by <code>z</code> and then adds the result to <code>x</code>, but <code>(x + y) * z</code> first adds <code>x</code> and <code>y</code> and then multiplies the result by <code>z</code>.</p>\n<p>Most operators can be <em>overloaded</em>. Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type.</p>\n<p>The following summarizes C#’s operators, listing the operator categories in order of precedence from highest to lowest. Operators in the same category have equal precedence. Under each category is a list of expressions in that category along with the description of that expression type.</p>\n<ul>\n<li>Primary<ul>\n<li><code>x.m</code>: Member access</li>\n<li><code>x(...)</code>: Method and delegate invocation</li>\n<li><code>x[...]</code>: Array and indexer access</li>\n<li><code>x++</code>: Post-increment</li>\n<li><code>x--</code>: Post-decrement</li>\n<li><code>new T(...)</code>:    Object and delegate creation</li>\n<li><code>new T(...){...}</code>: Object creation with initializer</li>\n<li><code>new {...}</code>:  Anonymous object initializer</li>\n<li><code>new T[...]</code>: Array creation</li>\n<li><code>typeof(T)</code>: Obtain <a class=\"xref\" href=\"../../../api/system.type\" data-linktype=\"relative-path\">Type</a> object for <code>T</code></li>\n<li><code>checked(x)</code>: Evaluate expression in checked context</li>\n<li><code>unchecked(x)</code>: Evaluate expression in unchecked context</li>\n<li><code>default(T)</code>: Obtain default value of type <code>T</code></li>\n<li><code>delegate {...}</code>: Anonymous function (anonymous method)</li>\n</ul>\n</li>\n<li>Unary<ul>\n<li><code>+x</code>: Identity</li>\n<li><code>-x</code>: Negation</li>\n<li><code>!x</code>: Logical negation</li>\n<li><code>~x</code>: Bitwise negation</li>\n<li><code>++x</code>: Pre-increment</li>\n<li><code>--x</code>: Pre-decrement</li>\n<li><code>(T)x</code>: Explicitly convert <code>x</code> to type <code>T</code></li>\n<li><code>await x</code>: Asynchronously wait for <code>x</code> to complete</li>\n</ul>\n</li>\n<li>Multiplicative<ul>\n<li><code>x * y</code>: Multiplication</li>\n<li><code>x / y</code>: Division</li>\n<li><code>x % y</code>: Remainder</li>\n</ul>\n</li>\n<li>Additive<ul>\n<li><code>x + y</code>: Addition, string concatenation, delegate combination</li>\n<li><code>x – y</code>: Subtraction, delegate removal</li>\n</ul>\n</li>\n<li>Shift<ul>\n<li><code>x &lt;&lt; y</code>: Shift left</li>\n<li><code>x &gt;&gt; y</code>: Shift right</li>\n</ul>\n</li>\n<li>Relational and type testing<ul>\n<li><code>x &lt; y</code>: Less than</li>\n<li><code>x &gt; y</code>: Greater than</li>\n<li><code>x &lt;= y</code>: Less than or equal</li>\n<li><code>x &gt;= y</code>: Greater than or equal</li>\n<li><code>x is T</code>: Return <code>true</code> if <code>x</code> is a <code>T</code>, <code>false</code> otherwise</li>\n<li><code>x as T</code>: Return <code>x</code> typed as <code>T</code>, or <code>null</code> if <code>x</code> is not a <code>T</code></li>\n</ul>\n</li>\n<li>Equality<ul>\n<li><code>x == y</code>: Equal</li>\n<li><code>x != y</code>: Not equal</li>\n</ul>\n</li>\n<li>Logical AND<ul>\n<li><code>x &amp; y</code>: Integer bitwise AND, boolean logical AND</li>\n</ul>\n</li>\n<li>Logical XOR<ul>\n<li><code>x ^ y</code>: Integer bitwise XOR, boolean logical XOR</li>\n</ul>\n</li>\n<li>Logical OR<ul>\n<li><code>x | y</code>: Integer bitwise OR, boolean logical OR</li>\n</ul>\n</li>\n<li>Conditional AND<ul>\n<li><code>x &amp;&amp; y</code>: Evaluates <code>y</code> only if <code>x</code> is not <code>false</code></li>\n</ul>\n</li>\n<li>Conditional OR<ul>\n<li><code>x || y</code>: Evaluates <code>y</code> only if <code>x</code> is not <code>true</code></li>\n</ul>\n</li>\n<li>Null coalescing<ul>\n<li><code>x ?? y</code>: Evaluates to <code>y</code> if <code>x</code> is null, to <code>x</code> otherwise</li>\n</ul>\n</li>\n<li>Conditional<ul>\n<li><code>x ? y : z</code>: Evaluates <code>y</code> if <code>x</code> is <code>true</code>, <code>z</code> if <code>x</code> is <code>false</code></li>\n</ul>\n</li>\n<li>Assignment or anonymous function<ul>\n<li><code>x = y</code>: Assignment</li>\n<li><code>x op= y</code>: Compound assignment; supported operators are<ul>\n<li><code>*=</code>   <code>/=</code>   <code>%=</code>   <code>+=</code>   <code>-=</code>   <code>&lt;&lt;=</code>   <code>&gt;&gt;=</code>   <code>&amp;=</code>  <code>^=</code>  <code>|=</code></li>\n</ul>\n</li>\n<li><code>(T x) =&gt; y</code>: Anonymous function (lambda expression)</li>\n</ul>\n</li>\n</ul>\n<div class=\"step-by-step\"><p><a href=\"types-and-variables\" data-linktype=\"relative-path\">Previous</a>\n<a href=\"statements\" data-linktype=\"relative-path\">Next</a></p>\n</div>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"20d5eb10-7381-47b9-ad90-f1cc895aa27e\">\r\n<meta name=\"description\" content=\"expressions, operands, and operators are building blocks of the C# language\">\r\n<meta name=\"keywords\" content=\".NET, csharp, expression, operator, operand\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"11/06/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/d55bd0671c05c738e8df78f95552b8dce6af03a4/docs/csharp/tour-of-csharp/expressions.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/tour-of-csharp/expressions.md\">\r\n<meta name=\"document_id\" content=\"575d8eb0-bb49-8275-889f-71a0bc38ed7b\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"C# Expressions | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"20d5eb10-7381-47b9-ad90-f1cc895aa27e","description":"expressions, operands, and operators are building blocks of the C# language","keywords":".NET, csharp, expression, operator, operand","ms.topic":"article","ms.date":"11/06/2016","ms.technology":"devlang-csharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Fix date format to be mm/dd/yyyy (#1360)","commit_sha":"d55bd0671c05c738e8df78f95552b8dce6af03a4","commit_date":"2016-12-27 12:57:27 -0500"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"Respond to feedback on PR #1076","commit_sha":"d14e3d5664a375974762539d705e3b4f87d7c396","commit_date":"2016-11-07 15:43:59 -0800"},{"author_name":"Bader Nasser","author_email":"badersur@users.noreply.github.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"Update expressions.md","commit_sha":"70a85e05bc4b1a56147cd18e10e8a55f21ba4e7a","commit_date":"2016-11-07 15:43:59 -0800"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Tour of csharp (#893)","commit_sha":"487f9831526f124ddd60dece21852da8c086b520","commit_date":"2016-08-23 10:20:56 -0400"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/badersur","display_name":"Bader Nasser","id":"1686391"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/d55bd0671c05c738e8df78f95552b8dce6af03a4/docs/csharp/tour-of-csharp/expressions.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/tour-of-csharp/expressions.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/tour-of-csharp/expressions.md","document_id":"575d8eb0-bb49-8275-889f-71a0bc38ed7b","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/tour-of-csharp/expressions","toc_asset_id":"articles/csharp/tour-of-csharp/toc.json","toc_rel":"toc.json","_op_ogTitle":"C# Expressions","_op_displayDate":"2016-11-6","_op_displayDate_source":"2016-11-06T00:00:00Z","_op_wordCount":629,"_op_rawTitle":"<h1 id=\"expressions\" sourcefile=\"docs/csharp/tour-of-csharp/expressions.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Expressions</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/tour-of-csharp/expressions","fileRelativePath":"articles/csharp/tour-of-csharp/expressions.html"},"themesRelativePathToOutputRoot":"_themes/"}