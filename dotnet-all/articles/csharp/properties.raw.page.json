{"content":"<div><div class=\"content\">\n<p>Properties are first class citizens in C#. The language\ndefines syntax that enables developers to write code\nthat accurately expresses their design intent.</p>\n<p>Properties behave like fields when they are accessed.\nHowever, unlike fields, properties are implemented\nwith accessors that define the statements executed\nwhen a property is accessed or assigned.</p>\n<h2 id=\"property-syntax\">Property Syntax</h2>\n<p>The syntax for properties is a natural extension to\nfields. A field defines a storage location:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">public class Person\n{\n    public string FirstName;\n    // remaining implementation removed from listing\n}\n</code></pre><p>A property definition contains declarations for a <code>get</code> and\n<code>set</code> accessor that retrieves and assigns the value of that\nproperty:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">public class Person\n{\n    public string FirstName\n    {\n        get;\n        set;\n    }\n    // remaining implementation removed from listing\n}\n</code></pre><p>The syntax shown above is the <em>auto property</em> syntax. The compiler\ngenerates the storage location for the field that backs up the \nproperty. The compiler also implements the body of the <code>get</code> and <code>set</code> accessors.\nYou can also define the storage yourself, as shown below:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">public class Person\n{\n    public string FirstName\n    {\n        get { return firstName; }\n        set { firstName = value; }\n    }\n    private string firstName;\n    // remaining implementation removed from listing\n}\n</code></pre><p>The property definition shown above is a read-write property. Notice\nthe keyword <code>value</code> in the set accessor. The <code>set</code> accessor always has\na single parameter named <code>value</code>. The <code>get</code> accessor must return a value\nthat is convertible to the type of the property (<code>string</code> in this example).</p>\n<p>That&#39;s the basics of the syntax. There are many different variations that support\na variety of different design idioms. Let&#39;s explore those, and learn the syntax\noptions for each. </p>\n<h2 id=\"scenarios\">Scenarios</h2>\n<p>The examples above showed one of the simplest cases of property definition:\na read-write property with no validation. By writing the code you want in the\n<code>get</code> and <code>set</code> accessors, you can create many different scenarios.  </p>\n<h3 id=\"validation\">Validation</h3>\n<p>You can write code in the <code>set</code> accessor to ensure that the values represented\nby a property are always valid. For example, suppose one rule for the <code>Person</code>\nclass is that the name cannot be blank, or whitespace. You would write that as\nfollows:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">public class Person\n{\n    public string FirstName\n    {\n        get { return firstName; }\n        set\n        {\n            if (string.IsNullOrWhiteSpace(value))\n                throw new ArgumentException(&quot;First name must not be blank&quot;);\n            firstName = value;\n        }\n    }\n    private string firstName;\n    // remaining implementation removed from listing\n}\n</code></pre><p>The example above enforces the rule that the first name must not be blank,\nor whitespace. If a developer writes</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">hero.FirstName = &quot;&quot;;\n</code></pre><p>That assignment throws an <code>ArgumentException</code>. Because a property set accessor\nmust have a void return type, you report errors in the set accessor by throwing an exception.</p>\n<p>That is a simple case of validation. You can extend this same syntax to anything needed\nin your scenario. You can check the relationships between different properties, or validate\nagainst any external conditions. Any valid C# statements are valid in a property accessor.</p>\n<h3 id=\"read-only\">Read-only</h3>\n<p>Up to this point, all the property definitions you have seen are read/write properties\nwith public accessors. That&#39;s not the only valid accessibility for properties.\nYou can create read-only properties, or give different accessibility to the set and get\naccessors. Suppose that your <code>Person</code> class should only enable changing the value of the\n<code>FirstName</code> property from other methods in that class. You could give the set accessor\n<code>private</code> accessibility instead of <code>public</code>:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">public class Person\n{\n    public string FirstName\n    {\n        get;\n        private set;\n    }\n    // remaining implementation removed from listing\n}\n</code></pre><p>Now, the <code>FirstName</code> property can be accessed from any code, but it can only be assigned\nfrom other code in the <code>Person</code> class.\nYou can add any restrictive access modifier to either the set or get accessors. Any access modifier\nyou place on the individual accessor must be more limited than the access modifier on the property\ndefinition. The above is legal because the <code>FirstName</code> property is <code>public</code>, but the set accessor is\n<code>private</code>. You could not declare a <code>private</code> property with a <code>public</code> accessor. Property declarations\ncan also be declared <code>protected</code>, <code>internal</code>, <code>protected internal</code> or even <code>private</code>.   </p>\n<p>It is also legal to place the more restrictive modifier on the <code>get</code> accessor. For example, you could\nhave a <code>public</code> property, but restrict the <code>get</code> accessor to <code>private</code>. That scenario is rarely done\nin practice.</p>\n<h3 id=\"computed-properties\">Computed Properties</h3>\n<p>A property does not need to simply return the value of a member field. You can create properties\nthat return a computed value. Let&#39;s expand the <code>Person</code> object to return the full name, computed\nby concatenating the first and last names:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">public class Person\n{\n    public string FirstName\n    {\n        get;\n        set;\n    }\n\n    public string LastName\n    {\n        get;\n        set;\n    }\n\n    public string FullName\n    {\n        get\n        {\n            return $&quot;{FirstName} {LastName}&quot;;\n        }\n    }\n}\n</code></pre><p>The example above uses the <em>String Interpolation</em> syntax to create\nthe formatted string for the full name.</p>\n<p>You can also use <em>Expression-bodied Members</em>, which provides a more\nsuccinct way to create the computed <code>FullName</code> property:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">public class Person\n{\n    public string FirstName\n    {\n        get;\n        set;\n    }\n\n    public string LastName\n    {\n        get;\n        set;\n    }\n\n    public string FullName =&gt;  $&quot;{FirstName} {LastName}&quot;;\n}\n</code></pre><p><em>Expression-bodied Members</em> use the <em>lambda expression</em> syntax to\ndefine a method that contain a single expression. Here, that\nexpression returns the full name for the person object.</p>\n<h3 id=\"lazy-evaluated-properties\">Lazy Evaluated Properties</h3>\n<p>You can mix the concept of a computed property with storage and create\na <em>lazy evaluated property</em>.  For example, you could update the <code>FullName</code>\nproperty so that the string formatting only happened the first time it\nwas accessed:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">public class Person\n{\n    public string FirstName\n    {\n        get;\n        set;\n    }\n\n    public string LastName\n    {\n        get;\n        set;\n    }\n\n    private string fullName;\n    public string FullName\n    {\n        get\n        {\n            if (fullName == null)\n                fullName = $&quot;{FirstName} {LastName}&quot;;\n            return fullName;\n        }\n    }\n}\n</code></pre><p>The above code contains a bug though. If code updates the value of\neither the <code>FirstName</code> or <code>LastName</code> property, the previously evaluated\n<code>fullName</code> field is invalid. You need to update the <code>set</code> accessors of the\n<code>FirstName</code> and <code>LastName</code> property so that the <code>fullName</code> field is calculated\nagain:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">public class Person\n{\n    private string firstName;\n    public string FirstName\n    {\n        get { return firstName; }\n        set\n        {\n            firstName = value;\n            fullName = null;\n        }\n    }\n\n    private string lastName;\n    public string LastName\n    {\n        get { return lastName; }\n        set\n        {\n            lastName = value;\n            fullName = null;\n        }\n    }\n\n    private string fullName;\n    public string FullName\n    {\n        get\n        {\n            if (fullName == null)\n                fullName = $&quot;{FirstName} {LastName}&quot;;\n            return fullName;\n        }\n    }\n}\n</code></pre><p>This final version evaluates the <code>FullName</code> property only when needed.\nIf the previously calculated version is valid, it&#39;s used. If another\nstate change invalidates the previously calculated version, it will be\nrecalculated. Developers that use this class do not need to know the\ndetails of the implementation. None of these internal changes affect the\nuse of the Person object. That&#39;s the key reason for using Properties to\nexpose data members of an object. </p>\n<h3 id=\"inotifypropertychanged\">INotifyPropertyChanged</h3>\n<p>A final scenario where you need to write code in a property accessor is to\nsupport the <code>INotifyPropertyChanged</code> interface used to notify data binding\nclients that a value has changed. When the value of a property changes, the object\nraises the <code>PropertyChanged</code> event\nto indicate the change. The data binding libraries, in turn, update display elements\nbased on that change. The code below shows how you would implement <code>INotifyPropertyChanged</code>\nfor the <code>FirstName</code> property of this person class.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">public class Person : INotifyPropertyChanged\n{\n    public string FirstName\n    {\n        get { return firstName; }\n        set\n        {\n            if (string.IsNullOrWhiteSpace(value))\n                throw new ArgumentException(&quot;First name must not be blank&quot;);\n            if (value != firstName)\n            {\n                PropertyChanged?.Invoke(this, \n                    new PropertyChangedEventArgs(nameof(FirstName)));\n            }\n            firstName = value;\n        }\n    }\n    private string firstName;\n\n    public event PropertyChangedEventHandler PropertyChanged;\n    // remaining implementation removed from listing\n}\n</code></pre><p>The <code>?.</code> operator is called\nthe <em>null conditional operator</em>. It checks for a null reference before evaluating\nthe right side of the operator. The end result is that if there are no subscribers\nto the <code>PropertyChanged</code> event, the code to raise the event doesn&#39;t execute. It would\nthrow a <code>NullReferenceException</code> without this check in that case. See the page on\n<a href=\"delegates-events\" data-linktype=\"relative-path\"><code>events</code></a> for more details. This example also uses the new\n<code>nameof</code> operator to convert from the property name symbol to its text representation.\nUsing <code>nameof</code> can reduce errors where you have mistyped the name of the property.</p>\n<p>Again, this is an example of a case where you can write code in your accessors to\nsupport the scenarios you need.</p>\n<h2 id=\"summing-up\">Summing up</h2>\n<p>Properties are a form of smart fields in a class or object. From\noutside the object, they appear like fields in the object. However,\nproperties can be implemented using the full palette of C# functionality.\nYou can provide validation, different accessibility, lazy evaluation,\nor any requirements your scenarios need.</p>\n</div></div>","outputRootRelativePath":"../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"6950d25a-bba1-4744-b7c7-a3cc90438c55\">\r\n<meta name=\"description\" content=\"Properties\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"06/20/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-04-01 05:46 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/400dfda51d978f35c3995f90840643aaff1b9c13/docs/csharp/properties.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/properties.md\">\r\n<meta name=\"document_id\" content=\"f5d7faec-580f-5d55-d382-9367defabdea\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","uhfHeaderId":"MSDocsHeader-DotNet","title":"Properties | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"6950d25a-bba1-4744-b7c7-a3cc90438c55","description":"Properties","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"06/20/2016","ms.technology":"devlang-csharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"tompratt-AQ","author_email":"v-thprat@microsoft.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"Update language identifiers and styleguide. (#1796)","commit_sha":"400dfda51d978f35c3995f90840643aaff1b9c13","commit_date":"2017-03-24 14:01:03 -0700"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"expression-bodied should be hyphenated (#1384)","commit_sha":"7ac95fa4b2aac81b2e8d33cedf2faf36a0bbf210","commit_date":"2017-01-05 10:03:42 -0500"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Petr Onderka","author_email":"gsvick@gmail.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@users.noreply.github.com","message":"Corrected titles and headings (#690)","commit_sha":"17cac6e7690fd2b08d9f5f73060056d14bca13d2","commit_date":"2016-06-28 12:36:36 -0700"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"Rich Lander","comitter_email":"rlander@microsoft.com","message":"Promote csharp from languages (#644)","commit_sha":"2d44b7e04c0fe2ca136ba6dfa9fc3a4368365ec8","commit_date":"2016-06-26 08:30:56 -0700"}],"updated_at":"2017-04-01 05:46 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/tompratt-AQ","display_name":"tompratt-AQ","id":"26311438"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/svick","display_name":"Petr Onderka","id":"287848"}],"update_at":"4/1/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/400dfda51d978f35c3995f90840643aaff1b9c13/docs/csharp/properties.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/properties.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/properties.md","document_id":"f5d7faec-580f-5d55-d382-9367defabdea","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/properties","toc_asset_id":"articles/toc.json","toc_rel":"../toc.json","_op_ogTitle":"Properties","_op_displayDate":"2016-6-20","_op_displayDate_source":"2016-06-20T00:00:00Z","_op_wordCount":1445,"_op_rawTitle":"<h1 id=\"properties\" sourcefile=\"docs/csharp/properties.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Properties</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/properties","fileRelativePath":"articles/csharp/properties.html"},"themesRelativePathToOutputRoot":"_themes/"}