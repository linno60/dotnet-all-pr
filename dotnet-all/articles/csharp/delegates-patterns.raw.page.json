{"content":"<div><div class=\"content\">\n<p><a href=\"delegates-strongly-typed\" data-linktype=\"relative-path\">Previous</a></p>\n<p>Delegates provide a mechanism that enables software designs\ninvolving minimal coupling between components.</p>\n<p>One excellent example for this kind of design is LINQ. The LINQ\nQuery Expression Pattern relies on delegates for all of its\nfeatures. Consider this simple example:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var smallNumbers = numbers.Where(n =&gt; n &lt; 10);\n</code></pre><p>This filters the sequence of numbers to only those less than the value 10.\nThe <code>Where</code> method uses a delegate that determines which elements of a\nsequence pass the filter. When you create a LINQ query, you supply the\nimplementation of the delegate for this specific purpose.</p>\n<p>The prototype for the Where method is:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public static IEnumerable&lt;TSource&gt; Where&lt;in TSource&gt; (IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate);\n</code></pre><p>This example is repeated with all the methods that are part of LINQ. They\nall rely on delegates for the code that manages the specific query. This API\ndesign pattern is a very powerful one to learn and understand.</p>\n<p>This simple example illustrates how delegates require very little coupling\nbetween components. You don&#39;t need to create a class that derives from a\nparticular base class. You don&#39;t need to implement a specific interface.\nThe only requirement is to provide the implementation of one method that\nis fundamental to the task at hand.</p>\n<h2 id=\"building-your-own-components-with-delegates\">Building Your Own Components with Delegates</h2>\n<p>Let&#39;s build on that example by creating a component using a design that\nrelies on delegates.</p>\n<p>Let&#39;s define a component that could be used for log messages in a large\nsystem. The library components could be used in many different environments,\non multiple different platforms. There are a lot of common features in the\ncomponent that manages the logs. It will need to accept messages from any\ncomponent in the system. Those messages will have different priorities, which\nthe core component can manage. The messages should have timestamps in their\nfinal archived form. For more advanced scenarios, you could filter messages by\nthe source component.</p>\n<p>There is one aspect of the feature that will change often: where messages are\nwritten. In some environments, they may be written to the error console. In\nothers, a file. Other possibilities include database storage, OS event logs,\nor other document storage.</p>\n<p>There are also combinations of output that might be used in different\nscenarios. You may want to write messages to the console and to a file.</p>\n<p>A design based on delegates will provide a great deal of flexibility, and\nmake it easy to support storage mechanisms that may be added in the future.</p>\n<p>Under this design, the primary log component can be a non-virtual, even\nsealed class. You can plug in any set of delegates to write the messages\nto different storage media. The built in support for multicast delegates\nmakes it easy to support scenarios where messages must be written to multiple\nlocations (a file, and a console).</p>\n<h2 id=\"a-first-implementation\">A First Implementation</h2>\n<p>Let&#39;s start small: the initial implementation will accept new messages,\nand write them using any attached delegate. You can start with one delegate\nthat writes messages to the console.</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public static class Logger\n{\n    public static Action&lt;string&gt; WriteMessage;\n\n    public static void LogMessage(string msg)\n    {\n        WriteMessage(msg);\n    }\n}\n</code></pre><p>The static class above is the simplest thing that can work. We need to\nwrite the single implementation for the method that writes messages\nto the console: </p>\n<pre class=\"loading\"><code class=\"lang-cs\">public static void LogToConsole(string message)\n{\n    Console.Error.WriteLine(message);\n}\n</code></pre><p>Finally, you need to hook up the delegate by attaching it to\nthe WriteMessage delegate declared in the logger:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">Logger.WriteMessage += LogToConsole;\n</code></pre><h2 id=\"practices\">Practices</h2>\n<p>Our sample so far is fairly simple, but it still demonstrates some\nof the important guidelines for designs involving delegates.</p>\n<p>Using the delegate types defined in the Core Framework makes it easier\nfor users to work with the delegates. You don&#39;t need to define new types,\nand developers using your library do not need to learn new, specialized\ndelegate types.</p>\n<p>The interfaces used are as minimal and as flexible as possible: To create\na new output logger, you must create one method. That method may be a static\nmethod, or an instance method. It may have any access.</p>\n<h2 id=\"formatting-output\">Formatting Output</h2>\n<p>Let&#39;s make this first version a bit more robust, and then start\ncreating other logging mechanisms.</p>\n<p>Next, let&#39;s add a few arguments to the <code>LogMessage()</code> method so that\nyour log class creates more structured messages:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">// Logger implementation two\npublic enum Severity\n{\n    Verbose,\n    Trace,\n    Information,\n    Warning,\n    Error,\n    Critical\n}\n\npublic static class Logger\n{\n    public static Action&lt;string&gt; WriteMessage;\n\n    public static void LogMessage(Severity s, string component, string msg)\n    {\n        var outputMsg = $&quot;{DateTime.Now}\\t{s}\\t{component}\\t{msg}&quot;;\n        WriteMessage(outputMsg);\n    }\n}\n</code></pre><p>Next, let&#39;s make use of that <code>Severity</code> argument to filter the messages\nthat are sent to the log&#39;s output. </p>\n<pre class=\"loading\"><code class=\"lang-cs\">public static class Logger\n{\n    public static Action&lt;string&gt; WriteMessage;\n\n    public static Severity LogLevel {get;set;} = Severity.Warning;\n\n    public static void LogMessage(Severity s, string component, string msg)\n    {\n        if (s &lt; LogLevel)\n            return;\n\n        var outputMsg = $&quot;{DateTime.Now}\\t{s}\\t{component}\\t{msg}&quot;;\n        WriteMessage(outputMsg);\n    }\n}\n</code></pre><h2 id=\"practices-1\">Practices</h2>\n<p>You&#39;ve added new features to the logging infrastructure. Because\nthe logger component is very loosely coupled to any output mechanism,\nthese new features can be added with no impact on any of the code\nimplementing the logger delegate.</p>\n<p>As you keep building this, you&#39;ll see more examples of how this loose\ncoupling enables greater flexibility in updating parts of the site without\nany changes to other locations. In fact, in a larger application, the logger\noutput classes might be in a different assembly, and not even need to be\nrebuilt.</p>\n<h2 id=\"building-a-second-output-engine\">Building a Second Output Engine</h2>\n<p>The Log component is coming along well. Let&#39;s add one more output\nengine that logs messages to a file. This will be a slightly more\ninvolved output engine. It will be a class that encapsulates the\nfile operations, and ensures that the file is always closed after\neach write. That ensures that all the data is flushed to disk after\neach message is generated.</p>\n<p>Here is that file based logger:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public class FileLogger\n{\n    private readonly string logPath;\n    public FileLogger(string path)\n    {\n        logPath = path;\n        Logger.WriteMessage += LogMessage;\n    }\n\n    public void DetachLog() =&gt; Logger.WriteMessage -= LogMessage;\n\n    // make sure this can&#39;t throw.\n    private void LogMessage(string msg)\n    {\n        try {\n            using (var log = File.AppendText(logPath))\n            {\n                log.WriteLine(msg);\n                log.Flush();\n            }\n        } catch (Exception e)\n        {\n            // Hmm. Not sure what to do.\n            // Logging is failing...\n        }\n    }\n}\n</code></pre><p>Once you&#39;ve created this class, you can instantiate it and it attaches\nits LogMessage method to the Logger component:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var file = new FileLogger(&quot;log.txt&quot;);\n</code></pre><p>These two are not mutually exclusive. You could attach both log\nmethods and generate messages to the console and a file:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var fileOutput = new FileLogger(&quot;log.txt&quot;);\nLogger.WriteMessage += LogToConsole;\n</code></pre><p>Later, even in the same application, you can remove one of the\ndelegates without any other issues to the system:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">Logger.WriteMessage -= LogToConsole;\n</code></pre><h2 id=\"practices-2\">Practices</h2>\n<p>Now, you&#39;ve added a second output handler for the logging sub-system.\nThis one needs a bit more infrastructure to correctly support the file\nsystem. The delegate is an instance method. It&#39;s also a private method.\nThere&#39;s no need for greater accessibility because the delegate\ninfrastructure can connect the delegates.</p>\n<p>Second, the delegate-based design enables multiple output methods\nwithout any extra code. You don&#39;t need to build any additional infrastructure\nto support multiple output methods. They simply become another method\non the invocation list.</p>\n<p>Pay special attention to the code in the file logging output method. It\nis coded to ensure that it does not throw any exceptions. While this isn&#39;t\nalways strictly necessary, it&#39;s often a good practice. If either of the\ndelegate methods throws an exception, the remaining delegates that are\non the invocation won&#39;t be invoked.</p>\n<p>As a last note, the file logger must manage its resources by opening and\nclosing the file on each log message. You could choose to keep the file\nopen and implement IDisposable to close the file when you are completed.\nEither method has its advantages and disadvantages. Both do create a bit\nmore coupling between the classes.</p>\n<p>None of the code in the Logger class would need to be updated\nin order to support either scenario.</p>\n<h2 id=\"handling-null-delegates\">Handling Null Delegates</h2>\n<p>Finally, let&#39;s update the LogMessage method so that it is robust\nfor those cases when no output mechanism is selected. The current\nimplementation will throw a <code>NullReferenceException</code> when the\n<code>WriteMessage</code> delegate does not have an invocation list attached.\nYou may prefer a design that silently continues when no methods\nhave been attached. This is easy using the null conditional operator,\ncombined with the <code>Delegate.Invoke()</code> method:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public static void LogMessage(string msg)\n{\n    WriteMessage?.Invoke(msg);\n}\n</code></pre><p>The null conditional operator (<code>?.</code>) short-circuits when the left operand\n(<code>WriteMessage</code> in this case) is null, which means no attempt is made\nto log a message.</p>\n<p>You won&#39;t find the <code>Invoke()</code> method listed in the documentation for\n<code>System.Delegate</code> or <code>System.MulticastDelegate</code>. The compiler generates\na type safe <code>Invoke</code> method for any delegate type declared. In this example,\nthat means <code>Invoke</code> takes a single <code>string</code> argument, and has a void\nreturn type.</p>\n<h2 id=\"summary-of-practices\">Summary of Practices</h2>\n<p>You&#39;ve seen the beginnings of a log component that could be expanded\nwith other writers, and other features. By using delegates in the design\nthese different components are very loosely coupled. This provides\nseveral advantages. It&#39;s very easy to create new output mechanisms\nand attach them to the system. These other mechanisms only need one\nmethod: the method that writes the log message. It&#39;s a design that\nis very resilient when new features are added. The contract required\nfor any writer is to implement one method. That method could be a\nstatic or instance method. It could be public, private, or any other\nlegal access.</p>\n<p>The Logger class can make any number of enhancements or changes without\nintroducing breaking changes. Like any class, you cannot modify the\npublic API without the risk of breaking changes. But, because the\ncoupling between the logger and any output engines is only through\nthe delegate, no other types (like interfaces or base classes) are\ninvolved. The coupling is as small as possible.</p>\n<p><a href=\"events-overview\" data-linktype=\"relative-path\">Next</a></p>\n</div></div>","outputRootRelativePath":"../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"0ff8fdfd-6a11-4327-b061-0f2526f35b43\">\r\n<meta name=\"description\" content=\"Common Patterns for Delegates\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"06/20/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-21 01:42 AM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/delegates-patterns.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/csharp/delegates-patterns.md\">\r\n<meta name=\"document_id\" content=\"baab006c-5962-28ca-335d-3606918c40c9\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Common Patterns for Delegates | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"0ff8fdfd-6a11-4327-b061-0f2526f35b43","description":"Common Patterns for Delegates","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"06/20/2016","ms.technology":"devlang-csharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Petr Onderka","author_email":"gsvick@gmail.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@users.noreply.github.com","message":"Corrected titles and headings (#690)","commit_sha":"17cac6e7690fd2b08d9f5f73060056d14bca13d2","commit_date":"2016-06-28 12:36:36 -0700"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"Rich Lander","comitter_email":"rlander@microsoft.com","message":"Promote csharp from languages (#644)","commit_sha":"2d44b7e04c0fe2ca136ba6dfa9fc3a4368365ec8","commit_date":"2016-06-26 08:30:56 -0700"}],"updated_at":"2017-03-21 01:42 AM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/svick","display_name":"Petr Onderka","id":"287848"}],"update_at":"3/21/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/delegates-patterns.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/csharp/delegates-patterns.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/delegates-patterns.md","document_id":"baab006c-5962-28ca-335d-3606918c40c9","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/delegates-patterns","toc_asset_id":"articles/toc.json","toc_rel":"../toc.json","_op_ogTitle":"Common Patterns for Delegates","_op_displayDate":"2016-6-20","_op_displayDate_source":"2016-06-20T00:00:00Z","_op_wordCount":1649,"_op_rawTitle":"<h1 id=\"common-patterns-for-delegates\" sourcefile=\"docs/csharp/delegates-patterns.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Common Patterns for Delegates</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/delegates-patterns","fileRelativePath":"articles/csharp/delegates-patterns.html"},"themesRelativePathToOutputRoot":"_themes/"}