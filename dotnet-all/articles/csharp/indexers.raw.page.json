{"content":"<div><div class=\"content\">\n<p><em>Indexers</em> are similar to properties. In many ways indexers build\non the same language features as <a href=\"properties\" data-linktype=\"relative-path\">properties</a>. Indexers\nenable <em>indexed</em> properties: properties referenced using one or more\narguments. Those arguments provide an index into some collection\nof values.</p>\n<h2 id=\"indexer-syntax\">Indexer Syntax</h2>\n<p>You access an indexer through a variable name and square brackets . You place the indexer\narguments inside the brackets:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">var item = someObject[&quot;key&quot;];\nsomeObject[&quot;AnotherKey&quot;] = item;\n</code></pre><p>You declare indexers using the <code>this</code> keyword as the property name, and\ndeclaring the arguments within square brackets. This declaration would match\nthe usage shown in the previous paragraph:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">public int this[string key]\n{\n    get { return storage.Find(key); }\n    set { storage.SetAt(key, value); }\n}\n</code></pre><p>From this initial example, you can see the relationship between the syntax\nfor properties and for indexers. This analogy carries through most of the\nsyntax rules for indexers. Indexers can have any valid access modifiers\n(public, protected internal, protected, internal, or private). They may\nbe sealed, virtual, or abstract. As with properties, you can specify\ndifferent access modifiers for the get and set accesssors in an indexer.\nYou may also specify read-only indexers (by omitting the set accessor),\nor write-only indexers (by omitting the get accessor).</p>\n<p>You can apply almost everything you learn from working with properties\nto indexers. The only exception to that rule is\n<em>auto implemented properties</em>. The compiler cannot always\ngenerate the correct storage for an indexer.</p>\n<p>The presence of arguments to reference an item in a set of items distinguishes\nindexers from properties. You may define multiple indexers on a type, as long\nas the argument lists for each indexer is unique. Let&#39;s explore different\nscenarios where you might use one or more indexers in a class definition. </p>\n<h2 id=\"scenarios\">Scenarios</h2>\n<p>You would define <em>indexers</em> in your type when its API models some\ncollection where you define the arguments to that collection. Your indexers\nmay or may not map directly to the collection types that are part of the .NET\ncore framework. Your type\nmay have other responsibilities in addition to modeling a collection.\nIndexers enable you to provide the API that matches your type&#39;s abstraction\nwithout exposing the inner details of how the values for that abstraction\nare stored or computed.</p>\n<p>Let&#39;s walk through some of the common scenarios for using <em>indexers</em>.\nThe code for all the samples is available at the core-docs <a href=\"https://github.com/dotnet/core-docs\" data-linktype=\"external\">GitHub\nrepository</a>. Or, you can\naccess the \n<a href=\"https://github.com/dotnet/docs/tree/master/samples/csharp/indexers\" data-linktype=\"external\">sample folder</a>\ndirectly.</p>\n<h3 id=\"arrays-and-vectors\">Arrays and Vectors</h3>\n<p>One of the most common scenarios for creating indexers is when your\ntype models an array, or a vector. You can create an indexer to model\nan ordered list of data. </p>\n<p>The advantage of creating your own indexer is that you can define\nthe storage for that collection to suit your needs. Imagine a\nscenario where your type models historical data that is too large\nto load into memory at once. You need to load and unload sections\nof the collection based on usage. The example following models\nthis behavior. It reports on how many data points exist. It creates\npages to hold sections of the data on demand. It removes pages\nfrom memory to make room for pages needed by more recent requests.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">public class DataSamples\n{\n    private class Page\n    {\n        private readonly List&lt;Measurements&gt; pageData = new List&lt;Measurements&gt;();\n        private readonly int startingIndex;\n        private readonly int length;\n        private bool dirty;\n        private DateTime lastAccess;\n\n        public Page(int startingIndex, int length)\n        {\n            this.startingIndex = startingIndex;\n            this.length = length;\n            lastAccess = DateTime.Now;\n\n            // This stays as random stuff:\n            var generator = new Random();\n            for(int i=0; i &lt; length; i++)\n            {\n                var m = new Measurements\n                {\n                    HiTemp = generator.Next(50, 95),\n                    LoTemp = generator.Next(12, 49),\n                    AirPressure = 28.0 + generator.NextDouble() * 4\n                };\n                pageData.Add(m);\n            }\n        }\n        public bool HasItem(int index) =&gt;\n            ((index &gt;= startingIndex) &amp;&amp;\n            (index &lt; startingIndex + length));\n\n        public Measurements this[int index]\n        {\n            get\n            {\n                lastAccess = DateTime.Now;\n                return pageData[index - startingIndex];\n            }\n            set\n            {\n                pageData[index - startingIndex] = value;\n                dirty = true;\n                lastAccess = DateTime.Now;\n            }\n        }\n\n        public bool Dirty =&gt; dirty;\n        public DateTime LastAccess =&gt; lastAccess;\n    }\n\n    private readonly int totalSize;\n    private readonly List&lt;Page&gt; pagesInMemory = new List&lt;Page&gt;();\n\n    public DataSamples(int totalSize)\n    {\n        this.totalSize = totalSize;\n    }\n\n    public Measurements this[int index]\n    {\n        get\n        {\n            if (index &lt; 0)\n                throw new IndexOutOfRangeException(&quot;Cannot index less than 0&quot;);\n            if (index &gt;= totalSize)\n                throw new IndexOutOfRangeException(&quot;Cannot index past the end of storage&quot;);\n\n            var page = updateCachedPagesForAccess(index);\n            return page[index];\n        }\n        set\n        {\n            if (index &lt; 0)\n                throw new IndexOutOfRangeException(&quot;Cannot index less than 0&quot;);\n            if (index &gt;= totalSize)\n                throw new IndexOutOfRangeException(&quot;Cannot index past the end of storage&quot;);\n            var page = updateCachedPagesForAccess(index);\n\n            page[index] = value;\n        }\n    }\n\n    private Page updateCachedPagesForAccess(int index)\n    {\n        foreach (var p in pagesInMemory)\n        {\n            if (p.HasItem(index))\n            {\n                return p;\n            }\n        }\n        var startingIndex = (index / 1000) * 1000;\n        var newPage = new Page(startingIndex, 1000);\n        addPageToCache(newPage);\n        return newPage;\n    }\n\n    private void addPageToCache(Page p)\n    {\n        if (pagesInMemory.Count &gt; 4)\n        {\n            // remove oldest non-dirty page:\n            var oldest = pagesInMemory\n                .Where(page =&gt; !page.Dirty)\n                .OrderBy(page =&gt; page.LastAccess)\n                .FirstOrDefault();\n            // Note that this may keep more than 5 pages in memory\n            // if too much is dirty\n            if (oldest != null)\n                pagesInMemory.Remove(oldest);\n        }\n        pagesInMemory.Add(p);\n    }\n}\n</code></pre><p>You can follow this design idiom to model any sort of collection where\nthere are good reasons not to load the entire set of data into an in-\nmemory collection. Notice that the <code>Page</code> class is a private nested\nclass that is not part of the public interface. Those details are hidden\nfrom any users of this class.</p>\n<h3 id=\"dictionaries\">Dictionaries</h3>\n<p>Another common scenario is when you need to model a dictionary\nor a map. This scenario is when your type stores values based on key,\ntypically text keys. This example creates a dictionary that maps command\nline arguments to <a href=\"delegates-overview\" data-linktype=\"relative-path\">lamdba expressions</a> that manage\nthose options. The following example shows two classes: an <code>ArgsActions</code>\nclass that maps a command line option to an <code>Action</code> delegate, and an\n<code>ArgsProcessor</code> that uses the <code>ArgsActions</code> to execute each <code>Action</code> when\nit encounters that option.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">public class ArgsProcessor\n{\n    private readonly ArgsActions actions;\n\n    public ArgsProcessor(ArgsActions actions)\n    {\n        this.actions = actions;\n    }\n\n    public void Process(string[] args)\n    {\n        foreach(var arg in args)\n        {\n            actions[arg]?.Invoke();\n        }\n    }\n\n}\npublic class ArgsActions\n{\n    readonly private Dictionary&lt;string, Action&gt; argsActions = new Dictionary&lt;string, Action&gt;();\n\n    public Action this[string s]\n    {\n        get\n        {\n            Action action;\n            Action defaultAction = () =&gt; {} ;\n            return argsActions.TryGetValue(s, out action) ? action : defaultAction;\n        }\n    }\n\n    public void SetOption(string s, Action a)\n    {\n        argsActions[s] = a;\n    }\n}\n</code></pre><p>In this example, the <code>ArgsAction</code> collection maps closely to the underlying collection.\nThe <code>get</code> determines if a given option has been configured. If so, it returns\nthe <code>Action</code> associated with that option. If not, it returns an <code>Action</code> that \ndoes nothing. The public accessor does not include a <code>set</code> accessor. Rather,\nthe design using a public method for setting options.</p>\n<h3 id=\"multi-dimensional-maps\">Multi-Dimensional Maps</h3>\n<p>You can create indexers that use multiple arguments. In addition,\nthose arguments are not constrained to be the same type. Let&#39;s look at\ntwo examples.   </p>\n<p>The first example shows a class that generates values for a Mandelbrot\nset. For more information on the mathematics behind the set, read\n<a href=\"https://en.wikipedia.org/wiki/Mandelbrot_set\" data-linktype=\"external\">this article</a>. \nThe indexer uses two doubles to define a point in the X, Y plane.\nThe get accessor computes the number of iterations until a point is\ndetermined to be not in the set. If the maximum iterations is reached, the point\nis in the set, and the class&#39;s maxIterations value is returned. (The computer\ngenerated images popularized for the Mandelbrot set define colors for the\nnumber of iterations necessary to determine that a point is outside the set.</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">public class Mandelbrot\n{\n    readonly private int maxIterations;\n\n    public Mandelbrot(int maxIterations)\n    {\n        this.maxIterations = maxIterations;\n    }\n\n    public int this [double x, double y]\n    {\n        get\n        {\n            var iterations = 0;\n            var x0 = x;\n            var y0 = y;\n\n            while ((x*x + y * y &lt; 4) &amp;&amp;\n                (iterations &lt; maxIterations))\n            {\n                var newX = x * x - y * y + x0;\n                y = 2 * x * y + y0;\n                x = newX;\n                iterations++;\n            }\n            return iterations;\n        }\n    }\n}\n</code></pre><p>The Mandelbrot Set defines values at every (x,y) coordinate for real number values.\nThat defines a dictionary that could contain an infinite number of values. Therefore,\nthere is no storage behind the set. Instead, this class computes the value for each\npoint when code calls the <code>get</code> accessor. There&#39;s no underlying storage used.</p>\n<p>Let&#39;s examine one last use of indexers, where the indexer takes multiple arguments\nof different types. Consider a program that manages historical temperature\ndata. This indexer uses a city and a date to set or get the high and low \ntemperatures for that location:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using DateMeasurements = \n    System.Collections.Generic.Dictionary&lt;System.DateTime, IndexersSamples.Common.Measurements&gt;;\nusing CityDataMeasurements = \n    System.Collections.Generic.Dictionary&lt;string, System.Collections.Generic.Dictionary&lt;System.DateTime, IndexersSamples.Common.Measurements&gt;&gt;;\n\npublic class HistoricalWeatherData\n{\n    readonly CityDataMeasurements storage = new CityDataMeasurements();\n\n    public Measurements this[string city, DateTime date]\n    {\n        get\n        {\n            var cityData = default(DateMeasurements);\n\n            if (!storage.TryGetValue(city, out cityData))\n                throw new ArgumentOutOfRangeException(nameof(city), &quot;City not found&quot;);\n\n            // strip out any time portion:\n            var index = date.Date;\n            var measure = default(Measurements);\n            if (cityData.TryGetValue(index, out measure))\n                return measure;\n            throw new ArgumentOutOfRangeException(nameof(date), &quot;Date not found&quot;);\n        }\n        set\n        {\n            var cityData = default(DateMeasurements);\n\n            if (!storage.TryGetValue(city, out cityData))\n            {\n                cityData = new DateMeasurements();\n                storage.Add(city, cityData);\n            }\n\n            // Strip out any time portion:\n            var index = date.Date;\n            cityData[index] = value;\n        }\n    }\n}\n</code></pre><p>This example creates an indexer that maps weather data on two different\narguments: a city (represented by a <code>string</code>) and a date (represented by\na <code>DateTime</code>). The internal storage uses two <code>Dictionary</code> classes to represent\nthe two-dimensional dictionary. The public API no longer represents the\nunderlying storage. Rather, the language features of indexers enables you\nto create a public interface that represents your abstraction, even though\nthe underlying storage must use different core collection types.</p>\n<p>There are two parts of this code that may be unfamiliar\nto some developers. These two <code>using</code> statements:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">using DateMeasurements = System.Collections.Generic.Dictionary&lt;System.DateTime, IndexersSamples.Common.Measurements&gt;;\nusing CityDataMeasurements = System.Collections.Generic.Dictionary&lt;string, System.Collections.Generic.Dictionary&lt;System.DateTime, IndexersSamples.Common.Measurements&gt;&gt;;\n</code></pre><p>create an <em>alias</em> for a constructed generic type. Those statements enable the\ncode later to use the more descriptive <code>DateMeasurements</code> and <code>CityDateMeasurements</code>\nnames instead of the generic construction of <code>Dictionary&lt;DateTime, Measurements&gt;</code>\nand <code>Dictionary&lt;string, Dictionary&lt;DateTime, Measurements&gt; &gt;</code>. \nThis construct does require using the fully qualified type names on the right\nside of the <code>=</code> sign.</p>\n<p>The second technique is to strip off the time portions of any <code>DateTime</code> object\nused to index into the collections. The .NET framework does not include a Date only type.\nDevelopers use the <code>DateTime</code> type, but use the <code>Date</code> property to ensure that any\n<code>DateTime</code> object from that day are equal.</p>\n<h2 id=\"summing-up\">Summing Up</h2>\n<p>You should create indexers anytime you have a property-like element in your\nclass where that property represents not a single value, but rather a collection\nof values where each individual item is identified by a set of arguments. Those\narguments can uniquely identify which item in the collection should be referenced.\nIndexers extend the concept of <a href=\"properties\" data-linktype=\"relative-path\">properties</a>, where a member is treated\nlike a data item from outside the class, but like a method on the side. Indexers allow\narguments to find a single item in a property that represents a set of items.</p>\n</div></div>","outputRootRelativePath":"../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"0e9496da-e766-45a9-b92b-91820d4a350e\">\r\n<meta name=\"description\" content=\"Indexers\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"06/20/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-04-01 05:46 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/400dfda51d978f35c3995f90840643aaff1b9c13/docs/csharp/indexers.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/indexers.md\">\r\n<meta name=\"document_id\" content=\"2889c5f1-b76b-c082-a520-8ad637f0eb86\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","uhfHeaderId":"MSDocsHeader-DotNet","title":"Indexers | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"0e9496da-e766-45a9-b92b-91820d4a350e","description":"Indexers","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"06/20/2016","ms.technology":"devlang-csharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"tompratt-AQ","author_email":"v-thprat@microsoft.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"Update language identifiers and styleguide. (#1796)","commit_sha":"400dfda51d978f35c3995f90840643aaff1b9c13","commit_date":"2017-03-24 14:01:03 -0700"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"renamed repo/fixed headings (#1186)","commit_sha":"15c55a87beb64f265a164db918c7721c7690fadf","commit_date":"2016-10-29 15:23:17 -0400"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update ci build for ubuntu (#891)","commit_sha":"ce52ada663c2ed9b8b3d10bc3d4dcb453abb79f7","commit_date":"2016-08-09 16:02:13 -0400"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"Fixed typos and other small things (#883)","commit_sha":"bb15293c569fa92f1acf6315c5fe7f2cd9cb6f68","commit_date":"2016-08-08 21:27:46 -0400"},{"author_name":"Petr Onderka","author_email":"gsvick@gmail.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@users.noreply.github.com","message":"Corrected titles and headings (#690)","commit_sha":"17cac6e7690fd2b08d9f5f73060056d14bca13d2","commit_date":"2016-06-28 12:36:36 -0700"},{"author_name":"brady gaster","author_email":"bradyg@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"fixed indexers sample link","commit_sha":"2b09b6a69d307b4a00680825f2f7c2e8ade8f478","commit_date":"2016-06-26 09:16:10 -0700"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"Rich Lander","comitter_email":"rlander@microsoft.com","message":"Promote csharp from languages (#644)","commit_sha":"2d44b7e04c0fe2ca136ba6dfa9fc3a4368365ec8","commit_date":"2016-06-26 08:30:56 -0700"}],"updated_at":"2017-04-01 05:46 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/tompratt-AQ","display_name":"tompratt-AQ","id":"26311438"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/svick","display_name":"Petr Onderka","id":"287848"},{"profile_url":"https://github.com/bradygaster","display_name":"brady gaster","id":"486363"}],"update_at":"4/1/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/400dfda51d978f35c3995f90840643aaff1b9c13/docs/csharp/indexers.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/indexers.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/indexers.md","document_id":"2889c5f1-b76b-c082-a520-8ad637f0eb86","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/indexers","toc_asset_id":"articles/toc.json","toc_rel":"../toc.json","_op_ogTitle":"Indexers","_op_displayDate":"2016-6-20","_op_displayDate_source":"2016-06-20T00:00:00Z","_op_wordCount":1842,"_op_rawTitle":"<h1 id=\"indexers\" sourcefile=\"docs/csharp/indexers.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Indexers</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/indexers","fileRelativePath":"articles/csharp/indexers.html"},"themesRelativePathToOutputRoot":"_themes/"}