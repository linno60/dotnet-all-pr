{"content":"<div><div class=\"content\">\n<p>Patterns test that a value has a certain <em>shape</em>, and can <em>extract</em>\ninformation from the value when it has the matching shape. Pattern\nmatching provides more concise syntax for algorithms you already use\ntoday. You already create pattern matching algorithms using existing\nsyntax. You write <code>if</code> or <code>switch</code> statements that test values. Then,\nwhen those statements match, you extract and use information from that\nvalue. The new syntax elements are extensions to statements you are already\nfamiliar with: <code>is</code> and <code>switch</code>. These new extensions combine testing\na value and extracting that information.</p>\n<p>In this topic, we&#39;ll look at the new syntax to show you how it enables\nreadable, concise code. Pattern matching enables idioms where data and\nthe code are separated, unlike object oriented designs where data \nand the methods that manipulate them are tightly coupled.</p>\n<p>To illustrate these new idioms, let&#39;s work with structures that represent\ngeometric shapes using pattern matching statements. You are probably\nfamiliar with building class hierarchies and creating\n<a href=\"methods#inherited\" data-linktype=\"relative-path\">virtual methods and overridden methods</a> to\ncustomize object behavior based on the runtime type of the object.</p>\n<p>Those techniques aren&#39;t possible for data that isn&#39;t structured in a class\nhierarchy. When data and methods are separate, you need other tools. The new\n<em>pattern matching</em> constructs enable cleaner syntax to examine data\nand manipulate control flow based on any condition of that data. You already\nwrite <code>if</code> statements and <code>switch</code> that test a variable&#39;s value. You write <code>is</code>\nstatements that test a variable&#39;s type. <em>Pattern matching</em> adds new capabilities\nto those statements.</p>\n<p>In this topic, you&#39;ll build a method  that computes the area of\ndifferent geometric shapes. But, you&#39;ll do it without resorting to object\noriented techniques and building a class hierarchy for the different shapes.\nYou&#39;ll use <em>pattern matching</em> instead. To further emphasize that we&#39;re not\nusing inheritance, you&#39;ll make each shape a <code>struct</code> instead of a class. \nNote that different <code>struct</code> types cannot specify a common user defined\nbase type, so inheritance is not a possible design.\nAs you go through this sample, contrast this code with how it would\nbe structured as an object hierarchy. When the data you must\nquery and manipulate is not a class hierarchy, pattern matching enables\nvery elegant designs.</p>\n<p>Rather than starting with an abstract shape definition and adding different\nspecific shape classes, let&#39;s start instead with simple data only definitions\nfor each of the geometric shapes:</p>\n<pre><code class=\"lang-csharp\" name=\"ShapeDefinitions\" title=\"Shape definitions\">public class Square\n{\n    public double Side { get; }\n\n    public Square(double side)\n    {\n        Side = side;\n    }\n}\npublic class Circle\n{\n    public double Radius { get; }\n\n    public Circle(double radius)\n    {\n        Radius = radius;\n    }\n}\npublic struct Rectangle\n{\n    public double Length { get; }\n    public double Height { get; }\n\n    public Rectangle(double length, double height)\n    {\n        Length = length;\n        Height = height;\n    }\n}\n\npublic struct Triangle\n{\n    public double Base { get; }\n    public double Height { get; }\n\n    public Triangle(double @base, double height)\n    {\n        Base = @base;\n        Height = height;\n    }\n}\n</code></pre><p>From these structures, let&#39;s write a method that computes the area\nof some shape.</p>\n<h2 id=\"the-is-type-pattern-expression\">The <code>is</code> type pattern expression</h2>\n<p>Before C# 7, you&#39;d need to test each type in a series of <code>if</code> and <code>is</code>\nstatements:</p>\n<pre><code class=\"lang-csharp\" name=\"ClassicIsExpression\" title=\"Classic type pattern using is\">public static double ComputeArea(object shape)\n{\n    if (shape is Square)\n    {\n        var s = shape as Square;\n        return s.Side * s.Side;\n    } else if (shape is Circle)\n    {\n        var c = shape as Circle;\n        return c.Radius * c.Radius * Math.PI;\n    }\n    // elided\n    throw new ArgumentException(\n        message: &quot;shape is not a recognized shape&quot;,\n        paramName: nameof(shape));\n}\n</code></pre><p>That code above is a classic expression of the <em>type pattern</em>: You&#39;re testing a variable\nto determine its type and taking a different action based on that type.</p>\n<p>This code becomes simpler using extensions to the <code>is</code> expression to assign\na variable if the test succeeds:</p>\n<pre><code class=\"lang-csharp\" name=\"IsPatternExpression\" title=\"is pattern expression\">public static double ComputeAreaModernIs(object shape)\n{\n    if (shape is Square s)\n        return s.Side * s.Side;\n    else if (shape is Circle c)\n        return c.Radius * c.Radius * Math.PI;\n    else if (shape is Rectangle r)\n        return r.Height * r.Length;\n    // elided\n    throw new ArgumentException(\n        message: &quot;shape is not a recognized shape&quot;,\n        paramName: nameof(shape));\n}\n</code></pre><p>In this updated version, the <code>is</code> expression both tests the variable and assigns\nit to a new variable of the proper type. Also, notice that this version includes\nthe <code>Rectangle</code> type, which is a <code>struct</code>. The new <code>is</code> expression works with\nvalue types as well as reference types.</p>\n<p>Language rules for pattern matching expressions help you avoid misusing\nthe results of a match expression. In the example above, the variables <code>s</code>,\n <code>c</code>, and <code>r</code> are only in scope and definitely assigned when the respective\npattern match expressions have <code>true</code> results. If you try to use either\nvariable in another location, your code generates compiler errors.</p>\n<p>Let&#39;s examine both of those rules in detail, beginning with scope. The variable\n<code>c</code> is in scope only in the <code>else</code> branch of the first <code>if</code> statement. The variable\n<code>s</code> is in scope in the method <code>ComputeArea</code>. That&#39;s because each \nbranch of an <code>if</code> statement establishes a separate scope for variables. However, the <code>if</code> statement\nitself does not. That means variables declared in the <code>if</code> statement are in the\nsame scope as the <code>if</code> statement (the method in this case.) This behavior is not\nspecific to pattern matching, but is the defined behavior for variable scopes \nand <code>if</code> and <code>else</code> statements.</p>\n<p>The variables <code>c</code> and <code>s</code> are assigned when the respective <code>if</code> statements are true\nbecause of the definitely assigned when true mechanism.</p>\n<div class=\"TIP\"><h5>Tip</h5><p>The samples in this topic use the recommended construct where\na pattern match <code>is</code> expression definitely assigns the match\nvariable in the <code>true</code> branch of the <code>if</code> statement.\nYou could reverse the logic by saying <code>if (!(shape is Square s))</code>\nand the variable <code>s</code> would be definitely assigned only in the\n<code>false</code> branch. While this is valid C#, it is not recommended\nbecause it is more confusing to follow the logic.</p>\n</div>\n<p>These rules mean that you are unlikely to accidentally access the result\nof a pattern match expression when that pattern was not met.</p>\n<h2 id=\"using-pattern-matching-switch-statements\">Using pattern matching <code>switch</code> statements</h2>\n<p>As time goes on, you may need to support other shape types. As the number\nof conditions you are testing grows, you&#39;ll find that using the <code>is</code> pattern\nmatching expressions can become cumbersome. In addition to requiring <code>if</code>\nstatements on each type you want to check, the <code>is</code> expressions are limited\nto testing if the input matches a single type. In this case, you&#39;ll find that the <code>switch</code> pattern\nmatching expressions becomes a better choice. </p>\n<p>The traditional <code>switch</code>\nstatement was a pattern expression: it supported the constant pattern.\nYou could compare a variable to any constant used in a <code>case</code> statement:</p>\n<pre><code class=\"lang-csharp\" name=\"ClassicSwitch\" title=\"Classic switch statement\">public static string GenerateMessage(params string[] parts)\n{\n    switch (parts.Length)\n    {\n        case 0:\n            return &quot;No elements to the input&quot;;\n        case 1:\n            return $&quot;One element: {parts[0]}&quot;;\n        case 2:\n            return $&quot;Two elements: {parts[0]}, {parts[1]}&quot;;\n        default:\n            return $&quot;Many elements. Too many to write&quot;;\n    }\n}\n</code></pre><p>The only pattern supported by the <code>switch</code> statement was the constant\npattern. It was further limited to numeric types and the <code>string</code> type.\nThose restrictions have been removed, and you can now write a <code>switch</code>\nstatement using the type pattern:</p>\n<pre><code class=\"lang-csharp\" name=\"Switch Type Pattern\" title=\"Compute with `switch` expression\">public static double ComputeAreaModernSwitch(object shape)\n{\n    switch (shape)\n    {\n        case Square s:\n            return s.Side * s.Side;\n        case Circle c:\n            return c.Radius * c.Radius * Math.PI;\n        case Rectangle r:\n            return r.Height * r.Length;\n        default:\n            throw new ArgumentException(\n                message: &quot;shape is not a recognized shape&quot;,\n                paramName: nameof(shape));\n    }\n}\n</code></pre><p>The pattern matching <code>switch</code> statement uses familiar syntax to developers\nwho have used the traditional C-style <code>switch</code> statement. Each <code>case</code> is evaluated\nand the code beneath the condition that matches the input variable is\nexecuted. Code execution cannot &quot;fall through&quot; from one case expression\nto the next; the syntax of the <code>case</code> statement requires that each <code>case</code>\nend with a <code>break</code>, <code>return</code>, or <code>goto</code>.</p>\n<div class=\"NOTE\"><h5>Note</h5><p>The <code>goto</code> statements to jump to another label are valid only\nfor the constant pattern, the classic switch statement.</p>\n</div>\n<p>There are important new rules governing the <code>switch</code> statement. The restrictions\non the type of the variable in the <code>switch</code> expression have been removed.\nAny type, such as <code>object</code> in this example, may be used. The case expressions\nare no longer limited to constant values. Removing that limitation means\nthat reordering <code>switch</code> sections may change a program&#39;s behavior.</p>\n<p>When limited to constant values, no more than one <code>case</code>\nlabel could match the value of the <code>switch</code> expression. Combine that with the \nrule that every <code>switch</code> section must not fall through to the next section, and \nit followed that the\n<code>switch</code> sections could be rearranged in any order without affecting behavior.\nNow, with more generalized <code>switch</code> expressions, the order of each section\nmatters. The <code>switch</code> expressions are evaluated in textual order. Execution\ntransfers to the first <code>switch</code> label that matches the <code>switch</code> expression.<br>Note that the <code>default</code> case will only be executed if no other\ncase labels match. The <code>default</code> case is evaluated last, regardless\nof its textual order. If there is no <code>default</code> case, and none of the\nother <code>case</code> statements match, execution continues at the statement\nfollowing the <code>switch</code> statement. None of the <code>case</code> labels code is\nexecuted.</p>\n<h2 id=\"when-clauses-in-case-expressions\"><code>when</code> clauses in <code>case</code> expressions</h2>\n<p>You can make special cases for those shapes that have 0 area by using\na <code>when</code> clause on the <code>case</code> label. A square with a side length of 0, or\na circle with a radius of 0 has a 0 area. You specify that condition\nusing a <code>when</code> clause on the <code>case</code> label:  </p>\n<pre><code class=\"lang-csharp\" name=\"ComputeDegenerateShapes\" title=\"Compute shapes with 0 area\">public static double ComputeArea_Version3(object shape)\n{\n    switch (shape)\n    {\n        case Square s when s.Side == 0:\n        case Circle c when c.Radius == 0:\n            return 0;\n\n        case Square s:\n            return s.Side * s.Side;\n        case Circle c:\n            return c.Radius * c.Radius * Math.PI;\n        default:\n            throw new ArgumentException(\n                message: &quot;shape is not a recognized shape&quot;,\n                paramName: nameof(shape));\n    }\n}\n</code></pre><p>This change demonstrates a few important points about the new syntax. First,\nmultiple <code>case</code> labels can be applied to one <code>switch</code> section. The statement\nblock is executed when any of those labels is <code>true</code>. In this instance,\nif the <code>switch</code> expression is either a circle or a square with 0 area, the\nmethod returns the constant 0.</p>\n<p>This example introduces two different variables in the two <code>case</code> labels\nfor the first <code>switch</code> block. Notice that the statements in this <code>switch</code> block\ndo not use either the variables <code>c</code> (for the circle) or <code>s</code> (for the square).\nNeither of those variables is definitely assigned in this <code>switch</code> block.\nIf either of these cases match, clearly one of the variables has been assigned.\nHowever, it is impossible to tell <em>which</em> has been assigned at compile-time,\nbecause either case could match at runtime. For that reason,\nmost times when you use multiple <code>case</code> labels for the same block, you won&#39;t\nintroduce a new variable in the <code>case</code> statement, or you will only use the\nvariable in the <code>when</code> clause.</p>\n<p>Having added those shapes with 0 area, let&#39;s add a couple more shape types:\na rectangle and a triangle:</p>\n<pre><code class=\"lang-csharp\" name=\"AddRectangleAndTriangle\" title=\"Add rectangle and triangle\">public static double ComputeArea_Version4(object shape)\n{\n    switch (shape)\n    {\n        case Square s when s.Side == 0:\n        case Circle c when c.Radius == 0:\n        case Triangle t when t.Base == 0 || t.Height == 0:\n        case Rectangle r when r.Length == 0 || r.Height == 0:\n            return 0;\n\n        case Square s:\n            return s.Side * s.Side;\n        case Circle c:\n            return c.Radius * c.Radius * Math.PI;\n        case Triangle t:\n            return t.Base * t.Height * 2;\n        case Rectangle r:\n            return r.Length * r.Height;\n        default:\n            throw new ArgumentException(\n                message: &quot;shape is not a recognized shape&quot;,\n                paramName: nameof(shape));\n    }\n}\n</code></pre><p> This set of changes adds <code>case</code> labels for the degenerate case, and labels\n and blocks for each of the new shapes. </p>\n<p>Finally, you can add a <code>null</code> case to ensure the argument is not <code>null</code>:</p>\n<pre><code class=\"lang-csharp\" name=\"NullCase\" title=\"Add null case\">public static double ComputeArea_Version5(object shape)\n{\n    switch (shape)\n    {\n        case Square s when s.Side == 0:\n        case Circle c when c.Radius == 0:\n        case Triangle t when t.Base == 0 || t.Height == 0:\n        case Rectangle r when r.Length == 0 || r.Height == 0:\n            return 0;\n\n        case Square s:\n            return s.Side * s.Side;\n        case Circle c:\n            return c.Radius * c.Radius * Math.PI;\n        case Triangle t:\n            return t.Base * t.Height * 2;\n        case Rectangle r:\n            return r.Length * r.Height;\n        case null:\n            throw new ArgumentNullException(paramName: nameof(shape), message: &quot;Shape must not be null&quot;);\n        default:\n            throw new ArgumentException(\n                message: &quot;shape is not a recognized shape&quot;,\n                paramName: nameof(shape));\n    }\n}\n</code></pre><p>The special case for the <code>null</code> pattern is interesting because the constant <code>null</code> does\nnot have a type, but can be converted to any reference type or nullable\ntype. </p>\n<h2 id=\"conclusions\">Conclusions</h2>\n<p><em>Pattern Matching constructs</em> enable you to easily manage control flow\namong different variables and types that are not related by an inheritance\nhierarchy. You can also control logic to use any condition you test on\nthe variable. It enables patterns and idioms that you&#39;ll need more often\nas you build more distributed applications, where data and the methods that\nmanipulate that data are separate. You&#39;ll notice that the shape structs\nused in this sample do not contain any methods, just read-only properties.\nPattern Matching works with any data type. You write expressions that examine\nthe object, and make control flow decisions based on those conditions.</p>\n<p>Compare the code from this sample with the design that would follow from\ncreating a class hierarchy for an abstract <code>Shape</code> and specific derived\nshapes each with their own implementation of a virtual method to calculate\nthe area. You&#39;ll often find that pattern matching expressions can be a very\nuseful tool when you are working with data and want to separate the data\nstorage concerns from the behavior concerns.</p>\n</div></div>","outputRootRelativePath":"../../","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-all/api/toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"1e575c32-2e2b-4425-9dca-7d118f3ed15b\">\r\n<meta name=\"description\" content=\"Learn about pattern matching expressions in C#\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core, C#\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"01/24/2017\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/d970e86efce5ecd437532909b337539222df6f5f/docs/csharp/pattern-matching.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/pattern-matching.md\">\r\n<meta name=\"document_id\" content=\"59c29524-e6a6-58c7-4ceb-cb1f009b853f\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../toc2.json\">\r\n","rawMetadata":{"author":"dotnet-bot","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Pattern Matching | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"1e575c32-2e2b-4425-9dca-7d118f3ed15b","description":"Learn about pattern matching expressions in C#","keywords":".NET, .NET Core, C#","ms.topic":"article","ms.date":"01/24/2017","ms.technology":"devlang-csharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update pattern matching to fix a couple small issues (#1612)","commit_sha":"d970e86efce5ecd437532909b337539222df6f5f","commit_date":"2017-03-06 15:45:58 -0500"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Csharp pattern matching (#1315)","commit_sha":"9b1bca18ed998fc6615b2f721951791bc44af9d2","commit_date":"2017-02-14 10:33:51 -0500"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"New in csharp7 (#1188)","commit_sha":"1442cbafa04d57e7eb864c0697afef01413db168","commit_date":"2016-11-13 15:54:48 -0500"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"renamed repo/fixed headings (#1186)","commit_sha":"15c55a87beb64f265a164db918c7721c7690fadf","commit_date":"2016-10-29 15:23:17 -0400"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Create outlines for csharp 7 (#1115)","commit_sha":"ada1b8f1252962556e42f180046b9b019307622c","commit_date":"2016-10-06 21:10:34 -0400"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/dotnet-bot","display_name":"dotnet bot","id":"9011267"},"contributors":[{"profile_url":"https://github.com/dotnet-bot","display_name":"dotnet bot"},{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/d970e86efce5ecd437532909b337539222df6f5f/docs/csharp/pattern-matching.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/pattern-matching.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/pattern-matching.md","document_id":"59c29524-e6a6-58c7-4ceb-cb1f009b853f","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/pattern-matching","toc_asset_id":"articles/toc.json","toc_rel":"../toc.json","_op_ogTitle":"Pattern Matching","_op_displayDate":"2017-1-24","_op_displayDate_source":"2017-01-24T00:00:00Z","_op_wordCount":2272,"_op_rawTitle":"<h1 id=\"pattern-matching\" sourcefile=\"docs/csharp/pattern-matching.md\" sourcestartlinenumber=\"14\" sourceendlinenumber=\"14\">Pattern Matching</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/pattern-matching","fileRelativePath":"articles/csharp/pattern-matching.html"},"themesRelativePathToOutputRoot":"_themes/"}