{"content":"<div><div class=\"content\">\n<p><a href=\"expression-trees-building\" data-linktype=\"relative-path\">Previous -- Building Expressions</a></p>\n<p>In this final section, you&#39;ll learn how to visit each node\nin an expression tree, while building a modified copy of that\nexpression tree. These are the techniques that you will use in two\nimportant scenarios. The first is to understand the algorithms\nexpressed by an expression tree so that it can be translated\ninto another environment. The second is when you want to change\nthe algorithm that has been created. This might be to add logging,\nintercept method calls and track them, or other purposes.</p>\n<h2 id=\"translating-is-visiting\">Translating is Visiting</h2>\n<p>The code you build to translate an expression tree is an extension\nof what you&#39;ve already seen to visit all the nodes in a tree. When\nyou translate an expression tree, you visit all the nodes, and while\nvisiting them, build the new tree. The new tree may contain references\nto the original nodes, or new nodes that you have placed in the tree.</p>\n<p>Let&#39;s see this in action by visiting an expression tree, and\ncreating a new tree with some replacement nodes. In this example,\nlet&#39;s replace any constant with a constant that is ten times larger.\nOtherwise, we&#39;ll leave the expression tree intact. Rather than\nreading the value of the constant, and replacing it with a new\nconstant, we&#39;ll make this replacement by replacing the constant\nnode with a new node that performs the multiplication.</p>\n<p>Here, once you find a constant node, you create a new multiplication\nnode whose children are the original constant, and the constant\n<code>10</code>:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">private static Expression ReplaceNodes(Expression original)\n{\n    if (original.NodeType == ExpressionType.Constant)\n    {\n        return Expression.Multiply(original, Expression.Constant(10));\n    }\n    else if (original.NodeType == ExpressionType.Add)\n    {\n        var binaryExpression = (BinaryExpression)original;\n        return Expression.Add(\n            ReplaceNodes(binaryExpression.Left),\n            ReplaceNodes(binaryExpression.Right));\n    }\n    return original;\n}\n</code></pre><p>By replacing the original node with the substitute, a new tree\nis formed that contains our modifications. We can verify that by\ncompiling and executing the replaced tree.</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var one = Expression.Constant(1, typeof(int));\nvar two = Expression.Constant(2, typeof(int));\nvar addition = Expression.Add(one, two);\nvar sum = ReplaceNodes(addition);\nvar executableFunc = Expression.Lambda(sum);\n\nvar func = (Func&lt;int&gt;)executableFunc.Compile();\nvar answer = func();\nConsole.WriteLine(answer);\n</code></pre><p>Building a new tree is a combination of visiting the nodes in\nthe existing tree, and creating new nodes and inserting them\ninto the tree.</p>\n<p>This example shows the importance of expression trees being\nimmutable. Notice that the new tree created above contains a\nmixture of newly created nodes, and nodes from the existing\ntree. That&#39;s safe, because the nodes in the existing tree cannot be\nmodified. This can result in significant memory efficiencies.\nThe same nodes can be used throughout a tree, or in multiple\nexpression trees. Since nodes can&#39;t be modified, the\nsame node can be reused whenever its needed.</p>\n<h2 id=\"traversing-and-executing-an-addition\">Traversing and Executing an Addition</h2>\n<p>Let&#39;s verify this by building a second visitor that walks the tree\nof addition nodes and computes the result. You can do this by\nmaking a couple modifications to the vistor that you&#39;ve seen so\nfar. In this new version, the visitor will return the partial sum\nof the addition operation up to this point. For a constant expression,\nthat is simply the value of the constant expression. For an addition\nexpression, the result is the sum of the left and right operands, once\nthose trees have been traversed.</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var one = Expression.Constant(1, typeof(int));\nvar two = Expression.Constant(2, typeof(int));\nvar three= Expression.Constant(3, typeof(int));\nvar four = Expression.Constant(4, typeof(int));\nvar addition = Expression.Add(one, two);\nvar add2 = Expression.Add(three, four);\nvar sum = Expression.Add(addition, add2);\n\n// Declare the delegate, so we can call it \n// from itself recursively:\nFunc&lt;Expression, int&gt; aggregate = null;\n// Aggregate, return constants, or the sum of the left and right operand.\n// Major simplification: Assume every binary expression is an addition.\naggregate = (exp) =&gt;\n    exp.NodeType == ExpressionType.Constant ?\n    (int)((ConstantExpression)exp).Value :\n    aggregate(((BinaryExpression)exp).Left) + aggregate(((BinaryExpression)exp).Right);\n\nvar theSum = aggregate(sum);\nConsole.WriteLine(theSum);\n</code></pre><p>There&#39;s quite a bit of code here, but the concepts are very approachable.\nThis code visits children in a depth first search. When it encounters a\nconstant node, the visitor returns the value of the constant. After the\nvisitor has visited both children, those children will have computed the sum\ncomputed for that sub-tree. The addition node can now compute its sum.\nOnce all the nodes in the expression tree have been visited, the sum\nwill have been computed. You can trace the execution by running the sample\nin the debugger and tracing the execution.</p>\n<p>Let&#39;s make it easier to trace how the nodes are analyzed and how the sum\nis computed by travsersing the tree. Here&#39;s an updated version of the\nAggregate method that includes quite a bit of tracing information:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">private static int Aggregate(Expression exp)\n{\n    if (exp.NodeType == ExpressionType.Constant)\n    {\n        var constantExp = (ConstantExpression)exp;\n        Console.Error.WriteLine($&quot;Found Constant: {constantExp.Value}&quot;);\n        return (int)constantExp.Value;\n    }\n    else if (exp.NodeType == ExpressionType.Add)\n    {\n        var addExp = (BinaryExpression)exp;\n        Console.Error.WriteLine(&quot;Found Addition Expression&quot;);\n        Console.Error.WriteLine(&quot;Computing Left node&quot;);\n        var leftOperand = Aggregate(addExp.Left);\n        Console.Error.WriteLine($&quot;Left is: {leftOperand}&quot;);\n        Console.Error.WriteLine(&quot;Computing Right node&quot;);\n        var rightOperand = Aggregate(addExp.Right);\n        Console.Error.WriteLine($&quot;Right is: {rightOperand}&quot;);\n        var sum = leftOperand + rightOperand;\n        Console.Error.WriteLine($&quot;Computed sum: {sum}&quot;);\n        return sum;\n    }\n    else throw new NotSupportedException(&quot;Haven&#39;t written this yet&quot;);\n}\n</code></pre><p>Running it on the same expression yields the following output:</p>\n<pre class=\"loading\"><code>10\nFound Addition Expression\nComputing Left node\nFound Addition Expression\nComputing Left node\nFound Constant: 1\nLeft is: 1\nComputing Right node\nFound Constant: 2\nRight is: 2\nComputed sum: 3\nLeft is: 3\nComputing Right node\nFound Addition Expression\nComputing Left node\nFound Constant: 3\nLeft is: 3\nComputing Right node\nFound Constant: 4\nRight is: 4\nComputed sum: 7\nRight is: 7\nComputed sum: 10\n10\n</code></pre><p>Trace the output and follow along in the code above. You should be able\nto work out how the code visits each node and computes the sum as it goes\nthrough the tree and finds the sum.</p>\n<p>Now, let&#39;s look at a different run, with the expression given by <code>sum1</code>:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">Expression&lt;Func&lt;int&gt; sum1 = () =&gt; 1 + (2 + (3 + 4));\n</code></pre><p>Here&#39;s the output from examining this expression:</p>\n<pre class=\"loading\"><code>Found Addition Expression\nComputing Left node\nFound Constant: 1\nLeft is: 1\nComputing Right node\nFound Addition Expression\nComputing Left node\nFound Constant: 2\nLeft is: 2\nComputing Right node\nFound Addition Expression\nComputing Left node\nFound Constant: 3\nLeft is: 3\nComputing Right node\nFound Constant: 4\nRight is: 4\nComputed sum: 7\nRight is: 7\nComputed sum: 9\nRight is: 9\nComputed sum: 10\n10\n</code></pre><p>While the final answer is the same, the tree traversal is completely\ndifferent. The nodes are traveled in a different order, because the\ntree was constructed with different operations occurring first.</p>\n<h2 id=\"learning-more\">Learning More</h2>\n<p>This sample shows a small subset of the code you would build to traverse\nand interpret the algorithms represented by an expression tree. For a complete\ndiscussion of all the work necessary to build a general purpose library that\ntranslates expression trees into another language, please read\n<a href=\"http://blogs.msdn.com/b/mattwar/archive/2008/11/18/linq-links.aspx\" data-linktype=\"external\">this series</a>\nby Matt Warren. It goes into great detail on how to translate any of the code\nyou might find in an expression tree.</p>\n<p>I hope you&#39;ve now seen the true power of expression trees.\nYou can examine a set of code, make any changes you&#39;d like to\nthat code, and execute the changed version. Because the\nexpression trees are immutable, you can create new trees by\nusing the components of existing trees. This minimizes the\namount of memory needed to create modified expression trees.</p>\n<p><a href=\"expression-trees-summary\" data-linktype=\"relative-path\">Next -- Summing up</a></p>\n</div></div>","outputRootRelativePath":"../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"b453c591-acc6-4e08-8175-97e5bc65958e\">\r\n<meta name=\"description\" content=\"Translating Expression Trees\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"06/20/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/expression-trees-translating.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/expression-trees-translating.md\">\r\n<meta name=\"document_id\" content=\"728d3f46-40f3-ced2-7045-154c8c7f8c2e\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Translating Expression Trees | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"b453c591-acc6-4e08-8175-97e5bc65958e","description":"Translating Expression Trees","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"06/20/2016","ms.technology":"devlang-csharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"Rich Lander","comitter_email":"rlander@microsoft.com","message":"Promote csharp from languages (#644)","commit_sha":"2d44b7e04c0fe2ca136ba6dfa9fc3a4368365ec8","commit_date":"2016-06-26 08:30:56 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/expression-trees-translating.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/expression-trees-translating.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/expression-trees-translating.md","document_id":"728d3f46-40f3-ced2-7045-154c8c7f8c2e","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/expression-trees-translating","toc_asset_id":"articles/toc.json","toc_rel":"../toc.json","_op_ogTitle":"Translating Expression Trees","_op_displayDate":"2016-6-20","_op_displayDate_source":"2016-06-20T00:00:00Z","_op_wordCount":1222,"_op_rawTitle":"<h1 id=\"translating-expression-trees\" sourcefile=\"docs/csharp/expression-trees-translating.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Translating Expression Trees</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/expression-trees-translating","fileRelativePath":"articles/csharp/expression-trees-translating.html"},"themesRelativePathToOutputRoot":"_themes/"}