{"content":"<div><div class=\"content\">\n<p><a href=\"expression-trees-execution\" data-linktype=\"relative-path\">Previous -- Executing Expressions</a></p>\n<p>Now, let&#39;s write some code to examine the structure of an \n<em>expression tree</em>. Every node in an expression tree will be\nan object of a class that is derived from <code>Expression</code>.</p>\n<p>That design makes visiting all the nodes in an expression tree\na relatively straight forward recursive operation. The general strategy\nis to start at the root node and determine what kind of node it is.</p>\n<p>If the node type has children, recursively visit the children. At each\nchild node, repeat the process used at the root node: determine the\ntype, and if the type has children, visit each of the children.</p>\n<h2 id=\"examining-an-expression-with-no-children\">Examining an Expression with No Children</h2>\n<p>Let&#39;s start by visiting each node in a very simple expression tree.\nHere&#39;s the code that creates a constant expression and then\nexamines its properties:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var constant = Expression.Constant(24, typeof(int));\n\nConsole.WriteLine($&quot;This is a/an {constant.NodeType} expression type&quot;);\nConsole.WriteLine($&quot;The type of the constant value is {constant.Type}&quot;);\nConsole.WriteLine($&quot;The value of the constant value is {constant.Value}&quot;);\n</code></pre><p>This will print the following:</p>\n<pre class=\"loading\"><code>This is an Constant expression type\nThe type of the constant value is System.Int32\nThe value of the constant value is 24\n</code></pre><p>Now, let&#39;s write the code that would examine this expression and write\nout some important properties about it. Here&#39;s that code:</p>\n<h2 id=\"examining-a-simple-addition-expression\">Examining a simple Addition Expression</h2>\n<p>Let&#39;s start with the addition sample from the\nintroduction to this section.</p>\n<pre class=\"loading\"><code class=\"lang-cs\">Expression&lt;Func&lt;int&gt;&gt; sum = () =&gt; 1 + 2;\n</code></pre><blockquote><p>I&#39;m not using <code>var</code> to declare this expression tree, as it is not possible\nbecause the right-hand side of the assignment is implicitly typed. To understand\nthis more deeply, read <a href=\"implicitly-typed-lambda-expressions\" data-linktype=\"relative-path\">here</a>.</p>\n</blockquote>\n<p>The root node is a <code>LambdaExpression</code>. In order to get the interesting\ncode on the right hand side of the <code>=&gt;</code> operator, you need to find one\nof the children of the <code>LambdaExpression</code>. We&#39;ll do that with all the\nexpressions in this section. The parent node does help us find the return\ntype of the <code>LambdaExpression</code>.</p>\n<p>To examine each node in this expression, we&#39;ll need to recursively\nvisit a number of nodes. Here&#39;s a simple first implementation:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">Expression&lt;Func&lt;int, int, int&gt;&gt; addition = (a, b) =&gt; a + b;\n\nConsole.WriteLine($&quot;This expression is a {addition.NodeType} expression type&quot;);\nConsole.WriteLine($&quot;The name of the lambda is {((addition.Name == null) ? &quot;&lt;null&gt;&quot; : addition.Name)}&quot;);\nConsole.WriteLine($&quot;The return type is {addition.ReturnType.ToString()}&quot;);\nConsole.WriteLine($&quot;The expression has {addition.Parameters.Count} arguments. They are:&quot;);\nforeach(var argumentExpression in addition.Parameters)\n{\n    Console.WriteLine($&quot;\\tParameter Type: {argumentExpression.Type.ToString()}, Name: {argumentExpression.Name}&quot;);\n}\n\nvar additionBody = (BinaryExpression)addition.Body;\nConsole.WriteLine($&quot;The body is a {additionBody.NodeType} expression&quot;);\nConsole.WriteLine($&quot;The left side is a {additionBody.Left.NodeType} expression&quot;);\nvar left = (ParameterExpression)additionBody.Left;\nConsole.WriteLine($&quot;\\tParameter Type: {left.Type.ToString()}, Name: {left.Name}&quot;);\nConsole.WriteLine($&quot;The right side is a {additionBody.Right.NodeType} expression&quot;);\nvar right= (ParameterExpression)additionBody.Right;\nConsole.WriteLine($&quot;\\tParameter Type: {right.Type.ToString()}, Name: {right.Name}&quot;);\n</code></pre><p>This sample prints the following output:</p>\n<pre class=\"loading\"><code>This expression is a/an Lambda expression type\nThe name of the lambda is &lt;null&gt;\nThe return type is System.Int32\nThe expression has 2 arguments. They are:\n        Parameter Type: System.Int32, Name: a\n        Parameter Type: System.Int32, Name: b\nThe body is a/an Add expression\nThe left side is a Parameter expression\n        Parameter Type: System.Int32, Name: a\nThe right side is a Parameter expression\n        Parameter Type: System.Int32, Name: b\n</code></pre><p>You&#39;ll notice a lot of repetition in the code sample above.\nLet&#39;s clean that up and build a more general purpose expression\nnode visitor. That&#39;s going to require us to write a recursive\nalgorithm. Any node could be of a type that might have children.\nAny node that has children requires us to visit those children\nand determine what that node is. Here&#39;s the cleaned up version\nthat utilizes recursion to visit the addition operations:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">// Base Visitor class:\npublic abstract class Visitor\n{\n    private readonly Expression node;\n\n    protected Visitor(Expression node)\n    {\n        this.node = node;\n    }\n\n    public abstract void Visit(string prefix);\n\n    public ExpressionType NodeType =&gt; this.node.NodeType;\n    public static Visitor CreateFromExpression(Expression node)\n    {\n        switch(node.NodeType)\n        {\n            case ExpressionType.Constant:\n                return new ConstantVisitor((ConstantExpression)node);\n            case ExpressionType.Lambda:\n                return new LambdaVisitor((LambdaExpression)node);\n            case ExpressionType.Parameter:\n                return new ParameterVisitor((ParameterExpression)node);\n            case ExpressionType.Add:\n                return new BinaryVisitor((BinaryExpression)node);\n            default:\n                Console.Error.WriteLine($&quot;Node not processed yet: {node.NodeType}&quot;);\n                return default(Visitor);\n        }\n    }\n}\n\n// Lambda Visitor\npublic class LambdaVisitor : Visitor\n{\n    private readonly LambdaExpression node;\n    public LambdaVisitor(LambdaExpression node) : base(node)\n    {\n        this.node = node;\n    }\n\n    public override void Visit(string prefix)\n    {\n        Console.WriteLine($&quot;{prefix}This expression is a {NodeType} expression type&quot;);\n        Console.WriteLine($&quot;{prefix}The name of the lambda is {((node.Name == null) ? &quot;&lt;null&gt;&quot; : node.Name)}&quot;);\n        Console.WriteLine($&quot;{prefix}The return type is {node.ReturnType.ToString()}&quot;);\n        Console.WriteLine($&quot;{prefix}The expression has {node.Parameters.Count} argument(s). They are:&quot;);\n        // Visit each parameter:\n        foreach (var argumentExpression in node.Parameters)\n        {\n            var argumentVisitor = Visitor.CreateFromExpression(argumentExpression);\n            argumentVisitor.Visit(prefix + &quot;\\t&quot;);\n        }\n        Console.WriteLine($&quot;{prefix}The expression body is:&quot;);\n        // Visit the body:\n        var bodyVisitor = Visitor.CreateFromExpression(node.Body);\n        bodyVisitor.Visit(prefix + &quot;\\t&quot;);\n    }\n}\n\n// Binary Expression Visitor:\npublic class BinaryVisitor : Visitor\n{\n    private readonly BinaryExpression node;\n    public BinaryVisitor(BinaryExpression node) : base(node)\n    {\n        this.node = node;\n    }\n\n    public override void Visit(string prefix)\n    {\n        Console.WriteLine($&quot;{prefix}This binary expression is a {NodeType} expression&quot;);\n        var left = Visitor.CreateFromExpression(node.Left);\n        Console.WriteLine($&quot;{prefix}The Left argument is:&quot;);\n        left.Visit(prefix + &quot;\\t&quot;);\n        var right = Visitor.CreateFromExpression(node.Right);\n        Console.WriteLine($&quot;{prefix}The Right argument is:&quot;);\n        right.Visit(prefix + &quot;\\t&quot;);\n    }\n}\n\n// Parameter visitor:\npublic class ParameterVisitor : Visitor\n{\n    private readonly ParameterExpression node;\n    public ParameterVisitor(ParameterExpression node) : base(node)\n    {\n        this.node = node;\n    }\n\n    public override void Visit(string prefix)\n    {\n        Console.WriteLine($&quot;{prefix}This is an {NodeType} expression type&quot;);\n        Console.WriteLine($&quot;{prefix}Type: {node.Type.ToString()}, Name: {node.Name}, ByRef: {node.IsByRef}&quot;);\n    }\n}\n</code></pre><p>This algorithm is the basis of an algorithm that can visit\nany arbitrary <code>LambdaExpression</code>. There are a lot of holes,\nnamely that the code I created only looks for a very small\nsample of the possible sets of expression tree nodes that\nit may encounter. However, you can still learn quite a bit\nfrom what it produces. (The default case in the <code>Visitor.CreateFromExpression</code>\nmethod prints a message to the error console when a new node type\nis encountered. That way, you know to add a new expression type.)</p>\n<p>When you run this visitor on the addition expression shown above, you get the\nfollowing output:</p>\n<pre class=\"loading\"><code>This expression is a/an Lambda expression type\nThe name of the lambda is &lt;null&gt;\nThe return type is System.Int32\nThe expression has 2 argument(s). They are:\n        This is an Parameter expression type\n        Type: System.Int32, Name: a, ByRef: False\n        This is an Parameter expression type\n        Type: System.Int32, Name: b, ByRef: False\nThe expression body is:\n        This binary expression is a Add expression\n        The Left argument is:\n                This is an Parameter expression type\n                Type: System.Int32, Name: a, ByRef: False\n        The Right argument is:\n                This is an Parameter expression type\n                Type: System.Int32, Name: b, ByRef: False\n</code></pre><p>Now that you&#39;ve built a more general visitor implementation, you\ncan visit and process many more different types of expressions.</p>\n<h2 id=\"examining-an-addition-expression-with-many-levels\">Examining an Addition Expression with Many Levels</h2>\n<p>Let&#39;s try a more complicated example,\nyet still limit the node types to addition only:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">Expression&lt;Func&lt;int&gt;&gt; sum = () =&gt; 1 + 2 + 3 + 4;\n</code></pre><p>Before you run this on the visitor algorithm, try a thought\nexercise to work out what the output might be. Remember that\nthe <code>+</code> operator is a <em>binary operator</em>: it must have two\nchildren, representing the left and right operands. There\nare several possible ways to construct a tree that \ncould be correct:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">Expression&lt;Func&lt;int&gt;&gt; sum1 = () =&gt; 1 + (2 + (3 + 4));\nExpression&lt;Func&lt;int&gt;&gt; sum2 = () =&gt; ((1 + 2) + 3) + 4;\n\nExpression&lt;Func&lt;int&gt;&gt; sum3 = () =&gt; (1 + 2) + (3 + 4);\nExpression&lt;Func&lt;int&gt;&gt; sum4 = () =&gt; 1 + ((2 + 3) + 4);\nExpression&lt;Func&lt;int&gt;&gt; sum5 = () =&gt; (1 + (2 + 3)) + 4;\n</code></pre><p>You can see the separation into two possible answers to highlight the\nmost promising. The first represents <em>right associative</em>\nexpressions. The second represent <em>left associative</em> expressions.\nThe advantage of both of those two formats is that the format scales\nto any arbitrary number of addition expressions. </p>\n<p>If you do run this expression through the visitor, you will see this\nthis output, verifying that the simple addition expression is\n<em>left associative</em>. </p>\n<p>In order to run this sample, and see the full expression tree, I had to\nmake one change to the source expression tree. When the expression tree\ncontains all constants, the resulting tree simply contains the constant\nvalue of <code>10</code>. The compiler performs all the addition and reduces the\nexpression to its simplest form. Simply adding one variable in the expression\nis sufficient to see the original tree:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">Expression&lt;Func&lt;int, int&gt;&gt; sum = (a) =&gt; 1 + a + 3 + 4;\n</code></pre><p>Create a visitor for this sum and run the visitor you&#39;ll see this output:</p>\n<pre class=\"loading\"><code>This expression is a/an Lambda expression type\nThe name of the lambda is &lt;null&gt;\nThe return type is System.Int32\nThe expression has 1 argument(s). They are:\n        This is an Parameter expression type\n        Type: System.Int32, Name: a, ByRef: False\nThe expression body is:\n        This binary expression is a Add expression\n        The Left argument is:\n                This binary expression is a Add expression\n                The Left argument is:\n                        This binary expression is a Add expression\n                        The Left argument is:\n                                This is an Constant expression type\n                                The type of the constant value is System.Int32\n                                The value of the constant value is 1\n                        The Right argument is:\n                                This is an Parameter expression type\n                                Type: System.Int32, Name: a, ByRef: False\n                The Right argument is:\n                        This is an Constant expression type\n                        The type of the constant value is System.Int32\n                        The value of the constant value is 3\n        The Right argument is:\n                This is an Constant expression type\n                The type of the constant value is System.Int32\n                The value of the constant value is 4\n</code></pre><p>You can also run any of the other samples through the visitor code\nand see what tree it represents. Here&#39;s an example of the <code>sum3</code>\nexpression above (with an additional parameter to prevent the compiler from\ncomputing the constant):</p>\n<pre class=\"loading\"><code class=\"lang-cs\">Expression&lt;Func&lt;int, int, int&gt;&gt; sum3 = (a, b) =&gt; (1 + a) + (3 + b);\n</code></pre><p>Here&#39;s the output from the visitor:</p>\n<pre class=\"loading\"><code>This expression is a/an Lambda expression type\nThe name of the lambda is &lt;null&gt;\nThe return type is System.Int32\nThe expression has 2 argument(s). They are:\n        This is an Parameter expression type\n        Type: System.Int32, Name: a, ByRef: False\n        This is an Parameter expression type\n        Type: System.Int32, Name: b, ByRef: False\nThe expression body is:\n        This binary expression is a Add expression\n        The Left argument is:\n                This binary expression is a Add expression\n                The Left argument is:\n                        This is an Constant expression type\n                        The type of the constant value is System.Int32\n                        The value of the constant value is 1\n                The Right argument is:\n                        This is an Parameter expression type\n                        Type: System.Int32, Name: a, ByRef: False\n        The Right argument is:\n                This binary expression is a Add expression\n                The Left argument is:\n                        This is an Constant expression type\n                        The type of the constant value is System.Int32\n                        The value of the constant value is 3\n                The Right argument is:\n                        This is an Parameter expression type\n                        Type: System.Int32, Name: b, ByRef: False\n</code></pre><p>Notice that the parentheses are not part of the output. There are no\nnodes in the expression tree that represent the parentheses in the\ninput expression. The structure of the expression tree contains all the\ninformation necessary to communicate the precedence.</p>\n<h2 id=\"extending-from-this-sample\">Extending from this sample</h2>\n<p>The sample deals with only the most rudimentary expression trees. The code\nyou&#39;ve seen in this section only handles constant integers and the binary\n<code>+</code> operator. As a final sample, let&#39;s update the visitor to handle a more\ncomplicated expression. Let&#39;s make it work for this:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">Expression&lt;Func&lt;int, int&gt;&gt; factorial = (n) =&gt;\n    n == 0 ? \n    1 : \n    Enumerable.Range(1, n).Aggregate((product, factor) =&gt; product * factor);\n</code></pre><p>This code represents one possible implementation for the\nmathematical <em>factorial</em> function. The way I&#39;ve written this code highlights\ntwo limitiations of building expression trees by assigning lambda expressions\nto Expressions. First, statement lambdas are not allowed. That means I can&#39;t use\nloops, blocks, if / else statements, and other control structures common in C#. I&#39;m\nlimited to using expressions. Second, I can&#39;t recursively call the same expression.\nI could if it were already a delegate, but I can&#39;t call it in its expression tree \nform. In the section on <a href=\"expression-trees-building\" data-linktype=\"relative-path\">building expression trees</a>\nyou&#39;ll learn techniques to overcome these limitations.</p>\n<p>In this expression, you&#39;ll encounter nodes of all these types:</p>\n<ol>\n<li>Equal (binary expression)</li>\n<li>Multiply (binary expression)</li>\n<li>Conditional (the ? : expression)</li>\n<li>Method Call Expression (calling <code>Range()</code> and <code>Aggregate()</code>)</li>\n</ol>\n<p>One way to modify the visitor algorithm is to keep executing it, and write\nthe node type every time you reach your <code>default</code> clause. After a few\niterations, you&#39;ll have seen each of the potential nodes. Then, you have\nall you need. The result would be something like this:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public static Visitor CreateFromExpression(Expression node)\n{\n    switch(node.NodeType)\n    {\n        case ExpressionType.Constant:\n            return new ConstantVisitor((ConstantExpression)node);\n        case ExpressionType.Lambda:\n            return new LambdaVisitor((LambdaExpression)node);\n        case ExpressionType.Parameter:\n            return new ParameterVisitor((ParameterExpression)node);\n        case ExpressionType.Add:\n        case ExpressionType.Equal:\n        case ExpressionType.Multiply:\n            return new BinaryVisitor((BinaryExpression)node);\n        case ExpressionType.Conditional:\n            return new ConditionalVisitor((ConditionalExpression)node);\n        case ExpressionType.Call:\n            return new MethodCallVisitor((MethodCallExpression)node);\n        default:\n            Console.Error.WriteLine($&quot;Node not processed yet: {node.NodeType}&quot;);\n            return default(Visitor);\n    }\n}\n</code></pre><p>The ConditionalVisitor and MethodCallVisitor process those two nodes:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public class ConditionalVisitor : Visitor\n{\n    private readonly ConditionalExpression node;\n    public ConditionalVisitor(ConditionalExpression node) : base(node)\n    {\n        this.node = node;\n    }\n\n    public override void Visit(string prefix)\n    {\n        Console.WriteLine($&quot;{prefix}This expression is a {NodeType} expression&quot;);\n        var testVisitor = Visitor.CreateFromExpression(node.Test);\n        Console.WriteLine($&quot;{prefix}The Test for this expression is:&quot;);\n        testVisitor.Visit(prefix + &quot;\\t&quot;);\n        var trueVisitor = Visitor.CreateFromExpression(node.IfTrue);\n        Console.WriteLine($&quot;{prefix}The True clause for this expression is:&quot;);\n        trueVisitor.Visit(prefix + &quot;\\t&quot;);\n        var falseVisitor = Visitor.CreateFromExpression(node.IfFalse);\n        Console.WriteLine($&quot;{prefix}The False clause for this expression is:&quot;);\n        falseVisitor.Visit(prefix + &quot;\\t&quot;);\n    }\n}\n\npublic class MethodCallVisitor : Visitor\n{\n    private readonly MethodCallExpression node;\n    public MethodCallVisitor(MethodCallExpression node) : base(node)\n    {\n        this.node = node;\n    }\n\n    public override void Visit(string prefix)\n    {\n        Console.WriteLine($&quot;{prefix}This expression is a {NodeType} expression&quot;);\n        if (node.Object == null)\n            Console.WriteLine($&quot;{prefix}This is a static method call&quot;);\n        else\n        {\n            Console.WriteLine($&quot;{prefix}The receiver (this) is:&quot;);\n            var receiverVisitor = Visitor.CreateFromExpression(node.Object);\n            receiverVisitor.Visit(prefix + &quot;\\t&quot;);\n        }\n\n        var methodInfo = node.Method;\n        Console.WriteLine($&quot;{prefix}The method name is {methodInfo.DeclaringType}.{methodInfo.Name}&quot;);\n        // There is more here, like generic arguments, and so on.\n        Console.WriteLine($&quot;{prefix}The Arguments are:&quot;);\n        foreach(var arg in node.Arguments)\n        {\n            var argVisitor = Visitor.CreateFromExpression(arg);\n            argVisitor.Visit(prefix + &quot;\\t&quot;);\n        }\n    }\n}\n</code></pre><p>And the output for the expression tree would be:</p>\n<pre class=\"loading\"><code>This expression is a/an Lambda expression type\nThe name of the lambda is &lt;null&gt;\nThe return type is System.Int32\nThe expression has 1 argument(s). They are:\n        This is an Parameter expression type\n        Type: System.Int32, Name: n, ByRef: False\nThe expression body is:\n        This expression is a Conditional expression\n        The Test for this expression is:\n                This binary expression is a Equal expression\n                The Left argument is:\n                        This is an Parameter expression type\n                        Type: System.Int32, Name: n, ByRef: False\n                The Right argument is:\n                        This is an Constant expression type\n                        The type of the constant value is System.Int32\n                        The value of the constant value is 0\n        The True clause for this expression is:\n                This is an Constant expression type\n                The type of the constant value is System.Int32\n                The value of the constant value is 1\n        The False clause for this expression is:\n                This expression is a Call expression\n                This is a static method call\n                The method name is System.Linq.Enumerable.Aggregate\n                The Arguments are:\n                        This expression is a Call expression\n                        This is a static method call\n                        The method name is System.Linq.Enumerable.Range\n                        The Arguments are:\n                                This is an Constant expression type\n                                The type of the constant value is System.Int32\n                                The value of the constant value is 1\n                                This is an Parameter expression type\n                                Type: System.Int32, Name: n, ByRef: False\n                        This expression is a Lambda expression type\n                        The name of the lambda is &lt;null&gt;\n                        The return type is System.Int32\n                        The expression has 2 arguments. They are:\n                                This is an Parameter expression type\n                                Type: System.Int32, Name: product, ByRef: False\n                                This is an Parameter expression type\n                                Type: System.Int32, Name: factor, ByRef: False\n                        The expression body is:\n                                This binary expression is a Multiply expression\n                                The Left argument is:\n                                        This is an Parameter expression type\n                                        Type: System.Int32, Name: product, ByRef: False\n                                The Right argument is:\n                                        This is an Parameter expression type\n                                        Type: System.Int32, Name: factor, ByRef: False\n</code></pre><h2 id=\"extending-the-sample-library\">Extending the Sample Library</h2>\n<p>The samples in this section show the core techniques to visit and\nexamine nodes in an expression tree. I glossed over many actions\nyou might need in order to concentrate on the core tasks of\nvisiting and accessing nodes in an expression tree. </p>\n<p>First, the visitors only handle constants\nthat are integers. Constant values could be any other numeric type,\nand the C# language supports conversions and promotions between those\ntypes. A more robust version of this code would mirror all those\ncapabilities.</p>\n<p>Even the last example recognizes a subset of the possible node types.\nYou can still feed it many expressions that will cause it to fail.\nA full implementation is included in the .NET Standard Library\nunder the name <a href=\"https://docs.microsoft.com/dotnet/core/api/System.Linq.Expressions.ExpressionVisitor\" data-linktype=\"external\">ExpressionVisitor</a>\nand can handle all the possible node types.</p>\n<p>Finally, the library I used in this article was built for demonstration\nand learning. It&#39;s not optimized. I wrote it to make the structures\nused very clear, and to highlight the techniques used to visit\nthe nodes and analyze what&#39;s there. A production implementation would\npay more attention to performance than I have.</p>\n<p>Even with those limitations, you should be well on your way to writing\nalgorithms that read and understand expression trees.</p>\n<p><a href=\"expression-trees-building\" data-linktype=\"relative-path\">Next -- Building Expressions</a></p>\n</div></div>","outputRootRelativePath":"../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"adf73dde-1e52-4df3-9929-2e0670e28e16\">\r\n<meta name=\"description\" content=\"Interpreting Expressions\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"06/20/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/expression-trees-interpreting.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/expression-trees-interpreting.md\">\r\n<meta name=\"document_id\" content=\"44b332c4-c92c-49d8-4d60-16cf02bf8789\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Interpreting Expressions | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"adf73dde-1e52-4df3-9929-2e0670e28e16","description":"Interpreting Expressions","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"06/20/2016","ms.technology":"devlang-csharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Nemanja Đorđević","author_email":"neman@users.noreply.github.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"Spelling error (#1234)","commit_sha":"5b05fb277db5a0ddbeb2d7ef648d4e5c6519d800","commit_date":"2016-11-15 11:18:58 -0500"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"Rich Lander","comitter_email":"rlander@microsoft.com","message":"Promote csharp from languages (#644)","commit_sha":"2d44b7e04c0fe2ca136ba6dfa9fc3a4368365ec8","commit_date":"2016-06-26 08:30:56 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/neman","display_name":"Nemanja Đorđević","id":"350314"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/expression-trees-interpreting.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/expression-trees-interpreting.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/expression-trees-interpreting.md","document_id":"44b332c4-c92c-49d8-4d60-16cf02bf8789","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/expression-trees-interpreting","toc_asset_id":"articles/toc.json","toc_rel":"../toc.json","_op_ogTitle":"Interpreting Expressions","_op_displayDate":"2016-6-20","_op_displayDate_source":"2016-06-20T00:00:00Z","_op_wordCount":2794,"_op_rawTitle":"<h1 id=\"interpreting-expressions\" sourcefile=\"docs/csharp/expression-trees-interpreting.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Interpreting Expressions</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/expression-trees-interpreting","fileRelativePath":"articles/csharp/expression-trees-interpreting.html"},"themesRelativePathToOutputRoot":"_themes/"}