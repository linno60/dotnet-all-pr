{"content":"<div><div class=\"content\">\n<p>Almost every program you write will have some need to iterate\nover a collection. You&#39;ll write code that examines every item in\na collection. </p>\n<p>You&#39;ll also create iterator methods which are methods that produces an\niterator for the elements of that class. These can be used for:</p>\n<ul>\n<li>Performing an action on each item in a collection.</li>\n<li>Enumerating a custom collection.</li>\n<li>Extending <a href=\"linq/index\" data-linktype=\"relative-path\">LINQ</a> or other libraries.</li>\n<li>Creating a data pipeline where data flows efficiently through iterator\nmethods.</li>\n</ul>\n<p>The C# language provides\nfeatures for both these scenarios. This article provides an overview\nof those features.</p>\n<h2 id=\"iterating-with-foreach\">Iterating with foreach</h2>\n<p>Enumerating a collection is simple: The <code>foreach</code> keyword enumerates\na collection, executing the embedded statement once for each element\nin the collection:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">foreach (var item in collection)\n{\n   Console.WriteLine(item.ToString());\n}\n</code></pre><p>That&#39;s all there is to it. To iterate over all the contents of a collection,\nthe <code>foreach</code> statement is all you need. The <code>foreach</code> statement isn&#39;t magic,\nthough. It relies on two generic interfaces defined in the .NET core library in order\nto generate the code necessary to iterate a collection: <code>IEnumerable&lt;T&gt;</code> and\n<code>IEnumerator&lt;T&gt;</code>. This mechanism is explained in more detail below.</p>\n<p>Both of these interfaces also have non-generic counterparts: <code>IEnumerable</code> and \n<code>IEnumerator</code>. The <a href=\"programming-guide/generics/index\" data-linktype=\"relative-path\">generic</a> versions are preferred for modern code.</p>\n<h2 id=\"enumeration-sources-with-iterator-methods\">Enumeration sources with iterator methods</h2>\n<p>Another great feature of the C# language enables you to build methods that create\na source for an enumeration. These are referred to as <em>iterator methods</em>. An iterator\nmethod defines how to generate the objects in a sequence when requested. You\nuse the <code>yield return</code> contextual keywords to define an iterator method. </p>\n<p>You could write this method to produce the sequence of integers from 0 through 9:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public IEnumerable&lt;int&gt; GetSingleDigitNumbers()\n{\n    yield return 0;\n    yield return 1;\n    yield return 2;\n    yield return 3;\n    yield return 4;\n    yield return 5;\n    yield return 6;\n    yield return 7;\n    yield return 8;\n    yield return 9;\n}\n</code></pre><p>The code above shows distinct <code>yield return</code> statements to highlight the fact that\nyou can use multiple discrete <code>yield return</code> statements in an iterator method.\nYou can (and often do) use other language constructs to simplify the code of an\niterator method. The method definition below produces the exact same sequence\nof numbers:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public IEnumerable&lt;int&gt; GetSingleDigitNumbers()\n{\n    int index = 0;\n    while (index++ &lt; 10)\n        yield return index;\n}\n</code></pre><p>You don&#39;t have to decide one or the other. You can have as many <code>yield return</code>\nstatements as necessary to meet the needs of your method:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public IEnumerable&lt;int&gt; GetSingleDigitNumbers()\n{\n    int index = 0;\n    while (index++ &lt; 10)\n        yield return index;\n\n    yield return 50;\n\n    index = 100;\n    while (index++ &lt; 110)\n        yield return index;\n}\n</code></pre><p>That&#39;s the basic syntax. Let&#39;s consider a real world example where you would\nwrite an iterator method. Imagine you&#39;re on an IoT project and the device\nsensors generate a very large stream of data. To get a feel for the data, you\nmight write a method that samples every Nth data element. This small iterator\nmethod does the trick:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public static IEnumerable&lt;T&gt; Sample(this IEnumerable&lt;T&gt; sourceSequence, int interval)\n{\n    int index = 0;\n    foreach (T item in sourceSequence)\n    {\n        if (index++ % interval == 0)\n            yield return item;\n    }\n}\n</code></pre><p>There is one important restriction on iterator methods: you can&#39;t have both a\n<code>return</code> statement and a <code>yield return</code> statement in the same method. The following\nwill not compile:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public IEnumerable&lt;int&gt; GetSingleDigitNumbers()\n{\n    int index = 0;\n    while (index++ &lt; 10)\n        yield return index;\n\n    yield return 50;\n\n    // generates a compile time error: \n    var items = new int[] {100, 101, 102, 103, 104, 105, 106, 107, 108, 109 };\n    return items;  \n}\n</code></pre><p>This restriction normally isn&#39;t a problem. You have a choice of either using\n<code>yield return</code> throughout the method, or separating the original method into\nmultiple methods, some using <code>return</code>, and some using <code>yield return</code>.</p>\n<p>You can modify the last method slightly to use <code>yield return</code> everywhere:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public IEnumerable&lt;int&gt; GetSingleDigitNumbers()\n{\n    int index = 0;\n    while (index++ &lt; 10)\n        yield return index;\n\n    yield return 50;\n\n    var items = new int[] {100, 101, 102, 103, 104, 105, 106, 107, 108, 109 };\n    foreach (var item in items)\n        yield return item;\n}\n</code></pre><p>Sometimes, the right answer is to split an iterator method into two different\nmethods. One that uses <code>return</code>, and a second that uses <code>yield return</code>. Consider\na situation where you might want to return an empty collection, or the first 5\nodd numbers, based on a boolean argument. You could write that as these two\nmethods:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public IEnumerable&lt;int&gt; GetSingleDigitOddNumbers(bool getCollection)\n{\n    if (getCollection == false)\n        return new int[0];\n    else\n        return IteratorMethod();\n}\n\nprivate IEnumerable&lt;int&gt; IteratorMethod()\n{\n    int index = 0;\n    while (index++ &lt; 10)\n        if (index % 2 == 1)\n            yield return index;\n}\n</code></pre><p>Look at the methods above. The first uses the standard <code>return</code> statement to return\neither an empty collection, or the iterator created by the second method. The second\nmethod uses the <code>yield return</code> statement to create the requested sequence.</p>\n<h2 id=\"deeper-dive-into-foreach\">Deeper Dive into <code>foreach</code></h2>\n<p>The <code>foreach</code> statement expands into a standard idiom that uses the\n<code>IEnumable&lt;T&gt;</code> and <code>IEnumerator&lt;T&gt;</code> interfaces to iterate across all\nelements of a collection. It also  minimizes errors developers make\nby not properly managing resources. </p>\n<p>The compiler translates the <code>foreach</code> loop shown in the first\nexample into something similar to this construct:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">IEnumerator&lt;int&gt; enumerator = collection.GetEnumerator();\nwhile (enumerator.MoveNext())\n{\n    var item = enumerator.Current;\n    Console.WriteLine(item.ToString());\n}\n</code></pre><p>The construct above represents the code generated by the C# compiler as of\nversion 5 and above. Prior to version 5, the <code>item</code> variable had a different scope:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">// C# versions 1 through 4:\nIEnumerator&lt;int&gt; enumerator = collection.GetEnumerator();\nint item = default(int);\nwhile (enumerator.MoveNext())\n{\n    item = enumerator.Current;\n    Console.WriteLine(item.ToString());\n}\n</code></pre><p>This was changed because the earlier behavior could lead to subtle and hard\nto diagnose bugs involving lambda expressions. See the section on\n<a href=\"lambda-expressions\" data-linktype=\"relative-path\">lambda expressions</a> for more information. </p>\n<p>The exact code generated by the compiler is somewhat more complicated, and\nhandles situations where the object returned by <code>GetEnumerator()</code> implements\nthe <code>IDisposable</code> interface. The full expansion generates code more like this:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">{\n    var enumerator = collection.GetEnumerator();\n    try \n    {\n        while (enumerator.MoveNext())\n        {\n            var item = enumerator.Current;\n            Console.WriteLine(item.ToString());\n        }\n    } finally \n    {\n        // dispose of enumerator.\n    }\n}\n</code></pre><p>The manner in which the enumerator is disposed of depends on the characteristics of\nthe type of <code>enumerator</code>. In the general case, the <code>finally</code> clause expands to:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">finally \n{\n   (enumerator as IDisposable)?.Dispose();\n} \n</code></pre><p>However, if the type of <code>enumerator</code> is a sealed type and there is no implicit\nconversion from the type of <code>enumerator</code> to <code>IDisposable</code>, the <code>finally</code> clause\nexpands to an empty block:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">finally \n{\n} \n</code></pre><p>If there is an implicit conversion from the type of <code>enumerator</code> to <code>IDisposable</code>,\nand <code>enumerator</code> is a non-nullable value type, the <code>finally</code> clause expands to:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">finally \n{\n   ((IDisposable)enumerator).Dispose();\n} \n</code></pre><p>Thankfully, you don&#39;t need to remember all these details. The <code>foreach</code> statement\nhandles all those nuances for you. The compiler will generate the correct code for\nany of these constructs. </p>\n</div></div>","outputRootRelativePath":"../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"5cf36f45-f91a-4fca-a0b7-87f233e108e9\">\r\n<meta name=\"description\" content=\"Iterators\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"06/20/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/763433b00ae7d01cfa0c7fa250f51d23a95f6f15/docs/csharp/iterators.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/iterators.md\">\r\n<meta name=\"document_id\" content=\"810e23f6-faa1-cb7a-d463-f2ff341f4129\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Iterators | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"5cf36f45-f91a-4fca-a0b7-87f233e108e9","description":"Iterators","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"06/20/2016","ms.technology":"devlang-csharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Ron Petrusha","author_email":"ronpet@microsoft.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"Fixed broken links to LINQ topic (#1331)","commit_sha":"763433b00ae7d01cfa0c7fa250f51d23a95f6f15","commit_date":"2016-12-13 19:28:50 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"remove 'wrench' articles that have been ported (#1298)","commit_sha":"61844748621d9536134e3efcb4ac866c3e7bdc45","commit_date":"2016-12-02 08:23:44 -0500"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"Fixed typos and other small things (#883)","commit_sha":"bb15293c569fa92f1acf6315c5fe7f2cd9cb6f68","commit_date":"2016-08-08 21:27:46 -0400"},{"author_name":"Petr Onderka","author_email":"gsvick@gmail.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@users.noreply.github.com","message":"Corrected titles and headings (#690)","commit_sha":"17cac6e7690fd2b08d9f5f73060056d14bca13d2","commit_date":"2016-06-28 12:36:36 -0700"},{"author_name":"brady gaster","author_email":"bradyg@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"removed anchor","commit_sha":"6ecc37699dd53a4b867f766e09f5c5ef7af83026","commit_date":"2016-06-26 09:19:22 -0700"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"Rich Lander","comitter_email":"rlander@microsoft.com","message":"Promote csharp from languages (#644)","commit_sha":"2d44b7e04c0fe2ca136ba6dfa9fc3a4368365ec8","commit_date":"2016-06-26 08:30:56 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/rpetrusha","display_name":"rpetrusha","id":"10886961"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/svick","display_name":"Petr Onderka","id":"287848"},{"profile_url":"https://github.com/bradygaster","display_name":"brady gaster","id":"486363"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/763433b00ae7d01cfa0c7fa250f51d23a95f6f15/docs/csharp/iterators.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/iterators.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/iterators.md","document_id":"810e23f6-faa1-cb7a-d463-f2ff341f4129","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/iterators","toc_asset_id":"articles/toc.json","toc_rel":"../toc.json","_op_ogTitle":"Iterators","_op_displayDate":"2016-6-20","_op_displayDate_source":"2016-06-20T00:00:00Z","_op_wordCount":1150,"_op_rawTitle":"<h1 id=\"iterators\" sourcefile=\"docs/csharp/iterators.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Iterators</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/iterators","fileRelativePath":"articles/csharp/iterators.html"},"themesRelativePathToOutputRoot":"_themes/"}