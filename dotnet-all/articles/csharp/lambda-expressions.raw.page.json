{"content":"<div><div class=\"content\">\n<p>A <em>lambda expression</em> is a block of code (an expression or a statement block) that is treated as an object. It can be passed as an argument to methods, and it can also be returned by method calls. Lambda expressions are used extensively for:</p>\n<ul>\n<li><p>Passing the code that is to be executed to asynchronous methods, such as <a class=\"xref\" href=\"../../api/system.threading.tasks.task#System_Threading_Tasks_Task_Run_System_Action_\" data-linktype=\"relative-path\">Run(Action)</a>.</p>\n</li>\n<li><p>Writing <a href=\"linq/index\" data-linktype=\"relative-path\">LINQ query expressions</a>.</p>\n</li>\n<li><p>Creating <a href=\"expression-trees-building\" data-linktype=\"relative-path\">expression trees</a>.</p>\n</li>\n</ul>\n<p>Lambda expressions are code that can be represented either as a delegate, or as an expression tree that compiles to a delegate. The specific delegate type of a lambda expression depends on its parameters and return value. Lambda expressions that don&#39;t return a value correspond to a specific <code>Action</code> delegate, depending on its number of parameters. Lambda expressions that return a value correspond to a specific <code>Func</code> delegate, depending on its number of parameters. For example, a lambda expression that has two parameters but returns no value corresponds to an <a class=\"xref\" href=\"../../api/system.action-2\" data-linktype=\"relative-path\">Action&lt;T1,T2&gt;</a> delegate. A lambda expression that has one parameter and returns a value corresponds to <a class=\"xref\" href=\"../../api/system.func-2\" data-linktype=\"relative-path\">Func&lt;T,TResult&gt;</a> delegate.</p>\n<p>A lambda expression uses <code>=&gt;</code>, the <a href=\"language-reference/operators/lambda-operator\" data-linktype=\"relative-path\">lambda declaration operator</a>, to separate the lambda&#39;s parameter list from its executable code. To create a lambda expression, you specify input parameters (if any) on the left side of the lambda operator, and you put the expression or statement block on the other side. For example, the single-line lambda expression <code>x =&gt; x * x</code> specifies a parameter thatâ€™s named <code>x</code> and returns the value of <code>x</code> squared. You can assign this expression to a delegate type, as the following example shows:</p>\n<pre><code name=\"csSnippets.Lambdas\">using System;\n\nclass Example\n{\n   public static void Main()\n   {\n      Func&lt;int, int&gt; square = x =&gt; x * x; \n      Console.WriteLine(square(25));\n   }\n}\n// The example displays the following output:\n//      625\n</code></pre><p>Or you can pass it directly as a method argument:</p>\n<pre><code name=\"csSnippets.Lambdas\">using System;\n\ndelegate int del(int i);  \n\npublic class Example\n{\n   static void Main()  \n   {  \n      ShowValue(x =&gt; x * x);  \n   }  \n\n   private static void ShowValue(Func&lt;int,int&gt; op)\n   {\n      for (int ctr = 1; ctr &lt;= 5; ctr++)\n         Console.WriteLine(&quot;{0} x {0} = {1}&quot;,\n                           ctr,  op(ctr));\n   }\n}\n// The example displays the following output:\n//   1, 1 x 1 = 1\n//   2, 2 x 2 = 4\n//   3, 3 x 3 = 9\n//   4, 4 x 4 = 16\n//   5, 5 x 5 = 25\n</code></pre><h2 id=\"expression-lambdas\">Expression lambdas</h2>\n<p> A lambda expression with an expression on the right side of the =&gt; operator is called an <em>expression lambda</em>. Expression lambdas are used extensively in the construction of <a href=\"expression-trees\" data-linktype=\"relative-path\">expression trees</a>. An expression lambda returns the result of the expression and takes the following basic form:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">(input parameters) =&gt; expression\n</code></pre><p>The parentheses are optional only if the lambda has one input parameter; otherwise they are required. Specify zero input parameters with empty parentheses:</p>\n<pre><code name=\"csSnippets.Lambdas\">Action line = () =&gt; Console.WriteLine();\n</code></pre><p>Two or more input parameters are separated by commas enclosed in parentheses:</p>\n<pre><code name=\"csSnippets.Lambdas\">Func&lt;int,int,bool&gt; testEquality = (x, y) =&gt; x == y;  // test for equality\n</code></pre><p>Ordinarily, the compiler uses type inference in determining parameter types. However, sometimes it is difficult or impossible for the compiler to infer the input types. When this occurs, you can specify the types explicitly, as in the following example:</p>\n<pre><code name=\"csSnippets.Lambdas\">Func&lt;int, string, bool&gt; isTooLong = (int x, string s) =&gt; s.Length &gt; x;\n</code></pre><p>Note in the previous example that the body of an expression lambda can consist of a method call. However, if you are creating expression trees that are evaluated outside of the .NET Framework, such as in SQL Server or Entity Framework (EF), you should refrain from using method calls in lambda expressions, since the methods may  have no meaning outside the context of the .NET runtime. If you do choose to use method calls in this case, be sure to test them thoroughly to ensure that the method calls can be successfuly resolved.</p>\n<h2 id=\"statement-lambdas\">Statement lambdas</h2>\n<p>A statement lambda resembles an expression lambda except that the statement(s) is enclosed in braces:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">(input parameters) =&gt; { statement; }\n</code></pre><p>The body of a statement lambda can consist of any number of statements; however, in practice there are typically no more than two or three.</p>\n<pre><code name=\"csSnippets.Lambdas\">using System;\n\n\npublic class Example\n{\n    delegate void TestDelegate(string s);\n\n    public static void Main()\n    {\n       TestDelegate test = n =&gt; { string s = n + &quot; &quot; + &quot;World&quot;; Console.WriteLine(s); };  \n       test(&quot;Hello&quot;);\n    }\n}\n// The example displays the following output:\n//     Hello World\n</code></pre><p>Statement lambdas, like anonymous methods, cannot be used to create expression trees.</p>\n<h2 id=\"async-lambdas\">Async lambdas</h2>\n<p>You can easily create lambda expressions and statements that incorporate asynchronous processing by using the <a href=\"language-reference/keywords/async\" data-linktype=\"relative-path\">async</a> and <a href=\"language-reference/keywords/await\" data-linktype=\"relative-path\">await</a> keywords. For example, the example calls a <code>ShowSquares</code> method that executes asynchronously.</p>\n<pre><code name=\"csSnippets.Lambdas\">using System;\nusing System.Threading.Tasks;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Begin().Wait();\n   }\n\n   private static async Task Begin()\n   {\n      for (int ctr = 2; ctr &lt;= 5; ctr++) {\n         var result = await ShowSquares(ctr);\n         Console.WriteLine(&quot;{0} * {0} = {1}&quot;, ctr, result);\n      }\n   }\n\n   private static async Task&lt;int&gt;  ShowSquares(int number)\n   {\n         return await Task.Factory.StartNew( x =&gt; (int)x * (int)x, number);\n   } \n}\n</code></pre><p>For more information about how to create and use async methods, see <a href=\"programming-guide/concepts/async/index\" data-linktype=\"relative-path\">Asynchronous programming with async and await</a>.</p>\n<h2 id=\"lambda-expressions-and-tuples\">Lambda expressions and tuples</h2>\n<p>Starting with C# 7.0, the C# language provides built-in support for tuples. You can provide a tuple as an argument to a lambda expression, and your lambda expression can also return a tuple. In some cases, the C# compiler uses type inference to determine the types of tuple components. </p>\n<p>You define a tuple by enclosing a comma-delimited list of its components in parentheses. The following example uses tuple with 5 components to pass a sequence of numbers to a lambda expression, which doubles each value and returns a tuple with 5 components that contains the result of the multiplications.</p>\n<pre><code name=\"csSnippets.Lambdas\">using System;\n\npublic class Example\n{\n    public static void Main()\n    {\n        var numbers = (2, 3, 4, 5, 6);\n        Func&lt;(int, int, int, int, int), (int, int, int, int, int)&gt; doubleThem = (n) =&gt; (n.Item1 * 2, n.Item2 * 2, n.Item3 * 2, n.Item4 * 2, n.Item5 * 2);\n        var doubledNumbers = doubleThem(numbers);\n\n        Console.WriteLine(&quot;The set {0} doubled: {1}&quot;, numbers, doubledNumbers);\n        Console.ReadLine();\n    }\n}\n// The example displays the following output:\n//    The set (2, 3, 4, 5, 6) doubled: (4, 6, 8, 10, 12)\n</code></pre><p>Ordinarily, the fields of a tuple are named <code>Item1</code>, <code>Item2</code>, etc. You can, however, define a tuple with named components, as the following example does.</p>\n<pre><code name=\"csSnippets.Lambdas\">using System;\n\npublic class Example\n{\n    public static void Main()\n    {\n        var numbers = (2, 3, 4, 5, 6);\n        Func&lt;(int n1, int n2, int n3, int n4, int n5), (int, int, int, int, int)&gt; doubleThem = (n) =&gt; (n.n1 * 2, n2 * 2, n.n3 * 2, n.n4 * 2, n.n5 * 2);\n        var doubledNumbers = doubleThem(numbers);\n\n        Console.WriteLine(&quot;The set {0} doubled: {1}&quot;, numbers, doubledNumbers);\n        Console.ReadLine();\n    }\n}\n// The example displays the following output:\n//    The set (2, 3, 4, 5, 6) doubled: (4, 6, 8, 10, 12)\n</code></pre><p>For more information on support for tuples in C#, see <a href=\"tuples\" data-linktype=\"relative-path\">C# Tuple types</a>.</p>\n<h2 id=\"lambdas-with-the-standard-query-operators\">Lambdas with the standard query operators</h2>\n<p>LINQ to Objects, among other implementations, have an input parameter whose type is one of the <a class=\"xref\" href=\"../../api/system.func-1\" data-linktype=\"relative-path\">Func&lt;TResult&gt;</a> family of generic delegates. These delegates use type parameters to define the number and type of input parameters, and the return type of the delegate. <code>Func</code> delegates are very useful for encapsulating user-defined expressions that are applied to each element in a set of source data. For example, consider the <a class=\"xref\" href=\"../../api/system.func-1\" data-linktype=\"relative-path\">Func&lt;TResult&gt;</a> delegate, whose syntax is:</p>\n<pre><code name=\"csSnippets.Lambdas\">public delegate TResult Func&lt;TArg, TResult&gt;(TArg arg);\n</code></pre><p>The delegate can be instantiated with code like the following</p>\n<pre><code name=\"csSnippets.Lambdas\">Func&lt;int, bool&gt; func = (x) =&gt; x == 5; \n</code></pre><p>where <code>int</code> is an input parameter, and <code>bool</code> is the return value. The return value is always specified in the last type parameter. When the following <code>Func</code> delegate is invoked, it returns true or false to indicate whether the input parameter is equal to 5:</p>\n<pre><code name=\"csSnippets.Lambdas\">Console.WriteLine(func(4));      // Returns &quot;False&quot;.     \n</code></pre><p>You can also supply a lambda expression when the argument type is an <a class=\"xref\" href=\"../../api/system.linq.expressions.expression-1\" data-linktype=\"relative-path\">Expression&lt;TDelegate&gt;</a>, for example in the standard query operators that are defined in the <a class=\"xref\" href=\"../../api/system.linq.queryable\" data-linktype=\"relative-path\">Queryable</a> type. When you specify an <a class=\"xref\" href=\"../../api/system.linq.expressions.expression-1\" data-linktype=\"relative-path\">Expression&lt;TDelegate&gt;</a> argument, the lambda is compiled to an expression tree. The following example uses the <a class=\"xref\" href=\"../../api/system.linq.enumerable#System_Linq_Enumerable_Count__1_System_Collections_Generic_IEnumerable___0__\" data-linktype=\"relative-path\">System.Linq.Enumerable.Count</a> standard query operator.</p>\n<pre><code name=\"csSnippets.Lambdas\">int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };  \nint oddNumbers = numbers.Count(n =&gt; n % 2 == 1);  \nConsole.WriteLine(&quot;There are {0} odd numbers in the set&quot;, oddNumbers);\n// Output: There are 5 odd numbers in the set\n</code></pre><p>The compiler can infer the type of the input parameter, or you can also specify it explicitly. This particular lambda expression counts those integers (<code>n</code>) that, when divided by two, have a remainder of 1.</p>\n<p>The following example produces a sequence that contains all elements in the <code>numbers</code> array that precede the 9, because that&#39;s the first number in the sequence that doesn&#39;t meet the condition.</p>\n<pre><code name=\"csSnippets.Lambdas\">var firstNumbersLessThan6 = numbers.TakeWhile(n =&gt; n &lt; 6);\nforeach (var number in firstNumbersLessThan6)\n   Console.Write(&quot;{0}     &quot;, number);  \n// Output: 5     4     1     3\n</code></pre><p>The following example specifies multiple input parameters by enclosing them in parentheses. The method returns all the elements in the numbers array until it encounters a number whose value is less than its ordinal position in the array.</p>\n<pre><code name=\"csSnippets.Lambdas\"> var firstSmallNumbers = numbers.TakeWhile((n, index) =&gt; n &gt;= index);\nforeach (var number in firstSmallNumbers)\n   Console.Write(&quot;{0}     &quot;, number);\n // Output: 5     4\n</code></pre><h2 id=\"type-inference-in-lambda-expressions\">Type inference in lambda expressions</h2>\n<p>When writing lambdas, you often do not have to specify a type for the input parameters because the compiler can infer the type based on the lambda body, the parameter types, and other factors, as described in the C# Language Specification. For most of the standard query operators, the first input is the type of the elements in the source sequence. If you are querying an <code>IEnumerable&lt;Customer&gt;</code>, then the input variable is inferred to be a <code>Customer</code> object, which means you have access to its methods and properties:</p>\n<pre><code name=\"csSnippets.Lambdas\">customers.Where(c =&gt; c.City == &quot;London&quot;);\n</code></pre><p>The general rules for type inference for lambdas are:</p>\n<ul>\n<li><p>The lambda must contain the same number of parameters as the delegate type.</p>\n</li>\n<li><p>Each input argument in the lambda must be implicitly convertible to its corresponding delegate parameter.</p>\n</li>\n<li><p>The return value of the lambda (if any) must be implicitly convertible to the delegate&#39;s return type.</p>\n</li>\n</ul>\n<p>Note that lambda expressions in themselves do not have a type because the common type system has no intrinsic concept of &quot;lambda expression.&quot; However, it is sometimes convenient to speak informally of the &quot;type&quot; of a lambda expression. In these cases the type refers to the delegate type or <a class=\"xref\" href=\"../../api/system.linq.expressions.expression\" data-linktype=\"relative-path\">Expression</a> type to which the lambda expression is converted.</p>\n<h2 id=\"variable-scope-in-lambda-expressions\">Variable Scope in Lambda Expressions</h2>\n<p>Lambdas can refer to <em>outer variables</em> (see <a href=\"programming-guide/statements-expressions-operators/anonymous-methods\" data-linktype=\"relative-path\">Anonymous methods</a>) that are in scope in the method that defines the lambda function, or in scope in the type that contains the lambda expression. Variables that are captured in this manner are stored for use in the lambda expression even if the variables would otherwise go out of scope and be garbage collected. An outer variable must be definitely assigned before it can be consumed in a lambda expression. The following example demonstrates these rules.</p>\n<pre><code name=\"csSnippets.Lambdas\">using System;\n\ndelegate bool D();  \ndelegate bool D2(int i);  \n  \nclass Test  \n{  \n    D del;  \n    D2 del2;  \n    public void TestMethod(int input)  \n    {  \n        int j = 0;  \n        // Initialize the delegates with lambda expressions.  \n        // Note access to 2 outer variables.  \n        // del will be invoked within this method.  \n        del = () =&gt; { j = 10;  return j &gt; input; };  \n  \n        // del2 will be invoked after TestMethod goes out of scope.  \n        del2 = (x) =&gt; {return x == j; };  \n  \n        // Demonstrate value of j:  \n        // Output: j = 0   \n        // The delegate has not been invoked yet.  \n        Console.WriteLine(&quot;j = {0}&quot;, j);        // Invoke the delegate.  \n        bool boolResult = del();  \n  \n        // Output: j = 10 b = True  \n        Console.WriteLine(&quot;j = {0}. b = {1}&quot;, j, boolResult);  \n    }  \n  \n    static void Main()  \n    {  \n        Test test = new Test();  \n        test.TestMethod(5);  \n  \n        // Prove that del2 still has a copy of  \n        // local variable j from TestMethod.  \n        bool result = test.del2(10);  \n  \n        // Output: True  \n        Console.WriteLine(result);  \n    }  \n}  \n// The example displays the following output:\n//      j = 0\n//      j = 10. b = True\n//      True\n</code></pre><p> The following rules apply to variable scope in lambda expressions:</p>\n<ul>\n<li><p>A variable that is captured will not be garbage-collected until the delegate that references it becomes eligible for garbage collection.</p>\n</li>\n<li><p>Variables introduced within a lambda expression are not visible in the outer method.</p>\n</li>\n<li><p>A lambda expression cannot directly capture a <code>ref</code> or <code>out</code> parameter from an enclosing method.</p>\n</li>\n<li><p>A return statement in a lambda expression does not cause the enclosing method to return.</p>\n</li>\n<li><p>A lambda expression cannot contain a <code>goto</code> statement, <code>break</code> statement, or <code>continue</code> statement that is inside the lambda function if the jump statementâ€™s target is outside the block. It is also an error to have a jump statement outside the lambda function block if the target is inside the block.</p>\n</li>\n</ul>\n<h2 id=\"see-also\">See also</h2>\n<p><a href=\"../standard/using-linq\" data-linktype=\"relative-path\">LINQ (Language-Integrated Query)</a><br><a href=\"programming-guide/statements-expressions-operators/anonymous-methods\" data-linktype=\"relative-path\">Anonymous methods</a><br><a href=\"expression-trees\" data-linktype=\"relative-path\">Expression trees</a></p>\n</div></div>","outputRootRelativePath":"../../","pageMetadata":"<meta name=\"author\" content=\"rpetrusha\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"b6a0539a-8ce5-4da7-adcf-44be345a2714\">\r\n<meta name=\"description\" content=\"Lean to use lambda expressions, which are executable code blocks that can be passed as arguments.\">\r\n<meta name=\"ms-author\" content=\"ronpet\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core, lambda expressions, lambdas, delegates\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"11/22/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-04-01 05:46 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/400dfda51d978f35c3995f90840643aaff1b9c13/docs/csharp/lambda-expressions.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/lambda-expressions.md\">\r\n<meta name=\"document_id\" content=\"701025ab-7a84-d808-eed0-ce54cf0ee75e\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../toc2.json\">\r\n","rawMetadata":{"author":"rpetrusha","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","uhfHeaderId":"MSDocsHeader-DotNet","title":"Lambda Expressions | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"b6a0539a-8ce5-4da7-adcf-44be345a2714","description":"Lean to use lambda expressions, which are executable code blocks that can be passed as arguments.","ms-author":"ronpet","keywords":".NET, .NET Core, lambda expressions, lambdas, delegates","ms.topic":"article","ms.date":"11/22/2016","ms.technology":"devlang-csharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"tompratt-AQ","author_email":"v-thprat@microsoft.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"Update language identifiers and styleguide. (#1796)","commit_sha":"400dfda51d978f35c3995f90840643aaff1b9c13","commit_date":"2017-03-24 14:01:03 -0700"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize the C# Guide TOC (#1318)","commit_sha":"3115359729431ecbcc16058612da59b85621fa0f","commit_date":"2017-01-23 23:20:14 -0500"},{"author_name":"Ron Petrusha","author_email":"ronpet@microsoft.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"Fixed broken links to LINQ topic (#1331)","commit_sha":"763433b00ae7d01cfa0c7fa250f51d23a95f6f15","commit_date":"2016-12-13 19:28:50 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Additional revisions from Bill and Maira.","commit_sha":"6c20aa242a823a7a864778cdccc9f18bbf75b3cd","commit_date":"2016-11-29 14:02:46 -0800"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Addressed comments from @shoag","commit_sha":"ef3f06850d6e26ff7b9ae0c754735214b2c2c7d9","commit_date":"2016-11-25 12:18:43 -0800"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Revisions to lambda expressions topic.","commit_sha":"e49fc12b0b67df24d0178051b2797fac0af0b874","commit_date":"2016-11-22 15:15:18 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"renamed repo/fixed headings (#1186)","commit_sha":"15c55a87beb64f265a164db918c7721c7690fadf","commit_date":"2016-10-29 15:23:17 -0400"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Create outlines for csharp 7 (#1115)","commit_sha":"ada1b8f1252962556e42f180046b9b019307622c","commit_date":"2016-10-06 21:10:34 -0400"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"Rich Lander","comitter_email":"rlander@microsoft.com","message":"Promote csharp from languages (#644)","commit_sha":"2d44b7e04c0fe2ca136ba6dfa9fc3a4368365ec8","commit_date":"2016-06-26 08:30:56 -0700"}],"updated_at":"2017-04-01 05:46 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/rpetrusha","display_name":"rpetrusha","id":"10886961"},"contributors":[{"profile_url":"https://github.com/rpetrusha","display_name":"rpetrusha"},{"profile_url":"https://github.com/tompratt-AQ","display_name":"tompratt-AQ","id":"26311438"},{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"4/1/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/400dfda51d978f35c3995f90840643aaff1b9c13/docs/csharp/lambda-expressions.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/lambda-expressions.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/lambda-expressions.md","document_id":"701025ab-7a84-d808-eed0-ce54cf0ee75e","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/lambda-expressions","toc_asset_id":"articles/toc.json","toc_rel":"../toc.json","_op_ogTitle":"Lambda Expressions","_op_displayDate":"2016-11-22","_op_displayDate_source":"2016-11-22T00:00:00Z","_op_wordCount":2162,"_op_rawTitle":"<h1 id=\"lambda-expressions\" sourcefile=\"docs/csharp/lambda-expressions.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Lambda expressions</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/lambda-expressions","fileRelativePath":"articles/csharp/lambda-expressions.html"},"themesRelativePathToOutputRoot":"_themes/"}