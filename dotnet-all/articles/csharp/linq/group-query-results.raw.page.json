{"content":"<div><div class=\"content\">\n<p>Grouping is one of the most powerful capabilities of LINQ. The following examples show how to group data in various ways:  </p>\n<ul>\n<li><p>By a single property.  </p>\n</li>\n<li><p>By the first letter of a string property.  </p>\n</li>\n<li><p>By a computed numeric range.  </p>\n</li>\n<li><p>By Boolean predicate or other expression.  </p>\n</li>\n<li><p>By a compound key.  </p>\n<p>In addition, the last two queries project their results into a new anonymous type that contains only the student&#39;s first and last name. For more information, see the <a href=\"../language-reference/keywords/group-clause\" data-linktype=\"relative-path\">group clause</a>.  </p>\n</li>\n</ul>\n<h2 id=\"example\">Example</h2>\n<p> All the examples in this topic use the following helper classes and data sources.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideLINQ#15\">    public class StudentClass\n    {\n        #region data\n        protected enum GradeLevel { FirstYear = 1, SecondYear, ThirdYear, FourthYear };\n        protected class Student\n        {\n            public string FirstName { get; set; }\n            public string LastName { get; set; }\n            public int ID { get; set; }\n            public GradeLevel Year;\n            public List&lt;int&gt; ExamScores;\n        }\n\n        protected static List&lt;Student&gt; students = new List&lt;Student&gt;\n        {\n            new Student {FirstName = &quot;Terry&quot;, LastName = &quot;Adams&quot;, ID = 120, \n                Year = GradeLevel.SecondYear, \n                ExamScores = new List&lt;int&gt;{ 99, 82, 81, 79}},\n            new Student {FirstName = &quot;Fadi&quot;, LastName = &quot;Fakhouri&quot;, ID = 116, \n                Year = GradeLevel.ThirdYear,\n                ExamScores = new List&lt;int&gt;{ 99, 86, 90, 94}},\n            new Student {FirstName = &quot;Hanying&quot;, LastName = &quot;Feng&quot;, ID = 117, \n                Year = GradeLevel.FirstYear, \n                ExamScores = new List&lt;int&gt;{ 93, 92, 80, 87}},\n            new Student {FirstName = &quot;Cesar&quot;, LastName = &quot;Garcia&quot;, ID = 114, \n                Year = GradeLevel.FourthYear,\n                ExamScores = new List&lt;int&gt;{ 97, 89, 85, 82}},\n            new Student {FirstName = &quot;Debra&quot;, LastName = &quot;Garcia&quot;, ID = 115, \n                Year = GradeLevel.ThirdYear, \n                ExamScores = new List&lt;int&gt;{ 35, 72, 91, 70}},\n            new Student {FirstName = &quot;Hugo&quot;, LastName = &quot;Garcia&quot;, ID = 118, \n                Year = GradeLevel.SecondYear, \n                ExamScores = new List&lt;int&gt;{ 92, 90, 83, 78}},\n            new Student {FirstName = &quot;Sven&quot;, LastName = &quot;Mortensen&quot;, ID = 113, \n                Year = GradeLevel.FirstYear, \n                ExamScores = new List&lt;int&gt;{ 88, 94, 65, 91}},\n            new Student {FirstName = &quot;Claire&quot;, LastName = &quot;O&#39;Donnell&quot;, ID = 112, \n                Year = GradeLevel.FourthYear, \n                ExamScores = new List&lt;int&gt;{ 75, 84, 91, 39}},\n            new Student {FirstName = &quot;Svetlana&quot;, LastName = &quot;Omelchenko&quot;, ID = 111, \n                Year = GradeLevel.SecondYear, \n                ExamScores = new List&lt;int&gt;{ 97, 92, 81, 60}},\n            new Student {FirstName = &quot;Lance&quot;, LastName = &quot;Tucker&quot;, ID = 119, \n                Year = GradeLevel.ThirdYear, \n                ExamScores = new List&lt;int&gt;{ 68, 79, 88, 92}},\n            new Student {FirstName = &quot;Michael&quot;, LastName = &quot;Tucker&quot;, ID = 122, \n                Year = GradeLevel.FirstYear, \n                ExamScores = new List&lt;int&gt;{ 94, 92, 91, 91}},\n            new Student {FirstName = &quot;Eugene&quot;, LastName = &quot;Zabokritski&quot;, ID = 121,\n                Year = GradeLevel.FourthYear, \n                ExamScores = new List&lt;int&gt;{ 96, 85, 91, 60}}\n        };\n        #endregion\n\n        //Helper method, used in GroupByRange.\n        protected static int GetPercentile(Student s)\n        {\n            double avg = s.ExamScores.Average();\n            return avg &gt; 0 ? (int)avg / 10 : 0;\n        }\n\n        \n\n        public void QueryHighScores(int exam, int score)\n        {\n            var highScores = from student in students\n                             where student.ExamScores[exam] &gt; score\n                             select new {Name = student.FirstName, Score = student.ExamScores[exam]};\n\n            foreach (var item in highScores)\n            {\n                Console.WriteLine($&quot;{item.Name:-15}{item.Score}&quot;);\n            }\n        }\n    }\n\n    public class Program\n    {\n        public static void Main()\n        {\n            StudentClass sc = new StudentClass();\n            sc.QueryHighScores(1, 90);\n\n            // Keep the console window open in debug mode.\n            Console.WriteLine(&quot;Press any key to exit&quot;);\n            Console.ReadKey();\n        }\n    }\n</code></pre><h2 id=\"example-1\">Example</h2>\n<p> The following example shows how to group source elements by using a single property of the element as the group key. In this case the key is a <code>string</code>, the student&#39;s last name. It is also possible to use a substring for the key. The grouping operation uses the default equality comparer for the type.  </p>\n<p> Paste the following method into the <code>StudentClass</code> class. Change the calling statement in the <code>Main</code> method to <code>sc.GroupBySingleProperty()</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideLINQ#17\">        public void GroupBySingleProperty()\n        {\n            Console.WriteLine(&quot;Group by a single property in an object:&quot;);\n\n            // Variable queryLastNames is an IEnumerable&lt;IGrouping&lt;string, \n            // DataClass.Student&gt;&gt;. \n            var queryLastNames =\n                from student in students\n                group student by student.LastName into newGroup\n                orderby newGroup.Key\n                select newGroup;\n\n            foreach (var nameGroup in queryLastNames)\n            {\n                Console.WriteLine(&quot;Key: {0}&quot;, nameGroup.Key);\n                foreach (var student in nameGroup)\n                {\n                    Console.WriteLine(&quot;\\t{student.LastName}, {student.FirstName}&quot;);\n                }\n            }\n        }\n        /* Output:\n            Group by a single property in an object:\n            Key: Adams\n                    Adams, Terry\n            Key: Fakhouri\n                    Fakhouri, Fadi\n            Key: Feng\n                    Feng, Hanying\n            Key: Garcia\n                    Garcia, Cesar\n                    Garcia, Debra\n                    Garcia, Hugo\n            Key: Mortensen\n                    Mortensen, Sven\n            Key: O&#39;Donnell\n                    O&#39;Donnell, Claire\n            Key: Omelchenko\n                    Omelchenko, Svetlana\n            Key: Tucker\n                    Tucker, Lance\n                    Tucker, Michael\n            Key: Zabokritski\n                    Zabokritski, Eugene\n        */\n</code></pre><h2 id=\"example-2\">Example</h2>\n<p> The following example shows how to group source elements by using something other than a property of the object for the group key. In this example, the key is the first letter of the student&#39;s last name.  </p>\n<p> Paste the following method into the <code>StudentClass</code> class. Change the calling statement in the <code>Main</code> method to <code>sc.GroupBySubstring()</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideLINQ#18\">        public void GroupBySubstring()\n        {            \n            Console.WriteLine(&quot;\\r\\nGroup by something other than a property of the object:&quot;);\n\n            var queryFirstLetters =\n                from student in students\n                group student by student.LastName[0];\n\n            foreach (var studentGroup in queryFirstLetters)\n            {\n                Console.WriteLine($&quot;Key: {studentGroup.Key}&quot;);\n                // Nested foreach is required to access group items.\n                foreach (var student in studentGroup)\n                {\n                    Console.WriteLine(&quot;\\t{student.LastName}, {student.FirstName}&quot;);\n                }\n            }           \n        }\n        /* Output:\n            Group by something other than a property of the object:\n            Key: A\n                    Adams, Terry\n            Key: F\n                    Fakhouri, Fadi\n                    Feng, Hanying\n            Key: G\n                    Garcia, Cesar\n                    Garcia, Debra\n                    Garcia, Hugo\n            Key: M\n                    Mortensen, Sven\n            Key: O\n                    O&#39;Donnell, Claire\n                    Omelchenko, Svetlana\n            Key: T\n                    Tucker, Lance\n                    Tucker, Michael\n            Key: Z\n                    Zabokritski, Eugene\n        */\n</code></pre><h2 id=\"example-3\">Example</h2>\n<p> The following example shows how to group source elements by using a numeric range as a group key. The query then projects the results into an anonymous type that contains only the first and last name and the percentile range to which the student belongs. An anonymous type is used because it is not necessary to use the complete <code>Student</code> object to display the results. <code>GetPercentile</code> is a helper function that calculates a percentile based on the student&#39;s average score. The method returns an integer between 0 and 10.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideLINQ#50\">        //Helper method, used in GroupByRange.\n        protected static int GetPercentile(Student s)\n        {\n            double avg = s.ExamScores.Average();\n            return avg &gt; 0 ? (int)avg / 10 : 0;\n        }\n</code></pre><p> Paste the following method into the <code>StudentClass</code> class. Change the calling statement in the <code>Main</code> method to <code>sc.GroupByRange()</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideLINQ#19\">        public void GroupByRange()\n        {            \n            Console.WriteLine(&quot;\\r\\nGroup by numeric range and project into a new anonymous type:&quot;);\n\n            var queryNumericRange =\n                from student in students\n                let percentile = GetPercentile(student)\n                group new { student.FirstName, student.LastName } by percentile into percentGroup\n                orderby percentGroup.Key\n                select percentGroup;\n\n            // Nested foreach required to iterate over groups and group items.\n            foreach (var studentGroup in queryNumericRange)\n            {\n                Console.WriteLine($&quot;Key: {studentGroup.Key * 10}&quot;); \n                foreach (var item in studentGroup)\n                {\n                    Console.WriteLine(&quot;\\t{item.LastName}, {item.FirstName}&quot;);\n                }\n            }            \n        }\n        /* Output:\n            Group by numeric range and project into a new anonymous type:\n            Key: 60\n                    Garcia, Debra\n            Key: 70\n                    O&#39;Donnell, Claire\n            Key: 80\n                    Adams, Terry\n                    Feng, Hanying\n                    Garcia, Cesar\n                    Garcia, Hugo\n                    Mortensen, Sven\n                    Omelchenko, Svetlana\n                    Tucker, Lance\n                    Zabokritski, Eugene\n            Key: 90\n                    Fakhouri, Fadi\n                    Tucker, Michael\n        */\n</code></pre><h2 id=\"example-4\">Example</h2>\n<p> The following example shows how to group source elements by using a Boolean comparison expression. In this example, the Boolean expression tests whether a student&#39;s average exam score is greater than 75. As in previous examples, the results are projected into an anonymous type because the complete source element is not needed. Note that the properties in the anonymous type become properties on the <code>Key</code> member and can be accessed by name when the query is executed.  </p>\n<p> Paste the following method into the <code>StudentClass</code> class. Change the calling statement in the <code>Main</code> method to <code>sc.GroupByBoolean()</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideLINQ#20\">        public void GroupByBoolean()\n        {            \n            Console.WriteLine(&quot;\\r\\nGroup by a Boolean into two groups with string keys&quot;);\n            Console.WriteLine(&quot;\\&quot;True\\&quot; and \\&quot;False\\&quot; and project into a new anonymous type:&quot;);\n            var queryGroupByAverages = from student in students\n                                       group new { student.FirstName, student.LastName }\n                                            by student.ExamScores.Average() &gt; 75 into studentGroup\n                                       select studentGroup;\n\n            foreach (var studentGroup in queryGroupByAverages)\n            {\n                Console.WriteLine($&quot;Key: {studentGroup.Key}&quot;);\n                foreach (var student in studentGroup)\n                    Console.WriteLine($&quot;\\t{student.FirstName} {student.LastName}&quot;);\n            }            \n        }\n        /* Output:\n            Group by a Boolean into two groups with string keys\n            &quot;True&quot; and &quot;False&quot; and project into a new anonymous type:\n            Key: True\n                    Terry Adams\n                    Fadi Fakhouri\n                    Hanying Feng\n                    Cesar Garcia\n                    Hugo Garcia\n                    Sven Mortensen\n                    Svetlana Omelchenko\n                    Lance Tucker\n                    Michael Tucker\n                    Eugene Zabokritski\n            Key: False\n                    Debra Garcia\n                    Claire O&#39;Donnell\n        */\n</code></pre><h2 id=\"example-5\">Example</h2>\n<p> The following example shows how to use an anonymous type to encapsulate a key that contains multiple values. In this example, the first key value is the first letter of the student&#39;s last name. The second key value is a Boolean that specifies whether the student scored over 85 on the first exam. You can order the groups by any property in the key.  </p>\n<p> Paste the following method into the <code>StudentClass</code> class. Change the calling statement in the <code>Main</code> method to <code>sc.GroupByCompositeKey()</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideLINQ#21\">        public void GroupByCompositeKey()\n        {\n\n            var queryHighScoreGroups =\n                from student in students\n                group student by new { FirstLetter = student.LastName[0], \n                    Score = student.ExamScores[0] &gt; 85 } into studentGroup\n                orderby studentGroup.Key.FirstLetter\n                select studentGroup;\n\n            Console.WriteLine(&quot;\\r\\nGroup and order by a compound key:&quot;);\n            foreach (var scoreGroup in queryHighScoreGroups)\n            {\n                string s = scoreGroup.Key.Score == true ? &quot;more than&quot; : &quot;less than&quot;;\n                ($&quot;Name starts with {scoreGroup.Key.FirstLetter} who scored {s} 85&quot;);\n                foreach (var item in scoreGroup)\n                {\n                    Console.WriteLine($&quot;\\t{item.FirstName} {item.LastName}&quot;);\n                }\n            }\n        }\n        /* Output:\n            Group and order by a compound key:\n            Name starts with A who scored more than 85\n                    Terry Adams\n            Name starts with F who scored more than 85\n                    Fadi Fakhouri\n                    Hanying Feng\n            Name starts with G who scored more than 85\n                    Cesar Garcia\n                    Hugo Garcia\n            Name starts with G who scored less than 85\n                    Debra Garcia\n            Name starts with M who scored more than 85\n                    Sven Mortensen\n            Name starts with O who scored less than 85\n                    Claire O&#39;Donnell\n            Name starts with O who scored more than 85\n                    Svetlana Omelchenko\n            Name starts with T who scored less than 85\n                    Lance Tucker\n            Name starts with T who scored more than 85\n                    Michael Tucker\n            Name starts with Z who scored more than 85\n                    Eugene Zabokritski\n        */\n</code></pre><h2 id=\"see-also\">See also</h2>\n<p> <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/bb341740(v=vs.110).aspx\" data-linktype=\"external\">GroupBy</a><br> <a class=\"xref\" href=\"../../../api/system.linq.igrouping-2\" data-linktype=\"relative-path\">IGrouping&lt;TKey,TElement&gt;</a><br> <a href=\"index\" data-linktype=\"relative-path\">LINQ Query Expressions</a><br> <a href=\"../language-reference/keywords/group-clause\" data-linktype=\"relative-path\">group clause</a><br> <a href=\"../programming-guide/classes-and-structs/anonymous-types\" data-linktype=\"relative-path\">Anonymous Types</a><br> <a href=\"perform-a-subquery-on-a-grouping-operation\" data-linktype=\"relative-path\">Perform a Subquery on a Grouping Operation</a><br> <a href=\"create-a-nested-group\" data-linktype=\"relative-path\">Create a Nested Group</a><br> <a href=\"../programming-guide/concepts/linq/grouping-data\" data-linktype=\"relative-path\">Grouping Data</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"dotnet\">\r\n<meta name=\"ms.assetid\" content=\"2e4ec27f-06fb-4de7-8973-0189906d4520\">\r\n<meta name=\"description\" content=\"How to group results.\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core, C#\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"12/1/2016\">\r\n<meta name=\"ms.technology\" content=\".net-core-technologies\">\r\n<meta name=\"ms.prod\" content=\".net-core\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/97a29e60f5d861d848b85ef1e8ed8b1988f9ced1/docs/csharp/linq/group-query-results.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/linq/group-query-results.md\">\r\n<meta name=\"document_id\" content=\"b4de8897-e0df-5e22-55bc-7d1f883741ee\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Group query results | Microsoft Docs","ms.devlang":"dotnet","ms.assetid":"2e4ec27f-06fb-4de7-8973-0189906d4520","description":"How to group results.","keywords":".NET, .NET Core, C#","ms.topic":"article","ms.date":"12/1/2016","ms.technology":".net-core-technologies","ms.prod":".net-core","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Steve Hoag","author_email":"shoag@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Updated LINQ topics for C# Concepts section (#1302)","commit_sha":"97a29e60f5d861d848b85ef1e8ed8b1988f9ced1","commit_date":"2016-12-12 09:02:31 -0800"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/97a29e60f5d861d848b85ef1e8ed8b1988f9ced1/docs/csharp/linq/group-query-results.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/linq/group-query-results.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/linq/group-query-results.md","document_id":"b4de8897-e0df-5e22-55bc-7d1f883741ee","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/linq/group-query-results","toc_asset_id":"articles/csharp/linq/toc.json","toc_rel":"toc.json","_op_ogTitle":"Group query results","_op_displayDate":"2016-12-1","_op_displayDate_source":"2016-12-01T00:00:00Z","_op_wordCount":1614,"_op_rawTitle":"<h1 id=\"group-query-results\" sourcefile=\"docs/csharp/linq/group-query-results.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Group query results</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/linq/group-query-results","fileRelativePath":"articles/csharp/linq/group-query-results.html"},"themesRelativePathToOutputRoot":"_themes/"}