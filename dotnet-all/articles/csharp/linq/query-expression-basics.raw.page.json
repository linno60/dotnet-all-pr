{"content":"<div><div class=\"content\">\n<h2 id=\"what-is-a-query-and-what-does-it-do\">What is a query and what does it do?</h2>\n<p> A <em>query</em> is a set of instructions that describes what data to retrieve from a given data source (or sources) and what shape and organization the returned data should have. A query is distinct from the results that it produces.  </p>\n<p> Generally, the source data is organized logically as a sequence of elements of the same kind. For example, a SQL database table contains a sequence of rows. In an XML file, there is a &quot;sequence&quot; of XML elements (although these are organized hierarchically in a tree structure). An in-memory collection contains a sequence of objects. </p>\n<p> From an application&#39;s viewpoint, the specific type and structure of the original source data is not important. The application always sees the source data as an <a class=\"xref\" href=\"../../../api/system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable&lt;T&gt;</a> or <a class=\"xref\" href=\"../../../api/system.linq.iqueryable-1\" data-linktype=\"relative-path\">IQueryable&lt;T&gt;</a> collection. For example, in LINQ to XML, the source data is made visible as an <code>IEnumerable</code>&lt;<a class=\"xref\" href=\"../../../api/system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>&gt;.  </p>\n<p> Given this source sequence, a query may do one of three things:  </p>\n<ul>\n<li><p>Retrieve a subset of the elements to produce a new sequence without modifying the individual elements. The query may then sort or group the returned sequence in various ways, as shown in the following example (assume <code>scores</code> is an <code>int[]</code>):  </p>\n<pre><code class=\"lang-cs\" name=\"csrefQueryExpBasics#45\">            IEnumerable&lt;int&gt; highScoresQuery =\n                from score in scores\n                where score &gt; 80\n                orderby score descending\n                select score;\n</code></pre></li>\n<li><p>Retrieve a sequence of elements as in the previous example but transform them to a new type of object. For example, a query may retrieve only the last names from certain customer records in a data source. Or it may retrieve the complete record and then use it to construct another in-memory object type or even XML data before generating the final result sequence. The following example shows a projection from an <code>int</code> to a <code>string</code>. Note the new type of <code>highScoresQuery</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"csrefQueryExpBasics#46\">            IEnumerable&lt;string&gt; highScoresQuery2 =\n                from score in scores\n                where score &gt; 80\n                orderby score descending\n                select String.Format(&quot;The score is {0}&quot;, score);\n</code></pre></li>\n<li><p>Retrieve a singleton value about the source data, such as:  </p>\n<ul>\n<li><p>The number of elements that match a certain condition.  </p>\n</li>\n<li><p>The element that has the greatest or least value.  </p>\n</li>\n<li><p>The first element that matches a condition, or the sum of particular values in a specified set of elements. For example, the following query returns the number of scores greater than 80 from the <code>scores</code> integer array:  </p>\n<pre><code class=\"lang-cs\" name=\"csrefQueryExpBasics#47\">            int highScoreCount =\n                (from score in scores\n                 where score &gt; 80\n                 select score)\n                 .Count();\n</code></pre><p>In the previous example, note the use of parentheses around the query expression before the call to the <code>Count</code> method. You can also express this by using a new variable to store the concrete result. This technique is more readable because it keeps the variable that stores the query separate from the query that stores a result.  </p>\n<pre><code class=\"lang-cs\" name=\"csrefQueryExpBasics#48\">            IEnumerable&lt;int&gt; highScoresQuery3 =\n                from score in scores\n                where score &gt; 80\n                select score;\n\n            int scoreCount = highScoresQuery3.Count();\n</code></pre></li>\n</ul>\n<p>In the previous example, the query is executed in the call to <code>Count</code>, because <code>Count</code> must iterate over the results in order to determine the number of elements returned by <code>highScoresQuery</code>.  </p>\n</li>\n</ul>\n<h2 id=\"what-is-a-query-expression\">What is a query expression?</h2>\n<p> A <em>query expression</em> is a query expressed in query syntax. A query expression is a first-class language construct. It is just like any other expression and can be used in any context in which a C# expression is valid. A query expression consists of a set of clauses written in a declarative syntax similar to SQL or XQuery. Each clause in turn contains one or more C# expressions, and these expressions may themselves be either a query expression or contain a query expression.  </p>\n<p> A query expression must begin with a <a href=\"../language-reference/keywords/from-clause\" data-linktype=\"relative-path\">from</a> clause and must end with a <a href=\"../language-reference/keywords/select-clause\" data-linktype=\"relative-path\">select</a> or <a href=\"../language-reference/keywords/group-clause\" data-linktype=\"relative-path\">group</a> clause. Between the first <code>from</code> clause and the last <code>select</code> or <code>group</code> clause, it can contain one or more of these optional clauses: <a href=\"../language-reference/keywords/where-clause\" data-linktype=\"relative-path\">where</a>, <a href=\"../language-reference/keywords/orderby-clause\" data-linktype=\"relative-path\">orderby</a>, <a href=\"../language-reference/keywords/join-clause\" data-linktype=\"relative-path\">join</a>, <a href=\"../language-reference/keywords/let-clause\" data-linktype=\"relative-path\">let</a> and even additional <a href=\"../language-reference/keywords/from-clause\" data-linktype=\"relative-path\">from</a> clauses. You can also use the <a href=\"../language-reference/keywords/into\" data-linktype=\"relative-path\">into</a> keyword to enable the result of a <code>join</code> or <code>group</code> clause to serve as the source for additional query clauses in the same query expression.  </p>\n<h3 id=\"query-variable\">Query variable</h3>\n<p> In LINQ, a query variable is any variable that stores a <em>query</em> instead of the <em>results</em> of a query. More specifically, a query variable is always an enumerable type that will produce a sequence of elements when it is iterated over in a <code>foreach</code> statement or a direct call to its <code>IEnumerator.MoveNext</code> method.  </p>\n<p> The following code example shows a simple query expression with one data source, one filtering clause, one ordering clause, and no transformation of the source elements. The <code>select</code> clause ends the query.  </p>\n<pre><code class=\"lang-cs\" name=\"csrefQueryExpBasics#49\">        static void Main()\n        {\n            // Data source.\n            int[] scores = { 90, 71, 82, 93, 75, 82 };\n\n            // Query Expression.\n            IEnumerable&lt;int&gt; scoreQuery = //query variable\n                from score in scores //required\n                where score &gt; 80 // optional\n                orderby score descending // optional\n                select score; //must end with select or group\n\n            // Execute the query to produce the results\n            foreach (int testScore in scoreQuery)\n            {\n                Console.WriteLine(testScore);\n            }                  \n        }\n        // Outputs: 93 90 82 82      \n</code></pre><p> In the previous example, <code>scoreQuery</code> is a <em>query variable,</em> which is sometimes referred to as just a <em>query</em>. The query variable stores no actual result data, which is produced in the <code>foreach</code> loop. And when the <code>foreach</code> statement executes, the query results are not returned through the query variable <code>scoreQuery</code>. Rather, they are returned through the iteration variable <code>testScore</code>. The <code>scoreQuery</code> variable can be iterated in a second <code>foreach</code> loop. It will produce the same results as long as neither it nor the data source has been modified.  </p>\n<p> A query variable may store a query that is expressed in query syntax or method syntax, or a combination of the two. In the following examples, both <code>queryMajorCities</code> and <code>queryMajorCities2</code> are query variables:  </p>\n<pre><code class=\"lang-cs\" name=\"csrefQueryExpBasics#50\">            //Query syntax\n            IEnumerable&lt;City&gt; queryMajorCities =\n                from city in cities\n                where city.Population &gt; 100000\n                select city;\n\n            \n            // Method-based syntax\n            IEnumerable&lt;City&gt; queryMajorCities2 = cities.Where(c =&gt; c.Population &gt; 100000);\n</code></pre><p> On the other hand, the following two examples show variables that are not query variables even through each is initialized with a query. They are not query variables because they store results:  </p>\n<pre><code class=\"lang-cs\" name=\"csrefQueryExpBasics#51\">            int highestScore =\n                (from score in scores\n                 select score)\n                .Max();\n\n            // or split the expression\n            IEnumerable&lt;int&gt; scoreQuery =\n                from score in scores\n                select score;\n\n            int highScore = scoreQuery.Max();\n            // the following returns the same result\n            int highScore = scores.Max();\n\n            List&lt;City&gt; largeCitiesList =\n                (from country in countries\n                 from city in country.Cities\n                 where city.Population &gt; 10000\n                 select city)\n                   .ToList();\n\n            // or split the expression\n            IEnumerable&lt;City&gt; largeCitiesQuery =\n                from country in countries\n                from city in country.Cities\n                where city.Population &gt; 10000\n                select city;\n\n            List&lt;City&gt; largeCitiesList2 = largeCitiesQuery.ToList();\n</code></pre><p> For more information about the different ways to express queries, see <a href=\"../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq\" data-linktype=\"relative-path\">Query syntax and method syntax in LINQ</a>.  </p>\n<h4 id=\"explicit-and-implicit-typing-of-query-variables\">Explicit and implicit typing of query variables</h4>\n<p> This documentation usually provides the explicit type of the query variable in order to show the type relationship between the query variable and the <a href=\"../language-reference/keywords/select-clause\" data-linktype=\"relative-path\">select clause</a>. However, you can also use the <a href=\"../language-reference/keywords/var\" data-linktype=\"relative-path\">var</a> keyword to instruct the compiler to infer the type of a query variable (or any other local variable) at compile time. For example, the query example that was shown previously in this topic can also be expressed by using implicit typing:  </p>\n<pre><code class=\"lang-cs\" name=\"csrefQueryExpBasics#52\">            // Use of var is optional here and in all queries.\n            // queryCities is an IEnumerable&lt;City&gt; just as \n            // when it is explicitly typed.\n            var queryCities =\n                from city in cities\n                where city.Population &gt; 100000\n                select city;\n</code></pre><p> For more information, see <a href=\"../programming-guide/classes-and-structs/implicitly-typed-local-variables\" data-linktype=\"relative-path\">Implicitly typed local variables</a> and <a href=\"../programming-guide/concepts/linq/type-relationships-in-linq-query-operations\" data-linktype=\"relative-path\">Type relationships in LINQ query operations</a>.  </p>\n<h3 id=\"starting-a-query-expression\">Starting a query expression</h3>\n<p> A query expression must begin with a <code>from</code> clause. It specifies a data source together with a range variable. The range variable represents each successive element in the source sequence as the source sequence is being traversed. The range variable is strongly typed based on the type of elements in the data source. In the following example, because <code>countries</code> is an array of <code>Country</code> objects, the range variable is also typed as <code>Country</code>. Because the range variable is strongly typed, you can use the dot operator to access any available members of the type.  </p>\n<pre><code class=\"lang-cs\" name=\"csrefQueryExpBasics#53\">            IEnumerable&lt;Country&gt; countryAreaQuery =\n                from country in countries\n                where country.Area &gt; 500000 //sq km\n                select country;\n</code></pre><p> The range variable is in scope until the query is exited either with a semicolon or with a <em>continuation</em> clause.  </p>\n<p> A query expression may contain multiple <code>from</code> clauses. Use additional <code>from</code> clauses when each element in the source sequence is itself a collection or contains a collection. For example, assume that you have a collection of <code>Country</code> objects, each of which contains a collection of <code>City</code> objects named <code>Cities</code>. To query the <code>City</code> objects in each <code>Country</code>, use two <code>from</code> clauses as shown here:  </p>\n<pre><code class=\"lang-cs\" name=\"csrefQueryExpBasics#54\">            IEnumerable&lt;City&gt; cityQuery =\n                from country in countries\n                from city in country.Cities\n                where city.Population &gt; 10000\n                select city;\n</code></pre><p> For more information, see <a href=\"../language-reference/keywords/from-clause\" data-linktype=\"relative-path\">from clause</a>.  </p>\n<h3 id=\"ending-a-query-expression\">Ending a query expression</h3>\n<p> A query expression must end with either a <code>group</code> clause or a <code>select</code> clause.  </p>\n<h4 id=\"group-clause\">group clause</h4>\n<p> Use the <code>group</code> clause to produce a sequence of groups organized by a key that you specify. The key can be any data type. For example, the following query creates a sequence of groups that contains one or more <code>Country</code> objects and whose key is a <code>char</code> value.  </p>\n<pre><code class=\"lang-cs\" name=\"csrefQueryExpBasics#55\">            var queryCountryGroups =\n                from country in countries\n                group country by country.Name[0];\n</code></pre><p> For more information about grouping, see <a href=\"../language-reference/keywords/group-clause\" data-linktype=\"relative-path\">group clause</a>.  </p>\n<h4 id=\"select-clause\">select clause</h4>\n<p> Use the <code>select</code> clause to produce all other types of sequences. A simple <code>select</code> clause just produces a sequence of the same type of objects as the objects that are contained in the data source. In this example, the data source contains <code>Country</code> objects. The <code>orderby</code> clause just sorts the elements into a new order and the <code>select</code> clause produces a sequence of the reordered <code>Country</code> objects.  </p>\n<pre><code class=\"lang-cs\" name=\"csrefQueryExpBasics#56\">            IEnumerable&lt;Country&gt; sortedQuery =\n                from country in countries\n                orderby country.Area\n                select country;\n</code></pre><p> The <code>select</code> clause can be used to transform source data into sequences of new types. This transformation is also named a <em>projection</em>. In the following example, the <code>select</code> clause <em>projects</em> a sequence of anonymous types which contains only a subset of the fields in the original element. Note that the new objects are initialized by using an object initializer.  </p>\n<pre><code class=\"lang-cs\" name=\"csrefQueryExpBasics#57\">            // Here var is required because the query\n            // produces an anonymous type.\n            var queryNameAndPop =\n                from country in countries\n                select new { Name = country.Name, Pop = country.Population };\n</code></pre><p> For more information about all the ways that a <code>select</code> clause can be used to transform source data, see <a href=\"../language-reference/keywords/select-clause\" data-linktype=\"relative-path\">select clause</a>.  </p>\n<h4 id=\"continuations-with-into\">Continuations with &quot;into&quot;</h4>\n<p> You can use the <code>into</code> keyword in a <code>select</code> or <code>group</code> clause to create a temporary identifier that stores a query. Do this when you must perform additional query operations on a query after a grouping or select operation. In the following example <code>countries</code> are grouped according to population in ranges of 10 million. After these groups are created, additional clauses filter out some groups, and then to sort the groups in ascending order. To perform those additional operations, the continuation represented by <code>countryGroup</code> is required.  </p>\n<pre><code class=\"lang-cs\" name=\"csrefQueryExpBasics#58\">            // percentileQuery is an IEnumerable&lt;IGrouping&lt;int, Country&gt;&gt;\n            var percentileQuery =\n                from country in countries\n                let percentile = (int) country.Population / 10_000_000\n                group country by percentile into countryGroup\n                where countryGroup.Key &gt;= 20\n                orderby countryGroup.Key\n                select countryGroup;\n\n            // grouping is an IGrouping&lt;int, Country&gt;\n            foreach (var grouping in percentileQuery)\n            {\n                Console.WriteLine(grouping.Key);\n                foreach (var country in grouping)\n                    Console.WriteLine(country.Name + &quot;:&quot; + country.Population);\n            }\n</code></pre><p> For more information, see <a href=\"../language-reference/keywords/into\" data-linktype=\"relative-path\">into</a>.  </p>\n<h3 id=\"filtering-ordering-and-joining\">Filtering, ordering, and joining</h3>\n<p> Between the starting <code>from</code> clause, and the ending <code>select</code> or <code>group</code> clause, all other clauses (<code>where</code>, <code>join</code>, <code>orderby</code>, <code>from</code>, <code>let</code>) are optional. Any of the optional clauses may be used zero times or multiple times in a query body.  </p>\n<h4 id=\"where-clause\">where clause</h4>\n<p> Use the <code>where</code> clause to filter out elements from the source data based on one or more predicate expressions. The <code>where</code> clause in the following example has one predicate with two conditions.  </p>\n<pre><code class=\"lang-cs\" name=\"csrefQueryExpBasics#59\">            IEnumerable&lt;City&gt; queryCityPop =\n                from city in cities\n                where city.Population &lt; 200000 &amp;&amp; city.Population &gt; 100000\n                select city;\n</code></pre><p> For more information, see <a href=\"../language-reference/keywords/where-clause\" data-linktype=\"relative-path\">where clause</a>.  </p>\n<h4 id=\"orderby-clause\">orderby clause</h4>\n<p> Use the <code>orderby</code> clause to sort the results in either ascending or descending order. You can also specify secondary sort orders. The following example performs a primary sort on the <code>country</code> objects by using the <code>Area</code> property. It then performs a secondary sort by using the <code>Population</code> property.  </p>\n<pre><code class=\"lang-cs\" name=\"csrefQueryExpBasics#60\">            IEnumerable&lt;Country&gt; querySortedCountries =\n                from country in countries\n                orderby country.Area, country.Population descending\n                select country;\n</code></pre><p> The <code>ascending</code> keyword is optional; it is the default sort order if no order is specified. For more information, see <a href=\"../language-reference/keywords/orderby-clause\" data-linktype=\"relative-path\">orderby clause</a>.  </p>\n<h4 id=\"join-clause\">join clause</h4>\n<p> Use the <code>join</code> clause to associate and/or combine elements from one data source with elements from another data source based on an equality comparison between specified keys in each element. In LINQ, join operations are performed on sequences of objects whose elements are different types. After you have joined two sequences, you must use a <code>select</code> or <code>group</code> statement to specify which element to store in the output sequence. You can also use an anonymous type to combine properties from each set of associated elements into a new type for the output sequence. The following example associates <code>prod</code> objects whose <code>Category</code> property matches one of the categories in the <code>categories</code> string array. Products whose <code>Category</code> does not match any string in <code>categories</code> are filtered out. The <code>select</code> statement projects a new type whose properties are taken from both <code>cat</code> and <code>prod</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"csrefQueryExpBasics#61\">            var categoryQuery =\n                from cat in categories\n                join prod in products on cat equals prod.Category\n                select new { Category = cat, Name = prod.Name };\n</code></pre><p> You can also perform a group join by storing the results of the <code>join</code> operation into a temporary variable by using the <a href=\"../language-reference/keywords/into\" data-linktype=\"relative-path\">into</a> keyword. For more information, see <a href=\"../language-reference/keywords/join-clause\" data-linktype=\"relative-path\">join clause</a>.  </p>\n<h4 id=\"let-clause\">let clause</h4>\n<p> Use the <code>let</code> clause to store the result of an expression, such as a method call, in a new range variable. In the following example, the range variable <code>firstName</code> stores the first element of the array of strings that is returned by <code>Split</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"csrefQueryExpBasics#62\">            string[] names = { &quot;Svetlana Omelchenko&quot;, &quot;Claire O&#39;Donnell&quot;, &quot;Sven Mortensen&quot;, &quot;Cesar Garcia&quot; };\n            IEnumerable&lt;string&gt; queryFirstNames =\n                from name in names\n                let firstName = name.Split(&#39; &#39;)[0]\n                select firstName;\n\n            foreach (string s in queryFirstNames)\n                Console.Write(s + &quot; &quot;);\n            //Output: Svetlana Claire Sven Cesar\n</code></pre><p> For more information, see <a href=\"../language-reference/keywords/let-clause\" data-linktype=\"relative-path\">let clause</a>.  </p>\n<h3 id=\"subqueries-in-a-query-expression\">Subqueries in a query expression</h3>\n<p> A query clause may itself contain a query expression, which is sometimes referred to as a <em>subquery</em>. Each subquery starts with its own <code>from</code> clause that does not necessarily point to the same data source in the first <code>from</code> clause. For example, the following query shows a query expression that is used in the select statement to retrieve the results of a grouping operation.  </p>\n<pre><code class=\"lang-cs\" name=\"csrefQueryExpBasics#63\">            var queryGroupMax =\n                from student in students\n                group student by student.GradeLevel into studentGroup\n                select new\n                {\n                    Level = studentGroup.Key,\n                    HighestScore =\n                        (from student2 in studentGroup\n                         select student2.Scores.Average())\n                         .Max()\n                };\n</code></pre><p> For more information, see <a href=\"perform-a-subquery-on-a-grouping-operation\" data-linktype=\"relative-path\">How to: perform a subquery on a grouping operation</a>.  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../programming-guide/index\" data-linktype=\"relative-path\">C# programming guide</a><br> <a href=\"index\" data-linktype=\"relative-path\">LINQ query expressions</a><br> <a href=\"../language-reference/keywords/query-keywords\" data-linktype=\"relative-path\">Query keywords (LINQ)</a><br> <a href=\"../programming-guide/concepts/linq/standard-query-operators-overview\" data-linktype=\"relative-path\">Standard query operators overview</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-all/api/toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"dotnet\">\r\n<meta name=\"ms.assetid\" content=\"027db1f8-346f-44d2-a16e-043fcea3a4e0\">\r\n<meta name=\"description\" content=\"Introduces concepts related to query expressions\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core, C#\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"11/30/2016\">\r\n<meta name=\"ms.technology\" content=\".net-core-technologies\">\r\n<meta name=\"ms.prod\" content=\".net-core\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/8bbede952bd9cd464211722059bb4fce6f2e13aa/docs/csharp/linq/query-expression-basics.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/linq/query-expression-basics.md\">\r\n<meta name=\"document_id\" content=\"772baef3-ad1f-dac6-5cfc-aa4fd5fc437f\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Query expression basics | Microsoft Docs","ms.devlang":"dotnet","ms.assetid":"027db1f8-346f-44d2-a16e-043fcea3a4e0","description":"Introduces concepts related to query expressions","keywords":".NET, .NET Core, C#","ms.topic":"article","ms.date":"11/30/2016","ms.technology":".net-core-technologies","ms.prod":".net-core","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"fixed snippet reference (#1690)","commit_sha":"8bbede952bd9cd464211722059bb4fce6f2e13aa","commit_date":"2017-03-10 00:01:08 -0800"},{"author_name":"Steve Hoag","author_email":"shoag@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Updated LINQ topics for C# Concepts section (#1302)","commit_sha":"97a29e60f5d861d848b85ef1e8ed8b1988f9ced1","commit_date":"2016-12-12 09:02:31 -0800"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/8bbede952bd9cd464211722059bb4fce6f2e13aa/docs/csharp/linq/query-expression-basics.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/linq/query-expression-basics.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/linq/query-expression-basics.md","document_id":"772baef3-ad1f-dac6-5cfc-aa4fd5fc437f","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/linq/query-expression-basics","toc_asset_id":"articles/csharp/linq/toc.json","toc_rel":"toc.json","_op_ogTitle":"Query expression basics","_op_displayDate":"2016-11-30","_op_displayDate_source":"2016-11-30T00:00:00Z","_op_wordCount":2494,"_op_rawTitle":"<h1 id=\"query-expression-basics\" sourcefile=\"docs/csharp/linq/query-expression-basics.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Query expression basics</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/linq/query-expression-basics","fileRelativePath":"articles/csharp/linq/query-expression-basics.html"},"themesRelativePathToOutputRoot":"_themes/"}