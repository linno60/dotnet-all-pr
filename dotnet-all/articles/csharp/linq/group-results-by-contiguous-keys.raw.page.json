{"content":"<div><div class=\"content\">\n<p>The following example shows how to group elements into chunks that represent subsequences of contiguous keys. For example, assume that you are given the following sequence of key-value pairs:  </p>\n<table>\n<thead>\n<tr>\n<th>Key</th>\n<th>Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>We</td>\n</tr>\n<tr>\n<td>A</td>\n<td>think</td>\n</tr>\n<tr>\n<td>A</td>\n<td>that</td>\n</tr>\n<tr>\n<td>B</td>\n<td>Linq</td>\n</tr>\n<tr>\n<td>C</td>\n<td>is</td>\n</tr>\n<tr>\n<td>A</td>\n<td>really</td>\n</tr>\n<tr>\n<td>B</td>\n<td>cool</td>\n</tr>\n<tr>\n<td>B</td>\n<td>!</td>\n</tr>\n</tbody>\n</table>\n<p> The following groups will be created in this order:  </p>\n<ol>\n<li><p>We, think, that  </p>\n</li>\n<li><p>Linq  </p>\n</li>\n<li><p>is  </p>\n</li>\n<li><p>really  </p>\n</li>\n<li><p>cool, !  </p>\n<p>The solution is implemented as an extension method that is thread-safe and that returns its results in a streaming manner. In other words, it produces its groups as it moves through the source sequence. Unlike the <code>group</code> or <code>orderby</code> operators, it can begin returning groups to the caller before all of the sequence has been read.  </p>\n<p>Thread-safety is accomplished by making a copy of each group or chunk as the source sequence is iterated, as explained in the source code comments. If the source sequence has a large sequence of contiguous items, the common language runtime may throw an <a class=\"xref\" href=\"../../../api/system.outofmemoryexception\" data-linktype=\"relative-path\">OutOfMemoryException</a>.  </p>\n</li>\n</ol>\n<h2 id=\"example\">Example</h2>\n<p> The following example shows both the extension method and the client code that uses it.  </p>\n<pre><code class=\"lang-cs\" name=\"cscsrefContiguousGroups#1\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\n\nnamespace ChunkIt\n{\n    // Static class to contain the extension methods.\n    public static class MyExtensions\n    {\n        public static IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt; ChunkBy&lt;TSource, TKey&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector)\n        {\n            return source.ChunkBy(keySelector, EqualityComparer&lt;TKey&gt;.Default);\n        }\n\n        public static IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt; ChunkBy&lt;TSource, TKey&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, TKey&gt; keySelector, IEqualityComparer&lt;TKey&gt; comparer)\n        {\n            // Flag to signal end of source sequence.\n            const bool noMoreSourceElements = true;\n\n            // Auto-generated iterator for the source array.       \n            var enumerator = source.GetEnumerator();\n\n            // Move to the first element in the source sequence.\n            if (!enumerator.MoveNext()) yield break;\n\n            // Iterate through source sequence and create a copy of each Chunk.\n            // On each pass, the iterator advances to the first element of the next &quot;Chunk&quot;\n            // in the source sequence. This loop corresponds to the outer foreach loop that\n            // executes the query.\n            Chunk&lt;TKey, TSource&gt; current = null;\n            while (true)\n            {\n                // Get the key for the current Chunk. The source iterator will churn through\n                // the source sequence until it finds an element with a key that doesn&#39;t match.\n                var key = keySelector(enumerator.Current);\n\n                // Make a new Chunk (group) object that initially has one GroupItem, which is a copy of the current source element.\n                current = new Chunk&lt;TKey, TSource&gt;(key, enumerator, value =&gt; comparer.Equals(key, keySelector(value)));\n\n                // Return the Chunk. A Chunk is an IGrouping&lt;TKey,TSource&gt;, which is the return value of the ChunkBy method.\n                // At this point the Chunk only has the first element in its source sequence. The remaining elements will be\n                // returned only when the client code foreach&#39;s over this chunk. See Chunk.GetEnumerator for more info.\n                yield return current;\n\n                // Check to see whether (a) the chunk has made a copy of all its source elements or \n                // (b) the iterator has reached the end of the source sequence. If the caller uses an inner\n                // foreach loop to iterate the chunk items, and that loop ran to completion,\n                // then the Chunk.GetEnumerator method will already have made\n                // copies of all chunk items before we get here. If the Chunk.GetEnumerator loop did not\n                // enumerate all elements in the chunk, we need to do it here to avoid corrupting the iterator\n                // for clients that may be calling us on a separate thread.\n                if (current.CopyAllChunkElements() == noMoreSourceElements)\n                {\n                    yield break;\n                }\n            }\n        }\n\n        // A Chunk is a contiguous group of one or more source elements that have the same key. A Chunk \n        // has a key and a list of ChunkItem objects, which are copies of the elements in the source sequence.\n        class Chunk&lt;TKey, TSource&gt; : IGrouping&lt;TKey, TSource&gt;\n        {\n            // INVARIANT: DoneCopyingChunk == true || \n            //   (predicate != null &amp;&amp; predicate(enumerator.Current) &amp;&amp; current.Value == enumerator.Current)\n\n            // A Chunk has a linked list of ChunkItems, which represent the elements in the current chunk. Each ChunkItem\n            // has a reference to the next ChunkItem in the list.\n            class ChunkItem\n            {\n                public ChunkItem(TSource value)\n                {\n                    Value = value;\n                }\n                public readonly TSource Value;\n                public ChunkItem Next = null;\n            }\n            // The value that is used to determine matching elements\n            private readonly TKey key;\n\n            // Stores a reference to the enumerator for the source sequence\n            private IEnumerator&lt;TSource&gt; enumerator;\n\n            // A reference to the predicate that is used to compare keys.\n            private Func&lt;TSource, bool&gt; predicate;\n\n            // Stores the contents of the first source element that\n            // belongs with this chunk.\n            private readonly ChunkItem head;\n\n            // End of the list. It is repositioned each time a new\n            // ChunkItem is added.\n            private ChunkItem tail;\n\n            // Flag to indicate the source iterator has reached the end of the source sequence.\n            internal bool isLastSourceElement = false;\n\n            // Private object for thread syncronization\n            private object m_Lock;\n\n            // REQUIRES: enumerator != null &amp;&amp; predicate != null\n            public Chunk(TKey key, IEnumerator&lt;TSource&gt; enumerator, Func&lt;TSource, bool&gt; predicate)\n            {\n                this.key = key;\n                this.enumerator = enumerator;\n                this.predicate = predicate;\n\n                // A Chunk always contains at least one element.\n                head = new ChunkItem(enumerator.Current);\n\n                // The end and beginning are the same until the list contains &gt; 1 elements.\n                tail = head;\n\n                m_Lock = new object();\n            }\n\n            // Indicates that all chunk elements have been copied to the list of ChunkItems, \n            // and the source enumerator is either at the end, or else on an element with a new key.\n            // the tail of the linked list is set to null in the CopyNextChunkElement method if the\n            // key of the next element does not match the current chunk&#39;s key, or there are no more elements in the source.\n            private bool DoneCopyingChunk =&gt; tail == null;\n\n            // Adds one ChunkItem to the current group\n            // REQUIRES: !DoneCopyingChunk &amp;&amp; lock(this)\n            private void CopyNextChunkElement()\n            {\n                // Try to advance the iterator on the source sequence.\n                // If MoveNext returns false we are at the end, and isLastSourceElement is set to true\n                isLastSourceElement = !enumerator.MoveNext();\n\n                // If we are (a) at the end of the source, or (b) at the end of the current chunk\n                // then null out the enumerator and predicate for reuse with the next chunk.\n                if (isLastSourceElement || !predicate(enumerator.Current))\n                {\n                    enumerator = null;\n                    predicate = null;\n                }\n                else\n                {\n                    tail.Next = new ChunkItem(enumerator.Current);\n                }\n\n                // tail will be null if we are at the end of the chunk elements\n                // This check is made in DoneCopyingChunk.\n                tail = tail.Next;\n            }\n\n            // Called after the end of the last chunk was reached. It first checks whether\n            // there are more elements in the source sequence. If there are, it \n            // Returns true if enumerator for this chunk was exhausted.\n            internal bool CopyAllChunkElements()\n            {\n                while (true)\n                {\n                    lock (m_Lock)\n                    {\n                        if (DoneCopyingChunk)\n                        {\n                            // If isLastSourceElement is false,\n                            // it signals to the outer iterator\n                            // to continue iterating.\n                            return isLastSourceElement;\n                        }\n                        else\n                        {\n                            CopyNextChunkElement();\n                        }\n                    }\n                }\n            }\n\n            public TKey Key =&gt; key;\n\n            // Invoked by the inner foreach loop. This method stays just one step ahead\n            // of the client requests. It adds the next element of the chunk only after\n            // the clients requests the last element in the list so far.\n            public IEnumerator&lt;TSource&gt; GetEnumerator()\n            {\n                //Specify the initial element to enumerate.\n                ChunkItem current = head;\n\n                // There should always be at least one ChunkItem in a Chunk.\n                while (current != null)\n                {\n                    // Yield the current item in the list.\n                    yield return current.Value;\n\n                    // Copy the next item from the source sequence, \n                    // if we are at the end of our local list.\n                    lock (m_Lock)\n                    {\n                        if (current == tail)\n                        {\n                            CopyNextChunkElement();\n                        }\n                    }\n\n                    // Move to the next ChunkItem in the list.\n                    current = current.Next;\n                }\n            }\n\n            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()  =&gt; GetEnumerator();\n            {\n                return GetEnumerator();\n            }\n        }\n    }\n\n    // A simple named type is used for easier viewing in the debugger. Anonymous types\n    // work just as well with the ChunkBy operator.\n    public class KeyValPair\n    {\n        public string Key { get; set; }\n        public string Value { get; set; }\n    }\n\n    class Program\n    {\n        // The source sequence.\n        public static IEnumerable&lt;KeyValPair&gt; list;\n\n        // Query variable declared as class member to be available\n        // on different threads.\n        static IEnumerable&lt;IGrouping&lt;string, KeyValPair&gt;&gt; query;\n\n\n        static void Main(string[] args)\n        {\n            // Initialize the source sequence with an array initializer.\n            list = new[]\n        {\n            new KeyValPair{ Key = &quot;A&quot;, Value = &quot;We&quot; },\n            new KeyValPair{ Key = &quot;A&quot;, Value = &quot;Think&quot; },\n            new KeyValPair{ Key = &quot;A&quot;, Value = &quot;That&quot; },\n            new KeyValPair{ Key = &quot;B&quot;, Value = &quot;Linq&quot; },\n            new KeyValPair{ Key = &quot;C&quot;, Value = &quot;Is&quot; },\n            new KeyValPair{ Key = &quot;A&quot;, Value = &quot;Really&quot; },\n            new KeyValPair{ Key = &quot;B&quot;, Value = &quot;Cool&quot; },\n            new KeyValPair{ Key = &quot;B&quot;, Value = &quot;!&quot; }\n        };\n\n            // Create the query by using our user-defined query operator.\n            query = list.ChunkBy(p =&gt; p.Key);\n\n            \n            // ChunkBy returns IGrouping objects, therefore a nested\n            // foreach loop is required to access the elements in each &quot;chunk&quot;.\n            foreach (var item in query)\n            {\n                Console.WriteLine(&quot;Group key = {0}&quot;, item.Key);\n                foreach (var inner in item)\n                {\n                    Console.WriteLine($&quot;\\t{inner.Value}&quot;);\n                }\n            }\n\n            Console.WriteLine(&quot;Press any key to exit&quot;);\n            Console.ReadKey();\n        }       \n\n     }\n}\n</code></pre><p> To use the extension method in your project, copy the <code>MyExtensions</code> static class to a new or existing source code file and if it is required, add a <code>using</code> directive for the namespace where it is located.  </p>\n<h2 id=\"see-also\">See also</h2>\n<p> <a href=\"index\" data-linktype=\"relative-path\">LINQ Query Expressions</a>   </p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"dotnet\">\r\n<meta name=\"ms.assetid\" content=\"cbda9c08-151b-4c9e-82f7-c3d7f3dac66b\">\r\n<meta name=\"description\" content=\"How to group results by contiguous keys.\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core, C#\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"12/1/2016\">\r\n<meta name=\"ms.technology\" content=\".net-core-technologies\">\r\n<meta name=\"ms.prod\" content=\".net-core\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/97a29e60f5d861d848b85ef1e8ed8b1988f9ced1/docs/csharp/linq/group-results-by-contiguous-keys.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/linq/group-results-by-contiguous-keys.md\">\r\n<meta name=\"document_id\" content=\"3f0817f4-1c27-b7f9-c798-379231d433f0\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Group results by contiguous keys | Microsoft Docs","ms.devlang":"dotnet","ms.assetid":"cbda9c08-151b-4c9e-82f7-c3d7f3dac66b","description":"How to group results by contiguous keys.","keywords":".NET, .NET Core, C#","ms.topic":"article","ms.date":"12/1/2016","ms.technology":".net-core-technologies","ms.prod":".net-core","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Steve Hoag","author_email":"shoag@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Updated LINQ topics for C# Concepts section (#1302)","commit_sha":"97a29e60f5d861d848b85ef1e8ed8b1988f9ced1","commit_date":"2016-12-12 09:02:31 -0800"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/97a29e60f5d861d848b85ef1e8ed8b1988f9ced1/docs/csharp/linq/group-results-by-contiguous-keys.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/linq/group-results-by-contiguous-keys.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/linq/group-results-by-contiguous-keys.md","document_id":"3f0817f4-1c27-b7f9-c798-379231d433f0","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/linq/group-results-by-contiguous-keys","toc_asset_id":"articles/csharp/linq/toc.json","toc_rel":"toc.json","_op_ogTitle":"Group results by contiguous keys","_op_displayDate":"2016-12-1","_op_displayDate_source":"2016-12-01T00:00:00Z","_op_wordCount":1536,"_op_rawTitle":"<h1 id=\"group-results-by-contiguous-keys\" sourcefile=\"docs/csharp/linq/group-results-by-contiguous-keys.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Group results by contiguous keys</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/linq/group-results-by-contiguous-keys","fileRelativePath":"articles/csharp/linq/group-results-by-contiguous-keys.html"},"themesRelativePathToOutputRoot":"_themes/"}