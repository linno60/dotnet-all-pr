{"content":"<div><div class=\"content\">\n<p>In relational database terms, an <em>inner join</em> produces a result set in which each element of the first collection appears one time for every matching element in the second collection. If an element in the first collection has no matching elements, it does not appear in the result set. The <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/bb344797(v=vs.110).aspx\" data-linktype=\"external\">Join</a> method, which is called by the <code>join</code> clause in C#, implements an inner join.  </p>\n<p> This topic shows you how to perform four variations of an inner join:  </p>\n<ul>\n<li><p>A simple inner join that correlates elements from two data sources based on a simple key.  </p>\n</li>\n<li><p>An inner join that correlates elements from two data sources based on a <em>composite</em> key. A composite key, which is a key that consists of more than one value, enables you to correlate elements based on more than one property.  </p>\n</li>\n<li><p>A <em>multiple join</em> in which successive join operations are appended to each other.  </p>\n</li>\n<li><p>An inner join that is implemented by using a group join.  </p>\n</li>\n</ul>\n<h2 id=\"example\">Example</h2>\n<h2 id=\"simple-key-join-example\">Simple key join example</h2>\n<p> The following example creates two collections that contain objects of two user-defined types, <code>Person</code> and <code>Pet</code>. The query uses the <code>join</code> clause in C# to match <code>Person</code> objects with <code>Pet</code> objects whose <code>Owner</code> is that <code>Person</code>. The <code>select</code> clause in C# defines how the resulting objects will look. In this example the resulting objects are anonymous types that consist of the owner&#39;s first name and the pet&#39;s name.  </p>\n<pre><code class=\"lang-cs\" name=\"CsLINQProgJoining#1\">        class Person\n        {\n            public string FirstName { get; set; }\n            public string LastName { get; set; }\n        }\n\n        class Pet\n        {\n            public string Name { get; set; }\n            public Person Owner { get; set; }\n        }\n\n        /// &lt;summary&gt;\n        /// Simple inner join.\n        /// &lt;/summary&gt;\n        public static void InnerJoinExample()\n        {\n            Person magnus = new Person { FirstName = &quot;Magnus&quot;, LastName = &quot;Hedlund&quot; };\n            Person terry = new Person { FirstName = &quot;Terry&quot;, LastName = &quot;Adams&quot; };\n            Person charlotte = new Person { FirstName = &quot;Charlotte&quot;, LastName = &quot;Weiss&quot; };\n            Person arlene = new Person { FirstName = &quot;Arlene&quot;, LastName = &quot;Huff&quot; };\n            Person rui = new Person { FirstName = &quot;Rui&quot;, LastName = &quot;Raposo&quot; };\n\n            Pet barley = new Pet { Name = &quot;Barley&quot;, Owner = terry };\n            Pet boots = new Pet { Name = &quot;Boots&quot;, Owner = terry };\n            Pet whiskers = new Pet { Name = &quot;Whiskers&quot;, Owner = charlotte };\n            Pet bluemoon = new Pet { Name = &quot;Blue Moon&quot;, Owner = rui };\n            Pet daisy = new Pet { Name = &quot;Daisy&quot;, Owner = magnus };\n\n            // Create two lists.\n            List&lt;Person&gt; people = new List&lt;Person&gt; { magnus, terry, charlotte, arlene, rui };\n            List&lt;Pet&gt; pets = new List&lt;Pet&gt; { barley, boots, whiskers, bluemoon, daisy };\n\n            // Create a collection of person-pet pairs. Each element in the collection\n            // is an anonymous type containing both the person&#39;s name and their pet&#39;s name.\n            var query = from person in people\n                        join pet in pets on person equals pet.Owner\n                        select new { OwnerName = person.FirstName, PetName = pet.Name };\n\n            foreach (var ownerAndPet in query)\n            {\n                Console.WriteLine($&quot;\\&quot;{ownerAndPet.PetName}\\&quot; is owned by {ownerAndPet.OwnerName}&quot;);\n            }\n        }\n\n        // This code produces the following output:\n        //\n        // &quot;Daisy&quot; is owned by Magnus\n        // &quot;Barley&quot; is owned by Terry\n        // &quot;Boots&quot; is owned by Terry\n        // &quot;Whiskers&quot; is owned by Charlotte\n        // &quot;Blue Moon&quot; is owned by Rui\n</code></pre><p> Note that the <code>Person</code> object whose <code>LastName</code> is &quot;Huff&quot; does not appear in the result set because there is no <code>Pet</code> object that has <code>Pet.Owner</code> equal to that <code>Person</code>.  </p>\n<h2 id=\"example-1\">Example</h2>\n<h2 id=\"composite-key-join-example\">Composite key join example</h2>\n<p> Instead of correlating elements based on just one property, you can use a composite key to compare elements based on multiple properties. To do this, specify the key selector function for each collection to return an anonymous type that consists of the properties you want to compare. If you label the properties, they must have the same label in each key&#39;s anonymous type. The properties must also appear in the same order.  </p>\n<p> The following example uses a list of <code>Employee</code> objects and a list of <code>Student</code> objects to determine which employees are also students. Both of these types have a <code>FirstName</code> and a <code>LastName</code> property of type <a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String</a>. The functions that create the join keys from each list&#39;s elements return an anonymous type that consists of the <code>FirstName</code> and <code>LastName</code> properties of each element. The join operation compares these composite keys for equality and returns pairs of objects from each list where both the first name and the last name match.  </p>\n<pre><code class=\"lang-cs\" name=\"CsLINQProgJoining#2\">        class Employee\n        {\n            public string FirstName { get; set; }\n            public string LastName { get; set; }\n            public int EmployeeID { get; set; }\n        }\n\n        class Student\n        {\n            public string FirstName { get; set; }\n            public string LastName { get; set; }\n            public int StudentID { get; set; }\n        }\n\n        /// &lt;summary&gt;\n        /// Performs a join operation using a composite key.\n        /// &lt;/summary&gt;\n        public static void CompositeKeyJoinExample()\n        {\n            // Create a list of employees.\n            List&lt;Employee&gt; employees = new List&lt;Employee&gt; {\n                new Employee { FirstName = &quot;Terry&quot;, LastName = &quot;Adams&quot;, EmployeeID = 522459 },\n                 new Employee { FirstName = &quot;Charlotte&quot;, LastName = &quot;Weiss&quot;, EmployeeID = 204467 },\n                 new Employee { FirstName = &quot;Magnus&quot;, LastName = &quot;Hedland&quot;, EmployeeID = 866200 },\n                 new Employee { FirstName = &quot;Vernette&quot;, LastName = &quot;Price&quot;, EmployeeID = 437139 } };\n\n            // Create a list of students.\n            List&lt;Student&gt; students = new List&lt;Student&gt; {\n                new Student { FirstName = &quot;Vernette&quot;, LastName = &quot;Price&quot;, StudentID = 9562 },\n                new Student { FirstName = &quot;Terry&quot;, LastName = &quot;Earls&quot;, StudentID = 9870 },\n                new Student { FirstName = &quot;Terry&quot;, LastName = &quot;Adams&quot;, StudentID = 9913 } };\n\n            // Join the two data sources based on a composite key consisting of first and last name,\n            // to determine which employees are also students.\n            IEnumerable&lt;string&gt; query = from employee in employees\n                                        join student in students\n                                        on new { employee.FirstName, employee.LastName }\n                                        equals new { student.FirstName, student.LastName }\n                                        select employee.FirstName + &quot; &quot; + employee.LastName;\n\n            Console.WriteLine(&quot;The following people are both employees and students:&quot;);\n            foreach (string name in query)\n                Console.WriteLine(name);\n        }\n\n        // This code produces the following output:\n        //\n        // The following people are both employees and students:\n        // Terry Adams\n        // Vernette Price\n</code></pre><h2 id=\"example-2\">Example</h2>\n<h2 id=\"multiple-join-example\">Multiple join example</h2>\n<p> Any number of join operations can be appended to each other to perform a multiple join. Each <code>join</code> clause in C# correlates a specified data source with the results of the previous join.  </p>\n<p> The following example creates three collections: a list of <code>Person</code> objects, a list of <code>Cat</code> objects, and a list of <code>Dog</code> objects.  </p>\n<p> The first <code>join</code> clause in C# matches people and cats based on a <code>Person</code> object matching <code>Cat.Owner</code>. It returns a sequence of anonymous types that contain the <code>Person</code> object and <code>Cat.Name</code>.  </p>\n<p> The second <code>join</code> clause in C# correlates the anonymous types returned by the first join with <code>Dog</code> objects in the supplied list of dogs, based on a composite key that consists of the <code>Owner</code> property of type <code>Person</code>, and the first letter of the animal&#39;s name. It returns a sequence of anonymous types that contain the <code>Cat.Name</code> and <code>Dog.Name</code> properties from each matching pair. Because this is an inner join, only those objects from the first data source that have a match in the second data source are returned.  </p>\n<pre><code class=\"lang-cs\" name=\"CsLINQProgJoining#3\">        class Person\n        {\n            public string FirstName { get; set; }\n            public string LastName { get; set; }\n        }\n\n        class Pet\n        {\n            public string Name { get; set; }\n            public Person Owner { get; set; }\n        }\n\n        class Cat : Pet\n        { }\n\n        class Dog : Pet\n        { }\n\n        public static void MultipleJoinExample()\n        {\n            Person magnus = new Person { FirstName = &quot;Magnus&quot;, LastName = &quot;Hedlund&quot; };\n            Person terry = new Person { FirstName = &quot;Terry&quot;, LastName = &quot;Adams&quot; };\n            Person charlotte = new Person { FirstName = &quot;Charlotte&quot;, LastName = &quot;Weiss&quot; };\n            Person arlene = new Person { FirstName = &quot;Arlene&quot;, LastName = &quot;Huff&quot; };\n            Person rui = new Person { FirstName = &quot;Rui&quot;, LastName = &quot;Raposo&quot; };\n            Person phyllis = new Person { FirstName = &quot;Phyllis&quot;, LastName = &quot;Harris&quot; };\n\n            Cat barley = new Cat { Name = &quot;Barley&quot;, Owner = terry };\n            Cat boots = new Cat { Name = &quot;Boots&quot;, Owner = terry };\n            Cat whiskers = new Cat { Name = &quot;Whiskers&quot;, Owner = charlotte };\n            Cat bluemoon = new Cat { Name = &quot;Blue Moon&quot;, Owner = rui };\n            Cat daisy = new Cat { Name = &quot;Daisy&quot;, Owner = magnus };\n\n            Dog fourwheeldrive = new Dog { Name = &quot;Four Wheel Drive&quot;, Owner = phyllis };\n            Dog duke = new Dog { Name = &quot;Duke&quot;, Owner = magnus };\n            Dog denim = new Dog { Name = &quot;Denim&quot;, Owner = terry };\n            Dog wiley = new Dog { Name = &quot;Wiley&quot;, Owner = charlotte };\n            Dog snoopy = new Dog { Name = &quot;Snoopy&quot;, Owner = rui };\n            Dog snickers = new Dog { Name = &quot;Snickers&quot;, Owner = arlene };\n\n            // Create three lists.\n            List&lt;Person&gt; people =\n                new List&lt;Person&gt; { magnus, terry, charlotte, arlene, rui, phyllis };\n            List&lt;Cat&gt; cats =\n                new List&lt;Cat&gt; { barley, boots, whiskers, bluemoon, daisy };\n            List&lt;Dog&gt; dogs =\n                new List&lt;Dog&gt; { fourwheeldrive, duke, denim, wiley, snoopy, snickers };\n\n            // The first join matches Person and Cat.Owner from the list of people and\n            // cats, based on a common Person. The second join matches dogs whose names start\n            // with the same letter as the cats that have the same owner.\n            var query = from person in people\n                        join cat in cats on person equals cat.Owner\n                        join dog in dogs on \n                        new { Owner = person, Letter = cat.Name.Substring(0, 1) }\n                        equals new { dog.Owner, Letter = dog.Name.Substring(0, 1) }\n                        select new { CatName = cat.Name, DogName = dog.Name };\n\n            foreach (var obj in query)\n            {\n                Console.WriteLine( \n                    $&quot;The cat \\&quot;{obj.CatName}\\&quot; shares a house, and the first letter of their name,\n                    with \\&quot;{obj.DogName}\\&quot;.&quot;);  \n            }\n        }\n\n        // This code produces the following output:\n        //\n        // The cat &quot;Daisy&quot; shares a house, and the first letter of their name, with &quot;Duke&quot;.\n        // The cat &quot;Whiskers&quot; shares a house, and the first letter of their name, with &quot;Wiley&quot;.\n</code></pre><h2 id=\"example-3\">Example</h2>\n<h2 id=\"inner-join-by-using-grouped-join-example\">Inner join by using grouped join example</h2>\n<p> The following example shows you how to implement an inner join by using a group join.  </p>\n<p> In <code>query1</code>, the list of <code>Person</code> objects is group-joined to the list of <code>Pet</code> objects based on the <code>Person</code> matching the <code>Pet.Owner</code> property. The group join creates a collection of intermediate groups, where each group consists of a <code>Person</code> object and a sequence of matching <code>Pet</code> objects.  </p>\n<p> By adding a second <code>from</code> clause to the query, this sequence of sequences is combined (or flattened) into one longer sequence. The type of the elements of the final sequence is specified by the <code>select</code> clause. In this example, that type is an anonymous type that consists of the <code>Person.FirstName</code> and <code>Pet.Name</code> properties for each matching pair.  </p>\n<p> The result of <code>query1</code> is equivalent to the result set that would have been obtained by using the <code>join</code> clause without the <code>into</code> clause to perform an inner join. The <code>query2</code> variable demonstrates this equivalent query.  </p>\n<pre><code class=\"lang-cs\" name=\"CsLINQProgJoining#4\">        class Person\n        {\n            public string FirstName { get; set; }\n            public string LastName { get; set; }\n        }\n\n        class Pet\n        {\n            public string Name { get; set; }\n            public Person Owner { get; set; }\n        }\n\n        /// &lt;summary&gt;\n        /// Performs an inner join by using GroupJoin().\n        /// &lt;/summary&gt;\n        public static void InnerGroupJoinExample()\n        {\n            Person magnus = new Person { FirstName = &quot;Magnus&quot;, LastName = &quot;Hedlund&quot; };\n            Person terry = new Person { FirstName = &quot;Terry&quot;, LastName = &quot;Adams&quot; };\n            Person charlotte = new Person { FirstName = &quot;Charlotte&quot;, LastName = &quot;Weiss&quot; };\n            Person arlene = new Person { FirstName = &quot;Arlene&quot;, LastName = &quot;Huff&quot; };\n\n            Pet barley = new Pet { Name = &quot;Barley&quot;, Owner = terry };\n            Pet boots = new Pet { Name = &quot;Boots&quot;, Owner = terry };\n            Pet whiskers = new Pet { Name = &quot;Whiskers&quot;, Owner = charlotte };\n            Pet bluemoon = new Pet { Name = &quot;Blue Moon&quot;, Owner = terry };\n            Pet daisy = new Pet { Name = &quot;Daisy&quot;, Owner = magnus };\n\n            // Create two lists.\n            List&lt;Person&gt; people = new List&lt;Person&gt; { magnus, terry, charlotte, arlene };\n            List&lt;Pet&gt; pets = new List&lt;Pet&gt; { barley, boots, whiskers, bluemoon, daisy };\n\n            var query1 = from person in people\n                         join pet in pets on person equals pet.Owner into gj\n                         from subpet in gj\n                         select new { OwnerName = person.FirstName, PetName = subpet.Name };\n\n            Console.WriteLine(&quot;Inner join using GroupJoin():&quot;);\n            foreach (var v in query1)\n            {\n                Console.WriteLine($&quot;{v.OwnerName} - {v.PetName}&quot;));\n            }\n\n            var query2 = from person in people\n                         join pet in pets on person equals pet.Owner\n                         select new { OwnerName = person.FirstName, PetName = pet.Name };\n                \n            Console.WriteLine(&quot;\\nThe equivalent operation using Join():&quot;);\n            foreach (var v in query2)\n                Console.WriteLine($&quot;{v.OwnerName} - {v.PetName}&quot;));\n        }\n\n        // This code produces the following output:\n        //\n        // Inner join using GroupJoin():\n        // Magnus - Daisy\n        // Terry - Barley\n        // Terry - Boots\n        // Terry - Blue Moon\n        // Charlotte - Whiskers\n        //\n        // The equivalent operation using Join():\n        // Magnus - Daisy\n        // Terry - Barley\n        // Terry - Boots\n        // Terry - Blue Moon\n        // Charlotte - Whiskers\n</code></pre><h2 id=\"see-also\">See also</h2>\n<p> <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/bb344797(v=vs.110).aspx\" data-linktype=\"external\">Join</a><br> <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/bb358101(v=vs.110).aspx\" data-linktype=\"external\">GroupJoin</a><br> <a href=\"perform-grouped-joins\" data-linktype=\"relative-path\">Perform grouped joins</a><br> <a href=\"perform-left-outer-joins\" data-linktype=\"relative-path\">Perform left outer joins</a><br> <a href=\"../programming-guide/classes-and-structs/anonymous-types\" data-linktype=\"relative-path\">Anonymous types</a>   </p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet/toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"dotnet\">\r\n<meta name=\"ms.assetid\" content=\"45bceed6-f549-4114-a9b1-b44feb497742\">\r\n<meta name=\"description\" content=\"How to perform inner joins.\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core, C#\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"12/1/2016\">\r\n<meta name=\"ms.technology\" content=\".net-core-technologies\">\r\n<meta name=\"ms.prod\" content=\".net-core\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/97a29e60f5d861d848b85ef1e8ed8b1988f9ced1/docs/csharp/linq/perform-inner-joins.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/linq/perform-inner-joins.md\">\r\n<meta name=\"document_id\" content=\"28708e42-4389-8dc0-6a44-a8d471ace1d9\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Perform inner joins | Microsoft Docs","ms.devlang":"dotnet","ms.assetid":"45bceed6-f549-4114-a9b1-b44feb497742","description":"How to perform inner joins.","keywords":".NET, .NET Core, C#","ms.topic":"article","ms.date":"12/1/2016","ms.technology":".net-core-technologies","ms.prod":".net-core","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Steve Hoag","author_email":"shoag@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Updated LINQ topics for C# Concepts section (#1302)","commit_sha":"97a29e60f5d861d848b85ef1e8ed8b1988f9ced1","commit_date":"2016-12-12 09:02:31 -0800"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/97a29e60f5d861d848b85ef1e8ed8b1988f9ced1/docs/csharp/linq/perform-inner-joins.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/linq/perform-inner-joins.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/linq/perform-inner-joins.md","document_id":"28708e42-4389-8dc0-6a44-a8d471ace1d9","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/linq/perform-inner-joins","toc_asset_id":"articles/csharp/linq/toc.json","toc_rel":"toc.json","_op_ogTitle":"Perform inner joins","_op_displayDate":"2016-12-1","_op_displayDate_source":"2016-12-01T00:00:00Z","_op_wordCount":2183,"_op_rawTitle":"<h1 id=\"perform-inner-joins\" sourcefile=\"docs/csharp/linq/perform-inner-joins.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Perform inner joins</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/linq/perform-inner-joins","fileRelativePath":"articles/csharp/linq/perform-inner-joins.html"},"themesRelativePathToOutputRoot":"_themes/"}