{"content":"<div><div class=\"content\">\n<p>This example shows how to perform join operations that are not possible with the <code>join</code> clause. In a query expression, the <code>join</code> clause is limited to, and optimized for, equijoins, which are by far the most common type of join operation. When performing an equijoin, you will probably always get the best performance by using the <code>join</code> clause.  </p>\n<p> However, the <code>join</code> clause cannot be used in the following cases:  </p>\n<ul>\n<li><p>When the join is predicated on an expression of inequality (a non-equijoin).  </p>\n</li>\n<li><p>When the join is predicated on more than one expression of equality or inequality.  </p>\n</li>\n<li><p>When you have to introduce a temporary range variable for the right side (inner) sequence before the join operation.  </p>\n</li>\n</ul>\n<p> To perform joins that are not equijoins, you can use multiple <code>from</code> clauses to introduce each data source independently. You then apply a predicate expression in a <code>where</code> clause to the range variable for each source. The expression also can take the form of a method call.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Do not confuse this kind of custom join operation with the use of multiple <code>from</code> clauses to access inner collections. For more information, see <a href=\"../language-reference/keywords/join-clause\" data-linktype=\"relative-path\">join clause</a>.  </p>\n</div>\n<h2 id=\"example\">Example</h2>\n<p> The first method in the following example shows a simple cross join. Cross joins must be used with caution because they can produce very large result sets. However, they can be useful in some scenarios for creating source sequences against which additional queries are run.  </p>\n<p> The second method produces a sequence of all the products whose category ID is listed in the category list on the left side. Note the use of the <code>let</code> clause and the <code>Contains</code> method to create a temporary array. It also is possible to create the array before the query and eliminate the first <code>from</code> clause.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideLINQ#64\">     class CustomJoins\n     {\n\n         #region Data\n\n         class Product\n         {\n             public string Name { get; set; }\n             public int CategoryID { get; set; }\n         }\n\n         class Category\n         {\n             public string Name { get; set; }\n             public int ID { get; set; }\n         }\n\n         // Specify the first data source.\n         List&lt;Category&gt; categories = new List&lt;Category&gt;()\n { \n     new Category(){Name=&quot;Beverages&quot;, ID=001},\n     new Category(){ Name=&quot;Condiments&quot;, ID=002},\n     new Category(){ Name=&quot;Vegetables&quot;, ID=003},         \n };\n\n         // Specify the second data source.\n         List&lt;Product&gt; products = new List&lt;Product&gt;()\n{\n   new Product{Name=&quot;Tea&quot;,  CategoryID=001},\n   new Product{Name=&quot;Mustard&quot;, CategoryID=002},\n   new Product{Name=&quot;Pickles&quot;, CategoryID=002},\n   new Product{Name=&quot;Carrots&quot;, CategoryID=003},\n   new Product{Name=&quot;Bok Choy&quot;, CategoryID=003},\n   new Product{Name=&quot;Peaches&quot;, CategoryID=005},\n   new Product{Name=&quot;Melons&quot;, CategoryID=005},\n   new Product{Name=&quot;Ice Cream&quot;, CategoryID=007},\n   new Product{Name=&quot;Mackerel&quot;, CategoryID=012},\n };\n         #endregion\n\n         static void Main()\n         {\n             CustomJoins app = new CustomJoins();\n             app.CrossJoin();\n             app.NonEquijoin();\n\n             Console.WriteLine(&quot;Press any key to exit.&quot;);\n             Console.ReadKey();\n         }\n\n         void CrossJoin()\n         {\n             var crossJoinQuery =\n                 from c in categories\n                 from p in products\n                 select new { c.ID, p.Name };\n\n             Console.WriteLine(&quot;Cross Join Query:&quot;);\n             foreach (var v in crossJoinQuery)\n             {\n                 Console.WriteLine($&quot;v.ID:-5}{v.Name});\n             }\n         }\n\n         void NonEquijoin()\n         {\n             var nonEquijoinQuery =\n                 from p in products\n                 let catIds = from c in categories\n                              select c.ID\n                 where catIds.Contains(p.CategoryID) == true\n                 select new { Product = p.Name, CategoryID = p.CategoryID };\n\n             Console.WriteLine(&quot;Non-equijoin query:&quot;);\n             foreach (var v in nonEquijoinQuery)\n             {\n                 Console.WriteLine($&quot;{v.CategoryID:-5}{v.Product}&quot;);\n             }\n         }\n     }\n     /* Output:\n Cross Join Query:\n 1    Tea\n 1    Mustard\n 1    Pickles\n 1    Carrots\n 1    Bok Choy\n 1    Peaches\n 1    Melons\n 1    Ice Cream\n 1    Mackerel\n 2    Tea\n 2    Mustard\n 2    Pickles\n 2    Carrots\n 2    Bok Choy\n 2    Peaches\n 2    Melons\n 2    Ice Cream\n 2    Mackerel\n 3    Tea\n 3    Mustard\n 3    Pickles\n 3    Carrots\n 3    Bok Choy\n 3    Peaches\n 3    Melons\n 3    Ice Cream\n 3    Mackerel\n Non-equijoin query:\n 1    Tea\n 2    Mustard\n 2    Pickles\n 3    Carrots\n 3    Bok Choy\n Press any key to exit.\n      */\n</code></pre><h2 id=\"example-1\">Example</h2>\n<p> In the following example, the query must join two sequences based on matching keys that, in the case of the inner (right side) sequence, cannot be obtained prior to the join clause itself. If this join were performed with a <code>join</code> clause, then the <code>Split</code> method would have to be called for each element. The use of multiple <code>from</code> clauses enables the query to avoid the overhead of the repeated method call. However, since <code>join</code> is optimized, in this particular case it might still be faster than using multiple <code>from</code> clauses. The results will vary depending primarily on how expensive the method call is.  </p>\n<pre><code class=\"lang-cs\" name=\"csProgGuideLINQ#13\">class MergeTwoCSVFiles\n{\n    static void Main()\n    {\n        // See section Compiling the Code for information about the data files.\n        string[] names = System.IO.File.ReadAllLines(@&quot;../../../names.csv&quot;);\n        string[] scores = System.IO.File.ReadAllLines(@&quot;../../../scores.csv&quot;);\n\n        // Merge the data sources using a named type.\n        // You could use var instead of an explicit type for the query.\n        IEnumerable&lt;Student&gt; queryNamesScores =\n            // Split each line in the data files into an array of strings.\n            from name in names\n            let x = name.Split(&#39;,&#39;)\n            from score in scores\n            let s = score.Split(&#39;,&#39;)\n            // Look for matching IDs from the two data files.\n            where x[2] == s[0]\n            // If the IDs match, build a Student object.\n            select new Student()\n            {\n                FirstName = x[0],\n                LastName = x[1],\n                ID = Convert.ToInt32(x[2]),\n                ExamScores = (from scoreAsText in s.Skip(1)\n                              select Convert.ToInt32(scoreAsText)).\n                              ToList()\n            };\n\n        // Optional. Store the newly created student objects in memory\n        // for faster access in future queries\n        List&lt;Student&gt; students = queryNamesScores.ToList();\n\n        foreach (var student in students)\n        {\n            Console.WriteLine($&quot;The average score of {student.FirstName} {student.LastName} is \n                {student.ExamScores.Average()}.&quot;);\n        }\n\n        //Keep console window open in debug mode\n        Console.WriteLine(&quot;Press any key to exit.&quot;);\n        Console.ReadKey();\n    }\n}\n\nclass Student\n{\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n    public int ID { get; set; }\n    public List&lt;int&gt; ExamScores { get; set; }\n}\n\n/* Output: \n    The average score of Omelchenko Svetlana is 82.5.\n    The average score of O&#39;Donnell Claire is 72.25.\n    The average score of Mortensen Sven is 84.5.\n    The average score of Garcia Cesar is 88.25.\n    The average score of Garcia Debra is 67.\n    The average score of Fakhouri Fadi is 92.25.\n    The average score of Feng Hanying is 88.\n    The average score of Garcia Hugo is 85.75.\n    The average score of Tucker Lance is 81.75.\n    The average score of Adams Terry is 85.25.\n    The average score of Zabokritski Eugene is 83.\n    The average score of Tucker Michael is 92.\n */\n</code></pre><h2 id=\"see-also\">See also</h2>\n<p> <a href=\"index\" data-linktype=\"relative-path\">LINQ query expressions</a><br> <a href=\"../language-reference/keywords/join-clause\" data-linktype=\"relative-path\">join clause</a><br> <a href=\"order-the-results-of-a-join-clause\" data-linktype=\"relative-path\">Order the results of a join clause</a></p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"stevehoag\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.devlang\" content=\"dotnet\">\r\n<meta name=\"ms.assetid\" content=\"56a2a4a5-7299-497d-b3c3-23c848678911\">\r\n<meta name=\"description\" content=\"How to perform custom join operations.\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core, C#\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"12/1/2016\">\r\n<meta name=\"ms.technology\" content=\".net-core-technologies\">\r\n<meta name=\"ms.prod\" content=\".net-core\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/97a29e60f5d861d848b85ef1e8ed8b1988f9ced1/docs/csharp/linq/perform-custom-join-operations.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/linq/perform-custom-join-operations.md\">\r\n<meta name=\"document_id\" content=\"a292850d-8742-dd2a-d7f3-6bb65018735a\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"stevehoag","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","title":"Perform custom join operations | Microsoft Docs","ms.devlang":"dotnet","ms.assetid":"56a2a4a5-7299-497d-b3c3-23c848678911","description":"How to perform custom join operations.","keywords":".NET, .NET Core, C#","ms.topic":"article","ms.date":"12/1/2016","ms.technology":".net-core-technologies","ms.prod":".net-core","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Steve Hoag","author_email":"shoag@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Updated LINQ topics for C# Concepts section (#1302)","commit_sha":"97a29e60f5d861d848b85ef1e8ed8b1988f9ced1","commit_date":"2016-12-12 09:02:31 -0800"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag","id":"13489215"},"contributors":[{"profile_url":"https://github.com/stevehoag","display_name":"Steve Hoag"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/97a29e60f5d861d848b85ef1e8ed8b1988f9ced1/docs/csharp/linq/perform-custom-join-operations.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/linq/perform-custom-join-operations.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/linq/perform-custom-join-operations.md","document_id":"a292850d-8742-dd2a-d7f3-6bb65018735a","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/linq/perform-custom-join-operations","toc_asset_id":"articles/csharp/linq/toc.json","toc_rel":"toc.json","_op_ogTitle":"Perform custom join operations","_op_displayDate":"2016-12-1","_op_displayDate_source":"2016-12-01T00:00:00Z","_op_wordCount":1005,"_op_rawTitle":"<h1 id=\"perform-custom-join-operations\" sourcefile=\"docs/csharp/linq/perform-custom-join-operations.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Perform custom join operations</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/linq/perform-custom-join-operations","fileRelativePath":"articles/csharp/linq/perform-custom-join-operations.html"},"themesRelativePathToOutputRoot":"_themes/"}