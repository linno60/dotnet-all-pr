{"content":"<div><div class=\"content\">\n<p><a href=\"delegates-overview\" data-linktype=\"relative-path\">Previous</a></p>\n<p>This article will cover the classes in the .NET framework\nthat support delegates, and how those map to the <code>delegate</code>\nkeyword.</p>\n<h2 id=\"defining-delegate-types\">Defining Delegate Types</h2>\n<p>Let&#39;s start with the &#39;delegate&#39; keyword, because that&#39;s primarily what\nyou will use as you work with delegates. The code that the\ncompiler generates when you use the <code>delegate</code> keyword will\nmap to method calls that invoke members of the <a class=\"xref\" href=\"../../api/system.delegate\" data-linktype=\"relative-path\">Delegate</a> \nand <a class=\"xref\" href=\"../../api/system.multicastdelegate\" data-linktype=\"relative-path\">MulticastDelegate</a> classes. </p>\n<p>You define a delegate type using syntax that is similar to defining\na method signature. You just add the <code>delegate</code> keyword to the\ndefinition.</p>\n<p>Let&#39;s continue to use the List.Sort() method as our example. The first\nstep is to create a type for the comparison delegate:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">// From the .NET Core library\n\n// Define the delegate type:\npublic delegate int Comparison&lt;in T&gt;(T left, T right);\n</code></pre><p>The compiler generates a class, derived from <code>System.Delegate</code>\nthat matches the signature used (in this case, a method that\nreturns an integer, and has two arguments). The type\nof that delegate is <code>Comparison</code>. The <code>Comparison</code> delegate\ntype is a generic type. For details on generics see <a href=\"generics\" data-linktype=\"relative-path\">here</a>.</p>\n<p>Notice that the syntax may appear as though it is declaring\na variable, but it is actually declaring a <em>type</em>. You can\ndefine delegate types inside classes, directly inside namespaces,\nor even in the global namespace.</p>\n<div class=\"NOTE\"><h5>Note</h5><p>Declaring delegate types (or other types) directly in\nthe global namespace is not recommended. </p>\n</div>\n<p>The compiler also generates add and remove handlers for this new\ntype so that clients of this class can add and remove methods from an instance&#39;s\ninvocation list. The compiler will enforce that the signature\nof the method being added or removed matches the signature\nused when declaring the method. </p>\n<h2 id=\"declaring-instances-of-delegates\">Declaring instances of delegates</h2>\n<p>After defining the delegate, you can create an instance of that type.\nLike all variables in C#, you cannot declare delegate instances directly\nin a namespace, or in the global namespace.</p>\n<pre class=\"loading\"><code class=\"lang-cs\">// inside a class definition:\n\n// Declare an instance of that type:\npublic Comparison&lt;T&gt; comparator;\n</code></pre><p>The type of the variable is <code>Comparison&lt;T&gt;</code>, the delegate type\n defined earlier. The name of the variable is <code>comparator</code>.</p>\n<p> That code snippet above declared a member variable inside a class. You can also\n declare delegate variables that are local variables, or arguments to methods.</p>\n<h2 id=\"invoking-delegates\">Invoking Delegates</h2>\n<p>You invoke the methods that are in the invocation list of a delegate by calling\nthat delegate. Inside the <code>Sort()</code> method, the code will call the\ncomparison method to determine which order to place objects:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">int result = comparator(left, right);\n</code></pre><p>In the line above, the code <em>invokes</em> the method attached to the delegate.\nYou treat the variable as a method name, and invoke it using normal\nmethod call syntax.</p>\n<p>That line of code makes an unsafe assumption: There&#39;s no guarantee that\na target has been added to the delegate. If no targets have been attached,\nthe line above would cause a <code>NullReferenceException</code> to be thrown. The\nidioms used to address this problem are more complicated than a simple\nnull-check, and are covered later in this <a href=\"delegates-patterns\" data-linktype=\"relative-path\">series</a>.</p>\n<h2 id=\"assigning-adding-and-removing-invocation-targets\">Assigning, Adding and removing Invocation Targets</h2>\n<p>That&#39;s how a delegate type is defined, and how delegate instances\nare declared and invoked.</p>\n<p>Developers that want to use the <code>List.Sort()</code> method need to define\na method whose signature matches the delegate type definition, and\nassign it to the delegate used by the sort method. This assignment\nadds the method to the invocation list of that delegate object.</p>\n<p>Suppose you wanted to sort a list of strings by their length. Your\ncomparison function might be the following:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">private static int CompareLength(string left, string right)\n{\n    return left.Length.CompareTo(right.Length);\n}\n</code></pre><p>The method is declared as a private method. That&#39;s fine. You may not\nwant this method to be part of your public interface. It can still\nbe used as the comparison method when attached to a delegate. The\ncalling code will have this method attached to the target list of\nthe delegate object, and can access it through that delegate.</p>\n<p>You create that relationship by passing that method to the\n<code>List.Sort()</code> method:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">phrases.Sort(CompareLength);\n</code></pre><p>Notice that the method name is used, without parentheses. Using the method\nas an argument tells the compiler to convert the method reference into a reference\nthat can be used as a delegate invocation target, and attach that method as\nan invocation target.</p>\n<p>You could also have been explicit by declaring a variable of type\n&#39;Comparison<string>` and doing an assignment:<p>\n<pre class=\"loading\"><code class=\"lang-cs\">Comparison&lt;string&gt; comparer = CompareLength;\nphrases.Sort(comparer);\n</code></pre><p>In uses where the method being used as a delegate target is a small method,\nit&#39;s common to use <a href=\"lambda-expressions\" data-linktype=\"relative-path\">Lambda Expression</a> syntax\nto perform the assignment:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">Comparison&lt;string&gt; comparer = (left, right) =&gt; left.Length.CompareTo(right.Length);\nphrases.Sort(comparer);\n</code></pre><p>Using Lambda Expressions for delegate targets\nis covered more in a <a href=\"delegates-patterns\" data-linktype=\"relative-path\">later section</a>.</p>\n<p>The Sort() example typically attaches a single target method to the\ndelegate. However, delegate objects do support invocation lists that\nhave multiple target methods attached to a delegate object.</p>\n<h2 id=\"delegate-and-multicastdelegate-classes\">Delegate and MulticastDelegate classes</h2>\n<p>The language support described above provides the features\nand support you&#39;ll typically need to work with delegates. These\nfeatures are built on two classes in the .NET Core\nframework: <a class=\"xref\" href=\"../../api/system.delegate\" data-linktype=\"relative-path\">Delegate</a> and <a class=\"xref\" href=\"../../api/system.multicastdelegate\" data-linktype=\"relative-path\">MulticastDelegate</a>.</p>\n<p>The <code>System.Delegate</code> class, and its single direct sub-class,\n<code>System.MulticastDelegate</code>, provide the framework support for\ncreating delegates, registering methods as delegate targets,\nand invoking all methods that are registered as a delegate\ntarget. </p>\n<p>Interestingly, the <code>System.Delegate</code> and <code>System.MulticastDelegate</code>\nclasses are not themselves delegate types. They do provide the\nbasis for all specific delegate types. That same language\ndesign process mandated that you cannot declare a class that derives\nfrom <code>Delegate</code> or <code>MulticastDelegate</code>. The C# language rules prohibit it.</p>\n<p>Instead, the C# compiler creates instances of a class derived from <code>MulticastDelegate</code>\nwhen you use the C# language keyword to declare delegate types.</p>\n<p>This design has its roots in the first release of C# and .NET. One\ngoal for the design team was to ensure that the language enforced\ntype safety when using delegates. That meant ensuring that delegates\nwere invoked with the right type and number of arguments. And, that\nany return type was correctly indicated at compile time. Delegates\nwere part of the 1.0 .NET release, which was before generics.</p>\n<p>The best way to enforce this type safety was for the compiler to\ncreate the concrete delegate classes that represented the\nmethod signature being used.</p>\n<p>Even though you cannot create derived classes directly, you will\nuse the methods defined on these classes. Let&#39;s go through\nthe most common methods that you will use when you work with delegates.</p>\n<p>The first, most important fact to remember is that every delegate you\nwork with is derived from <code>MulticastDelegate</code>. A multicast delegate means\nthat more than one method target can be invoked when invoking through\na delegate. The original design considered making a distinction between\ndelegates where only one target method could be attached and invoked,\nand delegates where multiple target methods could be attached and\ninvoked. That distinction proved to be less useful in practice than\noriginally thought. The two different classes were already created,\nand have been in the framework since its initial public release.</p>\n<p>The methods that you will use the most with delegates are <code>Invoke()</code> and\n<code>BeginInvoke()</code> / <code>EndInvoke()</code>. <code>Invoke()</code> will invoke all the methods that\nhave been attached to a particular delegate instance. As you saw above, you\ntypically invoke delegates using the method call syntax on the delegate\nvariable. As you&#39;ll see <a href=\"delegates-patterns\" data-linktype=\"relative-path\">later in this series</a>,\nthere are patterns that work directly with these methods.</p>\n<p>Now that you&#39;ve seen the language syntax and the classes that support\ndelegates, let&#39;s examine how strongly typed delegates are used, created\nand invoked.</p>\n<p><a href=\"delegates-strongly-typed\" data-linktype=\"relative-path\">Next</a></p>\n</string></div></div>","outputRootRelativePath":"../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet/toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"f3742fda-13c2-4283-8966-9e21c2674393\">\r\n<meta name=\"description\" content=\"System.Delegate and the `delegate` keyword\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"06/20/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/delegate-class.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/delegate-class.md\">\r\n<meta name=\"document_id\" content=\"df26447f-d703-2fbd-f35b-a8b2166131e7\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"System.Delegate and the `delegate` keyword | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"f3742fda-13c2-4283-8966-9e21c2674393","description":"System.Delegate and the `delegate` keyword","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"06/20/2016","ms.technology":"devlang-csharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"Fixed typos and other small things (#883)","commit_sha":"bb15293c569fa92f1acf6315c5fe7f2cd9cb6f68","commit_date":"2016-08-08 21:27:46 -0400"},{"author_name":"Maira Wenzel","author_email":"mairaw@users.noreply.github.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Broken link fixes and other issues (#724)","commit_sha":"cfe65fcba1b3fdc09ffcac704a760d8ce29ea60b","commit_date":"2016-06-30 23:16:40 -0700"},{"author_name":"brady gaster","author_email":"bradyg@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"repaired api links","commit_sha":"5676986d62b722604c7f95eee34a4ef557812516","commit_date":"2016-06-26 09:25:16 -0700"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"Rich Lander","comitter_email":"rlander@microsoft.com","message":"Promote csharp from languages (#644)","commit_sha":"2d44b7e04c0fe2ca136ba6dfa9fc3a4368365ec8","commit_date":"2016-06-26 08:30:56 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/bradygaster","display_name":"brady gaster","id":"486363"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/delegate-class.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/delegate-class.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/delegate-class.md","document_id":"df26447f-d703-2fbd-f35b-a8b2166131e7","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/delegate-class","toc_asset_id":"articles/toc.json","toc_rel":"../toc.json","_op_ogTitle":"System.Delegate and the `delegate` keyword","_op_displayDate":"2016-6-20","_op_displayDate_source":"2016-06-20T00:00:00Z","_op_wordCount":1257,"_op_rawTitle":"<h1 id=\"systemdelegate-and-the-delegate-keyword\" sourcefile=\"docs/csharp/delegate-class.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">System.Delegate and the <code>delegate</code> keyword</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/delegate-class","fileRelativePath":"articles/csharp/delegate-class.html"},"themesRelativePathToOutputRoot":"_themes/"}