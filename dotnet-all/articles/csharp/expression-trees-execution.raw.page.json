{"content":"<div><div class=\"content\">\n<p><a href=\"expression-classes\" data-linktype=\"relative-path\">Previous -- Framework Types Supporting Expression Trees</a></p>\n<p>An <em>expression tree</em> is a data structure that represents some code.\nIt is not compiled and executable code. If you want to execute\nthe .NET code that is represented by an expression tree, you must\nconvert it into executable IL instructions. </p>\n<h2 id=\"lambda-expressions-to-functions\">Lambda Expressions to Functions</h2>\n<p>You can convert any LambdaExpression, or any type derived from\nLambdaExpression into executable IL. Other expression types\ncannot be directly converted into code. This restriction has\nlittle effect in practice. Lambda expressions are the only\ntypes of expressions that you would want to execute by converting\nto executable intermediate language (IL). (Think about what it would mean\nto directly execute a <code>ConstantExpression</code>. Would it mean\nanything useful?) Any expression tree that is a <code>LamdbaExpression</code>,\nor a type derived from <code>LambdaExpression</code> can be converted to IL.\nThe expression type <code>Expression&lt;TDelegate&gt;</code>\nis the only concrete example in the .NET Core libraries. It&#39;s used\nto represent an expression that maps to any delegate type. Because\nthis type maps to a delegate type, .NET can examine\nthe expression, and generate IL for an appropriate delegate that\nmatches the signature of the lambda expression. </p>\n<p>In most cases, this creates a simple mapping between an expression,\nand its corresponding delegate. For example, an expression tree that\nis represented by <code>Expression&lt;Func&lt;int&gt;&gt;</code> would be converted to a delegate\nof the type <code>Func&lt;int&gt;</code>. For a lambda expression with any return type\nand argument list, there exists a delegate type that is the target type\nfor the executable code represented by that lamdba expression.</p>\n<p>The <code>LamdbaExpression</code> type contains <code>Compile</code> and <code>CompileToMethod</code>\nmembers that you would use to convert an expression tree to executable\ncode. The <code>Compile</code> method creates a delegate. The <code>ConmpileToMethod</code>\nmethod updates a <code>MethodBuilder</code> object with the IL that represents\nthe compiled output of the expression tree. Note that <code>CompileToMethod</code>\nis only available on the full desktop framework, not on the \n.NET Core framework.</p>\n<p>Optionally, you can also provide a <code>DebugInfoGenerator</code> that will\nreceive the symbol debugging information for the generated delegate\nobject. This enables you to convert the expression tree into a\ndelegate object, and have full debugging information about the\ngenerated delegate.</p>\n<p>You would convert an expression into a delegate using the following\ncode:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">Expression&lt;Func&lt;int&gt;&gt; add = () =&gt; 1 + 2;\nvar func = add.Compile(); // Create Delegate\nvar answer = func(); // Invoke Delegate\nConsole.WriteLine(answer);\n</code></pre><p>Notice that the delegate type is based on the expression type. You must\nknow the return type and the argument list if you want to use the\ndelegate object in a strongly typed manner. The <code>LambdaExpression.Compile()</code>\nmethod returns the <code>Delegate</code> type. You will have to cast it to the correct\ndelegate type to have any compile-time tools check the argument list of\nreturn type.</p>\n<h2 id=\"execution-and-lifetimes\">Execution and Lifetimes</h2>\n<p>You execute the code by invoking the delegate created when\nyou called <code>LamdbaExpression.Compile()</code>. You can see this above where\n<code>add.Compile()</code> returns a delegate. Invoking that delegate, by calling\n<code>func()</code> executes the code.</p>\n<p>That delegate represents the code in the expression tree. You can\nretain the handle to that delegate and invoke it later. You don&#39;t need\nto compile the expression tree each time you want to execute the code\nit represents. (Remember that expression trees are immutable, and\ncompiling the same expression tree later will create a delegate that\nexecutes the same code.)</p>\n<p>I will caution you against trying to create any more sophisticated\ncaching mechanisms to increase performance by avoiding unnecessary\ncompile calls. Comparing two arbitrary expression trees to determine\nif they represent the same algorithm will also be time consuming to\nexecute. You&#39;ll likely\nfind that the compute time you save avoiding any extra calls to\n<code>LambdaExpression.Compile()</code> will be more than consumed by the time executing\ncode that determines of two different expression trees result in\nthe same executable code.</p>\n<h2 id=\"caveats\">Caveats</h2>\n<p>Compiling a lambda expression to a delegate and invoking that delegate\nis one of the simplest operations you can perform with an expression\ntree. However, even with this simple operation, there are caveats\nyou must be aware of. </p>\n<p>Lambda Expressions create closures over any local variables that are\nreferenced in the expression. You must guarantee that any variables\nthat would be part of the delegate are usable at the location where\nyou call <code>Compile</code>, and when you execute the resulting delegate.</p>\n<p>In general, the compiler will ensure that this is true. However,\nif your expression accesses a variable that implements <code>IDisposable</code>,\nit&#39;s possible that your code might dispose of the object while it\nis still held by the expression tree.</p>\n<p>For example, this code works fine, because <code>int</code> does not implement\n<code>IDisposable</code>:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">private static Func&lt;int, int&gt; CreateBoundFunc()\n{\n    var constant = 5; // constant is captured by the expression tree\n    Expression&lt;Func&lt;int, int&gt;&gt; expression = (b) =&gt; constant + b;\n    var rVal = expression.Compile();\n    return rVal;\n}\n</code></pre><p>The delegate has captured a reference to the local variable <code>constant</code>.\nThat variable is accessed at any time later, when the function returned\nby <code>CreateBoundFunc</code> executes.</p>\n<p>However, consider this (rather contrived) class that implements\n<code>IDisposable</code>:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public class Resource : IDisposable\n{\n    private bool isDisposed = false;\n    public int Argument\n    {\n        get\n        {\n            if (!isDisposed)\n                return 5;\n            else throw new ObjectDisposedException(&quot;Resource&quot;);\n        }\n    }\n\n    public void Dispose()\n    {\n        isDisposed = true;\n    }\n}\n</code></pre><p>If you use it in an expression as shown below, you&#39;ll get an\n<code>ObjectDisposedException</code> when you execute the code referenced\nby the <code>Resource.Argument</code> property:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">private static Func&lt;int, int&gt; CreateBoundResource()\n{\n    using (var constant = new Resource()) // constant is captured by the expression tree\n    {\n        Expression&lt;Func&lt;int, int&gt;&gt; expression = (b) =&gt; constant.Argument + b;\n        var rVal = expression.Compile();\n        return rVal;\n    }\n}\n</code></pre><p>The delegate returned from this method has closed over the <code>constant</code> object,\nwhich has been disposed of. (It&#39;s been disposed, because it was declared in a\n<code>using</code> statement.) </p>\n<p>Now, when you execute the delegate returned from this method, you&#39;ll have a\n<code>ObjecctDisposedException</code> thrown at the point of execution.</p>\n<p>It does seem strange to have a runtime error representing a compile-time\nconstruct, but that&#39;s the world we enter when we work with\nexpression trees.</p>\n<p>There are a lot of permutations of this problem, so it&#39;s hard\nto offer general guidance to avoid it. Be careful about accessing\nlocal variables when defining expressions, and be careful about\naccessing state in the current object (represented by <code>this</code>) when\ncreating an expression tree that can be returned by a public API.</p>\n<p>The code in your expression may reference methods or properties in\nother assemblies. That assembly must be accessible when the expression\nis defined, and when it is compiled, and when the resulting delegate\nis invoked. You&#39;ll be met with a <code>ReferencedAssemblyNotFoundException</code>\nin cases where it is not present.</p>\n<h2 id=\"summary\">Summary</h2>\n<p>Expression Trees that represent lambda expressions can be compiled\nto create a delegate that you can execute. This provides one\nmechanism to execute the code represented by an expression tree.</p>\n<p>The Expression Tree does represent the code that would execute for\nany given construct you create. As long as the environment where\nyou compile and execute the code matches the environment where you\ncreate the expression, everything works as expected. When that\ndoesn&#39;t happen, the errors are very predictable, and they will\nbe caught in your first tests of any code using the expression\ntrees.</p>\n<p><a href=\"expression-trees-interpreting\" data-linktype=\"relative-path\">Next -- Interpreting Expressions</a></p>\n</div></div>","outputRootRelativePath":"../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet/toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"109e0ac5-2a9c-48b4-ac68-9b6219cdbccf\">\r\n<meta name=\"description\" content=\"Executing Expression Trees\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"06/20/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/expression-trees-execution.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/expression-trees-execution.md\">\r\n<meta name=\"document_id\" content=\"397b61e4-2ded-f0f6-4a6e-a8f5ba57a8c2\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Executing Expression Trees | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"109e0ac5-2a9c-48b4-ac68-9b6219cdbccf","description":"Executing Expression Trees","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"06/20/2016","ms.technology":"devlang-csharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"Rich Lander","comitter_email":"rlander@microsoft.com","message":"Promote csharp from languages (#644)","commit_sha":"2d44b7e04c0fe2ca136ba6dfa9fc3a4368365ec8","commit_date":"2016-06-26 08:30:56 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/expression-trees-execution.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/expression-trees-execution.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/expression-trees-execution.md","document_id":"397b61e4-2ded-f0f6-4a6e-a8f5ba57a8c2","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/expression-trees-execution","toc_asset_id":"articles/toc.json","toc_rel":"../toc.json","_op_ogTitle":"Executing Expression Trees","_op_displayDate":"2016-6-20","_op_displayDate_source":"2016-06-20T00:00:00Z","_op_wordCount":1205,"_op_rawTitle":"<h1 id=\"executing-expression-trees\" sourcefile=\"docs/csharp/expression-trees-execution.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Executing Expression Trees</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/expression-trees-execution","fileRelativePath":"articles/csharp/expression-trees-execution.html"},"themesRelativePathToOutputRoot":"_themes/"}