{"content":"<div><div class=\"content\">\n<p><a href=\"expression-trees\" data-linktype=\"relative-path\">Previous -- Overview</a></p>\n<p>An Expression Tree is a data structure that defines code. They are based on the same structures\nthat a compiler uses to analyze code and generate the compiled output. As you read through this\ntutorial, you will notice quite a bit of similarity between Expression Trees and the types used\nin the Roslyn APIs to build <a href=\"https://github.com/dotnet/roslyn-analyzers\" data-linktype=\"external\">Analyzers and CodeFixes</a>.\n(Analyzers and CodeFixes are NuGet packages that perform static analysis on code and can suggest\npotential fixes for a developer.)\nThe concepts are similar, and the end result\nis a data structure that allows examination of the source code in a meaningful way. However, Expression\nTrees are based on a totally different set of classes and APIs than the Roslyn APIs.</p>\n<p>Let&#39;s look at a simple example.\nHere&#39;s a line of code:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var sum = 1 + 2;\n</code></pre><p>If you were to analyze this as an expression tree, the tree contains several nodes.\nThe outermost node is a variable declaration statement with assignment (<code>var sum = 1 + 2;</code>)\nThat outermost node contains several child nodes: a variable declaration, an assignment operator, and an\nexpression representing the right hand side of the equals sign. That expression is further subdivided into\nexpressions that represent the addition operation, and left and right operands of the addition.</p>\n<p>Let&#39;s drill down a bit more into the expressions that make up the right side of the equals sign.\nThe expression is <code>1 + 2</code>. That&#39;s a binary expression. More specifically, it&#39;s a binary addition\nexpression. A binary addition expression has two children, representing the left and right nodes\nof the addition expression. Here, both nodes are constant expressions: The left operand is the\nvalue <code>1</code>, and the right operand is the value <code>2</code>.</p>\n<p>Visually, the entire statement is a tree: You could start at the root node, and travel to\neach node in the tree to see the code that makes up the statement:</p>\n<ul>\n<li>Variable declaration statement with assignment (<code>var sum = 1 + 2;</code>)<ul>\n<li>Implicit variable type declaration (<code>var sum</code>)<ul>\n<li>Implicit var keyword (<code>var</code>)</li>\n<li>Variable name declaration (<code>sum</code>)</li>\n</ul>\n</li>\n<li>Assignment operator (<code>=</code>)</li>\n<li>Binary addition expression (<code>1 + 2</code>)<ul>\n<li>Left operand (<code>1</code>)</li>\n<li>Addition operator (<code>+</code>)</li>\n<li>Right operand (<code>2</code>)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>This may look complicated, but it is very powerful. Following the same process, you can decompose\nmuch more complicated expressions. Consider this expression:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var finalAnswer = this.SecretSauceFuncion(\n    currentState.createInterimResult(), currentState.createSecondValue(1, 2),\n    decisionServer.considerFinalOptions(&quot;hello&quot;)) +\n    MoreSecretSauce(&#39;A&#39;, DateTime.Now, true);\n</code></pre><p>The expression above is also a variable declaration with an assignment.\nIn this instance, the right hand side of the assignment is a much more complicated tree.\nI&#39;m not going to decompose this expression, but consider what the different nodes might\nbe. There are method calls using the current object as a receiver, one that has an explicit <code>this</code>\nreceiver, one that does not. There are method calls using other receiver objects,\nthere are constant arguments of different types. And finally, there is a binary\naddition operator. Depending on the return type of <code>SecretSauceFunction()</code> or\n<code>MoreSecretSauce()</code>, that binary addition operator may be a method call to an\noverridden addition operator, resolving to a static method call to the binary \naddition operator defined for a class.</p>\n<p>Despite this perceived complexity, the expression above creates a tree structure\nthat can be navigated as easily as the first sample. You can keep traversing\nchild nodes to find leaf nodes in the expression. Parent nodes will have\nreferences to their children, and each node has a property that describes\nwhat kind of node it is.</p>\n<p>The structure of an expression tree is very consistent. Once you&#39;ve learned\nthe basics, you can understand even the most complex code when it is represented\nas an expression tree. The elegance in\nthe data structure explains how the C# compiler can analyze the most complex\nC# programs and create proper output from that complicated source code.</p>\n<p>Once you become familiar with the structure of expression trees, you will\nfind that knowledge you&#39;ve gained quickly enables you to work with many\nmore and more advanced scenarios. There is incredible power to expression\ntrees.</p>\n<p>In addition to translating algorithms to execute in other environments,\nexpression trees can be used to make it easier to write algorithms that inspect\ncode before executing it. You can write a method whose arguments are expressions\nand then examine those expressions before executing the code. The Expression Tree\nis a full representation of the code: you can see values of any sub-expression.\nYou can see method and property names. You can see the value of any constant expressions.\nYou can also convert an expression tree into an executable delegate, and execute the\ncode.</p>\n<p>The APIs for Expression Trees enable you to create trees that represent almost any\nvalid code construct. However, to keep things as simple as possible, some C# idioms\ncannot be created in an expression tree. One example is asynchronous expressions (using\nthe <code>async</code> and <code>await</code> keywords). If your needs require asynchronous algorithms, you would need\nto manipulate the <code>Task</code> objects directly, rather than rely on the compiler support. Another\nis in creating loops. Typically, you create these by using <code>for</code>, <code>foreach</code>, <code>while</code> or <code>do</code>\nloops. As you&#39;ll see <a href=\"expression-trees-building\" data-linktype=\"relative-path\">later in this series</a>, the APIs for\nexpression trees support a single loop expression, with <code>break</code> and <code>continue</code> expressions that\ncontrol repeating the loop.</p>\n<p>The one thing you can&#39;t do is modify an expression tree.  Expression Trees are immutable\ndata structures. If you want to mutate (change) an expression tree, you must create a new tree\nthat is a copy of the original, but with your desired changes. </p>\n<p><a href=\"expression-classes\" data-linktype=\"relative-path\">Next -- Framework Types Supporting Expression Trees</a></p>\n</div></div>","outputRootRelativePath":"../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"bbcdd339-86eb-4ae5-9911-4c214a39a92d\">\r\n<meta name=\"description\" content=\"Expression Trees Explained\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"06/20/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/expression-trees-explained.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/expression-trees-explained.md\">\r\n<meta name=\"document_id\" content=\"f3eb4320-07aa-39c1-a273-d6354447fdc2\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","title":"Expression Trees Explained | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"bbcdd339-86eb-4ae5-9911-4c214a39a92d","description":"Expression Trees Explained","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"06/20/2016","ms.technology":"devlang-csharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Corrected typo","commit_sha":"1b6d305399483ff6763f35b7a25ef523fae3325b","commit_date":"2016-10-18 13:10:49 -0700"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"Rich Lander","comitter_email":"rlander@microsoft.com","message":"Promote csharp from languages (#644)","commit_sha":"2d44b7e04c0fe2ca136ba6dfa9fc3a4368365ec8","commit_date":"2016-06-26 08:30:56 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/rpetrusha","display_name":"rpetrusha","id":"10886961"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/expression-trees-explained.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/expression-trees-explained.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/expression-trees-explained.md","document_id":"f3eb4320-07aa-39c1-a273-d6354447fdc2","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/expression-trees-explained","toc_asset_id":"articles/toc.json","toc_rel":"../toc.json","_op_ogTitle":"Expression Trees Explained","_op_displayDate":"2016-6-20","_op_displayDate_source":"2016-06-20T00:00:00Z","_op_wordCount":930,"_op_rawTitle":"<h1 id=\"expression-trees-explained\" sourcefile=\"docs/csharp/expression-trees-explained.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Expression Trees Explained</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/expression-trees-explained","fileRelativePath":"articles/csharp/expression-trees-explained.html"},"themesRelativePathToOutputRoot":"_themes/"}