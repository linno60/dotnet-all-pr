{"content":"<div><div class=\"content\">\n<p>A method is a code block that contains a series of statements. A program causes the statements to be executed by calling the method and specifying any required method arguments. In C#, every executed instruction is performed in the context of a method. The <code>Main</code> method is the entry point for every C# application and it is called by the common language runtime (CLR) when the program is started.</p>\n<div class=\"NOTE\"><h5>Note</h5><p>This topic discusses named methods. For information about anonymous functions, see <a href=\"https://msdn.microsoft.com/library/bb882516.aspx\" data-linktype=\"external\">Anonymous Functions</a>.</p>\n</div>\n<p>This topic contains the following sections:</p>\n<ul>\n<li><a href=\"#signatures\" data-linktype=\"self-bookmark\">Method signatures</a></li>\n<li><a href=\"#invocation\" data-linktype=\"self-bookmark\">Method invocation</a></li>\n<li><a href=\"#inherited\" data-linktype=\"self-bookmark\">Inherited and overridden methods</a></li>\n<li><a href=\"#passing\" data-linktype=\"self-bookmark\">Passing parameters</a><ul>\n<li><a href=\"#byval\" data-linktype=\"self-bookmark\">Passing parameters by value</a></li>\n<li><a href=\"#byref\" data-linktype=\"self-bookmark\">Passing parameters by reference</a></li>\n<li><a href=\"#paramarray\" data-linktype=\"self-bookmark\">Parameter arrays</a></li>\n</ul>\n</li>\n<li><a href=\"#optional\" data-linktype=\"self-bookmark\">Optional parameters and arguments</a></li>\n<li><a href=\"#return\" data-linktype=\"self-bookmark\">Return values</a></li>\n<li><a href=\"#extension\" data-linktype=\"self-bookmark\">Extension methods</a></li>\n<li><a href=\"#async\" data-linktype=\"self-bookmark\">Async Methods</a></li>\n<li><a href=\"#expr\" data-linktype=\"self-bookmark\">Expression-bodied members</a></li>\n<li><a href=\"#iterators\" data-linktype=\"self-bookmark\">Iterators</a></li>\n</ul>\n<p><a name=\"signatures\"><p>\n<h2 id=\"method-signatures\">Method signatures</h2>\n<p>Methods are declared in a <code>class</code> or <code>struct</code> by specifying:</p>\n<ul>\n<li>An optional access level, such as <code>public</code> or <code>private</code>. The default is <code>private</code>.</li>\n<li>Optional modifiers such as <code>abstract</code> or <code>sealed</code>.</li>\n<li>The return value, or <code>void</code> if the method has none.</li>\n<li>The method name.</li>\n<li>Any method parameters. Method parameters are enclosed in parentheses and are separated by commas. Empty parentheses indicate that the method requires no parameters.</li>\n</ul>\n<p>These parts together form the method signature.</p>\n<div class=\"NOTE\"><h5>Note</h5><p>A return type of a method is not part of the signature of the method for the purposes of method overloading. However, it is part of the signature of the method when determining the compatibility between a delegate and the method that it points to.</p>\n</div>\n<p>The following example defines a class named <code>Motorcycle</code> that contains five methods:</p>\n<pre><code name=\"csSnippets.Methods#40\">using System;\n\nabstract class Motorcycle\n{\n   // Anyone can call this.\n   public void StartEngine() {/* Method statements here */ }\n\n   // Only derived classes can call this.\n   protected void AddGas(int gallons) { /* Method statements here */ }\n\n   // Derived classes can override the base class implementation.\n   public virtual int Drive(int miles, int speed) { /* Method statements here */ return 1; }\n\n   // Derived classes can override the base class implementation.\n   public virtual int Drive(TimeSpan time, int speed) { /* Method statements here */ return 0; }\n\n   // Derived classes must implement this.\n   public abstract double GetTopSpeed(); \n}\n</code></pre><p>Note that the <code>Motorcycle</code> class includes an overloaded method, <code>Drive</code>. Two methods have the same name, but must be differentiated by their parameter types.</p>\n<p><a name=\"invocation\"></a></p>\n<h2 id=\"method-invocation\">Method invocation</h2>\n<p>Methods can be either <em>instance</em> or <em>static</em>. Invoking an instance method requires that you instantiate an object and call the method on that object; an instance method operates on that instance and its data. You invoke a static method by referencing the name of the type to which the method belongs; static methods operate do not operate on instance data. Attempting to call a static method through an object instance generates a compiler error.</p>\n<p>Calling a method is like accessing a field. After the object name (if you are calling an instance method) or the type name (if you are calling a <code>static</code> method), add a period, the name of the method, and parentheses. Arguments are listed within the parentheses, and are separated by commas.</p>\n<p>The method definition specifies the names and types of any parameters that are required. When a caller invokes the method, it provides concrete values, called arguments, for each parameter. The arguments must be compatible with the parameter type, but the argument name, if one is used in the calling code, does not have to be the same as the parameter named defined in the method. In the following example, the <code>Square</code> method includes a single parameter of type <code>int</code> named <em>i</em>. The first method call passes the <code>Square</code> method a variable of type <code>int</code> named <em>num</em>; the second, a numeric constant; and the third, an expression.</p>\n<pre><code name=\"csSnippets.Methods#74\">public class Example\n{\n   public static void Main()\n   {\n      // Call with an int variable.\n      int num = 4;\n      int productA = Square(num);\n\n      // Call with an integer literal.\n      int productB = Square(12);\n\n      // Call with an expression that evaulates to int.\n      int productC = Square(productA * 3);\n   }\n   \n   static int Square(int i)\n   {\n      // Store input argument in a local variable.\n      int input = i;\n      return input * input;\n   }\n}\n</code></pre><p>The most common form of method invocation used positional arguments; it supplies arguments in the same order as method parameters. The methods of the <code>Motorcycle</code> class can therefore be called as in the following example. The call to the <code>Drive</code> method, for example, includes two arguments that correspond to the two parameters in the method&#39;s syntax. The first becomes the value of the <code>miles</code> parameter, the second the value of the <code>speed</code> parameter.</p>\n<pre><code name=\"csSnippets.Methods#41\">class TestMotorcycle : Motorcycle\n{\n   public override double GetTopSpeed()\n   {\n      return 108.4;\n   }\n\n   static void Main()\n   {\n      \n      TestMotorcycle moto = new TestMotorcycle();\n\n      moto.StartEngine();\n      moto.AddGas(15);\n      moto.Drive(5, 20);\n      double speed = moto.GetTopSpeed();\n      Console.WriteLine(&quot;My top speed is {0}&quot;, speed);            \n   }\n}\n</code></pre><p>You can also used <em>named arguments</em> instead of positional arguments when invoking a method. When using named arguments, you specify the parameter name followed by a colon (&quot;:&quot;) and the argument. Arguments to the method can appear in any order, as long as all required arguments are present. The following example uses named arguments to invoke the <code>TestMotorcycle.Drive</code> method. In this example, the named arguments are passed in the opposite order from the method&#39;s parameter list.</p>\n<pre><code name=\"csSnippets.Methods#45\">using System;\n\nclass TestMotorcycle : Motorcycle\n{\n   public override int Drive(int miles, int speed)\n   {\n      return (int) Math.Round( ((double)miles) / speed, 0);\n   }\n\n   public override double GetTopSpeed()\n   {\n      return 108.4;\n   }\n\n   static void Main()\n   {\n      \n      TestMotorcycle moto = new TestMotorcycle();\n      moto.StartEngine();\n      moto.AddGas(15);\n      var travelTime = moto.Drive(speed: 60, miles: 170);\n      Console.WriteLine(&quot;Travel time: approx. {0} hours&quot;, travelTime);            \n   }\n}\n// The example displays the following output:\n//      Travel time: approx. 3 hours\n</code></pre><p>You can invoke a method using both positional arguments and named arguments. However, a positional argument cannot follow a named argument. The following example invokes the <code>TestMotorcycle.Drive</code> method from the previous example using one positional argument and one named argument.</p>\n<pre><code name=\"csSnippets.Methods#46\">var travelTime = moto.Drive(170, speed: 55);\n</code></pre><p> <a name=\"inherited\"></a></p>\n<h2 id=\"inherited-and-overridden-methods\">Inherited and overridden methods</h2>\n<p>In addition to the members that are explicitly defined in a type, a type inherits members defined in its base classes. Since all types in the managed type system inherit directly or indirectly from the <a class=\"xref\" href=\"../../api/system.object\" data-linktype=\"relative-path\">Object</a> class, all types inherit its members, such as <a class=\"xref\" href=\"../../api/system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a>, <a class=\"xref\" href=\"../../api/system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a>, and <a class=\"xref\" href=\"../../api/system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a>. The following example defines a <code>Person</code> class, instantiates two <code>Person</code> objects, and calls the <code>Person.Equals</code> method to determine whether the two objects are equal. The <code>Equals</code> method, however, is not defined in the <code>Person</code> class; it is inherited from <a class=\"xref\" href=\"../../api/system.object\" data-linktype=\"relative-path\">Object</a>.</p>\n<pre><code name=\"csSnippets.Methods#104\">using System;\n\npublic class Person\n{\n   public String FirstName;\n}\n\npublic class Example\n{\n   public static void Main()\n   {\n      var p1 = new Person();\n      p1.FirstName = &quot;John&quot;;\n      var p2 = new Person();\n      p2.FirstName = &quot;John&quot;;\n      Console.WriteLine(&quot;p1 = p2: {0}&quot;, p1.Equals(p2));\n   }\n}\n// The example displays the following output:\n//      p1 = p2: False\n</code></pre><p>Types can override inherited members by using the <code>override</code> keyword and providing an implementation for the overridden method. The method signature must be the same as that of the overriden method. The following example is like the previous one, except that it overrides the @Object.Equals(System.Object) method. (It also overrides the @Object.GetHashCode method, since the two methods are intended to provide consistent results.)</p>\n<pre><code name=\"csSnippets.Methods#105\">using System;\n\npublic class Person\n{\n   public String FirstName;\n\n   public override bool Equals(object obj)\n   {\n      var p2 = obj as Person; \n      if (p2 == null)\n         return false;\n      else\n         return FirstName.Equals(p2.FirstName);\n   }\n\n   public override int GetHashCode()\n   {\n      return FirstName.GetHashCode();\n   } \n}\n\npublic class Example\n{\n   public static void Main()\n   {\n      var p1 = new Person();\n      p1.FirstName = &quot;John&quot;;\n      var p2 = new Person();\n      p2.FirstName = &quot;John&quot;;\n      Console.WriteLine(&quot;p1 = p2: {0}&quot;, p1.Equals(p2));\n   }\n}\n// The example displays the following output:\n//      p1 = p2: True\n</code></pre><p><a name=\"passing\"></a></p>\n<h2 id=\"passing-parameters\">Passing parameters</h2>\n<p>Types in C# are either <em>value types</em> or <em>reference types</em>. For a list of built-in value types, see <a href=\"tour-of-csharp/types-and-variables\" data-linktype=\"relative-path\">Types and variables</a>. By default, both value types and reference types are passed to a method by value.</p>\n<p><a name=\"byval\"></a></p>\n<h3 id=\"passing-parameters-by-value\">Passing parameters by value</h3>\n<p>When a value type is passed to a method by value, a copy of the object instead of the object itself is passed to the method. Therefore, changes to the object in the called method have no effect on the original object when control returns to the caller.</p>\n<p>The following example passes a value type to a method by value, and the called method attempts to change the value type&#39;s value. It defines a variable of type <code>int</code>, which is a value type, initializes its value to 20, and passes it to a method named <code>ModifyValue</code> that changes the variable&#39;s value to 30. When the method returns, however, the variable&#39;s value remains unchanged.</p>\n<pre><code name=\"csSnippets.Methods#10\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      int value = 20;\n      Console.WriteLine(&quot;In Main, value = {0}&quot;, value);\n      ModifyValue(value);\n      Console.WriteLine(&quot;Back in Main, value = {0}&quot;, value);\n   }\n\n   static void ModifyValue(int i)\n   {\n      i = 30;\n      Console.WriteLine(&quot;In ModifyValue, parameter value = {0}&quot;, i);\n      return;\n   }\n}\n// The example displays the following output:\n//      In Main, value = 20\n//      In ModifyValue, parameter value = 30\n//      Back in Main, value = 20\n</code></pre><p>When an object of a reference type is passed to a method by value, a reference to the object is passed by value. That is, the method receives not the object itself, but an argument that indicates the location of the object. If you change a member of the object by using this reference, the change is reflected in the object when control returns to the calling method. However, replacing the object passed to the method has no effect on the original object when control returns to the caller.</p>\n<p>The following example defines a class (which is a reference type) named <code>SampleRefType</code>. It instantiates a <code>SampleRefType</code> object, assigns 44 to its <code>value</code> field, and passes the object to the <code>ModifyObject</code> method. This example does essentially the same thing as the previous example -- it passes an argument by value to a method. But because a reference type is used, the result is different. The modification that is made in <code>ModifyObject</code> to the <code>obj.value</code> field also changes the <code>value</code> field of the argument, <code>rt</code>, in the <code>Main</code> method to 33, as the output from the example shows.</p>\n<pre><code name=\"csSnippets.Methods#42\">using System;\n\npublic class SampleRefType\n{\n    public int value;\n}\n\npublic class Example\n{\n    public static void Main()\n    {\n        var rt = new SampleRefType();\n        rt.value = 44;\n        ModifyObject(rt);\n        Console.WriteLine(rt.value);\n    }\n        \n    static void ModifyObject(SampleRefType obj)\n    {\n        obj.value = 33;\n    }\n}\n</code></pre><p><a name=\"byref\"></a></p>\n<h3 id=\"passing-parameters-by-reference\">Passing parameters by reference</h3>\n<p>You pass a parameter by reference when you want to change the value of an argument in a method and want to refect that change when control returns to the calling method. To pass a parameter by reference, you use the <code>ref</code> or <code>out</code> keyword.</p>\n<p>The following example is identical to the previous one, except the value is passed by reference to the <code>ModifyValue</code> method. When the value of the parameter is modified in the <code>ModifyValue</code> method, the change in value is reflected when control returns to the caller.</p>\n<pre><code name=\"csSnippets.Methods#106\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      int value = 20;\n      Console.WriteLine(&quot;In Main, value = {0}&quot;, value);\n      ModifyValue(ref value);\n      Console.WriteLine(&quot;Back in Main, value = {0}&quot;, value);\n   }\n\n   static void ModifyValue(ref int i)\n   {\n      i = 30;\n      Console.WriteLine(&quot;In ModifyValue, parameter value = {0}&quot;, i);\n      return;\n   }\n}\n// The example displays the following output:\n//      In Main, value = 20\n//      In ModifyValue, parameter value = 30\n//      Back in Main, value = 30\n</code></pre><p>A common pattern that uses by ref parameters involves swapping the values of variables. You pass two variables to a method by reference, and the method swaps their contents. The following example swaps integer values.</p>\n<pre><code name=\"csSnippets.Methods#106\">using System;\n\npublic class Example\n{\n   static void Main()\n   {\n      int i = 2, j = 3;\n      System.Console.WriteLine(&quot;i = {0}  j = {1}&quot; , i, j);\n\n      Swap(ref i, ref j);\n\n      System.Console.WriteLine(&quot;i = {0}  j = {1}&quot; , i, j);\n   }\n\n   static void Swap(ref int x, ref int y)\n   {\n      int temp = x;\n      x = y;\n      y = temp;\n   }   \n}\n// The example displays the following output:\n//      i = 2  j = 3\n//      i = 3  j = 2\n</code></pre><p>Passing a reference-type parameter allows you to change the value of the reference itself, rather than the value of its individual elements or fields.</p>\n<p><a name=\"paramarray\"></a></p>\n<h3 id=\"parameter-arrays\">Parameter arrays</h3>\n<p>Sometimes, the requirement that you specify the exact number of arguments to your method is restrictive. By using the <code>params</code> keyword to indicate that a parameter is a parameter array, you allow your method to be called with a variable number of arguments. The parameter tagged with the <code>params</code> keyword must must be an array type, and it must be the last parameter in the method&#39;s parameter list.</p>\n<p>A caller can then invoke the method in either of three ways:</p>\n<ul>\n<li>By passing an array of the appropriate type that contains the desired number of elements.</li>\n<li>By passing a comma-separated list of individual arguments of the appropriate type to the method.</li>\n<li>By not providing an argument to the parameter array.</li>\n</ul>\n<p>The following example defines a method named <code>DoStringOperation</code> that performs the string operation specified by its first parameter, a <code>StringOperation</code> enumeration member. The strings upon which it is to perform the operation are defined by a parameter array. The <code>Main</code> method illustrates all three ways of invoking the method. Note that the method tagged with the <code>params</code> keyword must be prepared to handle the case in which no argument is supplied for the parameter array, so that its value is <code>null</code>.</p>\n<pre><code name=\"csSnippets.Methods#106\">using System;\n\nclass Example \n{\n    static void Main() \n    {\n        int[] arr = {1, 4, 5};\n        Console.WriteLine(&quot;In Main, array has {0} elements and starts with {1}&quot;,\n                          arr.Length, arr[0]);\n\n        Change(ref arr);\n        Console.WriteLine(&quot;Back in Main, array has {0} elements and starts with {1}&quot;,\n                          arr.Length, arr[0]);\n    }\n\n    static void Change(ref int[] arr)\n    {\n        // Both of the following changes will affect the original variables:\n        arr = new int[5] {-9, -7, -5, -3, -1};\n        Console.WriteLine(&quot;In Change, array has {0} elements and starts with {1}&quot;,\n                          arr.Length, arr[0]);\n    }\n}\n// The example displays the following output:\n//        In Main, array has 3 elements and starts with 1\n//        In Change, array has 5 elements and starts with -9\n//        Back in Main, array has 5 elements and starts with -9\n</code></pre><p><a name=\"optional\"></a></p>\n<h2 id=\"optional-parameters-and-arguments\">Optional parameters and arguments</h2>\n<p>A method definition can specify that its parameters are required or that they are optional. By default, parameters are required. Optional parameters are specified by including the parameter&#39;s default value in the method definition. When the method is called, if no argument is supplied for an optional parameter, the default value is used instead.</p>\n<p>The parameter&#39;s default value must be assigned by one of the following kinds of expressions:</p>\n<ul>\n<li>A constant, such as a literal string or number.</li>\n<li>An expression of the form <code>new ValType</code>, where <code>ValType</code> is a value type. Note that this invokes the value type&#39;s implicit default constructor, which is not an actual member of the type.</li>\n<li>An expression of the form <code>default(ValType)</code>, where <code>ValType</code> is a value type.</li>\n</ul>\n<p>If a method includes both required and optional parameters, optional parameters are defined at the end of the parameter list, after all required parameters.</p>\n<p>The following example defines a method, <code>ExampleMethod</code>, that has one required and two optional parameters.</p>\n<pre><code name=\"csSnippets.Methods#21\">using System;\n\npublic class Options\n{\n   public void ExampleMethod(int required, int optionalInt = default(int),\n                             string description = &quot;Optional Description&quot;)\n   {\n      Console.WriteLine(&quot;{0}: {1} + {2} = {3}&quot;, description, required, \n                        optionalInt, required + optionalInt);\n   }\n}\n</code></pre><p>If a method with multiple optional arguments is invoked using positional arguments, the caller must supply an argument for all optional parameters from the first one to the last one for which an argument is supplied. In the case of the  <code>ExampleMethod</code> method, for example, if the caller supplies an argument for the <code>description</code> parameter, it must also supply one for the <code>optionalInt</code> parameter. <code>opt.ExampleMethod(2, 2, &quot;Addition of 2 and 2&quot;);</code> is a valid method call; <code>opt.ExampleMethod(2, , &quot;Addition of 2 and 0);</code> generates an &quot;Argument missing&quot; compiler error.</p>\n<p>If a method is called using named arguments or a combination of positional and named arguments, the caller can omit any arguments that follow the last positional argument in the method call.</p>\n<p>The following example calls the <code>ExampleMethod</code> method three times.  The first two method calls use positional arguments. The first omits both optional arguments, while the second omits the last argument. The third method call supplies a positional argument for the required parameter, but uses a named argument to supply a value to the <code>description</code> parameter while omitting the <code>optionalInt</code> argument.</p>\n<pre><code name=\"csSnippets.Methods#22\">public class Example\n{\n   public static void Main()\n   {\n      var opt = new Options();\n      opt.ExampleMethod(10);\n      opt.ExampleMethod(10, 2);\n      opt.ExampleMethod(12, description: &quot;Addition with zero:&quot;);\n   }\n} \n// The example displays the following output:\n//      Optional Description: 10 + 0 = 10\n//      Optional Description: 10 + 2 = 12\n//      Addition with zero:: 12 + 0 = 12\n</code></pre><p>The use of optional parameters affects <em>overload resolution</em>, or the way in which the C# compiler determines which particular overload should be invoked by a method call, as follows:</p>\n<ul>\n<li>A method, indexer, or constructor is a candidate for execution if each of its parameters either is optional or corresponds, by name or by position, to a single argument in the calling statement, and that argument can be converted to the type of the parameter.</li>\n<li>If more than one candidate is found, overload resolution rules for preferred conversions are applied to the arguments that are explicitly specified. Omitted arguments for optional parameters are ignored.</li>\n<li>If two candidates are judged to be equally good, preference goes to a candidate that does not have optional parameters for which arguments were omitted in the call. This is a consequence of a general preference in overload resolution for candidates that have fewer parameters.</li>\n</ul>\n<p> <a name=\"return\"></a></p>\n<h2 id=\"return-values\">Return values</h2>\n<p>Methods can return a value to the caller. If the return type (the type listed before the method name) is not <code>void</code>, the method can return the value by using the <code>return</code> keyword. A statement with the <code>return</code> keyword followed by a variable, constant, or expression that matches the return type will return that value to the method caller. Methods with a non-void return type are required to use the <code>return</code> keyword to return a value. The <code>return</code> keyword also stops the execution of the method.</p>\n<p>If the return type is <code>void</code>, a <code>return</code> statement without a value is still useful to stop the execution of the method. Without the <code>return</code> keyword, the method will stop executing when it reaches the end of the code block.</p>\n<p>For example, these two methods use the <code>return</code> keyword to return integers:</p>\n<pre><code name=\"csSnippets.Methods#44\">class SimpleMath\n{\n    public int AddTwoNumbers(int number1, int number2)\n    {\n        return number1 + number2;\n    }\n\n    public int SquareANumber(int number)\n    {\n        return number * number;\n    }\n}\n</code></pre><p>To use a value returned from a method, the calling method can use the method call itself anywhere a value of the same type would be sufficient. You can also assign the return value to a variable. For example, the following two code examples accomplish the same goal:</p>\n<pre><code name=\"csSnippets.Methods#45\">int result = obj.AddTwoNumbers(1, 2);\nresult = obj.SquareANumber(result);\n// The result is 9.\nConsole.WriteLine(result);\n</code></pre><pre><code name=\"csSnippets.Methods#46\">result = obj.SquareANumber(obj.AddTwoNumbers(1, 2));\n// The result is 9.\nConsole.WriteLine(result);\n</code></pre><p>Using a local variable, in this case, <code>result</code>, to store a value is optional. It may help the readability of the code, or it may be necessary if you need to store the original value of the argument for the entire scope of the method.</p>\n<p>Sometimes, you want your method to return more than a single value. Starting with C# 7.0, you can do this easily by using <em>tuple types</em> and <em>tuple literals</em>. The tuple type defines the data types of the tuple&#39;s elements. Tuple literals provide the actual values of the returned tuple. In teh following example, <code>(string, string, string, int)</code> defines the tuple type that is returned by the <code>GetPersonalInfo</code> method. The expression <code>(per.FirstName, per.MiddleName, per.LastName, per.Age)</code> is the tuple literal; the method returns the first, middle, and last name, along with the age, of a <code>PersonInfo</code> object.</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public (string, string, string, int) GetPersonalInfo(string id)\n{\n    PersonInfo per = PersonInfo.RetrieveInfoById(id);\n    if (per != null)\n       return (per.FirstName, per.MiddleName, per.LastName, per.Age);\n    else\n       return null;\n}\n</code></pre><p>The caller can then consume the returned tuple with code like the following:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var person = GetPersonalInfo(&quot;111111111&quot;)\nif (person != null)\n   Console.WriteLine(&quot;{person.Item1} {person.Item3}: age = {person.Item4}&quot;);\n</code></pre><p>Names can also be assigned to the tuple elements in the tuple type definition. The following example shows an alternate version of the <code>GetPersonalInfo</code> method that uses named elements:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public (string FName, string MName, string LName, int Age) GetPersonalInfo(string id)\n{\n    PersonInfo per = PersonInfo.RetrieveInfoById(id);\n    if (per != null)\n       return (per.FirstName, per.MiddleName, per.LastName, per.Age);\n    else\n       return null;\n}\n</code></pre><p>The previous call to the <code>GetPersonInfo</code> method can then be modified as follows:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var person = GetPersonalInfo(&quot;111111111&quot;);\nif (person != null)\n   Console.WriteLine(&quot;{person.FName} {person.LName}: age = {person.Age}&quot;);\n</code></pre><p>If a method is passed an array as an argument and modifies the value of individual elements, it is not necessary for the method to return the array, although you may choose to do so for good style or functional flow of values.  This is because C# passes all reference types by value, and the value of an array reference is the pointer to the array. In the following example, changes to the contents of the <code>values</code> array that are made in the <code>DoubleValues</code> method are observable by any code that has a reference to the array.</p>\n<pre><code name=\"csSnippets.Methods#101\">\n\nusing System;\n\npublic class Example\n{\n   static void Main(string[] args)  \n   {  \n      int[] values = { 2, 4, 6, 8 };\n      DoubleValues(values);\n      foreach (var value in values)\n         Console.Write(&quot;{0}  &quot;, value);\n   }  \n  \n   public static void DoubleValues(int[] arr)\n   {\n      for (int ctr = 0; ctr &lt;= arr.GetUpperBound(0); ctr++)\n         arr[ctr] = arr[ctr] * 2;\n   }\n}\n// The example displays the following output:\n//       4  8  12  16\n</code></pre><p> <a name=\"exten\"></a></p>\n<h2 id=\"extension-methods\">Extension methods</h2>\n<p>Ordinarily, there are two ways to add a method to an existing type:</p>\n<ul>\n<li>Modify the source code for that type. You cannot do this, of course, if you do not own the type&#39;s source code. And this becomes a breaking change if you also add any private data fields to support the method.</li>\n<li>Define the new method in a derived class. A method cannot be added in this way using inheritance for other types, such as structures and enumerations. Nor can it be used to &quot;add&quot; a method to a sealed class.</li>\n</ul>\n<p>Extension methods let you &quot;add&quot; a method to an existing type without modifying the type itself or implementing the new method in an inherited type. The extension method also does not have to reside in the same assembly as the type it extends. You call an extension method as if it were a defined member of a type.</p>\n<p>For more information, see <a href=\"https://msdn.microsoft.com/library/bb383977.aspx\" data-linktype=\"external\">Extension Methods</a>.</p>\n<p><a name=\"async\"></a></p>\n<h2 id=\"async-methods\">Async Methods</h2>\n<p>By using the async feature, you can invoke asynchronous methods without using explicit callbacks or manually splitting your code across multiple methods or lambda expressions.</p>\n<p>If you mark a method with the <a href=\"https://msdn.microsoft.com/library/hh156513.aspx\" data-linktype=\"external\">async</a> modifier, you can use the <a href=\"https://msdn.microsoft.com/library/hh156528.aspx\" data-linktype=\"external\">await</a> operator in the method. When control reaches an <code>await</code> expression in the async method, control returns to the caller if the awaited task is not completed, and progress in the method with the <code>await</code> keyword is suspended until the awaited task completes. When the task is complete, execution can resume in the method.</p>\n<div class=\"NOTE\"><h5>Note</h5><p>An async method returns to the caller when either it encounters the first awaited object thatâ€™s not yet complete or it gets to the end of the async method, whichever occurs first.</p>\n</div>\n<p>An async method can have a return type of @System.Threading.Tasks.Task&lt;TResult&gt;, <a class=\"xref\" href=\"../../api/system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a>, or <code>void</code>. The <code>void</code> return type is used primarily to define event handlers, where a <code>void</code> return type is required. An async method that returns <code>void</code> can&#39;t be awaited, and the caller of a void-returning method can&#39;t catch exceptions that the method throws. C# 7, when it is released, will ease this restriction to allow an async method <a href=\"https://github.com/ljw1004/roslyn/blob/features/async-return/docs/specs/feature%20-%20arbitrary%20async%20returns.md\" data-linktype=\"external\">to return any task-like type</a>.</p>\n<p>In the following example, <code>DelayAsync</code> is an async method that has a return statement that returns an integer. Because it is an async method, its method declaration must have a return type of <code>Task&lt;int&gt;</code>. Because the return type is <code>Task&lt;int&gt;</code>, the evaluation of the <code>await</code> expression in <code>DoSomethingAsync</code> produces an integer, as the following <code>int result = await delayTask</code> statement demonstrates.</p>\n<pre><code name=\"csSnippets.Methods#102\">using System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\npublic class Example\n{\n    // This Click event is marked with the async modifier.\n    public static void Main()\n    {\n       DoSomethingAsync().Wait();\n    }\n\n    private static async Task DoSomethingAsync()\n    {\n        int result = await DelayAsync();\n        Console.WriteLine(&quot;Result: &quot; + result);\n    }\n\n    private static async Task&lt;int&gt; DelayAsync()\n    {\n        await Task.Delay(100);\n        return 5;\n    }\n\n    // Output:\n    //  Result: 5\n}\n// The example displays the following output:\n//        Result: 5\n</code></pre><p>An async method can&#39;t declare any <a href=\"https://msdn.microsoft.com/library/14akc2c7.aspx\" data-linktype=\"external\">ref</a> or <a href=\"https://msdn.microsoft.com/library/t3c3bfhx.aspx\" data-linktype=\"external\">out</a> parameters, but it can call methods that have such parameters.</p>\n<p> For more information about async methods, see <a href=\"https://msdn.microsoft.com/library/mt674882.aspx\" data-linktype=\"external\">Asynchronous Programming with Async and Await</a>, <a href=\"https://msdn.microsoft.com/library/mt674892.aspx\" data-linktype=\"external\">Control Flow in Async Programs</a>, and <a href=\"https://msdn.microsoft.com/library/mt674893.aspx\" data-linktype=\"external\">Async Return Types</a>.</p>\n<p><a name=\"expr\"></a></p>\n<h2 id=\"expression-bodied-members\">Expression-bodied members</h2>\n<p>It is common to have method definitions that simply return immediately with the result of an expression, or that have a single statement as the body of the method.  There is a syntax shortcut for defining such methods using <code>=&gt;</code>:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">\npublic Point Move(int dx, int dy) =&gt; new Point(x + dx, y + dy);\npublic void Print() =&gt; Console.WriteLine(First + &quot; &quot; + Last);\n// Works with operators, properties, and indexers too.\npublic static Complex operator +(Complex a, Complex b) =&gt; a.Add(b);\npublic string Name =&gt; First + &quot; &quot; + Last;\npublic Customer this[long id] =&gt; store.LookupCustomer(id);\n</code></pre><p>If the method returns <code>void</code> or is an async method, the body of the method must be a statement expression (same as with lambdas).  For properties and indexers, they must be read-only, and you do not use the <code>get</code> accessor keyword.</p>\n<p><a name=\"iterators\"></a></p>\n<h2 id=\"iterators\">Iterators</h2>\n<p>An iterator performs a custom iteration over a collection, such as a list or an array. An iterator uses the <a href=\"https://msdn.microsoft.com/library/9k7k7cf0.aspx\" data-linktype=\"external\">yield return</a> statement to return each element one at a time. When a <code>yield return</code> statement is reached, the current location is remembered so that the caller can request the next element in the sequence.</p>\n<p>The return type of an iterator can be <a class=\"xref\" href=\"../../api/system.collections.ienumerable\" data-linktype=\"relative-path\">IEnumerable</a>, <a class=\"xref\" href=\"../../api/system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable&lt;T&gt;</a>, <a class=\"xref\" href=\"../../api/system.collections.ienumerator\" data-linktype=\"relative-path\">IEnumerator</a>, or <a class=\"xref\" href=\"../../api/system.collections.generic.ienumerator-1\" data-linktype=\"relative-path\">IEnumerator&lt;T&gt;</a>.</p>\n<p>For more information, see <a href=\"https://msdn.microsoft.com/library/mt639331.aspx\" data-linktype=\"external\">Iterators</a>.</p>\n<h2 id=\"see-also\">See also</h2>\n<p><a href=\"https://msdn.microsoft.com/library/wxh6fsc7.aspx\" data-linktype=\"external\">Access Modifiers</a>\n<a href=\"https://msdn.microsoft.com/library/79b3xss3.aspx\" data-linktype=\"external\">Static Classes and Static Class Members</a>\n<a href=\"https://msdn.microsoft.com/library/ms173149.aspx\" data-linktype=\"external\">Inheritance</a>\n<a href=\"https://msdn.microsoft.com/library/ms173150.aspx\" data-linktype=\"external\">Abstract and Sealed Classes and Class Members</a>\n<a href=\"https://msdn.microsoft.com/library/w5zay9db.aspx\" data-linktype=\"external\">params</a>\n<a href=\"https://msdn.microsoft.com/library/t3c3bfhx.aspx\" data-linktype=\"external\">out</a>\n<a href=\"https://msdn.microsoft.com/library/14akc2c7.aspx\" data-linktype=\"external\">ref</a>\n<a href=\"https://msdn.microsoft.com/library/0f66670z.aspx\" data-linktype=\"external\">Passing Parameters</a></p>\n</a></div></div>","outputRootRelativePath":"../../","pageMetadata":"<meta name=\"author\" content=\"rpetrusha\">\r\n<meta name=\"ms.author\" content=\"ronpet\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc1.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"577a8527-1081-4b36-9b9e-0685b6553c6e\">\r\n<meta name=\"description\" content=\"Overview of methods, method parameters, and method return values\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core, C#\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"10/26/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/7ac95fa4b2aac81b2e8d33cedf2faf36a0bbf210/docs/csharp/methods.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/methods.md\">\r\n<meta name=\"document_id\" content=\"fb4d0985-d7ef-2fe4-3df1-756f9a7d919e\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../toc1.json\">\r\n","rawMetadata":{"author":"rpetrusha","ms.author":"ronpet","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","title":"Methods | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"577a8527-1081-4b36-9b9e-0685b6553c6e","description":"Overview of methods, method parameters, and method return values","keywords":".NET, .NET Core, C#","ms.topic":"article","ms.date":"10/26/2016","ms.technology":"devlang-csharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"expression-bodied should be hyphenated (#1384)","commit_sha":"7ac95fa4b2aac81b2e8d33cedf2faf36a0bbf210","commit_date":"2017-01-05 10:03:42 -0500"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Absolute urls and other fixes (#1281)","commit_sha":"f7dffe4885b331cec8d37f3cc5c9163f69c3b4c9","commit_date":"2016-11-22 12:57:26 -0800"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Two edits, and modified TOC","commit_sha":"05f8da5b6edef6b714c78d03457a6bea865a5e66","commit_date":"2016-11-07 08:21:30 -0800"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Added changes lost during merge.","commit_sha":"d8b976d2fb75fd4a6a93420aa7e058199d4b5348","commit_date":"2016-11-02 11:34:29 -0700"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Corrected publishing errors","commit_sha":"b93165542580f231443250109b1188013c1ca370","commit_date":"2016-11-02 11:34:29 -0700"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Incorporated comments.","commit_sha":"aa66541b0d2fbc40bf63ef5c776a43481c995b3d","commit_date":"2016-11-02 11:34:29 -0700"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Methods topic ported from MSDN and revised.","commit_sha":"f4010a199b3b2458ba1ac891e1177182b9bc8e2f","commit_date":"2016-11-02 11:34:29 -0700"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"renamed repo/fixed headings (#1186)","commit_sha":"15c55a87beb64f265a164db918c7721c7690fadf","commit_date":"2016-10-29 15:23:17 -0400"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Create outlines for csharp 7 (#1115)","commit_sha":"ada1b8f1252962556e42f180046b9b019307622c","commit_date":"2016-10-06 21:10:34 -0400"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/rpetrusha","display_name":"rpetrusha","id":"10886961"},"contributors":[{"profile_url":"https://github.com/rpetrusha","display_name":"rpetrusha"},{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/7ac95fa4b2aac81b2e8d33cedf2faf36a0bbf210/docs/csharp/methods.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/methods.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/methods.md","document_id":"fb4d0985-d7ef-2fe4-3df1-756f9a7d919e","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/methods","toc_asset_id":"articles/toc.json","toc_rel":"../toc.json","_op_ogTitle":"Methods","_op_displayDate":"2016-10-26","_op_displayDate_source":"2016-10-26T00:00:00Z","_op_wordCount":4380,"_op_rawTitle":"<h1 id=\"methods\" sourcefile=\"docs/csharp/methods.md\" sourcestartlinenumber=\"14\" sourceendlinenumber=\"14\">Methods</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/methods","fileRelativePath":"articles/csharp/methods.html"},"themesRelativePathToOutputRoot":"_themes/"}