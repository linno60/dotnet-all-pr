{"content":"<div><div class=\"content\">\n<p>In this tutorial you&#39;ll learn what versioning means in .NET. You&#39;ll also learn the factors to consider when versioning your library as well as upgrading\nto a new version of the a library.</p>\n<h2 id=\"authoring-libraries\">Authoring Libraries</h2>\n<p>As a developer who has created .NET libraries for public use, you&#39;ve most likely been in situations where you have\nto roll out new updates. How you go about this process matters a lot as you need to ensure that there&#39;s a seamless transition\nof existing code to the new version of your library. Here are several things to consider when creating a new release:</p>\n<h3 id=\"semantic-versioning\">Semantic Versioning</h3>\n<p><a href=\"http://semver.org/\" data-linktype=\"external\">Semantic versioning</a> (SemVer for short) is a naming convention applied to versions of your library to signify specific milestone events.\nIdeally, the version information you give your library should help developers determine the compatibility\nwith their projects that make use of older versions of that same library.</p>\n<p>The most basic approach to SemVer is the 3 component format <code>MAJOR.MINOR.PATCH</code>, where:</p>\n<ul>\n<li><code>MAJOR</code> is incremented when you make incompatible API changes</li>\n<li><code>MINOR</code> is incremented when you add functionality in a backwards-compatible manner</li>\n<li><code>PATCH</code> is incremented when you make backwards-compatible bug fixes</li>\n</ul>\n<p>There are also ways to specify other scenarios like pre-release versions etc. when applying version information to your .NET library.</p>\n<h3 id=\"backwards-compatibility\">Backwards Compatibility</h3>\n<p>As you release new versions of your library, backwards compatibility with previous versions will most likely be one of your major concerns.\nA new version of your library is source compatible with a previous version if code that depends on the previous version can, when recompiled, work with the new version. \nA new version of your library is binary compatible if an application that depended on the old version can, without recompilation, work with the new version.</p>\n<p>Here are some things to consider when trying to maintain backwards compatibility with older versions of your library:</p>\n<ul>\n<li>Virtual methods: When you make a virtual method non-virtual in your new version it means that projects that override that method\nwill have to be updated. This is a huge breaking change and is strongly discouraged.</li>\n<li>Method signatures: When updating a method behaviour requires you to change its signature as well, you should instead create an overload so that code calling into that method will still work.\nYou can always manipulate the old method signature to call into the new method signature so that implementation remains consistent.</li>\n<li><a href=\"programming-guide/concepts/attributes/common-attributes#Obsolete\" data-linktype=\"relative-path\">Obsolete attribute</a>: You can use this attribute in your code to specify classes or class members that are deprecated and likely to be removed in future versions.\nThis ensures developers utilizing your library are better prepared for breaking changes.</li>\n<li>Optional Method Arguments: When you make previously optional method arguments compulsory or change their default value then all code that does not supply those arguments will need to be updated.\n&gt; [!NOTE]\n&gt; Making compulsory arguments optional should have very little effect especially if it doesn&#39;t change the method&#39;s behaviour.</li>\n</ul>\n<p>The easier you make it for your users to upgrade to the new version of your library, the more likely that they will upgrade sooner.</p>\n<h3 id=\"application-configuration-file\">Application Configuration File</h3>\n<p>As a .NET developer there&#39;s a very high chance you&#39;ve encountered <a href=\"https://msdn.microsoft.com/en-us/library/1fk1t1t0(v=vs.110).aspx\" data-linktype=\"external\">the <code>app.config</code> file</a> present in most project types.\nThis simple configuration file can go a long way into improving the rollout of new updates. You should generally design your libraries in such\na way that information that is likely to change regularly is stored in the <code>app.config</code> file, this way when such information is updated\nthe config file of older versions just needs to be replaced with the new one without the need for recompilation of the library.</p>\n<h2 id=\"consuming-libraries\">Consuming Libraries</h2>\n<p>As a developer that consumes .NET libraries built by other developers you&#39;re most likely aware that a new version of a library might not be fully compatible with your project\nand you might often find yourself having to update your code to work with those changes.</p>\n<p>Lucky for you C# and the .NET ecosystem comes with features and techniques that allow us to easily update our app to work with new versions of libraries that might introduce breaking changes.</p>\n<h3 id=\"assembly-binding-redirection\">Assembly Binding Redirection</h3>\n<p>You can use the <code>app.config</code> file to update the version of a library your app uses. By adding what is called a <a href=\"https://msdn.microsoft.com/en-us/library/7wd6ex19(v=vs.110).aspx\" data-linktype=\"external\"><em>binding redirect</em></a> your\ncan use the new library version without having to recompile your app. The following example shows how you would update\nyour app&#39;s <code>app.config</code> file to use the <code>1.0.1</code> patch version of <code>ReferencedLibrary</code> instead of the <code>1.0.0</code> version it was originally compiled with.</p>\n<pre class=\"loading\"><code class=\"lang-xml\">&lt;dependentAssembly&gt;\n    &lt;assemblyIdentity name=&quot;ReferencedLibrary&quot; publicKeyToken=&quot;32ab4ba45e0a69a1&quot; culture=&quot;en-us&quot; /&gt;\n    &lt;bindingRedirect oldVersion=&quot;1.0.0&quot; newVersion=&quot;1.0.1&quot; /&gt;\n&lt;/dependentAssembly&gt;\n</code></pre><div class=\"NOTE\"><h5>Note</h5><p>This approach will only work if the new version of <code>ReferencedLibrary</code> is binary compatible with your app.\nSee the <a href=\"#backwards-compatibility\" data-linktype=\"self-bookmark\">Backwards Compatibility</a> section above for changes to look out for when determining compatibility.</p>\n</div>\n<h3 id=\"new\">new</h3>\n<p>You use the <code>new</code> modifier to hide inherited members of a base class. This is one way derived classes can respond to updates in base classes.</p>\n<p>Take the following example:</p>\n<pre><code class=\"lang-csharp\" name=\"Sample usage of the &#39;new&#39; modifier\">public class BaseClass\n{\n    public void MyMethod()\n    {\n        Console.WriteLine(&quot;A base method&quot;);\n    }\n}\n\npublic class DerivedClass : BaseClass\n{\n    public new void MyMethod()\n    {\n        Console.WriteLine(&quot;A derived method&quot;);\n    }\n}\n\npublic static void Main()\n{\n    BaseClass b = new BaseClass();\n    DerivedClass d = new DerivedClass();\n\n    b.MyMethod();\n    d.MyMethod();\n}\n</code></pre><p><strong>Output</strong></p>\n<pre class=\"loading\"><code>A base method\nA derived method\n</code></pre><p>From the example above you can see how <code>DerivedClass</code> hides the <code>MyMethod</code> method present in <code>BaseClass</code>.\nThis means that when a base class in the new version of a library adds a member that already exists in your derived class, you can\nsimply use the <code>new</code> modifier on your derived class member to hide the base class member.</p>\n<p>When no <code>new</code> modifier is specified, a derived class will by default hide conflicting members in a base class,\nalthough a compiler warning will be generated the code will still compile. This means that simply adding new members to an existing class\nmakes that new version of your library both source and binary compatible with code that depends on it.</p>\n<h3 id=\"override\">override</h3>\n<p>The <code>override</code> modifier means a derived implementation extends the implementation of a base class member rather than\nhides it. The base class member needs to have the <code>virtual</code> modifier applied to it.</p>\n<pre><code class=\"lang-csharp\" name=\"Sample usage of the &#39;override&#39; modifier\">public class MyBaseClass\n{\n    public virtual string MethodOne()\n    {\n        return &quot;Method One&quot;;\n    }\n}\n\npublic class MyDerivedClass : MyBaseClass\n{\n    public override string MethodOne()\n    {\n        return &quot;Derived Method One&quot;;\n    }\n}\n\npublic static void Main()\n{\n    MyBaseClass b = new MyBaseClass();\n    MyDerivedClass d = new MyDerivedClass();\n\n    Console.WriteLine(&quot;Base Method One: {0}&quot;, b.MethodOne());\n    Console.WriteLine(&quot;Derived Method One: {0}&quot;, d.MethodOne());\n}\n</code></pre><p><strong>Output</strong></p>\n<pre class=\"loading\"><code>Base Method One: Method One\nDerived Method One: Derived Method One\n</code></pre><p>The <code>override</code> modifier is evaluated at compile time and the compiler will throw an error if it doesn&#39;t find a virtual member to override.</p>\n<p>Your knowledge of the discussed techniques as well as your understanding of what situations to use them will go a long way to boost the ease\nof transition between versions of a library.</p>\n</div></div>","outputRootRelativePath":"../../","pageMetadata":"<meta name=\"author\" content=\"tsolarin\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"aa8732d7-5cd0-46e1-994a-78017f20d861\">\r\n<meta name=\"description\" content=\"Understand how versioning works in C# and .NET\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core, C#\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"01/08/2017\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\"visual-studio-dev-14\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/6308e17539e5388e887a728870902b456ed9ebe7/docs/csharp/versioning.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/versioning.md\">\r\n<meta name=\"document_id\" content=\"403e07b1-eb62-acbf-8cdf-4a9b28572c39\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../toc2.json\">\r\n","rawMetadata":{"author":"tsolarin","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","uhfHeaderId":"MSDocsHeader-DotNet","title":"C# Versioning | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"aa8732d7-5cd0-46e1-994a-78017f20d861","description":"Understand how versioning works in C# and .NET","keywords":".NET, .NET Core, C#","ms.topic":"article","ms.date":"01/08/2017","ms.technology":"devlang-csharp","ms.prod":"visual-studio-dev-14","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Toni Solarin-Sodara","author_email":"toni.edward@outlook.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"C# Versioning (#1197)","commit_sha":"6308e17539e5388e887a728870902b456ed9ebe7","commit_date":"2017-01-09 12:18:06 -0500"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/tsolarin","display_name":"Toni Solarin-Sodara","id":"7319262"},"contributors":[{"profile_url":"https://github.com/tsolarin","display_name":"Toni Solarin-Sodara"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/6308e17539e5388e887a728870902b456ed9ebe7/docs/csharp/versioning.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/versioning.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/versioning.md","document_id":"403e07b1-eb62-acbf-8cdf-4a9b28572c39","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/versioning","toc_asset_id":"articles/toc.json","toc_rel":"../toc.json","_op_ogTitle":"C# Versioning","_op_displayDate":"2017-1-8","_op_displayDate_source":"2017-01-08T00:00:00Z","_op_wordCount":1156,"_op_rawTitle":"<h1 id=\"versioning-in-c\" sourcefile=\"docs/csharp/versioning.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Versioning in C#</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/versioning","fileRelativePath":"articles/csharp/versioning.html"},"themesRelativePathToOutputRoot":"_themes/"}