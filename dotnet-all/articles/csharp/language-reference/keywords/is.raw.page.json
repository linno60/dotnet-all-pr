{"content":"<div><div class=\"content\">\n<p>Checks if an object is compatible with a given type, or (starting with C# 7) tests an expression against a pattern.</p>\n<h2 id=\"testing-for-type-compatibility\">Testing for type compatibility</h2>\n<p>The <code>is</code> keyword evaluates type compatibility at runtime. It determines whether an object instance or the result of an expression can be converted to a specified type. It has the syntax</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">   expr is type\n</code></pre><p>where <em>expr</em> is an expression that evaluates to an instance of some type, and <em>type</em> is the name of the type to which the result of <em>expr</em> is to be converted. The <code>is</code> statement is <code>true</code> if <em>expr</em> is non-null and the object that results from evaluating the expression can be converted to <em>type</em>; otherwise, it returns <code>false</code>.</p>\n<p>For example, the following code determines if <code>obj</code> can be cast to an instance of the <code>Person</code> type:</p>\n<pre><code class=\"lang-cs\" name=\"is#1\">if (obj is Person) {\n   // Do something if obj is a Person.\n}\n</code></pre><p>The <code>is</code> statement is true if:</p>\n<ul>\n<li><p><em>expr</em> is an instance of the same type as <em>type</em>.</p>\n</li>\n<li><p><em>expr</em> is an instance of a type that derives from <em>type</em>. In other words, the result of <em>expr</em> can be upcast to an instance of <em>type</em>.</p>\n</li>\n<li><p><em>expr</em> has a compile-time type that is a base class of <em>type</em>, and <em>expr</em> has a runtime type that is <em>type</em> or is derived from <em>type</em>. The <em>compile-time type</em> of a variable is the variable&#39;s type as defined in its declaration. The <em>runtime type</em> of a variable is the type of the instance that is assigned to that variable.</p>\n</li>\n<li><p><em>expr</em> is an instance of a type that implements the <em>type</em> interface.</p>\n</li>\n</ul>\n<p>The following example shows that the <code>is</code> expression evaluates to <code>true</code> for each of these conversions.</p>\n<pre><code class=\"lang-cs\" name=\"is#3\">using System;\n\npublic class Class1 : IFormatProvider\n{\n   public object GetFormat(Type t)\n   {\n      if (t.Equals(this.GetType()))      \n         return this;\n      return null;\n   }\n}\n\npublic class Class2 : Class1\n{\n   public int Value { get; set; }\n}\n\npublic class Example\n{\n   public static void Main()\n   {\n      var cl1 = new Class1();\n      Console.WriteLine(cl1 is IFormatProvider);\n      Console.WriteLine(cl1 is Object);\n      Console.WriteLine(cl1 is Class1);\n      Console.WriteLine(cl1 is Class2); \n      Console.WriteLine();\n \n      var cl2 = new Class2();\n      Console.WriteLine(cl2 is IFormatProvider);\n      Console.WriteLine(cl2 is Class2);\n      Console.WriteLine(cl2 is Class1);\n      Console.WriteLine();\n      \n      Class1 cl = cl2;\n      Console.WriteLine(cl is Class1);\n      Console.WriteLine(cl is Class2);\n   }\n}\n// The example displays the following output:\n//     True\n//     True\n//     True\n//     False\n//     \n//     True\n//     True\n//     True\n//     \n//     True\n//     True\n</code></pre><p>The <code>is</code> keyword generates a compile-time warning if the expression is known to always be either <code>true</code> or <code>false</code>. It only considers reference conversions, boxing conversions, and unboxing conversions; it does not consider user-defined conversions or conversions defined by a type&#39;s <a href=\"implicit\" data-linktype=\"relative-path\">implicit</a> and <a href=\"explicit\" data-linktype=\"relative-path\">explicit</a> operators. The following example generates warnings because the result of the conversion is known at compile-time. Note that the <code>is</code> expression for conversions from <code>int</code> to <code>long</code> and <code>double</code> return false, since these conversions are handled by the <a href=\"implicit\" data-linktype=\"relative-path\">implicit</a> operator.</p>\n<pre><code class=\"lang-cs\" name=\"is#2\">Console.WriteLine(3 is int);\nConsole.WriteLine();\n\nint value = 6;\nConsole.WriteLine(value is long);\nConsole.WriteLine(value is double);\nConsole.WriteLine(value is object);\nConsole.WriteLine(value is ValueType);\nConsole.WriteLine(value is int);\n// Compilation generates the following compiler warnings:\n//   is2.cs(8,25): warning CS0183: The given expression is always of the provided (&#39;int&#39;) type\n//   is2.cs(12,25): warning CS0184: The given expression is never of the provided (&#39;long&#39;) type\n//   is2.cs(13,25): warning CS0184: The given expression is never of the provided (&#39;double&#39;) type\n//   is2.cs(14,25): warning CS0183: The given expression is always of the provided (&#39;object&#39;) type\n//   is2.cs(15,25): warning CS0183: The given expression is always of the provided (&#39;ValueType&#39;) type\n//   is2.cs(16,25): warning CS0183: The given expression is always of the provided (&#39;int&#39;) type\n</code></pre><p><code>expr</code> can be any expression that returns a value, with the exception of anonymous methods and lambda expressions. The following example uses  <code>is</code> to evaluate the return value of a method call.   </p>\n<pre><code class=\"lang-cs\" name=\"is#4\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      double number1 = 12.63; \n      if (Math.Ceiling(number1) is double)\n         Console.WriteLine(&quot;The expression returns a double.&quot;);\n      else if (Math.Ceiling(number1) is decimal)    \n         Console.WriteLine(&quot;The expression returns a decimal.&quot;);\n\n      decimal number2 = 12.63m; \n      if (Math.Ceiling(number2) is double)\n         Console.WriteLine(&quot;The expression returns a double.&quot;);\n      else if (Math.Ceiling(number2) is decimal)    \n         Console.WriteLine(&quot;The expression returns a decimal.&quot;);\n\n   }\n}\n// The example displays the following output:\n//     The expression returns a double.\n//     The expression returns a decimal.\n</code></pre><p>Starting with C# 7, you can use pattern matching with the <a href=\"#type\" data-linktype=\"self-bookmark\">type pattern</a> to write more concise code that uses the <code>is</code> statement.</p>\n<h2 id=\"pattern-matching-with-is\">Pattern matching with <code>is</code></h2>\n<p>Starting with C# 7, the <code>is</code> and <a href=\"switch\" data-linktype=\"relative-path\">switch</a> statements support pattern matching. The <code>is</code> keyword supports the following patterns:</p>\n<ul>\n<li><p><a href=\"#type\" data-linktype=\"self-bookmark\">Type pattern</a>,  which tests whether an expression can be converted to a specified type and, if it can be, casts it to a variable of that type.</p>\n</li>\n<li><p><a href=\"#constant\" data-linktype=\"self-bookmark\">Constant pattern</a>, which tests whether an expression evaluates to a specified constant value.</p>\n</li>\n<li><p><a href=\"#var\" data-linktype=\"self-bookmark\">var pattern</a>, a match that always succeeds and binds the value of an expression to a new local variable. </p>\n</li>\n</ul>\n<h3 id=\"a-nametype--type-pattern-a\"><a name=\"type\"></a> Type pattern </h3>\n<p>When using the type pattern to perform pattern matching, <code>is</code> tests whether an expression can be converted to a specified type and, if it can be, casts it to a variable of that type. It is a straightforward extension of the <code>is</code> statement that enables concise type evaluation and conversion. The general form of the <code>is</code> type pattern is:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">   expr is type varname \n</code></pre><p>where <em>expr</em> is an expression that evaluates to an instance of some type, <em>type</em> is the name of the type to which the result of <em>expr</em> is to be converted, and <em>varname</em> is the object to which the result of <em>expr</em> is converted if the <code>is</code> test is <code>true</code>. </p>\n<p>The <code>is</code> expression is <code>true</code> if any of the following is true:</p>\n<ul>\n<li><p><em>expr</em> is an instance of the same type as <em>type</em>.</p>\n</li>\n<li><p><em>expr</em> is an instance of a type that derives from <em>type</em>. In other words, the result of <em>expr</em> can be upcast to an instance of <em>type</em>.</p>\n</li>\n<li><p><em>expr</em> has a compile-time type that is a base class of <em>type</em>, and <em>expr</em> has a runtime type that is <em>type</em> or is derived from <em>type</em>. The <em>compile-time type</em> of a variable is the variable&#39;s type as defined in its declaration. The <em>runtime type</em> of a variable is the type of the instance that is assigned to that variable.</p>\n</li>\n<li><p><em>expr</em> is an instance of a type that implements the <em>type</em> interface.</p>\n</li>\n</ul>\n<p>If <em>exp</em> is <code>true</code> and <code>is</code> is used with an <code>if</code> statement, <em>varname</em> is assigned and has local scope within the <code>if</code> statement only.</p>\n<p>The following example uses the <code>is</code> type pattern to provide the implementation of a type&#39;s <a class=\"xref\" href=\"../../../../api/system.icomparable#System_IComparable_CompareTo_System_Object_\" data-linktype=\"relative-path\">System.IComparable.CompareTo(Object)</a> method.</p>\n<pre><code class=\"lang-cs\" name=\"is#5\">using System;\n\npublic class Employee : IComparable\n{\n    public String Name { get; set; }\n    public int Id { get; set; }\n\n    public int CompareTo(Object o)\n    {\n        if (o is Employee e)\n        {\n            return Name.CompareTo(e.Name);\n        }\n        throw new ArgumentException(&quot;o is not an Employee object.&quot;);\n    }\n}\n</code></pre><p>Without pattern matching, this code might be written as follows. The use of type pattern matching produces more compact, readable code by eliminating the need to test whether the result of a conversion is a <code>null</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"is#6\">using System;\n\npublic class Employee : IComparable\n{\n    public String Name { get; set; }\n    public int Id { get; set; }\n\n    public int CompareTo(Object o)\n    {\n        var e = o as Employee;\n        if (o == null)\n        {\n           throw new ArgumentException(&quot;o is not an Employee object.&quot;);\n        }\n        return Name.CompareTo(e.Name);\n    }\n}\n</code></pre><p>The <code>is</code> type pattern also produces more compact code when determining the type of a value type. The following example uses the <code>is</code> type pattern to determine whether an object is a <code>Person</code> or a <code>Dog</code> instance before displaying the value of an appropriate property. </p>\n<pre><code class=\"lang-cs\" name=\"is#9\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Object o = new Person(&quot;Jane&quot;);\n      ShowValue(o);\n      \n      o = new Dog(&quot;Alaskan Malamute&quot;);\n      ShowValue(o);\n   }\n\n   public static void ShowValue(object o)\n   {\n      if (o is Person p) {\n         Console.WriteLine(p.Name);\n      }   \n      else if (o is Dog d) {\n         Console.WriteLine(d.Breed);\n      }             \n   }\n}\n\npublic struct Person\n{  \n   public string Name { get; set; }\n   \n   public Person(string name) : this()\n   {\n      Name = name;\n   }\n}\n\npublic struct Dog\n{\n   public string Breed { get; set; }\n\n   public Dog(string breedName) : this()\n   {\n      Breed = breedName;\n   }\n}\n// The example displays the following output:\n//\tJane\n//\tAlaskan Malamute\n</code></pre><p>The equivalent code without pattern matching requires a separate assignment that includes an explicit cast.</p>\n<pre><code class=\"lang-cs\" name=\"is#10\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Object o = new Person(&quot;Jane&quot;);\n      ShowValue(o);\n      \n      o = new Dog(&quot;Alaskan Malamute&quot;);\n      ShowValue(o);\n   }\n\n   public static void ShowValue(object o)\n   {\n      if (o is Person) {\n         Person p = (Person) o;\n         Console.WriteLine(p.Name);\n      }   \n      else if (o is Dog) {\n         Dog d = (Dog) o;\n         Console.WriteLine(d.Breed);\n      }             \n   }\n}\n\npublic struct Person\n{  \n   public string Name { get; set; }\n   \n   public Person(string name) : this()\n   {\n      Name = name;\n   }\n}\n\npublic struct Dog\n{\n   public string Breed { get; set; }\n\n   public Dog(string breedName) : this()\n   {\n      Breed = breedName;\n   }\n}\n// The example displays the following output:\n//       Jane\n//       Alaskan Malamute\n</code></pre><h3 id=\"a-nameconstant--constant-pattern\"><a name=\"constant\"></a> Constant pattern</h3>\n<p>When performing pattern matching with the constant pattern, <code>is</code> tests whether an expression equals a specified constant. In C# 6 and earlier versions, the constant pattern is supported by the <a href=\"switch\" data-linktype=\"relative-path\">switch</a> statement. Starting with C# 7, it is supported by the <code>is</code> statement as well. Its syntax is:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">   expr is constant\n</code></pre><p>where <em>expr</em> is the expression to evaluate, and <em>constant</em> is the value to test for. <em>constant</em> can be any of the following constant expressions: </p>\n<ul>\n<li><p>A literal value.</p>\n</li>\n<li><p>The name of a declared <code>const</code> variable.</p>\n</li>\n<li><p>An enumeration constant.</p>\n</li>\n</ul>\n<p>The constant expression is evaluated as follows:</p>\n<ul>\n<li><p>If <em>expr</em> and <em>constant</em> are integral types, the C# equality operator determines whether the expression returns <code>true</code> (that is, whether <code>expr == constant</code>).</p>\n</li>\n<li><p>Otherwise, the value of the expression is determined by a call to the static <a class=\"xref\" href=\"../../../../api/system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Object.Equals(expr, constant)</a> method.  </p>\n</li>\n</ul>\n<p>The following example combines the type and constant patterns to test whether an object is a <code>Dice</code> instance and, if it is, to determine whether the value of a dice roll is 6.</p>\n<pre><code class=\"lang-cs\" name=\"is#7\">using System;\n\npublic class Dice\n{\n    Random rnd = new Random();\n    public Dice()\n    {\n\n    }\n    public int Roll()\n    {\n        return rnd.Next(1, 7); \n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var d1 = new Dice();\n        ShowValue(d1);\n    }\n\n    private static void ShowValue(object o)\n    {\n        const int HIGH_ROLL = 6;\n\n        if (o is Dice d &amp;&amp; d.Roll() is HIGH_ROLL)\n            Console.WriteLine($&quot;The value is {HIGH_ROLL}!&quot;);\n        else\n            Console.WriteLine($&quot;The dice roll is not a {HIGH_ROLL}!&quot;);\n     }\n}\n// The example displays output like the following:\n//      The value is 6!\n</code></pre><h3 id=\"a-namevar--var-pattern-a\"><a name=\"var\"></a> var pattern </h3>\n<p>A pattern match with the var pattern always succeeds. Its syntax is</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">   expr is var varname\n</code></pre><p>where the value of <em>expr</em> is always assigned to a local variable named <em>varname</em>. <em>varname</em> is a static variable of the same type as <em>expr</em>. The following example uses the var pattern to assign an expression to a variable named <code>obj</code>. It then displays the value and the type of <code>obj</code>.</p>\n<pre><code class=\"lang-cs\" name=\"is#8\">using System;\n\nclass Program\n{\n    static void Main()\n   {\n      object[] items = { new Book(&quot;The Tempest&quot;), new Person(&quot;John&quot;) };\n      foreach (var item in items) {\n        if (item is var obj)\n          Console.WriteLine($&quot;Type: {obj.GetType().Name}, Value: {obj}&quot;); \n      }\n   }\n}\n\nclass Book\n{\n    public Book(string title) \n    {\n       Title = title;    \n    }\n\n    public string Title { get; set; }\n\n    public override string ToString()\n    {\n       return Title;\n    }\n}\n\nclass Person\n{\n   public Person(string name)\n   {\n      Name = name;\n   }\n\n   public string Name \n   { get; set; }\n\n   public override string ToString()\n   {\n      return Name;\n   }\n}\n// The example displays the following output:\n//       Type: Book, Value: The Tempest\n//       Type: Person, Value: John\n</code></pre><p>Note that if <em>expr</em> is <code>null</code>, the <code>is</code> expression still is true and assigns <code>null</code> to <em>varname</em>. </p>\n<h1 id=\"c-language-specification\">C# Language Specification</h1>\n<p>For more information, see the <a href=\"../language-specification\" data-linktype=\"relative-path\">C# Language Specification</a>. The language specification is the definitive source for C# syntax and usage.</p>\n<h2 id=\"see-also\">See also</h2>\n<p> <a href=\"../index\" data-linktype=\"relative-path\">C# Reference</a><br> <a href=\"index\" data-linktype=\"relative-path\">C# Keywords</a><br> <a href=\"typeof\" data-linktype=\"relative-path\">typeof</a><br> <a href=\"as\" data-linktype=\"relative-path\">as</a><br> <a href=\"operator-keywords\" data-linktype=\"relative-path\">Operator Keywords</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"ms.assetid\" content=\"bc62316a-d41f-4f90-8300-c6f4f0556e43\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"keywords\" content=\"is keyword (C#), is (C#)\">\r\n<meta name=\"caps.latest.revision\" content=\"20\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2017-02-17\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-04-01 05:46 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/400dfda51d978f35c3995f90840643aaff1b9c13/docs/csharp/language-reference/keywords/is.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/language-reference/keywords/is.md\">\r\n<meta name=\"document_id\" content=\"29d0596f-a099-0463-1d01-354056e6cce9\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","uhfHeaderId":"MSDocsHeader-DotNet","title":"is (C# Reference) | Microsoft Docs","ms.assetid":"bc62316a-d41f-4f90-8300-c6f4f0556e43","f1_keywords":["is_CSharpKeyword","is"],"translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"keywords":"is keyword (C#), is (C#)","caps.latest.revision":20,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["is keyword [C#]"],"ms.date":"2017-02-17","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"tompratt-AQ","author_email":"v-thprat@microsoft.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"Update language identifiers and styleguide. (#1796)","commit_sha":"400dfda51d978f35c3995f90840643aaff1b9c13","commit_date":"2017-03-24 14:01:03 -0700"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Changed 'type declaration' to 'declaration'.","commit_sha":"642a7960ef268925f645f58ea8115db781b9742d","commit_date":"2017-02-27 09:40:19 -0800"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Corrected bad code tag.","commit_sha":"6710c573fdcaed565309c8cf56f080ebc033a9b4","commit_date":"2017-02-24 09:05:57 -0800"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Addressed review comments.","commit_sha":"5d664ebfbc5cff30b0c2e8454a5dbb3c95e0bf6e","commit_date":"2017-02-22 13:25:16 -0800"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Fixed additional publishing errors","commit_sha":"7f93a2275c43f22cce2eef8870526a99ee1daf89","commit_date":"2017-02-16 11:51:37 -0800"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Fixed broken code references","commit_sha":"24c0eb0a2adc8c09357d3f4cec635f1cea7f3f33","commit_date":"2017-02-16 10:28:56 -0800"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Revised is keyword","commit_sha":"7e2b831caa18aac8b9b59b1c2a92b91151a93c5a","commit_date":"2017-02-15 17:29:56 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2017-04-01 05:46 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/tompratt-AQ","display_name":"tompratt-AQ","id":"26311438"},{"profile_url":"https://github.com/rpetrusha","display_name":"rpetrusha","id":"10886961"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"4/1/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/400dfda51d978f35c3995f90840643aaff1b9c13/docs/csharp/language-reference/keywords/is.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/language-reference/keywords/is.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/language-reference/keywords/is.md","document_id":"29d0596f-a099-0463-1d01-354056e6cce9","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/language-reference/keywords/is","toc_asset_id":"articles/csharp/language-reference/keywords/toc.json","toc_rel":"toc.json","_op_ogTitle":"is (C# Reference)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":1967,"_op_rawTitle":"<h1 id=\"is-c-reference\" sourcefile=\"docs/csharp/language-reference/keywords/is.md\" sourcestartlinenumber=\"35\" sourceendlinenumber=\"35\">is (C# Reference)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/language-reference/keywords/is","fileRelativePath":"articles/csharp/language-reference/keywords/is.html"},"themesRelativePathToOutputRoot":"_themes/"}