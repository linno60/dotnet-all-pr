{"content":"<div><div class=\"content\">\n<p><code>switch</code> is a selection statement that chooses a single <em>switch section</em> to execute from a list of candidates based on a pattern match with the <em>match expression</em>. </p>\n<pre><code class=\"lang-cs\" name=\"switch#1\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      int caseSwitch = 1;\n      \n      switch (caseSwitch)\n      {\n          case 1:\n              Console.WriteLine(&quot;Case 1&quot;);\n              break;\n          case 2:\n              Console.WriteLine(&quot;Case 2&quot;);\n              break;\n          default:\n              Console.WriteLine(&quot;Default case&quot;);\n              break;\n      }\n   }\n}\n// The example displays the following output:\n//       Case 1\n</code></pre><p>The <code>switch</code> statement is often used as an alternative to an <a href=\"if-else\" data-linktype=\"relative-path\">if-else</a> construct if a single expression is tested against three or more conditions. For example, the following <code>switch</code> statement determines whether a variable of type <code>Color</code> has one of three values: </p>\n<pre><code class=\"lang-cs\" name=\"switch#3\">using System;\n\npublic enum Color { Red, Green, Blue }\n\npublic class Example\n{\n   public static void Main()\n   {\n      Color c = (Color) (new Random()).Next(0, 3);\n      switch (c)\n      {\n         case Color.Red:\n            Console.WriteLine(&quot;The color is red&quot;);\n            break;\n         case Color.Green:\n            Console.WriteLine(&quot;The color is green&quot;);\n            break;\n         case Color.Blue:\n            Console.WriteLine(&quot;The color is blue&quot;);   \n            break;\n         default:\n            Console.WriteLine(&quot;The color is unknown.&quot;);\n            break;   \n      }\n   }\n}\n</code></pre><p>It is equivalent to the following example that uses an <code>if</code>-<code>else</code> construct. </p>\n<pre><code class=\"lang-cs\" name=\"switch#3a\">using System;\n\npublic enum Color { Red, Green, Blue }\n\npublic class Example\n{\n   public static void Main()\n   {\n      Color c = (Color) (new Random()).Next(0, 3);\n      if (c == Color.Red)\n         Console.WriteLine(&quot;The color is red&quot;);\n      else if (c == Color.Green)\n         Console.WriteLine(&quot;The color is green&quot;);\n      else if (c == Color.Blue)\n         Console.WriteLine(&quot;The color is blue&quot;);   \n      else\n         Console.WriteLine(&quot;The color is unknown.&quot;);\n   }\n}\n// The example displays the following output:\n//       The color is red\n</code></pre><h2 id=\"the-match-expression\">The match expression</h2>\n<p>The match expression provides the value to match against the patterns in <code>case</code> labels. Its syntax is:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">   switch (expr)\n</code></pre><p>In C# 6, the match expression must be an expression that returns a value of the following types:</p>\n<ul>\n<li>a <a href=\"char\" data-linktype=\"relative-path\">char</a>.</li>\n<li>a <a href=\"string\" data-linktype=\"relative-path\">string</a>.</li>\n<li>a <a href=\"bool\" data-linktype=\"relative-path\">bool</a>. </li>\n<li>an integral value, such as an <a href=\"int\" data-linktype=\"relative-path\">int</a> or a <a href=\"long\" data-linktype=\"relative-path\">long</a>.</li>\n<li>an <a href=\"enum\" data-linktype=\"relative-path\">enum</a> value.</li>\n</ul>\n<p>Starting with C# 7, the match expression can be any non-null expression.</p>\n<h2 id=\"the-switch-section\">The switch section</h2>\n<p> A <code>switch</code> statement includes one or more switch sections. Each switch section contains one or more <em>case labels</em> followed by one or more statements. The following example shows a simple <code>switch</code> statement that has three switch sections. Each switch section has one case label, such as <code>case 1:</code>, and two statements.</p>\n<p>  A <code>switch</code> statement can include any number of switch sections, and each section can have one or more case labels, as shown in the following example. However, no two case labels may contain the same expression.  </p>\n<pre><code class=\"lang-cs\" name=\"switch#2\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Random rnd = new Random();\n      int caseSwitch = rnd.Next(1,4);\n      \n      switch (caseSwitch)\n      {\n          case 1:\n              Console.WriteLine(&quot;Case 1&quot;);\n              break;\n          case 2:\n          case 3:\n              Console.WriteLine($&quot;Case {caseSwitch}&quot;);\n              break;\n          default:\n              Console.WriteLine($&quot;An unexpected value ({caseSwitch})&quot;);\n              break;\n      }\n   }\n}\n// The example displays output like the following:\n//       Case 1\n</code></pre><p> Only one switch section in a switch statement executes. C# does not allow execution to continue from one switch section to the next. Because of this, the following code generates a compiler error, CS0163: &quot;Control cannot fall through from one case label (<case label=\"\">) to another.&quot;   <p>\n<pre class=\"loading\"><code class=\"lang-cs\">switch (caseSwitch)  \n{  \n    // The following switch section causes an error.  \n    case 1:  \n        Console.WriteLine(&quot;Case 1...&quot;);  \n        // Add a break or other jump statement here.  \n    case 2:  \n        Console.WriteLine(&quot;... and/or Case 2&quot;);  \n        break;  \n}  \n</code></pre><p>This requirement is usually met by explicitly exiting the switch section by using a <a href=\"break\" data-linktype=\"relative-path\">break</a>, <a href=\"goto\" data-linktype=\"relative-path\">goto</a>, or <a href=\"return\" data-linktype=\"relative-path\">return</a> statement. However, the following code is also valid, because it ensures that program control cannot fall through to the <code>default</code> switch section.</p>\n<pre><code class=\"lang-cs\" name=\"switch#4\">switch (caseSwitch)  \n{  \n    // The following switch section causes an error.  \n    case 1:  \n        Console.WriteLine(&quot;Case 1...&quot;);  \n        break;  \n    case 2:  \n    case 3:\n        Console.WriteLine(&quot;... and/or Case 2&quot;);  \n        break;\n    case 4:  \n        while (true)  \n           Console.WriteLine(&quot;Endless looping. . . .&quot;); \n    default:\n        Console.WriteLine(&quot;Default value...&quot;);\n        break;                 \n}  \n</code></pre><p> Execution of the statement list in the switch section with a case label that matches the match expression begins with the first statement and proceeds through the statement list, typically until a jump statement, such as a <code>break</code>, <code>goto case</code>, <code>return</code>, or <code>throw</code>, is reached. At that point, control is transferred outside the <code>switch</code> statement or to another case label.  </p>\n<h2 id=\"case-labels\">Case labels</h2>\n<p> Each case label specifies a pattern to compare to the match expression (the <code>caseSwitch</code> variable in the previous examples). If they match, control is transferred to the switch section that contains the <strong>first</strong> matching case label. If no case label pattern matches the match expression, control is transfered to the section with the <code>default</code> case label, if there is one. If there is no <code>default</code> case, no statements in any switch section are executed, and control is transferred outside the <code>switch</code> statement.</p>\n<p> For information on the <code>switch</code> statement and pattern matching, see the <a href=\"#pattern\" data-linktype=\"self-bookmark\">Pattern matching with the <code>switch</code> statement</a> section.</p>\n<p> Because C# 6 supports only the constant pattern and does not allow the repetition of constant values, case labels define mutually exclusive values, and only one pattern can match the match expression. As a result, the order in which <code>case</code> statements appear is unimportant.</p>\n<p> In C# 7, however, because other patterns are supported, case labels need not define mutually exclusive values, and multiple patterns can match the match expression. Because only the statements in the switch section that contains the first matching pattern are executed, the order in which <code>case</code> statements appear is now important. If C# detects a switch section whose case statement or statements are equivalent to or are subsets of previous statements, it generates a compiler error, CS8120, &quot;The switch case has already been handled by a previous case.&quot; </p>\n<p> The following example illustrates a <code>switch</code> statement that uses a variety of non-mutually exclusive patterns. If you move the <code>case 0:</code> switch section so that it is no longer the first section in the <code>switch</code> statement, C# generates a compiler error because an integer whose value is zero is a subset of all integers, which is the pattern defined by the <code>case int val</code> statement.</p>\n<pre><code class=\"lang-cs\" name=\"switch#5\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Example\n{\n   public static void Main()\n   {\n      var values = new List&lt;object&gt;();\n      for (int ctr = 0; ctr &lt;= 7; ctr++) {\n         if (ctr == 2) \n            values.Add(DiceLibrary.Roll2());\n         else if (ctr == 4)\n            values.Add(DiceLibrary.Pass());\n         else   \n            values.Add(DiceLibrary.Roll());\n      }   \n\n      Console.WriteLine($&quot;The sum of { values.Count } die is { DiceLibrary.DiceSum(values) }&quot;);\n   }\n}\n\npublic static class DiceLibrary\n{\n   // Random number generator to simulate dice rolls.\n   static Random rnd = new Random();\n\n   // Roll a single die.\n   public static int Roll()\n   {\n      return rnd.Next(1, 7);\n   }\n\n   // Roll two dice.\n   public static List&lt;object&gt; Roll2()\n   {\n      var rolls = new List&lt;object&gt;();      \n      rolls.Add(Roll());\n      rolls.Add(Roll());\n      return rolls;\n   }\n\n   // Calculate the sum of n dice rolls.\n   public static int DiceSum(IEnumerable&lt;object&gt; values)\n   {\n      var sum = 0;\n      foreach (var item in values)\n      {\n            switch (item)\n            {\n               // A single zero value.\n               case 0:\n                  break;\n               // A single value.\n               case int val:\n                  sum += val;\n                  break;\n               // A non-empty collection.\n               case IEnumerable&lt;object&gt; subList when subList.Any():\n                  sum += DiceSum(subList);\n                  break;\n               // An empty collection.\n               case IEnumerable&lt;object&gt; subList:\n                  break;\n               //  A null reference.\n               case null:\n                  break;\n               // A value that is neither an integer nor a collection.\n               default:\n                  throw new InvalidOperationException(&quot;unknown item type&quot;);\n            }\n      }\n      return sum;\n   }\n\n   public static object Pass()\n   {\n      if (rnd.Next(0, 2) == 0)\n         return null;\n      else\n         return new List&lt;object&gt;();\n   }\n}\n</code></pre><p>You can correct this issue and eliminate the compiler warning in one of two ways:</p>\n<ul>\n<li><p>By changing the order of the switch sections. </p>\n</li>\n<li><p>By using a when clause in the <code>case</code> label.</p>\n</li>\n</ul>\n<h2 id=\"the-default-case\">The <code>default</code> case</h2>\n<p>The <code>default</code> case specifies the switch section to execute if the match expression does not match any other <code>case</code> label. If a <code>default</code> case is not present and the match expression does not match any other <code>case</code> label, program flow falls through the <code>switch</code> statement.</p>\n<p>The <code>default</code> case can appear in any order in the <code>switch</code> statement. Regardless of its order in the source code, it is always evaluated last, after all <code>case</code> labels have been evaluated.</p>\n<h2 id=\"a-namepattern--pattern-matching-with-the-switch-statement\"><a name=\"pattern\"></a> Pattern matching with the <code>switch</code> statement</h2>\n<p>Each <code>case</code> statement defines a pattern that, if it matches the match expression, causes its  containing switch section to be executed. All versions of C# support the constant pattern. The remaining patterns are supported beginning with C# 7. </p>\n<h3 id=\"constant-pattern\">Constant pattern</h3>\n<p>The constant pattern tests whether the match expression equals a specified constant. Its syntax is:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">   case constant:\n</code></pre><p>where <em>constant</em> is the value to test for. <em>constant</em> can be any of the following constant expressions: </p>\n<ul>\n<li>A <a href=\"bool\" data-linktype=\"relative-path\">bool</a> literal, either <code>true</code> or <code>false</code>.</li>\n<li>Any integral constant, such as an <a href=\"int\" data-linktype=\"relative-path\">int</a>, a <a href=\"long\" data-linktype=\"relative-path\">long</a>, or a <a href=\"byte\" data-linktype=\"relative-path\">byte</a>. </li>\n<li>The name of a declared <code>const</code> variable.</li>\n<li>An enumeration constant.</li>\n<li>A <a href=\"char\" data-linktype=\"relative-path\">char</a> literal.</li>\n<li>A <a href=\"string\" data-linktype=\"relative-path\">string</a> literal.</li>\n</ul>\n<p>The constant expression is evaluated as follows:</p>\n<ul>\n<li><p>If <em>expr</em> and <em>constant</em> are integral types, the C# equality operator determines whether the expression returns <code>true</code> (that is, whether <code>expr == constant</code>).</p>\n</li>\n<li><p>Otherwise, the value of the expression is determined by a call to the static <a class=\"xref\" href=\"../../../../api/system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Object.Equals(expr, constant)</a> method.  </p>\n</li>\n</ul>\n<p>The following example uses the constant pattern to determine whether a particular date is a weekend, the first day of the work week, the last day of the work week, or the middle of the work week. It evalutes the <a class=\"xref\" href=\"../../../../api/system.datetime#System_DateTime_DayOfWeek\" data-linktype=\"relative-path\">DateTime.DayOfWeek</a> property of the current day against the members of the <a class=\"xref\" href=\"../../../../api/system.dayofweek\" data-linktype=\"relative-path\">DayOfWeek</a> enumeration. </p>\n<pre><code class=\"lang-cs\" name=\"switch#7\">using System;\n\nclass Program\n{\n    static void Main()\n    {\n        switch (DateTime.Now.DayOfWeek)\n        {\n           case DayOfWeek.Sunday:\n           case DayOfWeek.Saturday:\n              Console.WriteLine(&quot;The weekend&quot;);\n              break;\n           case DayOfWeek.Monday:\n              Console.WriteLine(&quot;The first day of the work week.&quot;);\n              break;\n           case DayOfWeek.Friday:\n              Console.WriteLine(&quot;The last day of teh work week.&quot;);\n              break;\n           default:\n              Console.WriteLine(&quot;The middle of the work week.&quot;);\n              break;   \n        }\n    }\n}\n// The example displays output like the following:\n//       The middle of the work week.\n</code></pre><p>The following example uses the constant pattern to handle user input in a console application that simulates an automatic coffee machine.</p>\n<pre><code class=\"lang-cs\" name=\"switch#6\">using System;\n\nclass Example\n{\n   static void Main()\n   {\n       Console.WriteLine(&quot;Coffee sizes: 1=small 2=medium 3=large&quot;);\n       Console.Write(&quot;Please enter your selection: &quot;);\n       string str = Console.ReadLine();\n       int cost = 0;\n\n       // Because of the goto statements in cases 2 and 3, the base cost of 25\n       // cents is added to the additional cost for the medium and large sizes.\n       switch (str)\n       {\n          case &quot;1&quot;:\n          case &quot;small&quot;:\n              cost += 25;\n              break;\n          case &quot;2&quot;:\n          case &quot;medium&quot;:\n              cost += 25;\n              goto case &quot;1&quot;;\n          case &quot;3&quot;:\n          case &quot;large&quot;:\n              cost += 50;\n              goto case &quot;1&quot;;\n          default:\n              Console.WriteLine(&quot;Invalid selection. Please select 1, 2, or 3.&quot;);\n              break;\n      }\n      if (cost != 0)\n      {\n          Console.WriteLine(&quot;Please insert {0} cents.&quot;, cost);\n      }\n      Console.WriteLine(&quot;Thank you for your business.&quot;);\n   }\n}\n// The example displays output like the following:\n//         Coffee sizes: 1=small 2=medium 3=large\n//         Please enter your selection: 2\n//         Please insert 50 cents.\n//         Thank you for your business.\n\n\n</code></pre><h3 id=\"type-pattern\">Type pattern</h3>\n<p>The type pattern enables concise type evaluation and conversion. When used with the <code>switch</code> statement to perform pattern matching, it tests whether an expression can be converted to a specified type and, if it can be, casts it to a variable of that type. Its syntax is:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">   case type varname \n</code></pre><p>where <em>type</em> is the name of the type to which the result of <em>expr</em> is to be converted, and <em>varname</em> is the object to which the result of <em>expr</em> is converted if the match succeeds. </p>\n<p>The <code>case</code> expression is <code>true</code> if any of the following is true:</p>\n<ul>\n<li><p><em>expr</em> is an instance of the same type as <em>type</em>.</p>\n</li>\n<li><p><em>expr</em> is an instance of a type that derives from <em>type</em>. In other words, the result of <em>expr</em> can be upcast to an instance of <em>type</em>.</p>\n</li>\n<li><p><em>expr</em> has a compile-time type that is a base class of <em>type</em>, and <em>expr</em> has a runtime type that is <em>type</em> or is derived from <em>type</em>. The <em>compile-time type</em> of a variable is the variable&#39;s type as defined in its type declaration. The <em>runtime type</em> of a variable is the type of the instance that is assigned to that variable.</p>\n</li>\n<li><p><em>expr</em> is an instance of a type that implements the <em>type</em> interface.</p>\n</li>\n</ul>\n<p>If the case expression is true, <em>varname</em> is definitely assigned and has local scope within the switch section only.</p>\n<p>Note that <code>null</code> does not match a type. To match a <code>null</code>, you use the following <code>case</code> label:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">case null:\n</code></pre><p>The following example uses the type pattern to provide information about various kinds of collection types.</p>\n<pre><code class=\"lang-cs\" name=\"switch#5\">using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Example\n{\n    static void Main(string[] args)\n    {\n        int[] values = { 2, 4, 6, 8, 10 };\n        ShowCollectionInformation(values);\n        \n        var names = new List&lt;string&gt;();\n        names.AddRange( new string[] { &quot;Adam&quot;, &quot;Abigail&quot;, &quot;Bertrand&quot;, &quot;Bridgette&quot; } );\n        ShowCollectionInformation(names);\n\n        List&lt;int&gt; numbers = null;\n        ShowCollectionInformation(numbers);\n    }\n   \n    private static void ShowCollectionInformation(object coll)\n    {\n        switch (coll)\n        {\n            case Array arr:\n               Console.WriteLine($&quot;An array with {arr.Length} elements.&quot;);\n               break;\n            case IEnumerable&lt;int&gt; ieInt:\n               Console.WriteLine($&quot;Average: {ieInt.Average(s =&gt; s)}&quot;);\n               break;   \n            case IList list:\n               Console.WriteLine($&quot;{list.Count} items&quot;);\n               break;\n            case IEnumerable ie:\n               string result = &quot;&quot;;\n               foreach (var item in ie) \n                  result += &quot;${e} &quot;;\n               Console.WriteLine(result);\n               break;   \n            case null:\n               // Do nothing for a null.\n               break;\n            default:\n               Console.WriteLine($&quot;A instance of type {coll.GetType().Name}&quot;);\n               break;   \n        }\n    }\n}\n// The example displays the following output:\n//     An array with 5 elements.\n//     4 items\n</code></pre><p>Without pattern matching, this code might be written as follows. The use of type pattern matching produces more compact, readable code by eliminating the need to test whether the result of a conversion is a <code>null</code> or to perform repeated casts.  </p>\n<pre><code class=\"lang-cs\" name=\"switch#6\">using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Example\n{\n    static void Main(string[] args)\n    {\n        int[] values = { 2, 4, 6, 8, 10 };\n        ShowCollectionInformation(values);\n        \n        var names = new List&lt;string&gt;();\n        names.AddRange( new string[] { &quot;Adam&quot;, &quot;Abigail&quot;, &quot;Bertrand&quot;, &quot;Bridgette&quot; } );\n        ShowCollectionInformation(names);\n        \n        List&lt;int&gt; numbers = null;\n        ShowCollectionInformation(numbers);\n    }\n   \n    private static void ShowCollectionInformation(object coll)\n    {\n        if (coll is Array) {\n           Array arr = (Array) coll;\n           Console.WriteLine($&quot;An array with {arr.Length} elements.&quot;);\n        }\n        else if (coll is IEnumerable&lt;int&gt;) {\n            IEnumerable&lt;int&gt; ieInt = (IEnumerable&lt;int&gt;) coll;\n            Console.WriteLine($&quot;Average: {ieInt.Average(s =&gt; s)}&quot;);\n        }\n        else if (coll is IList) {\n            IList list = (IList) coll;\n            Console.WriteLine($&quot;{list.Count} items&quot;);\n        }\n        else if (coll is IEnumerable) { \n            IEnumerable ie = (IEnumerable) coll;\n            string result = &quot;&quot;;\n            foreach (var item in ie) \n               result += &quot;${e} &quot;;\n            Console.WriteLine(result);\n        }\n        else if (coll == null) { \n            // Do nothing. \n        }\n        else {\n            Console.WriteLine($&quot;An instance of type {coll.GetType().Name}&quot;);\n        }   \n    }\n}\n// The example displays the following output:\n//     An array with 5 elements.\n//     4 items\n</code></pre><h2 id=\"the-case-statement-and-the-when-clause\">The <code>case</code> statement and the <code>when</code> clause</h2>\n<p>Starting with C# 7, because case statements need not be mutually exclusive, you can use add a <code>when</code> clause to specify an additional condition that must be satisfied for the case statement to evaluate to true. The <code>when</code> clause can be any expression that returns a Boolean value. One of the more common uses for the <code>when</code> clause is used to prevent a switch section from executing when the value of a match expression is <code>null</code>. </p>\n<p> The following example defines a base <code>Shape</code> class, a <code>Rectangle</code> class that derives from <code>Shape</code>, and a <code>Square</code> class that derives from <code>Rectangle</code>. It uses the <code>when</code> clause to ensure that the <code>ShowShapeInfo</code> treats a <code>Rectangle</code> object that has been assigned equal lengths and widths as a <code>Square</code> even if is has not been instantiated as a <code>Square</code> object. The method does not attempt to display information either about an object that is <code>null</code> or a shape whose area is zero. </p>\n<pre><code class=\"lang-cs\" name=\"switch#8\">using System;\n\npublic abstract class Shape\n{\n   public abstract double Area { get; }\n   public abstract double Circumference { get; } \n}\n\npublic class Rectangle : Shape\n{\n   public Rectangle(double length, double width) \n   {\n      Length = length;\n      Width = width; \n   }\n\n   public double Length { get; set; }\n   public double Width { get; set; }\n   \n   public override double Area\n   { \n      get { return Math.Round(Length * Width,2); } \n   } \n   \n   public override double Circumference \n   {\n      get { return (Length + Width) * 2; }\n   }\n}\n\npublic class Square : Rectangle\n{\n   public Square(double side) : base(side, side) \n   {\n      Side = side; \n   }\n\n   public double Side { get; set; }\n}\n\npublic class Circle : Shape\n{\n   public Circle(double radius) \n   {\n      Radius = radius;\n   } \n   \n   public double Radius { get; set; }\n\n   public override double Circumference\n   {\n      get { return 2 * Math.PI * Radius; }\n   }\n\n   public override double Area\n   {\n      get { return Math.PI * Math.Pow(Radius, 2); } \n   }\n}\n\npublic class Example\n{\n   public static void Main()\n   {\n      Shape sh = null;\n      Shape[] shapes = { new Square(10), new Rectangle(5, 7),\n                         sh, new Square(0), new Rectangle(8, 8),\n                         new Circle(3) };\n      foreach (var shape in shapes)\n         ShowShapeInfo(shape);\n   }\n\n   private static void ShowShapeInfo(Shape sh)\n   {\n      switch (sh)\n      {\n         // Note that this code never evaluates to true.\n         case Shape shape when shape == null:\n            Console.WriteLine($&quot;An uninitialized shape (shape == null)&quot;);\n            break;\n         case null:\n            Console.WriteLine($&quot;An uninitialized shape&quot;);\n            break;\n         case Shape shape when sh.Area == 0:\n            Console.WriteLine($&quot;The shape: {sh.GetType().Name} with no dimensions&quot;);\n            break;\n         case Square sq when sh.Area &gt; 0:\n            Console.WriteLine(&quot;Information about square:&quot;);\n            Console.WriteLine($&quot;   Length of a side: {sq.Side}&quot;);\n            Console.WriteLine($&quot;   Area: {sq.Area}&quot;);\n            break;\n         case Rectangle r when r.Length == r.Width &amp;&amp; r.Area &gt; 0:\n            Console.WriteLine(&quot;Information about square rectangle:&quot;);\n            Console.WriteLine($&quot;   Length of a side: {r.Length}&quot;);\n            Console.WriteLine($&quot;   Area: {r.Area}&quot;);\n            break;\n         case Rectangle r when sh.Area &gt; 0:\n            Console.WriteLine(&quot;Information about rectangle:&quot;);\n            Console.WriteLine($&quot;   Dimensions: {r.Length} x {r.Width}&quot;);\n            Console.WriteLine($&quot;   Area: {r.Area}&quot;);\n            break;\n         case Shape shape when sh != null:\n            Console.WriteLine($&quot;A {sh.GetType().Name} shape&quot;);\n            break;\n         default:\n            Console.WriteLine($&quot;The {nameof(sh)} variable does not represent a Shape.&quot;);\n            break;   \n      }\n   }\n}\n// The example displays the following output:\n//       Information about square:\n//          Length of a side: 10\n//          Area: 100\n//       Information about rectangle:\n//          Dimensions: 5 x 7\n//          Area: 35\n//       An uninitialized shape\n//       The shape: Square with no dimensions\n//       Information about square rectangle:\n//          Length of a side: 8\n//          Area: 64\n//       A Circle shape\n</code></pre><p>Note that the <code>when</code> clause in the example that attempts to test whether a <code>Shape</code> object is <code>null</code> does not execute. The correct type pattern to test for a <code>null</code> is <code>case null:</code>.</p>\n<h2 id=\"c-language-specification\">C# Language Specification</h2>\n<p> For more information, see the <a href=\"../language-specification\" data-linktype=\"relative-path\">C# Language Specification</a>. The language specification is the definitive source for C# syntax and usage.  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../index\" data-linktype=\"relative-path\">C# Reference</a><br> <a href=\"../../programming-guide/index\" data-linktype=\"relative-path\">C# Programming Guide</a><br> <a href=\"index\" data-linktype=\"relative-path\">C# Keywords</a><br> <a href=\"if-else\" data-linktype=\"relative-path\">if-else</a><br> <a href=\"../../pattern-matching\" data-linktype=\"relative-path\">Pattern Matching</a>   </p>\n</case></div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"ms.assetid\" content=\"44bae8b8-8841-4d85-826b-8a94277daecb\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"47\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"translation.priority.mt\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.mt\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.mt\" content=\"pt-br\">\r\n<meta name=\"translation.priority.mt\" content=\"tr-tr\">\r\n<meta name=\"ms.date\" content=\"2017-03-07\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/deaaa5e939cd165953b7e05976c5c0a01ae6aa09/docs/csharp/language-reference/keywords/switch.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/language-reference/keywords/switch.md\">\r\n<meta name=\"document_id\" content=\"4232256d-ea85-edc5-263c-b735f96ddd55\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"switch keyword (C# Reference) | Microsoft Docs","ms.assetid":"44bae8b8-8841-4d85-826b-8a94277daecb","f1_keywords":["switch_CSharpKeyword","switch","case","case_CSharpKeyword"],"translation.priority.ht":["de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","ru-ru","zh-cn","zh-tw"],"caps.latest.revision":47,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["switch statement [C#]","switch keyword [C#]","case statement [C#]","default keyword [C#]"],"translation.priority.mt":["cs-cz","pl-pl","pt-br","tr-tr"],"ms.date":"2017-03-07","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Ron Petrusha","author_email":"ronpet@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"Switch statement revised for C# 7 (#1640)","commit_sha":"deaaa5e939cd165953b7e05976c5c0a01ae6aa09","commit_date":"2017-03-07 10:07:23 -0500"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Absolute urls and other fixes (#1281)","commit_sha":"f7dffe4885b331cec8d37f3cc5c9163f69c3b4c9","commit_date":"2016-11-22 12:57:26 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/rpetrusha","display_name":"rpetrusha","id":"10886961"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/deaaa5e939cd165953b7e05976c5c0a01ae6aa09/docs/csharp/language-reference/keywords/switch.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/language-reference/keywords/switch.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/language-reference/keywords/switch.md","document_id":"4232256d-ea85-edc5-263c-b735f96ddd55","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/language-reference/keywords/switch","toc_asset_id":"articles/csharp/language-reference/keywords/toc.json","toc_rel":"toc.json","_op_ogTitle":"switch keyword (C# Reference)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":2993,"_op_rawTitle":"<h1 id=\"switch-c-reference\" sourcefile=\"docs/csharp/language-reference/keywords/switch.md\" sourcestartlinenumber=\"40\" sourceendlinenumber=\"40\">switch (C# Reference)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/language-reference/keywords/switch","fileRelativePath":"articles/csharp/language-reference/keywords/switch.html"},"themesRelativePathToOutputRoot":"_themes/"}