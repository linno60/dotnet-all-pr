{"content":"<div><div class=\"content\">\n<p>The try-catch statement consists of a <code>try</code> block followed by one or more <code>catch</code> clauses, which specify handlers for different exceptions.  </p>\n<h2 id=\"remarks\">Remarks</h2>\n<p> When an exception is thrown, the common language runtime (CLR) looks for the <code>catch</code> statement that handles this exception. If the currently executing method does not contain such a <code>catch</code> block, the CLR looks at the method that called the current method, and so on up the call stack. If no <code>catch</code> block is found, then the CLR displays an unhandled exception message to the user and stops execution of the program.  </p>\n<p> The <code>try</code> block contains the guarded code that may cause the exception. The block is executed until an exception is thrown or it is completed successfully. For example, the following attempt to cast a <code>null</code> object raises the <a class=\"xref\" href=\"../../../../api/system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a> exception:  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">object o2 = null;  \ntry  \n{  \n    int i2 = (int)o2;   // Error  \n}  \n</code></pre><p> Although the <code>catch</code> clause can be used without arguments to catch any type of exception, this usage is not recommended. In general, you should only catch those exceptions that you know how to recover from. Therefore, you should always specify an object argument derived from <a class=\"xref\" href=\"../../../../api/system.exception\" data-linktype=\"relative-path\">System.Exception</a> For example:  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">catch (InvalidCastException e)   \n{  \n}  \n</code></pre><p> It is possible to use more than one specific <code>catch</code> clause in the same try-catch statement. In this case, the order of the <code>catch</code> clauses is important because the <code>catch</code> clauses are examined in order. Catch the more specific exceptions before the less specific ones. The compiler produces an error if you order your catch blocks so that a later block can never be reached.  </p>\n<p> Using <code>catch</code> arguments is one way to filter for the exceptions you want to handle.  You can also use a predicate expression that further examines the exception to decide whether to handle it.  If the predicate expression returns false, then the search for a handler continues.  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">catch (ArgumentException e) when (e.ParamName == “…”)  \n{  \n}  \n</code></pre><p> Exception filters are preferable to catching and rethrowing (explained below) because filters leave the stack unharmed.  If a later handler dumps the stack, you can see where the exception originally came from, rather than just the last place it was rethrown.  A common use of exception filter expressions is logging.  You can create a predicate function that always returns false that also outputs to a log, you can log exceptions as they go by without having to handle them and rethrow.  </p>\n<p> A <a href=\"throw\" data-linktype=\"relative-path\">throw</a> statement can be used in a <code>catch</code> block to re-throw the exception that is caught by the <code>catch</code> statement. The following example extracts source information from an <a class=\"xref\" href=\"../../../../api/system.io.ioexception\" data-linktype=\"relative-path\">IOException</a> exception, and then throws the exception to the parent method.  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">catch (FileNotFoundException e)  \n{  \n    // FileNotFoundExceptions are handled here.  \n}  \ncatch (IOException e)  \n{  \n    // Extract some information from this exception, and then   \n    // throw it to the parent method.  \n    whenDo not initialize (e.Source != null)  \n        Console.WriteLine(&quot;IOException source: {0}&quot;, e.Source);  \n    throw;  \n}  \n</code></pre><p> You can catch one exception and throw a different exception. When you do this, specify the exception that you caught as the inner exception, as shown in the following example.  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">catch (InvalidCastException e)   \n{  \n    // Perform some action here, and then throw a new exception.  \n    throw new YourCustomException(&quot;Put your error message here.&quot;, e);  \n}  \n</code></pre><p> You can also re-throw an exception when a specified condition is true, as shown in the following example.  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">\ncatch (InvalidCastException e)  \n{  \n    if (e.Data == null)  \n    {  \n        throw;  \n    }  \n    else  \n    {  \n        // Take some action.  \n    }  \n }  \n</code></pre><p> From inside a <code>try</code> block, initialize only variables that are declared therein. Otherwise, an exception can occur before the execution of the block is completed. For example, in the following code example, the variable <code>n</code> is initialized inside the <code>try</code> block. An attempt to use this variable outside the <code>try</code> block in the <code>Write(n)</code> statement will generate a compiler error.  </p>\n<pre class=\"loading\"><code class=\"lang-cs\">static void Main()   \n{  \n    int n;  \n    try   \n    {  \n        // Do not initialize this variable here.  \n        n = 123;  \n    }  \n    catch  \n    {  \n    }  \n    // Error: Use of unassigned local variable &#39;n&#39;.  \n    Console.Write(n);  \n}  \n</code></pre><p> For more information about catch, see <a href=\"try-catch-finally\" data-linktype=\"relative-path\">try-catch-finally</a>.  </p>\n<h2 id=\"exceptions-in-async-methods\">Exceptions in Async Methods</h2>\n<p> An async method is marked  by an  <a href=\"async\" data-linktype=\"relative-path\">async</a> modifier and usually contains one or more await expressions or statements. An await expression applies the <a href=\"await\" data-linktype=\"relative-path\">await</a> operator to a <a class=\"xref\" href=\"../../../../api/system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> or <a class=\"xref\" href=\"../../../../api/system.threading.tasks.task-1\" data-linktype=\"relative-path\">Task&lt;TResult&gt;</a>.  </p>\n<p> When control reaches an <code>await</code> in the async method, progress in the method is suspended until the awaited task completes. When the task  is complete, execution can resume in the method. For more information, see <a href=\"../../programming-guide/concepts/async/index\" data-linktype=\"relative-path\">Asynchronous Programming with async and await</a> and <a href=\"../../programming-guide/concepts/async/control-flow-in-async-programs\" data-linktype=\"relative-path\">Control Flow in Async Programs</a>.  </p>\n<p> The completed task to which <code>await</code> is applied might be in a faulted state because of an unhandled exception in the method that returns the task. Awaiting the task throws an exception. A task can also end up in a canceled state if the asynchronous process that returns it is canceled. Awaiting a canceled task throws  an <code>OperationCanceledException</code>. For more information about how to cancel an asynchronous process, see <a href=\"http://msdn.microsoft.com/library/daaa32ea-c84c-4761-8230-c8292ffebd74\" data-linktype=\"external\">Fine-Tuning Your Async Application</a>.  </p>\n<p> To catch the exception, await the task in a <code>try</code> block, and catch the exception in the associated <code>catch</code> block. For an example, see the &quot;Example&quot; section.  </p>\n<p> A task can be in a faulted state because multiple exceptions occurred in the awaited async method. For example, the task might be the result of a call to <a class=\"xref\" href=\"../../../../api/system.threading.tasks.task#System_Threading_Tasks_Task_WhenAll_\" data-linktype=\"relative-path\">WhenAll</a>. When you await such a task, only one of the exceptions is caught, and you can&#39;t predict which exception will be caught. For an example, see the &quot;Example&quot; section.  </p>\n<h2 id=\"example\">Example</h2>\n<p> In the following example, the <code>try</code> block contains a call to the <code>ProcessString</code> method that may cause an exception. The <code>catch</code> clause contains the exception handler that just displays a message on the screen. When the <code>throw</code> statement is called from inside <code>MyMethod</code>, the system looks for the <code>catch</code> statement and displays the message <code>Exception caught</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"csrefKeywordsExceptions#2\">    class TryFinallyTest\n{\n    static void ProcessString(string s)\n    {\n        if (s == null)\n        {\n            throw new ArgumentNullException();\n        }\n    }\n    \n    static void Main()\n    {\n        string s = null; // For demonstration purposes.\n\n        try\n        {            \n            ProcessString(s);\n        }\n\n        catch (Exception e)\n        {\n            Console.WriteLine(&quot;{0} Exception caught.&quot;, e);\n        }\n    }\n}\n    /*\n    Output:\n    System.ArgumentNullException: Value cannot be null.\n       at TryFinallyTest.Main() Exception caught.\n     * */\n</code></pre><h2 id=\"example-1\">Example</h2>\n<p> In the following example, two catch blocks are used, and the most specific exception, which comes first, is caught.  </p>\n<p> To catch the least specific exception, you can replace the throw statement in <code>ProcessString</code> with the following statement: <code>throw new Exception()</code>.  </p>\n<p> If you place the least-specific catch block first in the example, the following  error message appears: <code>A previous catch clause already catches all exceptions of this or a super type (&#39;System.Exception&#39;)</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"csrefKeywordsExceptions#3\">    class ThrowTest3\n    {\n        static void ProcessString(string s)\n        {\n            if (s == null)\n            {\n                throw new ArgumentNullException();\n            }\n        }\n\n        static void Main()\n        {\n            try\n            {\n                string s = null;\n                ProcessString(s);\n            }\n            // Most specific:\n            catch (ArgumentNullException e)\n            {\n                Console.WriteLine(&quot;{0} First exception caught.&quot;, e);\n            }\n            // Least specific:\n            catch (Exception e)\n            {\n                Console.WriteLine(&quot;{0} Second exception caught.&quot;, e);\n            }\n        }\n    }\n    /*\n     Output:\n     System.ArgumentNullException: Value cannot be null.\n     at Test.ThrowTest3.ProcessString(String s) ... First exception caught.\n    */\n</code></pre><h2 id=\"example-2\">Example</h2>\n<p> The following example illustrates exception handling for async methods. To catch an exception that an async task throws, place the <code>await</code> expression in a <code>try</code> block, and catch the exception in a <code>catch</code> block.  </p>\n<p> Uncomment the <code>throw new Exception</code> line in the example to demonstrate exception handling. The task&#39;s <code>IsFaulted</code> property is set to <code>True</code>, the task&#39;s <code>Exception.InnerException</code> property is set to the exception, and the exception is caught in the <code>catch</code> block.  </p>\n<p> Uncomment the <code>throw new OperationCancelledException</code> line to demonstrate what happens when you cancel an asynchronous process. The task&#39;s <code>IsCanceled</code> property is set to <code>true</code>, and the exception is caught in the <code>catch</code> block. Under some conditions that don&#39;t apply to this example, the task&#39;s <code>IsFaulted</code> property is set to <code>true</code> and <code>IsCanceled</code> is set to <code>false</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"csAsyncExceptions#2\">        public async Task DoSomethingAsync()\n        {\n            Task&lt;string&gt; theTask = DelayAsync();\n\n            try\n            {\n                string result = await theTask;\n                Debug.WriteLine(&quot;Result: &quot; + result);\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine(&quot;Exception Message: &quot; + ex.Message);\n            }\n            Debug.WriteLine(&quot;Task IsCanceled: &quot; + theTask.IsCanceled);\n            Debug.WriteLine(&quot;Task IsFaulted:  &quot; + theTask.IsFaulted);\n            if (theTask.Exception != null)\n            {\n                Debug.WriteLine(&quot;Task Exception Message: &quot;\n                    + theTask.Exception.Message);\n                Debug.WriteLine(&quot;Task Inner Exception Message: &quot;\n                    + theTask.Exception.InnerException.Message);\n            }\n        }\n\n        private async Task&lt;string&gt; DelayAsync()\n        {\n            await Task.Delay(100);\n\n            // Uncomment each of the following lines to\n            // demonstrate exception handling.\n\n            //throw new OperationCanceledException(&quot;canceled&quot;);\n            //throw new Exception(&quot;Something happened.&quot;);\n            return &quot;Done&quot;;\n        }\n\n        // Output when no exception is thrown in the awaited method:\n        //   Result: Done\n        //   Task IsCanceled: False\n        //   Task IsFaulted:  False\n\n        // Output when an Exception is thrown in the awaited method:\n        //   Exception Message: Something happened.\n        //   Task IsCanceled: False\n        //   Task IsFaulted:  True\n        //   Task Exception Message: One or more errors occurred.\n        //   Task Inner Exception Message: Something happened.\n\n        // Output when a OperationCanceledException or TaskCanceledException\n        // is thrown in the awaited method:\n        //   Exception Message: canceled\n        //   Task IsCanceled: True\n        //   Task IsFaulted:  False\n</code></pre><h2 id=\"example-3\">Example</h2>\n<p> The following example illustrates exception handling where multiple tasks can result in multiple exceptions. The <code>try</code> block awaits the task that&#39;s returned by a call to <a class=\"xref\" href=\"../../../../api/system.threading.tasks.task#System_Threading_Tasks_Task_WhenAll_\" data-linktype=\"relative-path\">WhenAll</a>. The task is complete when the three tasks to which WhenAll is applied are complete.  </p>\n<p> Each of the three tasks causes an exception. The <code>catch</code> block iterates through the exceptions, which are found in the <code>Exception.InnerExceptions</code> property of the task that was returned by <a class=\"xref\" href=\"../../../../api/system.threading.tasks.task#System_Threading_Tasks_Task_WhenAll_\" data-linktype=\"relative-path\">WhenAll</a>.  </p>\n<pre><code class=\"lang-cs\" name=\"csAsyncExceptions#4\">        public async Task DoMultipleAsync()\n        {\n            Task theTask1 = ExcAsync(info: &quot;First Task&quot;);\n            Task theTask2 = ExcAsync(info: &quot;Second Task&quot;);\n            Task theTask3 = ExcAsync(info: &quot;Third Task&quot;);\n\n            Task allTasks = Task.WhenAll(theTask1, theTask2, theTask3);\n\n            try\n            {\n                await allTasks;\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine(&quot;Exception: &quot; + ex.Message);\n                Debug.WriteLine(&quot;Task IsFaulted: &quot; + allTasks.IsFaulted);\n                foreach (var inEx in allTasks.Exception.InnerExceptions)\n                {\n                    Debug.WriteLine(&quot;Task Inner Exception: &quot; + inEx.Message);\n                }\n            }\n        }\n\n        private async Task ExcAsync(string info)\n        {\n            await Task.Delay(100);\n            \n            throw new Exception(&quot;Error-&quot; + info);\n        }\n\n        // Output:\n        //   Exception: Error-First Task\n        //   Task IsFaulted: True\n        //   Task Inner Exception: Error-First Task\n        //   Task Inner Exception: Error-Second Task\n        //   Task Inner Exception: Error-Third Task\n</code></pre><h2 id=\"c-language-specification\">C# Language Specification</h2>\n<p> For more information, see the <a href=\"../language-specification\" data-linktype=\"relative-path\">C# Language Specification</a>. The language specification is the definitive source for C# syntax and usage.  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../index\" data-linktype=\"relative-path\">C# Reference</a><br> <a href=\"../../programming-guide/index\" data-linktype=\"relative-path\">C# Programming Guide</a><br> <a href=\"index\" data-linktype=\"relative-path\">C# Keywords</a><br> <a href=\"https://docs.microsoft.com/cpp/cpp/try-throw-and-catch-statements-cpp\" data-linktype=\"external\">try, throw, and catch Statements (C++)</a><br> <a href=\"exception-handling-statements\" data-linktype=\"relative-path\">Exception Handling Statements</a><br> <a href=\"throw\" data-linktype=\"relative-path\">throw</a><br> <a href=\"try-finally\" data-linktype=\"relative-path\">try-finally</a><br> <a href=\"https://msdn.microsoft.com/library/xhcbs8fz\" data-linktype=\"external\">How to: Explicitly Throw Exceptions</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet/toc2.json\">\r\n<meta name=\"ms.assetid\" content=\"cb5503c7-bfa1-4610-8fc2-ddcd2e84c438\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"45\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"translation.priority.mt\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.mt\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.mt\" content=\"pt-br\">\r\n<meta name=\"translation.priority.mt\" content=\"tr-tr\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/3115359729431ecbcc16058612da59b85621fa0f/docs/csharp/language-reference/keywords/try-catch.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/language-reference/keywords/try-catch.md\">\r\n<meta name=\"document_id\" content=\"922a6168-ea28-16d4-3c0a-dfa11b740300\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"try-catch (C# Reference) | Microsoft Docs","ms.assetid":"cb5503c7-bfa1-4610-8fc2-ddcd2e84c438","f1_keywords":["try","try_CSharpKeyword","catch","catch_CSharpKeyword"],"translation.priority.ht":["de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","ru-ru","zh-cn","zh-tw"],"caps.latest.revision":45,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["catch keyword [C#]","try-catch statement [C#]"],"translation.priority.mt":["cs-cz","pl-pl","pt-br","tr-tr"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Reorganize the C# Guide TOC (#1318)","commit_sha":"3115359729431ecbcc16058612da59b85621fa0f","commit_date":"2017-01-23 23:20:14 -0500"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Absolute urls and other fixes (#1281)","commit_sha":"f7dffe4885b331cec8d37f3cc5c9163f69c3b4c9","commit_date":"2016-11-22 12:57:26 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/3115359729431ecbcc16058612da59b85621fa0f/docs/csharp/language-reference/keywords/try-catch.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/language-reference/keywords/try-catch.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/language-reference/keywords/try-catch.md","document_id":"922a6168-ea28-16d4-3c0a-dfa11b740300","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/language-reference/keywords/try-catch","toc_asset_id":"articles/csharp/language-reference/keywords/toc.json","toc_rel":"toc.json","_op_ogTitle":"try-catch (C# Reference)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":1698,"_op_rawTitle":"<h1 id=\"try-catch-c-reference\" sourcefile=\"docs/csharp/language-reference/keywords/try-catch.md\" sourcestartlinenumber=\"38\" sourceendlinenumber=\"38\">try-catch (C# Reference)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/language-reference/keywords/try-catch","fileRelativePath":"articles/csharp/language-reference/keywords/try-catch.html"},"themesRelativePathToOutputRoot":"_themes/"}