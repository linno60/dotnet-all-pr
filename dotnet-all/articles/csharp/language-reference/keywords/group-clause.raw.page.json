{"content":"<div><div class=\"content\">\n<p>The <code>group</code> clause returns a sequence of <a class=\"xref\" href=\"../../../../api/system.linq.igrouping-2\" data-linktype=\"relative-path\">IGrouping&lt;TKey,TElement&gt;</a> objects that contain zero or more items that match the key value for the group. For example, you can group a sequence of strings according to the first letter in each string. In this case, the first letter is the key and has a type <a href=\"char\" data-linktype=\"relative-path\">char</a>, and is stored in the <code>Key</code> property of each <a class=\"xref\" href=\"../../../../api/system.linq.igrouping-2\" data-linktype=\"relative-path\">IGrouping&lt;TKey,TElement&gt;</a> object. The compiler infers the type of the key.  </p>\n<p> You can end a query expression with a <code>group</code> clause, as shown in the following example:  </p>\n<pre><code class=\"lang-cs\" name=\"cscsrefQueryKeywords#10\">            // Query variable is an IEnumerable&lt;IGrouping&lt;char, Student&gt;&gt;\n            var studentQuery1 =\n                from student in students\n                group student by student.Last[0];\n</code></pre><p> If you want to perform additional query operations on each group, you can specify a temporary identifier by using the <a href=\"into\" data-linktype=\"relative-path\">into</a> contextual keyword. When you use <code>into</code>, you must continue with the query, and eventually end it with either a <code>select</code> statement or another <code>group</code> clause, as shown in the following excerpt:  </p>\n<pre><code class=\"lang-cs\" name=\"cscsrefQueryKeywords#11\">            // Group students by the first letter of their last name\n            // Query variable is an IEnumerable&lt;IGrouping&lt;char, Student&gt;&gt;\n            var studentQuery2 =\n                from student in students\n                group student by student.Last[0] into g\n                orderby g.Key\n                select g;\n</code></pre><p> More complete examples of the use of <code>group</code> with and without <code>into</code> are provided in the Example section of this topic.  </p>\n<h2 id=\"enumerating-the-results-of-a-group-query\">Enumerating the Results of a Group Query</h2>\n<p> Because the <a class=\"xref\" href=\"../../../../api/system.linq.igrouping-2\" data-linktype=\"relative-path\">IGrouping&lt;TKey,TElement&gt;</a> objects produced by a <code>group</code> query are essentially a list of lists, you must use a nested <a href=\"foreach-in\" data-linktype=\"relative-path\">foreach</a> loop to access the items in each group. The outer loop iterates over the group keys, and the inner loop iterates over each item in the group itself. A group may have a key but no elements. The following is the <code>foreach</code> loop that executes the query in the previous code examples:  </p>\n<pre><code class=\"lang-cs\" name=\"cscsrefQueryKeywords#12\">           // Iterate group items with a nested foreach. This IGrouping encapsulates\n           // a sequence of Student objects, and a Key of type char.\n           // For convenience, var can also be used in the foreach statement.\n           foreach (IGrouping&lt;char, Student&gt; studentGroup in studentQuery2)\n           {\n                Console.WriteLine(studentGroup.Key);\n                // Explicit type for student could also be used here.\n                foreach (var student in studentGroup)\n                {\n                    Console.WriteLine(&quot;   {0}, {1}&quot;, student.Last, student.First);\n                }\n            }\n</code></pre><h2 id=\"key-types\">Key Types</h2>\n<p> Group keys can be any type, such as a string, a built-in numeric type, or a user-defined named type or anonymous type.  </p>\n<h3 id=\"grouping-by-string\">Grouping by string</h3>\n<p> The previous code examples used a <code>char</code>. A string key could easily have been specified instead, for example the complete last name:  </p>\n<pre><code class=\"lang-cs\" name=\"cscsrefQueryKeywords#13\">           // Same as previous example except we use the entire last name as a key.\n           // Query variable is an IEnumerable&lt;IGrouping&lt;string, Student&gt;&gt;\n            var studentQuery3 =\n                from student in students\n                group student by student.Last;\n</code></pre><h3 id=\"grouping-by-bool\">Grouping by bool</h3>\n<p> The following example shows the use of a bool value for a key to divide the results into two groups. Note that the value is produced by a sub-expression in the <code>group</code> clause.  </p>\n<pre><code class=\"lang-cs\" name=\"cscsrefQueryKeywords#14\">    class GroupSample1\n    {\n        // The element type of the data source.\n        public class Student\n        {\n            public string First { get; set; }\n            public string Last { get; set; }\n            public int ID { get; set; }\n            public List&lt;int&gt; Scores;\n        }\n\n        public static List&lt;Student&gt; GetStudents()\n        {\n            // Use a collection initializer to create the data source. Note that each element\n            //  in the list contains an inner sequence of scores.\n            List&lt;Student&gt; students = new List&lt;Student&gt;\n            {\n               new Student {First=&quot;Svetlana&quot;, Last=&quot;Omelchenko&quot;, ID=111, Scores= new List&lt;int&gt; {97, 72, 81, 60}},\n               new Student {First=&quot;Claire&quot;, Last=&quot;O&#39;Donnell&quot;, ID=112, Scores= new List&lt;int&gt; {75, 84, 91, 39}},\n               new Student {First=&quot;Sven&quot;, Last=&quot;Mortensen&quot;, ID=113, Scores= new List&lt;int&gt; {99, 89, 91, 95}},\n               new Student {First=&quot;Cesar&quot;, Last=&quot;Garcia&quot;, ID=114, Scores= new List&lt;int&gt; {72, 81, 65, 84}},\n               new Student {First=&quot;Debra&quot;, Last=&quot;Garcia&quot;, ID=115, Scores= new List&lt;int&gt; {97, 89, 85, 82}} \n            };\n\n            return students;\n\n        }\n\n        static void Main()\n        {\n            // Obtain the data source.\n            List&lt;Student&gt; students = GetStudents();\n\n            // Group by true or false.\n            // Query variable is an IEnumerable&lt;IGrouping&lt;bool, Student&gt;&gt;\n            var booleanGroupQuery =\n                from student in students\n                group student by student.Scores.Average() &gt;= 80; //pass or fail!\n\n            // Execute the query and access items in each group\n            foreach (var studentGroup in booleanGroupQuery)\n            {\n                Console.WriteLine(studentGroup.Key == true ? &quot;High averages&quot; : &quot;Low averages&quot;);\n                foreach (var student in studentGroup)\n                {\n                    Console.WriteLine(&quot;   {0}, {1}:{2}&quot;, student.Last, student.First, student.Scores.Average());\n                }\n            }\n\n            // Keep the console window open in debug mode.\n            Console.WriteLine(&quot;Press any key to exit.&quot;);\n            Console.ReadKey();\n        }\n    }\n    /* Output:\n      Low averages\n       Omelchenko, Svetlana:77.5\n       O&#39;Donnell, Claire:72.25\n       Garcia, Cesar:75.5\n      High averages\n       Mortensen, Sven:93.5\n       Garcia, Debra:88.25\n    */\n</code></pre><h3 id=\"grouping-by-numeric-range\">Grouping by numeric range</h3>\n<p> The next example uses an expression to create numeric group keys that represent a percentile range. Note the use of <a href=\"let-clause\" data-linktype=\"relative-path\">let</a> as a convenient location to store a method call result, so that you do not have to call the method two times in the <code>group</code> clause. Note also in the <code>group</code> clause that to avoid a &quot;divide by zero&quot; exception the code checks to make sure that the student does not have an average of zero. For more information about how to safely use methods in query expressions, see <a href=\"../../programming-guide/linq-query-expressions/how-to-handle-exceptions-in-query-expressions\" data-linktype=\"relative-path\">How to: Handle Exceptions in Query Expressions</a>.  </p>\n<pre><code class=\"lang-cs\" name=\"cscsrefQueryKeywords#15\">    class GroupSample2\n    {\n        // The element type of the data source.\n        public class Student\n        {\n            public string First { get; set; }\n            public string Last { get; set; }\n            public int ID { get; set; }\n            public List&lt;int&gt; Scores;\n        }\n\n        public static List&lt;Student&gt; GetStudents()\n        {\n            // Use a collection initializer to create the data source. Note that each element\n            //  in the list contains an inner sequence of scores.\n            List&lt;Student&gt; students = new List&lt;Student&gt;\n            {\n               new Student {First=&quot;Svetlana&quot;, Last=&quot;Omelchenko&quot;, ID=111, Scores= new List&lt;int&gt; {97, 72, 81, 60}},\n               new Student {First=&quot;Claire&quot;, Last=&quot;O&#39;Donnell&quot;, ID=112, Scores= new List&lt;int&gt; {75, 84, 91, 39}},\n               new Student {First=&quot;Sven&quot;, Last=&quot;Mortensen&quot;, ID=113, Scores= new List&lt;int&gt; {99, 89, 91, 95}},\n               new Student {First=&quot;Cesar&quot;, Last=&quot;Garcia&quot;, ID=114, Scores= new List&lt;int&gt; {72, 81, 65, 84}},\n               new Student {First=&quot;Debra&quot;, Last=&quot;Garcia&quot;, ID=115, Scores= new List&lt;int&gt; {97, 89, 85, 82}} \n            };\n\n            return students;\n\n        }\n\n        // This method groups students into percentile ranges based on their\n        // grade average. The Average method returns a double, so to produce a whole\n        // number it is necessary to cast to int before dividing by 10. \n        static void Main()\n        {\n            // Obtain the data source.\n            List&lt;Student&gt; students = GetStudents();\n\n            // Write the query.\n            var studentQuery =\n                from student in students\n                let avg = (int)student.Scores.Average()\n                group student by (avg == 0 ? 0 : avg / 10) into g\n                orderby g.Key\n                select g;            \n\n            // Execute the query.\n            foreach (var studentGroup in studentQuery)\n            {\n                int temp = studentGroup.Key * 10;\n                Console.WriteLine(&quot;Students with an average between {0} and {1}&quot;, temp, temp + 10);\n                foreach (var student in studentGroup)\n                {\n                    Console.WriteLine(&quot;   {0}, {1}:{2}&quot;, student.Last, student.First, student.Scores.Average());\n                }\n            }\n\n            // Keep the console window open in debug mode.\n            Console.WriteLine(&quot;Press any key to exit.&quot;);\n            Console.ReadKey();\n        }\n    }\n    /* Output:\n         Students with an average between 70 and 80\n           Omelchenko, Svetlana:77.5\n           O&#39;Donnell, Claire:72.25\n           Garcia, Cesar:75.5\n         Students with an average between 80 and 90\n           Garcia, Debra:88.25\n         Students with an average between 90 and 100\n           Mortensen, Sven:93.5\n     */\n</code></pre><h3 id=\"grouping-by-composite-keys\">Grouping by Composite Keys</h3>\n<p> Use a composite key when you want to group elements according to more than one key. You create a composite key by using an anonymous type or a named type to hold the key element. In the following example, assume that a class <code>Person</code> has been declared with members named <code>surname</code> and <code>city</code>. The <code>group</code> clause causes a separate group to be created for each set of persons with the same last name and the same city.  </p>\n<p><codecontentplaceholder>0</codecontentplaceholder><br> Use a named type if you must pass the query variable to another method. Create a special class using auto-implemented properties for the keys, and then override the <a class=\"xref\" href=\"../../../../api/system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a> and <a class=\"xref\" href=\"../../../../api/system.object#System_Object_GetHashCode_\" data-linktype=\"relative-path\">GetHashCode</a> methods. You can also use a struct, in which case you do not strictly have to override those methods. For more information see <a href=\"../../programming-guide/classes-and-structs/how-to-implement-a-lightweight-class-with-auto-implemented-properties\" data-linktype=\"relative-path\">How to: Implement a Lightweight Class with Auto-Implemented Properties</a> and <a href=\"../../programming-guide/concepts/linq/how-to-query-for-duplicate-files-in-a-directory-tree-linq\" data-linktype=\"relative-path\">How to: Query for Duplicate Files in a Directory Tree (LINQ)</a>. The latter topic has a code example that demonstrates how to use a composite key with a named type.  </p>\n<h2 id=\"example\">Example</h2>\n<p> The following example shows the standard pattern for ordering source data into groups when no additional query logic is applied to the groups. This is called a grouping without a continuation. The elements in an array of strings are grouped according to their first letter. The result of the query is an <a class=\"xref\" href=\"../../../../api/system.linq.igrouping-2\" data-linktype=\"relative-path\">IGrouping&lt;TKey,TElement&gt;</a> type that contains a public <code>Key</code> property of type <code>char</code> and an <a class=\"xref\" href=\"../../../../api/system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable&lt;T&gt;</a> collection that contains each item in the grouping.  </p>\n<p> The result of a <code>group</code> clause is a sequence of sequences. Therefore, to access the individual elements within each returned group, use a nested <code>foreach</code> loop inside the loop that iterates the group keys, as shown in the following example.  </p>\n<pre><code class=\"lang-cs\" name=\"cscsrefQueryKeywords#16\">    class GroupExample1\n    {\n        static void Main()\n        {\n            // Create a data source.\n            string[] words = { &quot;blueberry&quot;, &quot;chimpanzee&quot;, &quot;abacus&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;cheese&quot; };\n\n            // Create the query.\n            var wordGroups =\n                from w in words\n                group w by w[0];\n\n            // Execute the query.\n            foreach (var wordGroup in wordGroups)\n            {\n                Console.WriteLine(&quot;Words that start with the letter &#39;{0}&#39;:&quot;, wordGroup.Key);\n                foreach (var word in wordGroup)\n                {\n                    Console.WriteLine(word);\n                }\n            }\n\n            // Keep the console window open in debug mode\n            Console.WriteLine(&quot;Press any key to exit.&quot;);\n            Console.ReadKey();\n        }        \n    }\n    /* Output:\n          Words that start with the letter &#39;b&#39;:\n            blueberry\n            banana\n          Words that start with the letter &#39;c&#39;:\n            chimpanzee\n            cheese\n          Words that start with the letter &#39;a&#39;:\n            abacus\n            apple\n         */\n</code></pre><h2 id=\"example-1\">Example</h2>\n<p> This example shows how to perform additional logic on the groups after you have created them, by using a <em>continuation</em> with <code>into</code>. For more information, see <a href=\"into\" data-linktype=\"relative-path\">into</a>. The following example queries each group to select only those whose key value is a vowel.  </p>\n<pre><code class=\"lang-cs\" name=\"cscsrefQueryKeywords#17\">    class GroupClauseExample2\n    {\n        static void Main()\n        {\n            // Create the data source.\n            string[] words2 = { &quot;blueberry&quot;, &quot;chimpanzee&quot;, &quot;abacus&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;cheese&quot;, &quot;elephant&quot;, &quot;umbrella&quot;, &quot;anteater&quot; };\n\n            // Create the query.\n            var wordGroups2 =\n                from w in words2\n                group w by w[0] into grps\n                where (grps.Key == &#39;a&#39; || grps.Key == &#39;e&#39; || grps.Key == &#39;i&#39;\n                       || grps.Key == &#39;o&#39; || grps.Key == &#39;u&#39;)\n                select grps;\n\n            // Execute the query.\n            foreach (var wordGroup in wordGroups2)\n            {\n                Console.WriteLine(&quot;Groups that start with a vowel: {0}&quot;, wordGroup.Key);\n                foreach (var word in wordGroup)\n                {\n                    Console.WriteLine(&quot;   {0}&quot;, word);\n                }\n            }\n\n            // Keep the console window open in debug mode\n            Console.WriteLine(&quot;Press any key to exit.&quot;);\n            Console.ReadKey();\n        }\n    }\n    /* Output:\n        Groups that start with a vowel: a\n            abacus\n            apple\n            anteater\n        Groups that start with a vowel: e\n            elephant\n        Groups that start with a vowel: u\n            umbrella\n    */    \n</code></pre><h2 id=\"remarks\">Remarks</h2>\n<p> At compile time, <code>group</code> clauses are translated into calls to the <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/bb341740(v=vs.110).aspx\" data-linktype=\"external\">GroupBy</a> method.  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a class=\"xref\" href=\"../../../../api/system.linq.igrouping-2\" data-linktype=\"relative-path\">IGrouping&lt;TKey,TElement&gt;</a><br> <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/bb341740(v=vs.110).aspx\" data-linktype=\"external\">GroupBy</a><br> <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/bb302612(v=vs.110).aspx\" data-linktype=\"external\">ThenBy</a><br> <a class=\"xref\" href=\"https://msdn.microsoft.com/en-us/library/bb341945(v=vs.110).aspx\" data-linktype=\"external\">ThenByDescending</a><br> <a href=\"query-keywords\" data-linktype=\"relative-path\">Query Keywords (LINQ)</a><br> <a href=\"../../programming-guide/linq-query-expressions/index\" data-linktype=\"relative-path\">LINQ Query Expressions</a><br> <a href=\"../../programming-guide/linq-query-expressions/how-to-create-a-nested-group\" data-linktype=\"relative-path\">How to: Create a Nested Group</a><br> <a href=\"../../programming-guide/linq-query-expressions/how-to-group-query-results\" data-linktype=\"relative-path\">How to: Group Query Results</a><br> <a href=\"../../programming-guide/linq-query-expressions/how-to-perform-a-subquery-on-a-grouping-operation\" data-linktype=\"relative-path\">How to: Perform a Subquery on a Grouping Operation</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc2.json\">\r\n<meta name=\"ms.assetid\" content=\"c817242e-b12c-4baa-a57e-73ee138f34d1\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"24\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/language-reference/keywords/group-clause.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/language-reference/keywords/group-clause.md\">\r\n<meta name=\"document_id\" content=\"b4552e67-bc44-f156-dc80-8b465fe0bc65\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"group clause (C# Reference) | Microsoft Docs","ms.assetid":"c817242e-b12c-4baa-a57e-73ee138f34d1","f1_keywords":["group","group_CSharpKeyword"],"translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":24,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["group keyword [C#]","group clause [C#]"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/language-reference/keywords/group-clause.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/language-reference/keywords/group-clause.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/language-reference/keywords/group-clause.md","document_id":"b4552e67-bc44-f156-dc80-8b465fe0bc65","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/language-reference/keywords/group-clause","toc_asset_id":"articles/csharp/language-reference/keywords/toc.json","toc_rel":"toc.json","_op_ogTitle":"group clause (C# Reference)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":1770,"_op_rawTitle":"<h1 id=\"group-clause-c-reference\" sourcefile=\"docs/csharp/language-reference/keywords/group-clause.md\" sourcestartlinenumber=\"35\" sourceendlinenumber=\"35\">group clause (C# Reference)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/language-reference/keywords/group-clause","fileRelativePath":"articles/csharp/language-reference/keywords/group-clause.html"},"themesRelativePathToOutputRoot":"_themes/"}