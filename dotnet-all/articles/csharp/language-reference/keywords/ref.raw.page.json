{"content":"<div><div class=\"content\">\n<p>The <code>ref</code> keyword causes an argument to be passed by reference, not by value. The effect of passing by reference is that any change to the parameter in the called method is reflected in the calling method. For example, if the caller passes a local variable expression or an array element access expression, and the called method replaces the object to which the ref parameter refers, then the callerâ€™s local variable or the array element now refer to the new object.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Do not confuse the concept of passing by reference with the concept of reference types. The two concepts are not the same. A method parameter can be modified by <code>ref</code> regardless of whether it is a value type or a reference type. There is no boxing of a value type when it is passed by reference.  </p>\n</div>\n<p> To use a <code>ref</code> parameter, both the method definition and the calling method must explicitly use the <code>ref</code> keyword, as shown in the following example.  </p>\n<pre><code class=\"lang-cs\" name=\"csrefKeywordsMethodParams#6\">    class RefExample\n    {\n        static void Method(ref int i)\n        {\n            // Rest the mouse pointer over i to verify that it is an int.\n            // The following statement would cause a compiler error if i\n            // were boxed as an object.\n            i = i + 44;\n        }\n\n        static void Main()\n        {\n            int val = 1;\n            Method(ref val);\n            Console.WriteLine(val);\n\n            // Output: 45\n        }\n    }\n</code></pre><p> An argument that is passed to a <code>ref</code> parameter must be initialized before it is passed. This differs from <code>out</code> parameters, whose arguments do not have to be explicitly initialized before they are passed. For more information, see <a href=\"out\" data-linktype=\"relative-path\">out</a>.  </p>\n<p> Members of a class can&#39;t have signatures that differ only by <code>ref</code> and <code>out</code>. A compiler error occurs if the only difference between two members of a type is that one of them has a <code>ref</code> parameter and the other has an <code>out</code> parameter. The following code, for example, doesn&#39;t compile.  </p>\n<pre><code class=\"lang-cs\" name=\"csrefKeywordsMethodParams#2\">    class CS0663_Example\n    {\n        // Compiler error CS0663: &quot;Cannot define overloaded \n        // methods that differ only on ref and out&quot;.\n        public void SampleMethod(out int i) { }\n        public void SampleMethod(ref int i) { }\n    }\n</code></pre><p> However, overloading can be done when one method has a <code>ref</code> or <code>out</code> parameter and the other has a value parameter, as shown in the following example.  </p>\n<pre><code class=\"lang-cs\" name=\"csrefKeywordsMethodParams#7\">    class RefOverloadExample\n    {\n        public void SampleMethod(int i) { }\n        public void SampleMethod(ref int i) { }\n    }\n</code></pre><p> In other situations that require signature matching, such as hiding or overriding, <code>ref</code> and <code>out</code> are part of the signature and don&#39;t match each other.  </p>\n<p> Properties are not variables. They are methods, and cannot be passed to <code>ref</code> parameters.  </p>\n<p> For information about how to pass arrays, see <a href=\"../../programming-guide/arrays/passing-arrays-using-ref-and-out\" data-linktype=\"relative-path\">Passing Arrays Using ref and out</a>.  </p>\n<p> You can&#39;t use the <code>ref</code> and <code>out</code> keywords for the following kinds of methods:  </p>\n<ul>\n<li><p>Async methods, which you define by using the <a href=\"async\" data-linktype=\"relative-path\">async</a> modifier.  </p>\n</li>\n<li><p>Iterator methods, which include a <a href=\"yield\" data-linktype=\"relative-path\">yield return</a> or <code>yield break</code> statement.  </p>\n</li>\n</ul>\n<h2 id=\"example\">Example</h2>\n<p> The previous examples demonstrate what happens when you pass value types by reference. You can also use the <code>ref</code> keyword to pass reference types. Passing a reference type by reference enables the called method to replace the object in the calling method to which the reference parameter refers. The storage location of the object is passed to the method as the value of the reference parameter. If you change the value in the storage location of the parameter (to point to a new object), you also change the storage location to which the caller refers. The following example passes an instance of a reference type as a <code>ref</code> parameter. For more information about how to pass reference types by value and by reference, see <a href=\"../../programming-guide/classes-and-structs/passing-reference-type-parameters\" data-linktype=\"relative-path\">Passing Reference-Type Parameters</a>.  </p>\n<pre><code class=\"lang-cs\" name=\"csrefKeywordsMethodParams#8\">    class RefExample2\n    {\n        static void ChangeByReference(ref Product itemRef)\n        {\n            // The following line changes the address that is stored in  \n            // parameter itemRef. Because itemRef is a ref parameter, the\n            // address that is stored in variable item in Main also is changed.\n            itemRef = new Product(&quot;Stapler&quot;, 99999);\n\n            // You can change the value of one of the properties of\n            // itemRef. The change happens to item in Main as well.\n            itemRef.ItemID = 12345;\n        }\n\n        static void Main()\n        {\n            // Declare an instance of Product and display its initial values.\n            Product item = new Product(&quot;Fasteners&quot;, 54321);\n            System.Console.WriteLine(&quot;Original values in Main.  Name: {0}, ID: {1}\\n&quot;,\n                item.ItemName, item.ItemID);\n\n            // Send item to ChangeByReference as a ref argument.\n            ChangeByReference(ref item);\n            System.Console.WriteLine(&quot;Back in Main.  Name: {0}, ID: {1}\\n&quot;,\n                item.ItemName, item.ItemID);\n        }\n    }\n\n    class Product\n    {\n        public Product(string name, int newID)\n        {\n            ItemName = name;\n            ItemID = newID;\n        }\n\n        public string ItemName { get; set; }\n        public int ItemID { get; set; }\n    }\n\n    // Output: \n    //Original values in Main.  Name: Fasteners, ID: 54321\n\n    //Back in Main.  Name: Stapler, ID: 12345\n</code></pre><h2 id=\"c-language-specification\">C# Language Specification</h2>\n<p> For more information, see the <a href=\"../language-specification\" data-linktype=\"relative-path\">C# Language Specification</a>. The language specification is the definitive source for C# syntax and usage.  </p>\n<h2 id=\"see-also\">See Also</h2>\n<p> <a href=\"../index\" data-linktype=\"relative-path\">C# Reference</a><br> <a href=\"../../programming-guide/index\" data-linktype=\"relative-path\">C# Programming Guide</a><br> <a href=\"../../programming-guide/classes-and-structs/passing-parameters\" data-linktype=\"relative-path\">Passing Parameters</a><br> <a href=\"method-parameters\" data-linktype=\"relative-path\">Method Parameters</a><br> <a href=\"index\" data-linktype=\"relative-path\">C# Keywords</a></p>\n</div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet/toc2.json\">\r\n<meta name=\"ms.assetid\" content=\"b8a5e59c-907d-4065-b41d-95bf4273c0bd\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"caps.latest.revision\" content=\"32\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2015-07-20\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/language-reference/keywords/ref.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/language-reference/keywords/ref.md\">\r\n<meta name=\"document_id\" content=\"86a3b7bd-4028-0000-8b5c-2b462449d0bf\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"ref (C# Reference) | Microsoft Docs","ms.assetid":"b8a5e59c-907d-4065-b41d-95bf4273c0bd","f1_keywords":["ref_CSharpKeyword","ref"],"translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"caps.latest.revision":32,"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["parameters [C#], ref","ref keyword [C#]"],"ms.date":"2015-07-20","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":":books: migration changes (#1235)","commit_sha":"b828bb1d6c8fb750ad9ef34f8a7a1b7d2574f4c6","commit_date":"2016-11-15 15:08:11 -0500"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/language-reference/keywords/ref.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/language-reference/keywords/ref.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/language-reference/keywords/ref.md","document_id":"86a3b7bd-4028-0000-8b5c-2b462449d0bf","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/language-reference/keywords/ref","toc_asset_id":"articles/csharp/language-reference/keywords/toc.json","toc_rel":"toc.json","_op_ogTitle":"ref (C# Reference)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":821,"_op_rawTitle":"<h1 id=\"ref-c-reference\" sourcefile=\"docs/csharp/language-reference/keywords/ref.md\" sourcestartlinenumber=\"35\" sourceendlinenumber=\"35\">ref (C# Reference)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/language-reference/keywords/ref","fileRelativePath":"articles/csharp/language-reference/keywords/ref.html"},"themesRelativePathToOutputRoot":"_themes/"}