{"content":"<div><div class=\"content\">\n<p>The <code>using static</code> directive designates a type whose static members you can access without specifying a type name. Its syntax is:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">using static &lt;fully-qualified-type-name&gt;\n</code></pre><p>where <em>fully-qualified-type-name</em> is the name of the type whose static members can be referenced without specifying a type name. If you do not provide a fully qualified type name (the full namespace name along with the type name), C# generates compiler error CS0246: &quot;The type or namespace name &#39;<type-name>&#39; could not be found.&quot;<p>\n<p>The <code>using static</code> directive applies to any type that has static members, even if it also has instance members. However, instance members can only be invoked through the type instance.</p>\n<p>The <code>using static</code> directive was introduced in C# 6.</p>\n<h2 id=\"reamrks\">Reamrks</h2>\n<p>Ordinarily, when you call a static member, you provide the type name along with the member name. Repeatedly entering the same type name to invoke members of the type can result in verbose, obscure code. For example, the following definition of a <code>Circle</code> class references a number of members of the <a class=\"xref\" href=\"../../../../api/system.math\" data-linktype=\"relative-path\">Math</a> class.</p>\n<pre><code class=\"lang-cs\" name=\"using-static#1\">using System;\n\npublic class Circle\n{\n   public Circle(double radius)\n   {\n      Radius = radius;\n   }\n\n   public double Radius { get; set; }\n\n   public double Diameter\n   {\n      get { return 2 * Radius; }\n   }\n\n   public double Area\n   {\n      get { return 2 * Radius * Math.PI; }      \n   }\n\n   public double Circumference\n   {\n      get { return Math.PI * Math.Pow(Radius, 2); }\n   }\n}\n</code></pre><p>By eliminating the need to explicitly reference the <a class=\"xref\" href=\"../../../../api/system.math\" data-linktype=\"relative-path\">Math</a> class each time a member is referenced, the <code>using static</code> directive produces much cleaner code:</p>\n<pre><code class=\"lang-cs\" name=\"using-static#2\">using System;\nusing static System.Math;\n\npublic class Circle\n{\n   public Circle(double radius)\n   {\n      Radius = radius;\n   }\n\n   public double Radius { get; set; }\n\n   public double Diameter\n   {\n      get { return 2 * Radius; }\n   }\n\n   public double Area\n   {\n      get { return 2 * Radius * PI; }      \n   }\n\n   public double Circumference\n   {\n      get { return PI * Pow(Radius, 2); }\n   }\n}\n</code></pre><p><code>using static</code> imports only accessible static members and nested types declared in the specified type.  Inherited members are not imported.  You can import from any named type with a using static directive, including Visual Basic modules.  If F# top-level functions appear in metadata as static members of a named type whose name is a valid C# identifier, then the F# functions can be imported.  </p>\n<p> <code>using static</code> makes extension methods declared in the specified type available for extension method lookup.  However, the names of the extension methods are not imported into scope for unqualified reference in code.  </p>\n<p> Methods with the same name imported from different types by different <code>using static</code> directives in the same compilation unit or namespace form a method group.  Overload resolution within these method groups follows normal C# rules.  </p>\n<h2 id=\"example\">Example</h2>\n<p>The following example uses the <code>using static</code> directive to make the static members of the <a class=\"xref\" href=\"../../../../api/system.console\" data-linktype=\"relative-path\">Console</a>, <a class=\"xref\" href=\"../../../../api/system.math\" data-linktype=\"relative-path\">Math</a>, and <a class=\"xref\" href=\"../../../../api/system.string\" data-linktype=\"relative-path\">String</a> classes available without having to specify their type name.</p>\n<pre><code class=\"lang-cs\" name=\"using-static#3\">using System;\nusing static System.Console;\nusing static System.Math;\nusing static System.String;\n\nclass Program\n{\n   static void Main()\n   {\n      Write(&quot;Enter a circle&#39;s radius: &quot;);\n      var input = ReadLine();\n      if (!IsNullOrEmpty(input) &amp;&amp; double.TryParse(input, out var radius)) {\n         var c = new Circle(radius);\n         \n         string s = &quot;\\nInformation about the circle:\\n&quot;;\n         s = s + Format(&quot;   Radius: {0:N2}\\n&quot;, c.Radius);\n         s = s + Format(&quot;   Diameter: {0:N2}\\n&quot;, c.Diameter);\n         s = s + Format(&quot;   Circumference: {0:N2}\\n&quot;, c.Circumference);\n         s = s + Format(&quot;   Area: {0:N2}\\n&quot;, c.Radius);\n         WriteLine(s);\n      }\n      else {\n         WriteLine(&quot;Invalid input...&quot;);\n      }\n   }\n}\n\npublic class Circle\n{\n   public Circle(double radius)\n   {\n      Radius = radius;\n   }\n\n   public double Radius { get; set; }\n\n   public double Diameter\n   {\n      get { return 2 * Radius; }\n   }\n\n   public double Area\n   {\n      get { return 2 * Radius * PI; }      \n   }\n\n   public double Circumference\n   {\n      get { return PI * Pow(Radius, 2); }\n   }\n}\n// The example displays the following output:\n//       Enter a circle&#39;s radius: 12.45\n//       \n//       Information about the circle:\n//          Radius: 12.45\n//          Diameter: 24.90\n//          Circumference: 486.95\n//          Area: 12.45\n   \n</code></pre><p>In the example, the <code>using static</code> directive could also have been applied to the <a class=\"xref\" href=\"../../../../api/system.double\" data-linktype=\"relative-path\">Double</a> type. This would have made it possible to call the <a class=\"xref\" href=\"../../../../api/system.double#System_Double_TryParse_System_String_System_Double__\" data-linktype=\"relative-path\">TryParse(String, Double)</a> method without specifying a type name. However, this creates less readable code, since it becomes necessary to check the <code>using static</code> statements to determine which numeric type&#39;s <code>TryParse</code> method is called.</p>\n<h2 id=\"see-also\">See also</h2>\n<p><a href=\"using-directive\" data-linktype=\"relative-path\">using directive</a><br><a href=\"../index\" data-linktype=\"relative-path\">C# Reference</a><br><a href=\"index\" data-linktype=\"relative-path\">C# Keywords</a><br><a href=\"../../programming-guide/namespaces/using-namespaces\" data-linktype=\"relative-path\">Using Namespaces</a><br><a href=\"namespace-keywords\" data-linktype=\"relative-path\">Namespace Keywords</a><br><a href=\"../../programming-guide/namespaces/index\" data-linktype=\"relative-path\">Namespaces</a>   </p>\n</type-name></div></div>","outputRootRelativePath":"../../../../","pageMetadata":"<meta name=\"author\" content=\"rpetrusha\">\r\n<meta name=\"ms.author\" content=\"ronpet\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc1.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.assetid\" content=\"8b8f9e34-c75e-469b-ba85-6f2eb4090314\">\r\n<meta name=\"translation.priority.ht\" content=\"cs-cz\">\r\n<meta name=\"translation.priority.ht\" content=\"de-de\">\r\n<meta name=\"translation.priority.ht\" content=\"es-es\">\r\n<meta name=\"translation.priority.ht\" content=\"fr-fr\">\r\n<meta name=\"translation.priority.ht\" content=\"it-it\">\r\n<meta name=\"translation.priority.ht\" content=\"ja-jp\">\r\n<meta name=\"translation.priority.ht\" content=\"ko-kr\">\r\n<meta name=\"translation.priority.ht\" content=\"pl-pl\">\r\n<meta name=\"translation.priority.ht\" content=\"pt-br\">\r\n<meta name=\"translation.priority.ht\" content=\"ru-ru\">\r\n<meta name=\"translation.priority.ht\" content=\"tr-tr\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-cn\">\r\n<meta name=\"translation.priority.ht\" content=\"zh-tw\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"2017-03-10\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/169498eabf60039261f10f6cda4127baa46fa094/docs/csharp/language-reference/keywords/using-static.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/language-reference/keywords/using-static.md\">\r\n<meta name=\"document_id\" content=\"db420166-23a0-f8d2-f0b7-a9a7321be085\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc1.json\">\r\n","rawMetadata":{"author":"rpetrusha","ms.author":"ronpet","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","title":"using static Directive (C# Reference) | Microsoft Docs","ms.assetid":"8b8f9e34-c75e-469b-ba85-6f2eb4090314","translation.priority.ht":["cs-cz","de-de","es-es","fr-fr","it-it","ja-jp","ko-kr","pl-pl","pt-br","ru-ru","tr-tr","zh-cn","zh-tw"],"ms.topic":"article","dev_langs":["csharp"],"helpviewer_keywords":["using static directive [C#]"],"ms.date":"2017-03-10","ms.technology":["devlang-csharp"],"ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Added 'using static' directive","commit_sha":"169498eabf60039261f10f6cda4127baa46fa094","commit_date":"2017-03-08 13:58:38 -0800"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/rpetrusha","display_name":"rpetrusha","id":"10886961"},"contributors":[{"profile_url":"https://github.com/rpetrusha","display_name":"rpetrusha"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/169498eabf60039261f10f6cda4127baa46fa094/docs/csharp/language-reference/keywords/using-static.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/language-reference/keywords/using-static.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/language-reference/keywords/using-static.md","document_id":"db420166-23a0-f8d2-f0b7-a9a7321be085","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/language-reference/keywords/using-static","toc_asset_id":"articles/csharp/language-reference/keywords/toc.json","toc_rel":"toc.json","_op_ogTitle":"using static Directive (C# Reference)","_op_displayDate":null,"_op_displayDate_source":null,"_op_wordCount":720,"_op_rawTitle":"<h1 id=\"using-static-directive-c-reference\" sourcefile=\"docs/csharp/language-reference/keywords/using-static.md\" sourcestartlinenumber=\"30\" sourceendlinenumber=\"30\">using static Directive (C# Reference)</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/language-reference/keywords/using-static","fileRelativePath":"articles/csharp/language-reference/keywords/using-static.html"},"themesRelativePathToOutputRoot":"_themes/"}