{"content":"<div><div class=\"content\">\n<p><a href=\"event-pattern\" data-linktype=\"relative-path\">Previous</a></p>\n<p>The previous article discussed the most common event patterns. .NET\nCore has a more relaxed pattern. In this version, the \n<code>EventHandler&lt;TEventArgs&gt;</code> definition no longer has the constraint that\n<code>TEventArgs</code> must be a class derived from <code>System.EventArgs</code>.</p>\n<p>This increases flexibility for you, and is backwards compatible. Let&#39;s\nstart with the flexibility. The class System.EventArgs introduces one\nmethod: <code>MemberwiseClone()</code>, which creates a shallow copy of the object.\nThat method must use <a href=\"reflection\" data-linktype=\"relative-path\">reflection</a> in order to implement\nits functionality for any class derived from <code>EventArgs</code>. That\nfunctionality is easier to create in a specific derived class. That\neffectively means that deriving from System.EventArgs is a constraint\nthat limits your designs, but does not provide any additional benefit.\nIn fact, you can changes the definitions of <code>FileFoundArgs</code> and\n<code>SearchDirectoryArgs</code> so that they do not derive from <code>EventArgs</code>.\nThe program will work exactly the same.</p>\n<p>You could also change the <code>SearchDirectoryArgs</code> to a struct, if you\nalso make one more change:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">internal struct SearchDirectoryArgs  \n{  \n    internal string CurrentSearchDirectory { get; }  \n    internal int TotalDirs { get; }  \n    internal int CompletedDirs { get; }  \n\n    internal SearchDirectoryArgs(string dir, int totalDirs, \n        int completedDirs) : this()  \n    {  \n        CurrentSearchDirectory = dir;  \n        TotalDirs = totalDirs;  \n        CompletedDirs = completedDirs;  \n    }  \n}  \n</code></pre><p>The additional change is to call the default constructor before\nentering the constructor that initializes all the fields. Without\nthat addition, the rules of C# would report that the properties are\nbeing accessed before they have been assigned.</p>\n<p>You should not change the <code>FileFoundArgs</code> from a class (reference\ntype) to a struct (value type). That&#39;s because the protocol for\nhandling cancel requires that the event arguments are passed by reference. If you made the same change, the file search class could\nnever observe any changes made by any of the event subscribers. A new\ncopy of the structure would be used for each subscriber, and that\ncopy would be a different copy than the one seen by the file search\nobject.</p>\n<p>Next, let&#39;s consider how this change can be backwards compatible.\nThe removal of the constraint does not affect any existing code. Any\nexisting event argument types do still derive from <code>System.EventArgs</code>.\nBackwards compatibility is one major reason why they will continue\nto derive from <code>System.EventArgs</code>. Any existing event subscribers will\nbe subscribers to an event that followed the classic pattern.</p>\n<p>Following similar logic, any event argument type created now would\nnot have any subscribers in any existing codebases. New event types\nthat do not derive from <code>System.EventArgs</code> will not break those\ncodebases.</p>\n<h2 id=\"events-with-async-subscribers\">Events with Async subscribers</h2>\n<p>You have one final pattern to learn: How to correctly write event\nsubscribers that call async code. The challenge is described in\nthe article on <a href=\"async\" data-linktype=\"relative-path\">async and await</a>. Async methods can\nhave a void return type, but that is strongly discouraged. When your\nevent subscriber code calls an async method, you have no choice but\nto create an <code>async void</code> method. The event handler signature requires\nit.</p>\n<p>You need to reconcile this opposing guidance. Somehow, you must\ncreate a safe <code>async void</code> method. The basics of the pattern you need\nto implement are below:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">worker.StartWorking += async (sender, eventArgs) =&gt;\n{\n    try \n    {\n        await DoWorkAsync();\n    }\n    catch (Exception e)\n    {\n        //Some form of logging.\n        Console.WriteLine($&quot;Async task failure: {e.ToString()}&quot;);\n        // Consider gracefully, and quickly exiting.\n    }\n};\n</code></pre><p>First, notice that the handler is marked as an async handler. Because\nit is being assigned to an event handler delegate type, it will have\na void return type. That means you must follow the pattern shown in the\nhandler, and not allow any exceptions to be thrown out of the context\nof the async handler. Because it does not return a task, there is no\ntask that can report the error by entering the faulted state. Because\nthe method is async, the method can&#39;t simply throw the exception. (The\ncalling method has continued execution because it is <code>async</code>.) The\nactual runtime behavior will be defined differently for different\nenvironments. It may terminate the thread, it may terminate the program,\nor it may leave the program in an undetermined state. None of those\nare good outcomes.</p>\n<p>That&#39;s why you should wrap the await statement for the async Task\nin your own try block. If it does cause a faulted task, you can\nlog the error. If it is an error from which your application cannot\nrecover, you can exit the program quickly and gracefully</p>\n<p>Those are the major updates to the .NET event pattern. You will see many\nexamples of the earlier versions in the libraries you work with. However,\nyou should understand what the latest patterns are as well.</p>\n<p>The next article in this series helps you distinguish between using\n<code>delegates</code> and <code>events</code> in your designs. They are similar concepts,\nand that article will help you make the best decision for your\nprograms.</p>\n<p><a href=\"distinguish-delegates-events\" data-linktype=\"relative-path\">Next</a></p>\n</div></div>","outputRootRelativePath":"../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"uhfHeaderId\" content=\"MSDocsHeader-DotNet\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"9aa627c3-3222-4094-9ca8-7e88e1071e06\">\r\n<meta name=\"description\" content=\"The Updated .NET Core Event Pattern\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"06/20/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-04-01 05:46 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/400dfda51d978f35c3995f90840643aaff1b9c13/docs/csharp/modern-events.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/modern-events.md\">\r\n<meta name=\"document_id\" content=\"f463a69c-587d-30ac-41e0-6386f9547100\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","uhfHeaderId":"MSDocsHeader-DotNet","title":"The Updated .NET Core Event Pattern | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"9aa627c3-3222-4094-9ca8-7e88e1071e06","description":"The Updated .NET Core Event Pattern","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"06/20/2016","ms.technology":"devlang-csharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"tompratt-AQ","author_email":"v-thprat@microsoft.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"Update language identifiers and styleguide. (#1796)","commit_sha":"400dfda51d978f35c3995f90840643aaff1b9c13","commit_date":"2017-03-24 14:01:03 -0700"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"update names per naming guidelines. (#1012)","commit_sha":"59cb2f6799814e37aa02ca35e719329a8af49a20","commit_date":"2016-09-08 14:53:56 -0400"},{"author_name":"Petr Onderka","author_email":"gsvick@gmail.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@users.noreply.github.com","message":"Corrected titles and headings (#690)","commit_sha":"17cac6e7690fd2b08d9f5f73060056d14bca13d2","commit_date":"2016-06-28 12:36:36 -0700"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"Rich Lander","comitter_email":"rlander@microsoft.com","message":"Promote csharp from languages (#644)","commit_sha":"2d44b7e04c0fe2ca136ba6dfa9fc3a4368365ec8","commit_date":"2016-06-26 08:30:56 -0700"}],"updated_at":"2017-04-01 05:46 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/tompratt-AQ","display_name":"tompratt-AQ","id":"26311438"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/svick","display_name":"Petr Onderka","id":"287848"}],"update_at":"4/1/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/400dfda51d978f35c3995f90840643aaff1b9c13/docs/csharp/modern-events.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/modern-events.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/modern-events.md","document_id":"f463a69c-587d-30ac-41e0-6386f9547100","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/modern-events","toc_asset_id":"articles/toc.json","toc_rel":"../toc.json","_op_ogTitle":"The Updated .NET Core Event Pattern","_op_displayDate":"2016-6-20","_op_displayDate_source":"2016-06-20T00:00:00Z","_op_wordCount":797,"_op_rawTitle":"<h1 id=\"the-updated-net-core-event-pattern\" sourcefile=\"docs/csharp/modern-events.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">The Updated .NET Core Event Pattern</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/modern-events","fileRelativePath":"articles/csharp/modern-events.html"},"themesRelativePathToOutputRoot":"_themes/"}