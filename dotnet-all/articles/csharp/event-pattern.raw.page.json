{"content":"<div><div class=\"content\">\n<p><a href=\"events-overview\" data-linktype=\"relative-path\">Previous</a></p>\n<p>.NET events generally follow a few known patterns. Standardizing\non these patterns means that developers can leverage knowledge of\nthose standard patterns, which can be applied to any .NET event program.</p>\n<p>Let&#39;s go through these standard patterns so you will have all\nthe knowledge you need to create standard event sources, and\nsubscribe and process standard events in your code.</p>\n<h2 id=\"event-delegate-signatures\">Event Delegate Signatures</h2>\n<p>The standard signature for a .NET event delegate is:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">void OnEventRaised(object sender, EventArgs args);\n</code></pre><p>The return type is void. Events are based on delegates and are\nmulticast delegates. That supports multiple subscribers for any\nevent source. The single return value from a method doesn&#39;t scale\nto multiple event subscribers. Which return value does the event\nsource see after raising an event? Later in this article you&#39;ll\nsee how to create event protocols that support event subscribers\nthat report information to the event source.</p>\n<p>The argument list contains two arguments: the sender, and the event\narguments. The compile time type of <code>sender</code> is <code>System.Object</code>,\neven though you likely know a more derived type that would always\nbe correct. By convention, use <code>object</code>.</p>\n<p>The second argument has typically been a type that is derived from\n<code>System.EventArgs</code>. (You&#39;ll see in the \n<a href=\"modern-events\" data-linktype=\"relative-path\">next section</a> that this convention is no longer\nenforced.) If your event type does not need any additional\narguments, you will still provide both arguments.\nThere is a special value, <code>EventArgs.Empty</code> that you should use to\ndenote that your event does not contain any additional information.</p>\n<p>Let&#39;s build a class that lists files in a directory, or any of its\nsubdirectories that follow a pattern. This component raises an event\nfor each file found that matches the pattern.</p>\n<p>Using an event model provides some design advantages. You can create\nmultiple event listeners that perform different actions when a sought\nfile is found. Combining the different listeners can create more\nrobust algorithms.</p>\n<p>Here is the initial event argument declaration for finding a sought\nfile: </p>\n<pre class=\"loading\"><code class=\"lang-cs\">public class FileFoundArgs : EventArgs\n{\n    public string FoundFile { get; }\n\n    public FileFoundArgs(string fileName)\n    {\n        FoundFile = fileName;\n    }\n}\n</code></pre><p>Even though this type looks like a small, data-only type, you should\nfollow the convention and make it a reference (<code>class</code>) type. That\nmeans the argument object will be passed by reference, and any\nupdates to the data will be viewed by all subscribers. The first\nversion is an immutable object. You should prefer to make the\nproperties in your event argument type immutable. That way, one\nsubscriber cannot change the values before another subscriber sees\nthem. (There are exceptions to this, as you&#39;ll see below.)  </p>\n<p>Next, we need to create the event declaration in the FileSearcher\nclass. Leveraging the <code>EventHandler&lt;T&gt;</code> type means that you don&#39;t\nneed to create yet another type definition. You simply use a generic\nspecialization.</p>\n<p>Let&#39;s fill out the FileSearcher class to search for files that match\na pattern, and raise the correct event when a match is discovered.</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public class FileSearcher\n{\n    public event EventHandler&lt;FileFoundArgs&gt; FileFound;\n\n    public void Search(string directory, string searchPattern)\n    {\n        foreach (var file in Directory.EnumerateFiles(directory, searchPattern))\n        {\n            FileFound?.Invoke(this, new FileFoundArgs(file));\n        }\n    }\n}\n</code></pre><h2 id=\"definining-and-raising-field-like-events\">Definining and Raising Field-Like Events</h2>\n<p>The simplest way to add an event to your class is to declare that\nevent as a public field, as in the above example:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public event EventHandler&lt;FileFoundArgs&gt; FileFound;\n</code></pre><p>This looks like it&#39;s declaring a public field, which would appear to\nbe bad object oriented practice. You want to protect data access\nthrough properties, or methods. While this make look like a bad\npractice, the code generated by the compiler does create wrappers so\nthat the event objects can only be accessed in safe ways. The only\noperations available on a field-like event are add handler:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">EventHandler&lt;FileFoundArgs&gt; onFileFound = (sender, eventArgs) =&gt;\n    Console.WriteLine(eventArgs.FoundFile);\nlister.FileFound += onFIleFound;\n</code></pre><p>and remove handler:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">lister.FileFound -= onFileFound;\n</code></pre><p>Note that there&#39;s a local variable for the handler. If you used\nthe body of the lambda, the remove would not work correctly. It would\nbe a different instance of the delegate, and silently do nothing.</p>\n<p>Code outside the class cannot raise the event, nor can it perform any\nother operations.</p>\n<h2 id=\"returning-values-from-event-subscribers\">Returning Values from Event Subscribers</h2>\n<p>Your simple version is working fine. Let&#39;s add another feature:\nCancellation.</p>\n<p>When you raise the found event, listeners should be able to stop\nfurther processing, if this file is that last one sought.</p>\n<p>The event handlers do not return a value, so you need to communicate\nthat in another way. The standard event pattern uses the EventArgs\nobject to include fields that event subscribers can use to\ncommunicate cancel.</p>\n<p>There are two different patterns that could be used, based on the\nsemantics of the Cancel contract. In both cases, you&#39;ll add a boolean\nfield to the EventArguments for the found file event. </p>\n<p>One pattern would allow any one subscriber to cancel the operation.\nFor this pattern, the new field is initialized to <code>false</code>. Any\nsubscriber can change it to <code>true</code>. After all subscribers have seen\nthe event raised, the FileSearcher component examines the boolean\nvalue and takes action.</p>\n<p>The second pattern would only cancel the operation if all subscribers\nwanted the operation cancelled. In this pattern, the new field is\ninitialized to indicate the operation should cancel, and any\nsubscriber could change it to indicate the operation should continue.\nAfter all subscribers have seen the event raised, the FileSearcher\ncomponent examines the boolean and takes action. There is one extra\nstep in this pattern: the component needs to know if any subscribers\nhave seen the event. If there are no subscribers, the field would\nindicate a cancel incorrectly.</p>\n<p>Let&#39;s implement the first version for this sample. You need to add a\nboolean field to the FileFoundEventArgs type:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public class FileFoundArgs : EventArgs\n{\n    public string FoundFile { get; }\n    public bool CancelRequested { get; set; }\n\n    public FileFoundArgs(string fileName)\n    {\n        FoundFile = fileName;\n    }\n}\n</code></pre><p>This new Field should be initialized to false, so you don&#39;t cancel\nfor no reason. That is the default value for a boolean field, so that\nhappens automatically. The only other change to the component is to\ncheck the flag after raising the event to see if any of the\nsubscribers have requested a cancellation:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public void List(string directory, string searchPattern)\n{\n    foreach (var file in Directory.EnumerateFiles(directory, searchPattern))\n    {\n        var args = new FileFoundArgs(file);\n        FileFound?.Invoke(this, args);\n        if (args.CancelRequested)\n            break;\n    }\n}\n</code></pre><p>One advantage of this pattern is that it isn&#39;t a breaking change.\nNone of the subscribers requested a cancel before, and they still are\nnot. None of the subscriber code needs updating unless they want to\nsupport the new cancel protocol. It&#39;s very loosely coupled.</p>\n<p>Let&#39;s update the subscriber so that it requests a cancellation once\nit finds the first executable:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">EventHandler&lt;FileFoundArgs&gt; onFileFound = (sender, eventArgs) =&gt;\n{\n    Console.WriteLine(eventArgs.FoundFile);\n    eventArgs.CancelRequested = true;\n};\n</code></pre><h2 id=\"adding-another-event-declaration\">Adding Another Event Declaration</h2>\n<p>Let&#39;s add one more feature, and demonstrate other language idioms\nfor events. Let&#39;s add an overload of the <code>Search()</code> method that\ntraverses all subdirectories in search of files.</p>\n<p>This could get to be a lengthy operation in a directory with many\nsub-directories. Let&#39;s add an event that gets raised when each new\ndirectory search begins. This enables subscribers to track progress,\nand update the user as to progress. All the samples you&#39;ve created so\nfar are public. Let&#39;s make this one an internal event. That means you\ncan also make the types used for the arguments internal as well.</p>\n<p>You&#39;ll start by creating the new EventArgs derived class for\nreporting the new directory and progress. </p>\n<pre class=\"loading\"><code class=\"lang-cs\">internal class SearchDirectoryArgs : EventArgs\n{\n    internal string CurrentSearchDirectory { get; }\n    internal int TotalDirs { get; }\n    internal int CompletedDirs { get; }\n\n    internal SearchDirectoryArgs(string dir, int totalDirs, int completedDirs)\n    {\n        CurrentSearchDirectory = dir;\n        TotalDirs = totalDirs;\n        CompletedDirs = completedDirs;\n    }\n}\n</code></pre><p>Again, you can follow the recommendations to make an immutable\nreference type for the event arguments.</p>\n<p>Next, define the event. This time, you&#39;ll use a different syntax. In\naddition to using the field syntax, you can explicitly create the\nproperty, with add and remove handlers. In this sample, you won&#39;t\nneed extra code in those handlers in this project, but this shows how\nyou would create them.</p>\n<pre class=\"loading\"><code class=\"lang-cs\">internal event EventHandler&lt;SearchDirectoryArgs&gt; DirectoryChanged\n{\n    add { directoryChanged += value; }\n    remove { directoryChanged -= value; }\n}\nprivate EventHandler&lt;SearchDirectoryArgs&gt; directoryChanged;\n</code></pre><p>In may ways, the code you write here mirrors the code the compiler\ngenerates for the field event definitions you&#39;ve seen earlier. You\ncreate the event using syntax very similar to that used for\n<a href=\"properties\" data-linktype=\"relative-path\">properties</a>. Notice that the handlers have different\nnames: <code>add</code> and <code>remove</code>. These are called to subscribe to the event,\nor unsubscribe from the event. Notice that you also must declare a\nprivate backing field to store the event variable. It is initialized\nto null.</p>\n<p>Next, let&#39;s add the overload of the Search() method that traverses\nsubdirectories and raises both events. The easiest way to accomplish\nthis is to use a default argument to specify that you want to search\nall directories:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public void Search(string directory, string searchPattern, bool searchSubDirs = false)\n{\n    if (searchSubDirs)\n    {\n        var allDirectories = Directory.GetDirectories(directory, &quot;*.*&quot;, SearchOption.AllDirectories);\n        var completedDirs = 0;\n        var totalDirs = allDirectories.Length + 1;\n        foreach (var dir in allDirectories)\n        {\n            directoryChanged?.Invoke(this,\n                new SearchDirectoryArgs(dir, totalDirs, completedDirs++));\n            // Recursively search this child directory:\n            SearchDirectory(dir, searchPattern);\n        }\n        // Include the Current Directory:\n        directoryChanged?.Invoke(this,\n            new SearchDirectoryArgs(directory, totalDirs, completedDirs++));\n        SearchDirectory(directory, searchPattern);\n    }\n    else\n    {\n        SearchDirectory(directory, searchPattern);\n    }\n}\n\nprivate void SearchDirectory(string directory, string searchPattern)\n{\n    foreach (var file in Directory.EnumerateFiles(directory, searchPattern))\n    {\n        var args = new FileFoundArgs(file);\n        FileFound?.Invoke(this, args);\n        if (args.CancelRequested)\n            break;\n    }\n}\n</code></pre><p>At this point, you can run the application calling the overload for\nsearching all sub-directories. There are no subscribers on the new\n<code>ChangeDirectory</code> event, but using the <code>?.Invoke()</code> idiom ensures\nthat this works correctly.</p>\n<p> Let&#39;s add a handler to write a line that shows the progress in the\n console window. </p>\n<pre class=\"loading\"><code class=\"lang-cs\">lister.DirectoryChanged += (sender, eventArgs) =&gt;\n{\n    Console.Write($&quot;Entering &#39;{eventArgs.CurrentSearchDirectory}&#39;.&quot;);\n    Console.WriteLine($&quot; {eventArgs.CompletedDirs} of {eventArgs.TotalDirs} completed...&quot;);\n};\n</code></pre><p>You&#39;ve seen patterns that are followed throughout the .NET ecosystem.\nBy learning these patterns and conventions, you&#39;ll be writing\nidiomatic C# and .NET quickly.</p>\n<p>Next, you&#39;ll see some changes in these patterns in the most recent\nrelease of .NET.</p>\n<p><a href=\"modern-events\" data-linktype=\"relative-path\">Next</a></p>\n</div></div>","outputRootRelativePath":"../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc.json\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"8a3133d6-4ef2-46f9-9c8d-a8ea8898e4c9\">\r\n<meta name=\"description\" content=\"The Standard .NET Event Pattern\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"06/20/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-21 01:42 AM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/event-pattern.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/csharp/event-pattern.md\">\r\n<meta name=\"document_id\" content=\"97cb59ac-87dc-7340-ea0c-3a05be9062a7\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../toc.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"The Standard .NET Event Pattern | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"8a3133d6-4ef2-46f9-9c8d-a8ea8898e4c9","description":"The Standard .NET Event Pattern","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"06/20/2016","ms.technology":"devlang-csharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"update names per naming guidelines. (#1012)","commit_sha":"59cb2f6799814e37aa02ca35e719329a8af49a20","commit_date":"2016-09-08 14:53:56 -0400"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"Fixed typos and other small things (#883)","commit_sha":"bb15293c569fa92f1acf6315c5fe7f2cd9cb6f68","commit_date":"2016-08-08 21:27:46 -0400"},{"author_name":"Petr Onderka","author_email":"gsvick@gmail.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@users.noreply.github.com","message":"Corrected titles and headings (#690)","commit_sha":"17cac6e7690fd2b08d9f5f73060056d14bca13d2","commit_date":"2016-06-28 12:36:36 -0700"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"Rich Lander","comitter_email":"rlander@microsoft.com","message":"Promote csharp from languages (#644)","commit_sha":"2d44b7e04c0fe2ca136ba6dfa9fc3a4368365ec8","commit_date":"2016-06-26 08:30:56 -0700"}],"updated_at":"2017-03-21 01:42 AM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/svick","display_name":"Petr Onderka","id":"287848"}],"update_at":"3/21/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/event-pattern.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/csharp/event-pattern.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/event-pattern.md","document_id":"97cb59ac-87dc-7340-ea0c-3a05be9062a7","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/event-pattern","toc_asset_id":"articles/toc.json","toc_rel":"../toc.json","_op_ogTitle":"The Standard .NET Event Pattern","_op_displayDate":"2016-6-20","_op_displayDate_source":"2016-06-20T00:00:00Z","_op_wordCount":1689,"_op_rawTitle":"<h1 id=\"the-standard-net-event-pattern\" sourcefile=\"docs/csharp/event-pattern.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">The Standard .NET Event Pattern</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/event-pattern","fileRelativePath":"articles/csharp/event-pattern.html"},"themesRelativePathToOutputRoot":"_themes/"}