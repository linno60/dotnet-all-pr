{"content":"<div><div class=\"content\">\n<p>The 6.0 release of C# contained many features that improve\nproductivity for developers. Features in this release include:</p>\n<ul>\n<li><a href=\"#read-only-auto-properties\" data-linktype=\"self-bookmark\">Read-only Auto-properties</a>:<ul>\n<li>You can create read-only auto-properties that can be set only in constructors.</li>\n</ul>\n</li>\n<li><a href=\"#auto-property-initializers\" data-linktype=\"self-bookmark\">Auto-Property Initializers</a>:<ul>\n<li>You can write initialization expressions to set the initial value of an auto-property.</li>\n</ul>\n</li>\n<li><a href=\"#expression-bodied-function-members\" data-linktype=\"self-bookmark\">Expression-bodied function members</a>:<ul>\n<li>You can author one-line methods using lambda expressions.</li>\n</ul>\n</li>\n<li><a href=\"#using-static\" data-linktype=\"self-bookmark\">using static</a>:<ul>\n<li>You can import all the methods of a single class into the current namespace.</li>\n</ul>\n</li>\n<li><a href=\"#null-conditional-operators\" data-linktype=\"self-bookmark\">Null - conditional operators</a>:<ul>\n<li>You can concisely and safely access members of an object while still checking for null with the null conditional operator.</li>\n</ul>\n</li>\n<li><a href=\"#string-interpolation\" data-linktype=\"self-bookmark\">String Interpolation</a>:<ul>\n<li>You can write string formatting expressions using inline expressions instead of positional arguments.</li>\n</ul>\n</li>\n<li><a href=\"#exception-filters\" data-linktype=\"self-bookmark\">Exception filters</a>:<ul>\n<li>You can catch expressions based on properties of the exception or other program state. </li>\n</ul>\n</li>\n<li><a href=\"#nameof-expressions\" data-linktype=\"self-bookmark\">nameof Expressions</a>:<ul>\n<li>You can let the compiler generate string representations of symbols.</li>\n</ul>\n</li>\n<li><a href=\"#await-in-catch-and-finally-blocks\" data-linktype=\"self-bookmark\">await in catch and finally blocks</a>:<ul>\n<li>You can use <code>await</code> expressions in locations that previously disallowed them.</li>\n</ul>\n</li>\n<li><a href=\"#index-initializers\" data-linktype=\"self-bookmark\">index initializers</a>:<ul>\n<li>You can author initialization expressions for associative containers as well as sequence containers.</li>\n</ul>\n</li>\n<li><a href=\"#extension-add-methods-in-collection-initializers\" data-linktype=\"self-bookmark\">Extension methods for collection initializers</a>:<ul>\n<li>Collection initializers can rely on accessible extension methods, in addition to member methods.</li>\n</ul>\n</li>\n<li><a href=\"#improved-overload-resolution\" data-linktype=\"self-bookmark\">Improved overload resolution</a>:<ul>\n<li>Some constructs that previously generated ambiguous method calls now resolve correctly.</li>\n</ul>\n</li>\n</ul>\n<p>The overall effect of these features is that you write more concise code\nthat is also more readable. The syntax contains less ceremony for many\ncommon practices. It&#39;s easier to see the design intent with less\nceremony. Learn these features well, and you&#39;ll be more productive,\nwrite more readable code, and concentrate more on your core features\nthan on the constructs of the language.</p>\n<p>The remainder of this topic provides details on each of these features.</p>\n<h2 id=\"auto-property-enhancements\">Auto-Property enhancements</h2>\n<p>The syntax for automatically implemented properties (usually referred to as &#39;auto-properties&#39;)\nmade it very easy to create properties\nthat had simple get and set accessors:</p>\n<pre><code class=\"lang-csharp\" name=\"ClassicAutoProperty\">public string FirstName { get; set; }\npublic string LastName { get; set; }\n</code></pre><p>However, this simple syntax limited the kinds of designs you could support using\nauto-properties. C# 6 improves the auto-properties capabilities so that you can use\nthem in more scenarios. You won&#39;t need to fall back on the more verbose syntax of\ndeclaring and manipulating the backing field by hand so often.</p>\n<p>The new syntax addresses scenarios for read only properties, and for initializing\nthe variable storage behind an auto-property.</p>\n<h3 id=\"read-only-auto-properties\">Read-only auto-properties</h3>\n<p><em>Read-only auto-properties</em> provide a more concise syntax to create\nimmutable types. The closest you could get to immutable types\nin earlier versions of C# was to declare private setters:</p>\n<pre><code class=\"lang-csharp\" name=\"ClassicReadOnlyAutoProperty\">public string FirstName { get; private set; }\npublic string LastName { get; private set; }\n</code></pre><p>Using this syntax, the compiler doesn&#39;t ensure that the type really is immutable. It only\nenforces that the <code>FirstName</code> and <code>LastName</code> properties are not modified from any\ncode outside the class.</p>\n<p>Read-only auto-properties enable true read-only behavior. You declare the auto-property\nwith only a get accessor:</p>\n<pre><code class=\"lang-csharp\" name=\"ReadOnlyAutoProperty\">public string FirstName { get; }\npublic string LastName { get;  }\n</code></pre><p>The <code>FirstName</code> and <code>LastName</code> properties can be set only in the body of a constructor:</p>\n<pre><code class=\"lang-csharp\" name=\"ReadOnlyAutoPropertyConstructor\">public Student(string firstName, string lastName)\n{\n    if (IsNullOrWhiteSpace(lastName))\n        throw new ArgumentException(message: &quot;Cannot be blank&quot;, paramName: nameof(lastName));\n    FirstName = firstName;\n    LastName = lastName;\n}\n</code></pre><p>Trying to set <code>LastName</code> in another method generates a <code>CS0200</code> compilation error:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">public class Student\n{\n    public string LastName { get;  }\n\n    public void ChangeName(string newLastName)\n    {\n        // Generates CS 0200: Property or indexer cannot be assigned to -- it is read only\n        LastName = newLastName;\n    }\n}\n</code></pre><p>This feature enables true language support for creating immutable types and using\nthe more concise and convenient auto-property syntax.</p>\n<h3 id=\"auto-property-initializers\">Auto-Property Initializers</h3>\n<p><em>Auto-Property Initializers</em> let you declare the initial value for\nan auto-property as part of the property declaration.  In earlier versions,\nthese properties would need to have setters and you would need\nto use that setter to initialize the data storage used by the backing\nfield. Consider this class for a student that contains the name and a\nlist of the student&#39;s grades:</p>\n<pre><code class=\"lang-csharp\" name=\"Construction\">public Student(string firstName, string lastName)\n{\n    FirstName = firstName;\n    LastName = lastName;\n}\n</code></pre><p>As this class grows, you may include other constructors. Each constructor\nneeds to initialize this field, or you&#39;ll introduce errors.</p>\n<p>C# 6 enables you to assign an initial value for the storage used by an\nauto-property in the auto-property declaration:</p>\n<pre><code class=\"lang-csharp\" name=\"Initialization\">public ICollection&lt;double&gt; Grades { get; } = new List&lt;double&gt;();\n</code></pre><p>The <code>Grades</code> member is initialized where it is declared. That makes it\neasier to perform the initialization exactly once. The initialization\nis part of the property declaration, making it easier to equate the\nstorage allocation with public interface for <code>Student</code> objects.</p>\n<p>Property Initializers can be used with read/write properties as well\nas read only properties, as shown here.</p>\n<pre><code class=\"lang-csharp\" name=\"ReadWriteInitialization\">public Standing YearInSchool { get; set;} = Standing.Freshman;\n</code></pre><h2 id=\"expression-bodied-function-members\">Expression-bodied function members</h2>\n<p>The body of a lot of members that we write consist of only one statement\nthat can be represented as an expression. You can reduce that syntax by\nwriting an expression-bodied member instead. It works for methods and\nread-only properties.&quot; For example, an override of <code>ToString()</code> is often\na great candidate:</p>\n<pre><code class=\"lang-csharp\" name=\"ToStringExpressionMember\">public override string ToString() =&gt; $&quot;{LastName}, {FirstName}&quot;;\n</code></pre><p>You can also use expression-bodied members in read only properties as well:</p>\n<pre><code class=\"lang-csharp\" name=\"FullNameExpressionMember\">public string FullName =&gt; $&quot;{FirstName} {LastName}&quot;;\n</code></pre><h2 id=\"using-static\">using static</h2>\n<p>The <em>using static</em> enhancement enables you to import the static methods\nof a single class. Previously, the <code>using</code> statement imported all types\nin a namespace. </p>\n<p>Often we use a class&#39; static methods throughout our code. Repeatedly\ntyping the class name can obscure the meaning of your code. A common\nexample is when you write classes that perform many numeric calculations.\nYour code will be littered with @System.Math.Sin, @System.Math.Sqrt and other calls\nto different methods in the <a class=\"xref\" href=\"../../api/system.math\" data-linktype=\"relative-path\">Math</a> class. The new <code>using static</code> syntax can make these\nclasses much cleaner to read. You specify the class you&#39;re using:</p>\n<pre><code class=\"lang-csharp\" name=\"UsingStaticMath\">using static System.Math;\n</code></pre><p>And now, you can use any static method in the <a class=\"xref\" href=\"../../api/system.math\" data-linktype=\"relative-path\">Math</a> class without\nqualifying the <a class=\"xref\" href=\"../../api/system.math\" data-linktype=\"relative-path\">Math</a> class. The <a class=\"xref\" href=\"../../api/system.math\" data-linktype=\"relative-path\">Math</a> class is a great use case for\nthis feature because it does not contain any\ninstance methods. You can also use <code>using static</code> to import a\nclass&#39; static methods for a class that has both static\nand instance methods. One of the most useful examples is <a class=\"xref\" href=\"../../api/system.string\" data-linktype=\"relative-path\">String</a>:</p>\n<pre><code class=\"lang-csharp\" name=\"UsingStatic\">using static System.String;\n</code></pre><div class=\"NOTE\"><h5>Note</h5><p>You must use the fully qualified class name, <code>System.String</code>\nin a static using statement. \nYou cannot use the <code>string</code> keyword instead. </p>\n</div>\n<p>You can now call static methods defined in the <a class=\"xref\" href=\"../../api/system.string\" data-linktype=\"relative-path\">String</a> class without\nqualifying those methods as members of that class:</p>\n<pre><code class=\"lang-csharp\" name=\"UsingStaticString\">if (IsNullOrWhiteSpace(lastName))\n    throw new ArgumentException(message: &quot;Cannot be blank&quot;, paramName: nameof(lastName));\n</code></pre><p>The <code>static using</code> feature and extension methods interact in\ninteresting ways, and the language design included some rules\nthat specifically address those interactions. The goal is to\nminimize any chances of breaking changes in existing codebases,\nincluding yours.</p>\n<p>Extension methods are only in scope when called using the\nextension method invocation syntax, not when called as a static method.\nYou&#39;ll often see this in LINQ queries. You can import the LINQ pattern\nby importing <a class=\"xref\" href=\"../../api/system.linq.enumerable\" data-linktype=\"relative-path\">Enumerable</a>. </p>\n<pre><code class=\"lang-csharp\" name=\"UsingStaticLinq\">using static System.Linq.Enumerable;\n</code></pre><p>This imports all the methods in the <a class=\"xref\" href=\"../../api/system.linq.enumerable\" data-linktype=\"relative-path\">Enumerable</a> class.\nHowever, the extension methods are only in scope when called as extension\nmethods. They are not in scope if they are called using the static method\nsyntax:</p>\n<pre><code class=\"lang-csharp\" name=\"UsingStaticLinqMethod\">public bool MakesDeansList()\n{\n    return Grades.All(g =&gt; g &gt; 3.5) &amp;&amp; Grades.Any();\n    // Code below generates CS0103: \n    // The name &#39;All&#39; does not exist in the current context.\n    //return All(Grades, g =&gt; g &gt; 3.5) &amp;&amp; Grades.Any();\n}\n</code></pre><p>This decision is because extension methods are typically called using\nextension method invocation expressions. In the rare case where they are\ncalled using the static method call syntax it is to resolve ambiguity.\nRequiring the class name as part of the invocation seems wise.</p>\n<p>There&#39;s one last feature of <code>static using</code>. The <code>static using</code> directive\nalso imports any nested types. That enables you to reference any nested\ntypes without qualification.</p>\n<h2 id=\"null-conditional-operators\">Null-conditional operators</h2>\n<p>Null values complicate code. You need to check every access\nof variables to ensure you are not dereferencing <code>null</code>. The\n<em>null conditional operator</em> makes those checks much easier\nand fluid.</p>\n<p>Simply replace the member access <code>.</code> with <code>?.</code>:</p>\n<pre><code class=\"lang-csharp\" name=\"NullConditional\">var first = person?.FirstName; \n</code></pre><p>In the preceding example, the variable <code>first</code> is assigned <code>null</code> if the person object\nis <code>null</code>. Otherwise, it gets assigned the value of the <code>FirstName</code> property. Most importantly,\nthe <code>?.</code> means that this line of code does not generate a <code>NullReferenceException</code> when\nthe <code>person</code> variable is <code>null</code>. Instead, it short-circuits and produces <code>null</code>.</p>\n<p>Also, note that this expression returns a <code>string</code>, regardless of the value of <code>person</code>.\nIn the case of short circuiting, the <code>null</code> value returned is typed to match the full\nexpression.</p>\n<p>You can often use this construct with the <em>null coalescing</em> operator to assign\ndefault values when one of the properties are <code>null</code>:</p>\n<pre><code class=\"lang-csharp\" name=\"NullCoalescing\">first = person?.FirstName ?? &quot;Unspecified&quot;;\n</code></pre><p>The right hand side operand of the <code>?.</code> operator is not limited to properties or fields.\nYou can also use it to conditionally invoke methods. The most common use of member functions\n with the null conditional operator is to safely invoke delegates\n(or event handlers) that may be <code>null</code>.  You&#39;ll do this by calling the delegate&#39;s <code>Invoke</code> method\nusing the <code>?.</code> operator to access the member. You can see an example in the<br><a href=\"delegates-patterns#handling-null-delegates\" data-linktype=\"relative-path\">delegate patterns</a> topic.</p>\n<p>The rules of the <code>?.</code> operator ensure that the left-hand side of the operator is\nevaluated only once. This is important and enables many idioms, including the\nexample using event handlers. Let&#39;s start with the event handler usage. In previous\nversions of C#, you were encouraged to write code like this:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">var handler = this.SomethingHappened;\nif (handler != null)\n    handler(this, eventArgs);\n</code></pre><p>This was preferred over a simpler syntax:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">// Not recommended\nif (this.SomethingHappened != null)\n    this.SomethingHappened(this, eventArgs);\n</code></pre><div class=\"IMPORTANT\"><h5>Important</h5><p>The preceding example introduces a race condition. The <code>SomethingHappened</code>\nevent may have subscribers when checked against <code>null</code>, and those subscribers\nmay have been removed before the event is raised. That would cause \na <a class=\"xref\" href=\"../../api/system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a> to be thrown.</p>\n</div>\n<p>In this second version, the <code>SomethingHappened</code> event handler might\nbe non-null when tested, but if other code removes a handler,\nit could still be null when the event handler was called.</p>\n<p>The compiler generates code for the <code>?.</code> operator that ensures\nthe left side (<code>this.SomethingHappened</code>) of the <code>?.</code> expression is evaluated once, and the result\nis cached:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">// preferred in C# 6:\nthis.SomethingHappened?.Invoke(this, eventArgs);\n</code></pre><p>Ensuring that the left side is evaluated only once also enables you\nto use any expression, including method calls, on the left side of the\n<code>?.</code> Even if these have side-effects, they are evaluated once, so the\nside effects occur only once. You can see an example in our content\non <a href=\"events-overview#language-support-for-events\" data-linktype=\"relative-path\">events</a>.</p>\n<h2 id=\"string-interpolation\">String Interpolation</h2>\n<p>C# 6 contains new syntax for composing strings from a format string\nand expressions that can be evaluated to produce other string values.</p>\n<p>Traditionally, you needed to use positional parameters in a method\nlike <code>string.Format</code>:</p>\n<pre><code class=\"lang-csharp\" name=\"stringFormat\">public string FullName\n{\n    get\n    {\n        return string.Format(&quot;{0} {1}&quot;, FirstName, LastName);\n    }\n}\n</code></pre><p>With C# 6, the new string interpolation feature enables you to embed\nthe expressions in the format string. Simple preface the string with\n<code>$</code>:</p>\n<pre><code class=\"lang-csharp\" name=\"stringInterpolation\">public string FullName =&gt; $&quot;{FirstName} {LastName}&quot;;\n</code></pre><p>This initial example used variable expressions for the substituted\nexpressions. You can expand on this syntax to use any expression. For\nexample, you could compute a student&#39;s grade point average as part of\nthe interpolation:</p>\n<pre><code class=\"lang-csharp\" name=\"stringInterpolationExpression\">public string GetFormattedGradePoint() =&gt;\n    $&quot;Name: {LastName}, {FirstName}. G.P.A: {Grades.Average()}&quot;;\n</code></pre><p>Running the preceding example, you would find that the output for <code>Grades.Average()</code>\nmight have more decimal places than you would like. The string interpolation\nsyntax supports all the format strings available using earlier formatting\nmethods. You add the format strings inside the braces. Add a <code>:</code> following\nthe expression to format:</p>\n<pre><code class=\"lang-csharp\" name=\"stringInterpolationFormat\">public string GetGradePointPercentage() =&gt;\n    $&quot;Name: {LastName}, {FirstName}. G.P.A: {Grades.Average():F2}&quot;;\n</code></pre><p>The preceding line of code will format the value for <code>Grades.Average()</code> as\na floating-point number with two decimal places.</p>\n<p>The <code>:</code> is always interpreted as the separator between the expression\nbeing formatted and the format string. This can introduce problems when\nyour expression uses a <code>:</code> in another way, such as a conditional operator:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">public string GetGradePointPercentages() =&gt;\n    $&quot;Name: {LastName}, {FirstName}. G.P.A: {Grades.Any() ? Grades.Average() : double.NaN:F2}&quot;;\n</code></pre><p>In the preceding example, the <code>:</code> is parsed as the beginning of the format string, not part\nof the conditional operator. In all cases where this happens, you can\nsurround the expression with parentheses to force the compiler to interpret\nthe expression as you intend:</p>\n<pre><code class=\"lang-csharp\" name=\"stringInterpolationConditional\">public string GetGradePointPercentages() =&gt;\n    $&quot;Name: {LastName}, {FirstName}. G.P.A: {(Grades.Any() ? Grades.Average() : double.NaN):F2}&quot;;\n</code></pre><p>There aren&#39;t any limitations on the expressions you can place between\nthe braces. You can execute a complex LINQ query inside an interpolated\nstring to perform computations and display the result:</p>\n<pre><code class=\"lang-csharp\" name=\"stringInterpolationLinq\">public string GetAllGrades() =&gt;\n    $@&quot;All Grades: {Grades.OrderByDescending(g =&gt; g)\n    .Select(s =&gt; s.ToString(&quot;F2&quot;)).Aggregate((partial, element) =&gt; $&quot;{partial}, {element}&quot;)}&quot;;\n</code></pre><p>You can see from this sample that you can even nest a string interpolation\nexpression inside another string interpolation expression. This example\nis very likely more complex than you would want in production code.\nRather, it is illustrative of the breadth of the feature. Any C# expression\ncan be placed between the curly braces of an interpolated string.</p>\n<h3 id=\"string-interpolation-and-specific-cultures\">String interpolation and specific cultures</h3>\n<p>All the examples shown in the preceding section will format the strings using the current\nculture and language on the machine where the code executes. Often you\nmay need to format the string produced using a specific culture.\nThe object produced from a string interpolation is a type that has an\nimplicit conversion to either <a class=\"xref\" href=\"../../api/system.string\" data-linktype=\"relative-path\">String</a> or <a class=\"xref\" href=\"../../api/system.formattablestring\" data-linktype=\"relative-path\">FormattableString</a>.</p>\n<p>The <a class=\"xref\" href=\"../../api/system.formattablestring\" data-linktype=\"relative-path\">FormattableString</a> type contains the format string, and the results\nof evaluating the arguments before converting them to strings. You can\nuse public methods of <a class=\"xref\" href=\"../../api/system.formattablestring\" data-linktype=\"relative-path\">FormattableString</a> to specify the culture when\nformatting a string. For example, the following will produce a string\nusing German as the language and culture. (It will use the &#39;,&#39; character\nfor the decimal separator,\nand the &#39;.&#39; character as the thousands separator.)</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">FormattableString str = @&quot;Average grade is {s.Grades.Average()}&quot;;\nvar gradeStr = string.Format(null, \n    System.Globalization.CultureInfo.CreateSpecificCulture(&quot;de-de&quot;),\n    str.GetFormat(), str.GetArguments());\n</code></pre><div class=\"NOTE\"><h5>Note</h5><p>The preceding example is not supported in .NET Core version 1.0.1. It is\nonly supported in the .NET Framework.</p>\n</div>\n<p>In general, string interpolation expressions produce strings as their\noutput. However, when you want greater control over the culture used to\nformat the string, you can specify a specific output.  If this is a capability\nyou often need, you can create convenience methods, as extension methods,\nto enable easy formatting with specific cultures.</p>\n<h2 id=\"exception-filters\">Exception Filters</h2>\n<p>Another new feature in C# 6 is <em>exception filters</em>. Exception Filters\nare clauses that determine when a given catch clause should be applied.\nIf the expression used for an exception filter evaluates to <code>true</code>, the\ncatch clause performs its normal processing on an exception. If the\nexpression evaluates to <code>false</code>, then the <code>catch</code> clause is skipped.</p>\n<p>One use is to examine information about an exception to determine if a\n<code>catch</code> clause can process the exception:</p>\n<pre><code class=\"lang-csharp\" name=\"ExceptionFilter\">public static async Task&lt;string&gt; MakeRequest()\n{ \n    var client = new System.Net.Http.HttpClient();\n    var streamTask = client.GetStringAsync(&quot;https://localHost:10000&quot;);\n    try {\n        var responseText = await streamTask;\n        return responseText;\n    } catch (System.Net.Http.HttpRequestException e) when (e.Message.Contains(&quot;301&quot;))\n    {\n        return &quot;Site Moved&quot;;\n    }\n}\n</code></pre><p>The code generated by exception filters provides better information about\nan exception that is thrown and not processed. Before exception filters\nwere added to the language, you would need to create code like the following:</p>\n<pre><code class=\"lang-csharp\" name=\"ExceptionFilterOld\">public static async Task&lt;string&gt; MakeRequest()\n{ \n    var client = new System.Net.Http.HttpClient();\n    var streamTask = client.GetStringAsync(&quot;https://localHost:10000&quot;);\n    try {\n        var responseText = await streamTask;\n        return responseText;\n    } catch (System.Net.Http.HttpRequestException e)\n    {\n        if (e.Message.Contains(&quot;301&quot;))\n            return &quot;Site Moved&quot;;\n        else\n            throw;\n    }\n}\n</code></pre><p>The point where the exception is thrown changes between these two examples.\nIn the previous code, where a <code>throw</code> clause is used, any stack trace\nanalysis or examination of crash dumps will show that the exception was\nthrown from the <code>throw</code> statement in your catch clause. The actual exception\nobject will contain the original call stack, but all other information\nabout any variables in the call stack between this throw point and the\nlocation of the original throw point has been lost. </p>\n<p>Contrast that with how the code using an exception filter is processed:\nthe exception filter expression evaluates to <code>false</code>. Therefore, execution never\nenters the <code>catch</code> clause. Because the <code>catch</code> clause does not execute,\nno stack unwinding takes place. That means the original\nthrow location is preserved for any debugging activities that would take\nplace later.</p>\n<p>Whenever you need to evaluate fields or properties of an exception, instead\nof relying solely on the exception type, use an exception filter to\npreserve more debugging information.</p>\n<p>Another recommended pattern with exception filters is to use them for\nlogging routines. This usage also leverages the manner in which the exception\nthrow point is preserved when an exception filter evaluates to <code>false</code>.</p>\n<p>A logging method would be a method whose argument is the exception that\nunconditionally returns <code>false</code>:</p>\n<pre><code class=\"lang-csharp\" name=\"ExceptionFilterLogging\">public static bool LogException(this Exception e)\n{\n    Console.Error.WriteLine(@&quot;Exceptions happen: {e}&quot;);\n    return false;\n} \n</code></pre><p>Whenever you want to log an exception, you can add a catch clause, and\nuse this method as the exception filter:</p>\n<pre><code class=\"lang-csharp\" name=\"LogException\">public void MethodThatFailsSometimes()\n{\n    try {\n        PerformFailingOperation();\n    } catch (Exception e) when (e.LogException())\n    {\n        // This is never reached!\n    }\n} \n</code></pre><p>The exceptions are never caught, because the <code>LogException</code> method always\nreturns <code>false</code>. That always false exception filter means that you can\nplace this logging handler before any other exception handlers:</p>\n<pre><code class=\"lang-csharp\" name=\"LogExceptionRecovery\">public void MethodThatFailsButHasRecoveryPath()\n{\n    try {\n        PerformFailingOperation();\n    } catch (Exception e) when (e.LogException())\n    {\n        // This is never reached!\n    }\n    catch (RecoverableException ex)\n    {\n        Console.WriteLine(ex.ToString());\n        // This can still catch the more specific\n        // exception because the exception filter\n        // above always returns false.\n        // Perform recovery here \n    }\n}\n</code></pre><p>The preceding example highlights a very important facet of exception filters.\nThe exception filters enable scenarios where a more general exception\ncatch clause may appear before a more specific one. It&#39;s also possible\nto have the same exception type appear in multiple catch clauses:</p>\n<pre><code class=\"lang-csharp\" name=\"HandleNotChanged\">public static async Task&lt;string&gt; MakeRequestWithNotModifiedSupport()\n{ \n    var client = new System.Net.Http.HttpClient();\n    var streamTask = client.GetStringAsync(&quot;https://localHost:10000&quot;);\n    try {\n        var responseText = await streamTask;\n        return responseText;\n    } catch (System.Net.Http.HttpRequestException e) when (e.Message.Contains(&quot;301&quot;))\n    {\n        return &quot;Site Moved&quot;;\n    } catch (System.Net.Http.HttpRequestException e) when (e.Message.Contains(&quot;304&quot;))\n    {\n        return &quot;Use the Cache&quot;;\n    }\n}\n</code></pre><p>Another recommended pattern helps prevent catch clauses from processing\nexceptions when a debugger is attached. This technique enables you to\nrun an application with the debugger, and stop execution when an exception\nis thrown.</p>\n<p>In your code, add an exception filter so that any recovery code executes\nonly when a debugger is not attached:</p>\n<pre><code class=\"lang-csharp\" name=\"LogExceptionDebugger\">public void MethodThatFailsWhenDebuggerIsNotAttached()\n{\n    try {\n        PerformFailingOperation();\n    } catch (Exception e) when (e.LogException())\n    {\n        // This is never reached!\n    }\n    catch (RecoverableException ex) when (!System.Diagnostics.Debugger.IsAttached)\n    {\n        Console.WriteLine(ex.ToString());\n        // Only catch exceptions when a debugger is not attached.\n        // Otherwise, this should stop in the debugger. \n    }\n}\n</code></pre><p>After adding this in code, you set your debugger to break on all unhandled\nexceptions. Run the program under the debugger, and the debugger breaks\nwhenever <code>PerformFailingOperation()</code> throws a <code>RecoverableException</code>.\nThe debugger breaks your program, because the catch clause won&#39;t be executed\ndue to the false-returning exception filter.</p>\n<h2 id=\"nameof-expressions\"><code>nameof</code> Expressions</h2>\n<p>The <code>nameof</code> expression evaluates to the name of a symbol. It&#39;s a great\nway to get tools working whenever you need the name of a variable,\na property, or a member field.</p>\n<p>One of the most common uses for <code>nameof</code> is to provide the name of a symbol\nthat caused an exception:</p>\n<pre><code class=\"lang-csharp\" name=\"nameof\">if (IsNullOrWhiteSpace(lastName))\n    throw new ArgumentException(message: &quot;Cannot be blank&quot;, paramName: nameof(lastName));\n</code></pre><p>Another use is with XAML based applications that implement the <code>INotifyPropertyChanged</code>\ninterface:</p>\n<pre><code class=\"lang-csharp\" name=\"nameofNotify\">public string LastName\n{\n    get { return lastName; }\n    set\n    {\n        if (value != lastName)\n        {\n            lastName = value;\n            PropertyChanged?.Invoke(this, \n                new PropertyChangedEventArgs(nameof(LastName)));\n        }\n    }\n}\nprivate string lastName;\n</code></pre><p>The advantage of using the <code>nameof</code> operator over a constant string is\nthat tools can understand the symbol. If you use refactoring tools to\nrename the symbol, it will rename it in the <code>nameof</code> expression. Constant\nstrings don&#39;t have that advantage. Try it yourself in your favorite editor:\nrename a variable, and any <code>nameof</code> expressions will update as well.</p>\n<p>The <code>nameof</code> expression produces the unqualified name of its argument\n(<code>LastName</code> in the previous examples) even if you use the fully qualified\nname for the argument:</p>\n<pre><code class=\"lang-csharp\" name=\"QualifiedNameofNotify\">public string FirstName\n{\n    get { return firstName; }\n    set\n    {\n        if (value != firstName)\n        {\n            firstName = value;\n            PropertyChanged?.Invoke(this, \n                new PropertyChangedEventArgs(nameof(UXComponents.ViewModel.FirstName)));\n        }\n    }\n}\nprivate string firstName;\n</code></pre><p>This <code>nameof</code> expression produces <code>FirstName</code>, not <code>UXComponents.ViewModel.FirstName</code>.</p>\n<h2 id=\"await-in-catch-and-finally-blocks\">Await in Catch and Finally blocks</h2>\n<p>C# 5 had several limitations around where you could place <code>await</code> expressions.\nOne of those has been removed in C# 6. You can now use <code>await</code> in <code>catch</code>\nor <code>finally</code> expressions. </p>\n<p>The addition of await expressions in catch and finally blocks may appear\nto complicate how those are processed. Let&#39;s add an example to discuss\nhow this appears. In any async method, you can use an await expression\nin a finally clause.</p>\n<p>With C# 6, you can also await in catch expressions. This is most often\nused with logging scenarios:</p>\n<pre><code class=\"lang-csharp\" name=\"AwaitFinally\">public static async Task&lt;string&gt; MakeRequestAndLogFailures()\n{ \n    await logMethodEntrance();\n    var client = new System.Net.Http.HttpClient();\n    var streamTask = client.GetStringAsync(&quot;https://localHost:10000&quot;);\n    try {\n        var responseText = await streamTask;\n        return responseText;\n    } catch (System.Net.Http.HttpRequestException e) when (e.Message.Contains(&quot;301&quot;))\n    {\n        await logError(&quot;Recovered from redirect&quot;, e);\n        return &quot;Site Moved&quot;;\n    }\n    finally\n    {\n        await logMethodExit();\n        client.Dispose();\n    }\n}\n</code></pre><p>The implementation details for adding <code>await</code> support inside <code>catch</code>\nand <code>finally</code> clauses ensures that the behavior is consistent with the\nbehavior for synchronous code. When code executed in a <code>catch</code> or <code>finally</code>\nclause throws, execution looks for a suitable <code>catch</code> clause in the next\nsurrounding block. If there was a current exception, that exception is\nlost. The same happens with awaited expressions in <code>catch</code> and <code>finally</code>\nclauses: a suitable <code>catch</code> is searched for, and the current exception,\nif any, is lost.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p>This behavior is the reason it&#39;s recommended to write <code>catch</code> and <code>finally</code>\nclauses carefully, to avoid introducing new exceptions.</p>\n</div>\n<h2 id=\"index-initializers\">Index Initializers</h2>\n<p><em>Index Initializers</em> is one of two features that make collection\ninitializers more consistent. In earlier releases of C#, you could use\n<em>collection initializers</em> only with sequence style collections:</p>\n<pre><code class=\"lang-csharp\" name=\"ListInitializer\">private List&lt;string&gt; messages = new List&lt;string&gt; \n{\n    &quot;Page not Found&quot;,\n    &quot;Page moved, but left a forwarding address.&quot;,\n    &quot;The web server can&#39;t come out to play today.&quot;\n};\n</code></pre><p>Now, you can also use them with @System.Collections.Generic.Dictionary collections and similar types:</p>\n<pre><code class=\"lang-csharp\" name=\"DictionaryInitializer\">private Dictionary&lt;int, string&gt; webErrors = new Dictionary&lt;int, string&gt;\n{\n    [404] = &quot;Page not Found&quot;,\n    [302] = &quot;Page moved, but left a forwarding address.&quot;,\n    [500] = &quot;The web server can&#39;t come out to play today.&quot;\n};\n</code></pre><p>This feature means that associative containers can be initialized using\nsyntax similar to what&#39;s been in place for sequence containers for several\nversions.</p>\n<h3 id=\"extension-add-methods-in-collection-initializers\">Extension <code>Add</code> methods in collection initializers</h3>\n<p>Another feature that makes collection initialization easier is the ability\nto use an <em>extension method</em> for the <code>Add</code> method. This feature was\nadded for parity with Visual Basic. </p>\n<p>The feature is most useful when you have a custom collection class that\nhas a method with a different name to semantically add new items.</p>\n<p>For example, consider a collection of students like this:</p>\n<pre><code class=\"lang-csharp\" name=\"Enrollment\">public class Enrollment : IEnumerable&lt;Student&gt;\n{\n    private List&lt;Student&gt; allStudents = new List&lt;Student&gt;();\n\n    public void Enroll(Student s)\n    {\n        allStudents.Add(s);\n    }\n\n    public IEnumerator&lt;Student&gt; GetEnumerator()\n    {\n        return ((IEnumerable&lt;Student&gt;)allStudents).GetEnumerator();\n    }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    {\n        return ((IEnumerable&lt;Student&gt;)allStudents).GetEnumerator();\n    }\n}\n</code></pre><p>The <code>Enroll</code> method adds a student. But it doesn&#39;t follow the <code>Add</code> pattern.\nIn previous versions of C#, you could not use collection initializers with an\n<code>Enrollment</code> object:</p>\n<pre><code class=\"lang-csharp\" name=\"InitializeEnrollment\">var classList = new Enrollment()\n{\n    new Student(&quot;Lessie&quot;, &quot;Crosby&quot;),\n    new Student(&quot;Vicki&quot;, &quot;Petty&quot;),\n    new Student(&quot;Ofelia&quot;, &quot;Hobbs&quot;),\n    new Student(&quot;Leah&quot;, &quot;Kinney&quot;),\n    new Student(&quot;Alton&quot;, &quot;Stoker&quot;),\n    new Student(&quot;Luella&quot;, &quot;Ferrell&quot;),\n    new Student(&quot;Marcy&quot;, &quot;Riggs&quot;),\n    new Student(&quot;Ida&quot;, &quot;Bean&quot;),\n    new Student(&quot;Ollie&quot;, &quot;Cottle&quot;),\n    new Student(&quot;Tommy&quot;, &quot;Broadnax&quot;),\n    new Student(&quot;Jody&quot;, &quot;Yates&quot;),\n    new Student(&quot;Marguerite&quot;, &quot;Dawson&quot;),\n    new Student(&quot;Francisca&quot;, &quot;Barnett&quot;),\n    new Student(&quot;Arlene&quot;, &quot;Velasquez&quot;),\n    new Student(&quot;Jodi&quot;, &quot;Green&quot;),\n    new Student(&quot;Fran&quot;, &quot;Mosley&quot;),\n    new Student(&quot;Taylor&quot;, &quot;Nesmith&quot;),\n    new Student(&quot;Ernesto&quot;, &quot;Greathouse&quot;),\n    new Student(&quot;Margret&quot;, &quot;Albert&quot;),\n    new Student(&quot;Pansy&quot;, &quot;House&quot;),\n    new Student(&quot;Sharon&quot;, &quot;Byrd&quot;),\n    new Student(&quot;Keith&quot;, &quot;Roldan&quot;),\n    new Student(&quot;Martha&quot;, &quot;Miranda&quot;),\n    new Student(&quot;Kari&quot;, &quot;Campos&quot;),\n    new Student(&quot;Muriel&quot;, &quot;Middleton&quot;),\n    new Student(&quot;Georgette&quot;, &quot;Jarvis&quot;),\n    new Student(&quot;Pam&quot;, &quot;Boyle&quot;),\n    new Student(&quot;Deena&quot;, &quot;Travis&quot;),\n    new Student(&quot;Cary&quot;, &quot;Totten&quot;),\n    new Student(&quot;Althea&quot;, &quot;Goodwin&quot;)\n};\n</code></pre><p>Now you can, but only if you create an extension method that maps <code>Add</code> to\n<code>Enroll</code>:</p>\n<pre><code class=\"lang-csharp\" name=\"ExtensionAdd\">public static class StudentExtensions\n{\n    public static void Add(this Enrollment e, Student s) =&gt; e.Enroll(s);\n}\n</code></pre><p>What you are doing with this feature is to map whatever method adds\nitems to a collection to a method named <code>Add</code> by creating an\nextension method: </p>\n<pre><code class=\"lang-csharp\" name=\"Enrollment\">public class Enrollment : IEnumerable&lt;Student&gt;\n{\n    private List&lt;Student&gt; allStudents = new List&lt;Student&gt;();\n\n    public void Enroll(Student s)\n    {\n        allStudents.Add(s);\n    }\n\n    public IEnumerator&lt;Student&gt; GetEnumerator()\n    {\n        return ((IEnumerable&lt;Student&gt;)allStudents).GetEnumerator();\n    }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    {\n        return ((IEnumerable&lt;Student&gt;)allStudents).GetEnumerator();\n    }\n}\n</code></pre><pre><code class=\"lang-csharp\" name=\"ExtensionAddSample\">public class ClassList\n{\n    public Enrollment CreateEnrollment()\n    {\n        var classList = new Enrollment()\n        {\n            new Student(&quot;Lessie&quot;, &quot;Crosby&quot;),\n            new Student(&quot;Vicki&quot;, &quot;Petty&quot;),\n            new Student(&quot;Ofelia&quot;, &quot;Hobbs&quot;),\n            new Student(&quot;Leah&quot;, &quot;Kinney&quot;),\n            new Student(&quot;Alton&quot;, &quot;Stoker&quot;),\n            new Student(&quot;Luella&quot;, &quot;Ferrell&quot;),\n            new Student(&quot;Marcy&quot;, &quot;Riggs&quot;),\n            new Student(&quot;Ida&quot;, &quot;Bean&quot;),\n            new Student(&quot;Ollie&quot;, &quot;Cottle&quot;),\n            new Student(&quot;Tommy&quot;, &quot;Broadnax&quot;),\n            new Student(&quot;Jody&quot;, &quot;Yates&quot;),\n            new Student(&quot;Marguerite&quot;, &quot;Dawson&quot;),\n            new Student(&quot;Francisca&quot;, &quot;Barnett&quot;),\n            new Student(&quot;Arlene&quot;, &quot;Velasquez&quot;),\n            new Student(&quot;Jodi&quot;, &quot;Green&quot;),\n            new Student(&quot;Fran&quot;, &quot;Mosley&quot;),\n            new Student(&quot;Taylor&quot;, &quot;Nesmith&quot;),\n            new Student(&quot;Ernesto&quot;, &quot;Greathouse&quot;),\n            new Student(&quot;Margret&quot;, &quot;Albert&quot;),\n            new Student(&quot;Pansy&quot;, &quot;House&quot;),\n            new Student(&quot;Sharon&quot;, &quot;Byrd&quot;),\n            new Student(&quot;Keith&quot;, &quot;Roldan&quot;),\n            new Student(&quot;Martha&quot;, &quot;Miranda&quot;),\n            new Student(&quot;Kari&quot;, &quot;Campos&quot;),\n            new Student(&quot;Muriel&quot;, &quot;Middleton&quot;),\n            new Student(&quot;Georgette&quot;, &quot;Jarvis&quot;),\n            new Student(&quot;Pam&quot;, &quot;Boyle&quot;),\n            new Student(&quot;Deena&quot;, &quot;Travis&quot;),\n            new Student(&quot;Cary&quot;, &quot;Totten&quot;),\n            new Student(&quot;Althea&quot;, &quot;Goodwin&quot;)\n        };\n        return classList;\n    }           \n}\n\npublic static class StudentExtensions\n{\n    public static void Add(this Enrollment e, Student s) =&gt; e.Enroll(s);\n}\n</code></pre><h2 id=\"improved-overload-resolution\">Improved overload resolution</h2>\n<p>This last feature is one you probably won&#39;t notice. There were constructs\nwhere the previous version of the C# compiler may have found some method\ncalls involving lambda expressions ambiguous. Consider this method:</p>\n<pre><code class=\"lang-csharp\" name=\"AsyncMethod\">static Task DoThings() \n{\n     return Task.FromResult(0); \n}\n</code></pre><p>In earlier versions of C#, calling that method using the method group\nsyntax would fail:</p>\n<pre><code class=\"lang-csharp\" name=\"MethodGroup\">Task.Run(DoThings); \n</code></pre><p>The earlier compiler could not distinguish correctly between <code>Task.Run(Action)</code>\nand <code>Task.Run(Func&lt;Task&gt;())</code>. In previous versions, you&#39;d need to use\na lambda expression as an argument:</p>\n<pre><code class=\"lang-csharp\" name=\"Lambda\">Task.Run(() =&gt; DoThings());\n</code></pre><p>The C# 6 compiler correctly determines that <code>Task.Run(Func&lt;Task&gt;())</code> is\na better choice.</p>\n</div></div>","outputRootRelativePath":"../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"4d879f69-f889-4d3f-a781-75194e143400\">\r\n<meta name=\"description\" content=\"Learn the new features in C# Version 6\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"09/22/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/202bcba28d56df8b40d8f4a9ef7fb795c9542686/docs/csharp/csharp-6.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/csharp-6.md\">\r\n<meta name=\"document_id\" content=\"00fe8736-935a-2998-abe2-ff09805d8e68\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"What's New in C# 6 | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"4d879f69-f889-4d3f-a781-75194e143400","description":"Learn the new features in C# Version 6","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"09/22/2016","ms.technology":"devlang-csharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"That Blair Guy","author_email":"thatblairguy@users.noreply.github.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Match case of the sample property name.","commit_sha":"202bcba28d56df8b40d8f4a9ef7fb795c9542686","commit_date":"2017-02-22 10:31:35 -0500"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"expression-bodied should be hyphenated (#1384)","commit_sha":"7ac95fa4b2aac81b2e8d33cedf2faf36a0bbf210","commit_date":"2017-01-05 10:03:42 -0500"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"updates suggested during the docs bug bash (#1380)","commit_sha":"32194f2f1a4b38209180da10a712ff0f51b0b709","commit_date":"2017-01-04 11:03:18 -0500"},{"author_name":"Alaa Masoud","author_email":"alaa.masoud@live.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"Add missing parenthesis (#1344)","commit_sha":"c3d674c7ad1c455999df433fe95bcd336691f559","commit_date":"2016-12-20 15:52:08 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Whats new in csharp 6 (#1068)","commit_sha":"7b847301575aef12e5245f4f405324460bec7aa9","commit_date":"2016-09-23 14:55:56 -0400"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update C# Guide section. (#782)","commit_sha":"fcf7f3ea67de6ebe6bfb8472ad786c471ac45e2e","commit_date":"2016-08-30 19:20:46 -0400"},{"author_name":"Tom Dykstra","author_email":"tdykstra@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"create c# 6 what's new stub (#672)","commit_sha":"86c73a35dacee26719361b2d098c5d43e38c7aed","commit_date":"2016-06-27 18:15:50 -0400"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/thatblairguy","display_name":"That Blair Guy","id":"8117943"},{"profile_url":"https://github.com/alaatm","display_name":"Alaa Masoud","id":"2095803"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/tdykstra","display_name":"Tom Dykstra","id":"1569635"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/202bcba28d56df8b40d8f4a9ef7fb795c9542686/docs/csharp/csharp-6.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/csharp-6.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/csharp-6.md","document_id":"00fe8736-935a-2998-abe2-ff09805d8e68","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/csharp-6","toc_asset_id":"articles/toc.json","toc_rel":"../toc.json","_op_ogTitle":"What's New in C# 6","_op_displayDate":"2016-9-22","_op_displayDate_source":"2016-09-22T00:00:00Z","_op_wordCount":4287,"_op_rawTitle":"<h1 id=\"whats-new-in-c-6\" sourcefile=\"docs/csharp/csharp-6.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">What&#39;s New in C# 6</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/csharp-6","fileRelativePath":"articles/csharp/csharp-6.html"},"themesRelativePathToOutputRoot":"_themes/"}