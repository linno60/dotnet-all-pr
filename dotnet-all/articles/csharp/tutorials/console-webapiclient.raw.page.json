{"content":"<div><div class=\"content\">\n<h2 id=\"introduction\">Introduction</h2>\n<p>This tutorial teaches you a number of features in .NET Core and the C# language. You’ll learn:</p>\n<ul>\n<li>The basics of the .NET Core Command Line Interface (CLI).</li>\n<li>An overview of C# Language features.</li>\n<li>Managing dependencies with NuGet</li>\n<li>HTTP Communications</li>\n<li>Processing JSON information</li>\n<li>Managing configuration with Attributes. </li>\n</ul>\n<p>You’ll build an application that issues HTTP Requests to a REST\nservice on GitHub. You&#39;ll read information in JSON format, and convert\nthat JSON packet into C# objects. Finally, you&#39;ll see how to work with\nC# objects.</p>\n<p>There are a lot of features in this tutorial. Let’s build them one by one. </p>\n<h2 id=\"prerequisites\">Prerequisites</h2>\n<p>You’ll need to set up your machine to run .NET core. You can find the\ninstallation instructions on the <a href=\"https://www.microsoft.com/net/core\" data-linktype=\"external\">.NET Core</a>\npage. You can run this\napplication on Windows, Linux, macOS or in a Docker container. \nYou’ll need to install your favorite code editor. The descriptions below\nuse <a href=\"https://code.visualstudio.com/\" data-linktype=\"external\">Visual Studio Code</a>, which is an open\nsource, cross platform editor. However, you can use whatever tools you are\ncomfortable with.</p>\n<h2 id=\"create-the-application\">Create the Application</h2>\n<p>The first step is to create a new application. Open a command prompt and\ncreate a new directory for your application. Make that the current\ndirectory. Type the command <code>dotnet new console</code> at the command prompt. This\ncreates the starter files for a basic “Hello World” application.</p>\n<p>Before you start making modifications, let’s go through the steps to run\nthe simple Hello World application. After creating the application, type\n<code>dotnet restore</code> at the command prompt. This command runs the NuGet\npackage restore process. NuGet is a .NET package manager. This command\ndownloads any of the missing dependencies for your project. As this is a\nnew project, none of the dependencies are in place, so the first run will\ndownload the .NET Core framework. After this initial step, you will only\nneed to run <code>dotnet restore</code> when you add new dependent packages, or update\nthe versions of any of your dependencies.  </p>\n<p>After restoring packages, you run <code>dotnet build</code>. This executes the build\nengine and creates your application. Finally, you execute <code>dotnet run</code> to\nrun your application.</p>\n<h2 id=\"adding-new-dependencies\">Adding New Dependencies</h2>\n<p>One of the key design goals for .NET Core is to minimize the size of\nthe .NET framework installation. The .NET Core Application framework contains\nonly the most common elements of the .NET full framework. If an application\nneeds additional libraries for some of its features, you add those\ndependencies into your C# project (*.csproj) file. For our example, you&#39;ll need to add the <code>System.Runtime.Serialization.Json</code> package\nso your application can process JSON responses.</p>\n<p>Open your <code>csproj</code> project file. The first line of the file should appear as:</p>\n<pre class=\"loading\"><code class=\"lang-xml\">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;\n</code></pre><p>Add the following immediately after this line: </p>\n<pre class=\"loading\"><code class=\"lang-xml\">   &lt;ItemGroup&gt;\n      &lt;PackageReference Include=&quot;System.Runtime.Serialization.Json&quot; Version=&quot;4.3.0&quot; /&gt;\n   &lt;/ItemGroup&gt; \n</code></pre><p>Most code editors will provide completion for different versions of these\nlibraries. You&#39;ll usually want to use the latest version of any package\nthat you add. However, it is important to make sure that the versions\nof all packages match, and that they also match the version of the .NET\nCore Application framework.</p>\n<p>After you&#39;ve made these changes, you should run <code>dotnet restore</code> again so\nthat the package is installed on your system.</p>\n<h2 id=\"making-web-requests\">Making Web Requests</h2>\n<p>Now you&#39;re ready to start retrieving data from the web. In this\napplication, you&#39;ll read information from the \n<a href=\"https://developer.github.com/v3/\" data-linktype=\"external\">GitHub API</a>. Let&#39;s read information\nabout the projects under the\n<a href=\"http://www.dotnetfoundation.org/\" data-linktype=\"external\">.NET Foundation</a> umbrella. You&#39;ll\nstart by making the request to the GitHub API to retrieve information\non the projects. The endpoint you&#39;ll use is: <a href=\"https://api.github.com/orgs/dotnet/repos\" data-linktype=\"external\">https://api.github.com/orgs/dotnet/repos</a>. You want to retrieve all the\ninformation about these projects, so you&#39;ll use an HTTP GET request.\nYour browser also uses HTTP GET requests, so you can paste that URL into\nyour browser to see what information you&#39;ll be receiving and processing.</p>\n<p>You use the <a class=\"xref\" href=\"../../../api/system.net.http.httpclient\" data-linktype=\"relative-path\">HttpClient</a> class to make web requests. Like all modern .NET\nAPIs, <a class=\"xref\" href=\"../../../api/system.net.http.httpclient\" data-linktype=\"relative-path\">HttpClient</a> supports only async methods for its long-running APIs.\nStart by making an async method. You&#39;ll fill in the implementation as you\nbuild the functionality of the application. Start by opening the <code>program.cs</code> file in your project directory and adding the following method to the <code>Program</code> class:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">private static async Task ProcessRepositories()\n{\n\n}\n</code></pre><p>You&#39;ll need to add a <code>using</code> statement at the top of your <code>Main</code> method so\nthat the C# compiler recognizes the <a class=\"xref\" href=\"../../../api/system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> type:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">using System.Threading.Tasks;\n</code></pre><p>If you build your project at this point, you&#39;ll get a warning generated\nfor this method, because it does not contain any <code>await</code> operators and\nwill run synchronously. Ignore that for now; you&#39;ll add <code>await</code> operators\nas you fill in the method.</p>\n<p>Next, rename the namespace defined in the <code>namespace</code> statement from its default of <code>ConsoleApp</code> to <code>WebAPIClient</code>. We&#39;ll later define a <code>repo</code> class in this namespace.</p>\n<p>Next, update the <code>Main</code> method to call this method. The\n<code>ProcessRepositories</code> method returns a Task, and you shouldn&#39;t exit the\nprogram before that task finishes. Therefore, you must use the <code>Wait</code>\nmethod to block and wait for the task to finish:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public static void Main(string[] args)\n{\n    ProcessRepositories().Wait();\n}\n</code></pre><p>Now, you have a program that does nothing, but does it asynchronously. Let&#39;s go back to the\n<code>ProcessRepositories</code> method and fill in a first version of it:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">private static async Task ProcessRepositories()\n{\n    var client = new HttpClient();\n    client.DefaultRequestHeaders.Accept.Clear();\n    client.DefaultRequestHeaders.Accept.Add(\n        new MediaTypeWithQualityHeaderValue(&quot;application/vnd.github.v3+json&quot;));\n    client.DefaultRequestHeaders.Add(&quot;User-Agent&quot;, &quot;.NET Foundation Repository Reporter&quot;);\n\n    var stringTask = client.GetStringAsync(&quot;https://api.github.com/orgs/dotnet/repos&quot;);\n\n    var msg = await stringTask;\n    Console.Write(msg);\n}\n</code></pre><p>You&#39;ll need to also add two new using statements at the top of the file for this to compile:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">using System.Net.Http;\nusing System.Net.Http.Headers;\n</code></pre><p>This first version makes a web request to read the list of all repositories under the dotnet\nfoundation organization. (The gitHub ID for the .NET Foundation is &#39;dotnet&#39;). First, you create\na new <a class=\"xref\" href=\"../../../api/system.net.http.httpclient\" data-linktype=\"relative-path\">HttpClient</a>. This object handles the request and the responses. The next few lines set up\nthe <a class=\"xref\" href=\"../../../api/system.net.http.httpclient\" data-linktype=\"relative-path\">HttpClient</a> for this request. First, it is configured to accept the GitHub JSON responses.\nThis format is simply JSON. The next line adds a User Agent header to all requests from this\nobject. These two headers are checked by the GitHub server code, and are necessary to retrieve\ninformation from GitHub.</p>\n<p>After you&#39;ve configured the <a class=\"xref\" href=\"../../../api/system.net.http.httpclient\" data-linktype=\"relative-path\">HttpClient</a>, you make a web request and retrieve the response. In\nthis first version, you use the <a class=\"xref\" href=\"../../../api/system.net.http.httpclient#System_Net_Http_HttpClient_GetStringAsync_System_String_\" data-linktype=\"relative-path\">GetStringAsync(String)</a> convenience method. This convenience method\nstarts a task that makes the web request, and then when the request returns, it reads the\nresponse stream and extracts the content from the stream. The body of the response is returned\nas a <a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String</a>. The string is available when the task completes. </p>\n<p>The final two lines of this method await that task, and then print the response to the console.\nBuild the app, and run it. The build warning is gone now, because the <code>ProcessRepositories</code> now\ndoes contain an <code>await</code> operator. You&#39;ll see a long display of JSON formatted text.   </p>\n<h2 id=\"processing-the-json-result\">Processing the JSON Result</h2>\n<p>At this point, you&#39;ve written the code to retrieve a response from a web server, and display\nthe text that is contained in that response. Next, let&#39;s convert that JSON response into C#\nobjects.</p>\n<p>The JSON Serializer converts JSON data into C# Objects. Your first task is to define a C# class\ntype to contain the information you use from this response. Let&#39;s build this slowly, so start with\na simple C# type that contains the name of the repository:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">using System;\n\nnamespace WebAPIClient\n{\n    public class repo\n    {\n        public string name;\n    }\n}\n</code></pre><p>Put the above code in a new file called &#39;repo.cs&#39;. This version of the class represents the\nsimplest path to process JSON data. The class name and the member name match the names used\nin the JSON packet, instead of following C# conventions. You&#39;ll fix that by providing some\nconfiguration attributes later. This class demonstrates another important feature of JSON\nserialization and deserialization: Not all the fields in the JSON packet are part of this class.\nThe JSON serializer will ignore information that is not included in the class type being used.\nThis feature makes it easier to create types that work with only a subset of the fields in\nthe JSON packet.</p>\n<p>Now that you&#39;ve created the type, let&#39;s deserialize it. You&#39;ll need to create a\n<a class=\"xref\" href=\"../../../api/system.runtime.serialization.json.datacontractjsonserializer\" data-linktype=\"relative-path\">DataContractJsonSerializer</a> object. This object must know the CLR type expected for the\nJSON packet it retrieves. The packet from GitHub contains a sequence of repositories, so a\n<code>List&lt;repo&gt;</code> is the correct type. Add the following line to your <code>ProcessRepositories</code> method:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var serializer = new DataContractJsonSerializer(typeof(List&lt;repo&gt;));\n</code></pre><p>You&#39;re using two new namespaces, so you&#39;ll need to add those as well:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">using System.Collections.Generic;\nusing System.Runtime.Serialization.Json;\n</code></pre><p>Next, you&#39;ll use the serializer to convert JSON into C# objects. Replace the call to\n<a class=\"xref\" href=\"../../../api/system.net.http.httpclient#System_Net_Http_HttpClient_GetStringAsync_System_String_\" data-linktype=\"relative-path\">GetStringAsync(String)</a> in your <code>ProcessRepositories</code> method with the following two lines:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var streamTask = client.GetStreamAsync(&quot;https://api.github.com/orgs/dotnet/repos&quot;);\nvar repositories = serializer.ReadObject(await streamTask) as List&lt;repo&gt;;\n</code></pre><p>Notice that you&#39;re now using <a class=\"xref\" href=\"../../../api/system.net.http.httpclient#System_Net_Http_HttpClient_GetStreamAsync_System_String_\" data-linktype=\"relative-path\">GetStreamAsync(String)</a> instead of <a class=\"xref\" href=\"../../../api/system.net.http.httpclient#System_Net_Http_HttpClient_GetStringAsync_System_String_\" data-linktype=\"relative-path\">GetStringAsync(String)</a>. The serializer\nuses a stream instead of a string as its source. Let&#39;s explain a couple features of the C#\nlanguage that are being used in the second line above. The argument to <a class=\"xref\" href=\"../../../api/system.runtime.serialization.json.datacontractjsonserializer#System_Runtime_Serialization_Json_DataContractJsonSerializer_ReadObject_System_IO_Stream_\" data-linktype=\"relative-path\">ReadObject(Stream)</a> is an\n<code>await</code> expression. Await expressions can appear almost anywhere in your code, even though\nup to now, you&#39;ve only seen them as part of an assignment statement.</p>\n<p>Secondly, the <code>as</code> operator converts from the compile time type of <code>object</code> to <code>List&lt;repo&gt;</code>. \nThe declaration of <a class=\"xref\" href=\"../../../api/system.runtime.serialization.json.datacontractjsonserializer#System_Runtime_Serialization_Json_DataContractJsonSerializer_ReadObject_System_IO_Stream_\" data-linktype=\"relative-path\">ReadObject(Stream)</a> declares that it returns an object of type <a class=\"xref\" href=\"../../../api/system.object\" data-linktype=\"relative-path\">System.Object</a>. <a class=\"xref\" href=\"../../../api/system.runtime.serialization.json.datacontractjsonserializer#System_Runtime_Serialization_Json_DataContractJsonSerializer_ReadObject_System_IO_Stream_\" data-linktype=\"relative-path\">ReadObject(Stream)</a> will return the type you specified when you constructed it (<code>List&lt;repo&gt;</code> in\nthis tutorial). If the conversion does not succeed, the <code>as</code> operator evaluates to <code>null</code>,\ninstead of throwing an exception.</p>\n<p>You&#39;re almost done with this section. Now that you&#39;ve converted the JSON to C# objects, let&#39;s display\nthe name of each repository. Replace the lines that read:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var msg = await stringTask;   //**Deleted this\nConsole.Write(msg);\n</code></pre><p>with the following:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">foreach (var repo in repositories)\n    Console.WriteLine(repo.name);\n</code></pre><p>Compile and run the application. It will print out the names of the repositories that are part of the\n.NET Foundation.</p>\n<h2 id=\"controlling-serialization\">Controlling Serialization</h2>\n<p>Before you add more features, let&#39;s address the <code>repo</code> type and make it follow more standard\nC# conventions. You&#39;ll do this by annotating the <code>repo</code> type with <em>attributes</em> that control how\nthe JSON Serializer works. In your case, you&#39;ll use these attributes to define a mapping between\nthe JSON key names and the C# class and member names. The two attributes used are the <code>DataContract</code>\nattribute and the <code>DataMember</code> attribute. By convention, all Attribute classes end in the suffix\n<code>Attribute</code>. However, you do not need to use that suffix when you apply an attribute. </p>\n<p>The <code>DataContract</code> and <code>DataMember</code> attributes are in a different library, so you&#39;ll need to add\nthat library to your C# project file as a dependency. Add the following line to the <code>&lt;ItemGroup&gt;</code> section of your project file:</p>\n<pre class=\"loading\"><code class=\"lang-xml\">&lt;PackageReference Include=&quot;System.Runtime.Serialization.Primitives&quot; Version=&quot;4.3.0&quot; /&gt;\n</code></pre><p>After you save the file, run <code>dotnet restore</code> to retrieve this package.</p>\n<p>Next, open the <code>repo.cs</code> file. Let&#39;s change the name to use Pascal Case, and fully spell out the name\n<code>Repository</code>. We still want to map JSON &#39;repo&#39; nodes to this type, so you&#39;ll need to add the \n<code>DataContract</code> attribute to the class declaration. You&#39;ll set the <code>Name</code> property of the attribute\nto the name of the JSON nodes that map to this type:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">[DataContract(Name=&quot;repo&quot;)]\npublic class Repository\n</code></pre><p>The <a class=\"xref\" href=\"../../../api/system.runtime.serialization.datacontractattribute\" data-linktype=\"relative-path\">DataContractAttribute</a> is a member of the <a class=\"xref\" href=\"../../../api/system.runtime.serialization\" data-linktype=\"relative-path\">System.Runtime.Serialization</a> namespace, so you&#39;ll\nneed to add the appropriate <code>using</code> statement at the top of the file:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">using System.Runtime.Serialization;\n</code></pre><p>You changed the name of the <code>repo</code> class to <code>Repository</code>, so you&#39;ll need to make the same name change\nin Program.cs (some editors may support a rename refactoring that will make this change automatically:)</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var serializer = new DataContractJsonSerializer(typeof(List&lt;Repository&gt;));\n\n// ...\n\nvar repositories = serializer.ReadObject(await streamTask) as List&lt;Repository&gt;;\n</code></pre><p>Next, let&#39;s make the same change with the <code>name</code> field by using the <a class=\"xref\" href=\"../../../api/system.runtime.serialization.datamemberattribute\" data-linktype=\"relative-path\">DataMemberAttribute</a> class. Make\nthe following changes to the declaration of the <code>name</code> field in repo.cs:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">[DataMember(Name=&quot;name&quot;)]\npublic string Name;\n</code></pre><p>This change means you need to change the code that writes the name of each repository in program.cs:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">Console.WriteLine(repo.Name);\n</code></pre><p>Do a <code>dotnet build</code> followed by a <code>dotnet run</code> to make sure you&#39;ve got the mappings correct. You should\nsee the same output as before. Before we process more properties from the web server, let&#39;s make one\nmore change to the <code>Repository</code> class. The <code>Name</code> member is a publicly accessible field. That&#39;s not\na good object-oriented practice, so let&#39;s change it to a property. For our purposes, we don&#39;t need\nany specific code to run when getting or setting the property, but changing to a property makes it\neasier to add those changes later without breaking any code that uses the <code>Repository</code> class.</p>\n<p>Remove the field definition, and replace it with an <a href=\"../programming-guide/classes-and-structs/auto-implemented-properties\" data-linktype=\"relative-path\">auto-implemented property</a>:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public string Name { get; set; }\n</code></pre><p>The compiler generates the body of the <code>get</code> and <code>set</code> accessors, as well as a private field to\nstore the name. It would be similar to the following code that you could type by hand:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public string Name \n{ \n    get { return this._name; }\n    set { this._name = value; }\n}\nprivate string _name;\n</code></pre><p>Let&#39;s make one more change before adding new features. The <code>ProcessRepositories</code> method can do the async\nwork and return a collection of the repositories. Let&#39;s return the <code>List&lt;Repository&gt;</code> from that method,\nand move the code that writes the information into the <code>Main</code> method.</p>\n<p>Change the signature of <code>ProcessRepositories</code> to return a task whose result is a list of <code>Repository</code>\nobjects:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">private static async Task&lt;List&lt;Repository&gt;&gt; ProcessRepositories()\n</code></pre><p>Then, just return the repositories after processing the JSON response:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var repositories = serializer.ReadObject(await streamTask) as List&lt;Repository&gt;;\nreturn repositories;\n</code></pre><p>The compiler generates the <code>Task&lt;T&gt;</code> object for the return because you&#39;ve marked this method as <code>async</code>.\nThen, let&#39;s modify the <code>Main</code> method so that it captures those results and writes each repository name\nto the console. Your <code>Main</code> method now looks like this:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public static void Main(string[] args)\n{\n    var repositories = ProcessRepositories().Result;\n\n    foreach (var repo in repositories)\n        Console.WriteLine(repo.Name);\n}\n</code></pre><p>Accessing the <code>Result</code> property of a Task blocks until the task has completed. Normally, you would prefer\nto <code>await</code> the completion of the task, as in the <code>ProcessRepositories</code> method, but that isn&#39;t allowed in the\n<code>Main</code> method.</p>\n<h2 id=\"reading-more-information\">Reading More Information</h2>\n<p>Let&#39;s finish this by processing a few more of the properties in the JSON packet that gets sent from the\nGitHub API. You won&#39;t want to grab everything, but adding a few properties will demonstrate a few more\nfeatures of the C# language.</p>\n<p>Let&#39;s start by adding a few more simple types to the <code>Repository</code> class definition. Add these properties\nto that class:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">[DataMember(Name=&quot;description&quot;)]\npublic string Description { get; set; }\n\n[DataMember(Name=&quot;html_url&quot;)]\npublic Uri GitHubHomeUrl { get; set; }\n\n[DataMember(Name=&quot;homepage&quot;)]\npublic Uri Homepage { get; set; }\n\n[DataMember(Name=&quot;watchers&quot;)]\npublic int Watchers { get; set; }\n</code></pre><p>These properties have built-in conversions from the string type (which is what the JSON packets contain) to\nthe target type. The <a class=\"xref\" href=\"../../../api/system.uri\" data-linktype=\"relative-path\">Uri</a> type may be new to you. It represents a URI, or in this case, a URL. In the case\nof the <code>Uri</code> and <code>int</code> types, if the JSON packet contains data that does not convert to the target type,\nthe serialization action will throw an exception.</p>\n<p>Once you&#39;ve added these, update the <code>Main</code> method to display those elements:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">foreach (var repo in repositories)\n{\n    Console.WriteLine(repo.Name);\n    Console.WriteLine(repo.Description);\n    Console.WriteLine(repo.GitHubHomeUrl);\n    Console.WriteLine(repo.Homepage);\n    Console.WriteLine(repo.Watchers);\n    Console.WriteLine();\n}\n</code></pre><p>As a final step, let&#39;s add the information for the last push operation. This information is formatted in\nthis fashion in the JSON response:</p>\n<pre class=\"loading\"><code class=\"lang-json\">2016-02-08T21:27:00Z\n</code></pre><p>That format does not follow any of the standard .NET <a class=\"xref\" href=\"../../../api/system.datetime\" data-linktype=\"relative-path\">DateTime</a> formats. Because of that, you&#39;ll need to write\na custom conversion method. You also probably don&#39;t want the raw string exposed to users of the <code>Repository</code>\nclass. Attributes can help control that as well. First, define a <code>private</code> property that will hold the\nstring representation of the date time in your <code>Repository</code> class:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">[DataMember(Name=&quot;pushed_at&quot;)]\nprivate string JsonDate { get; set; }\n</code></pre><p>The <code>DataMember</code> attribute informs the serializer that this should be processed, even though it is not\na public member. Next, you need to write a public read-only property that converts the string to a\nvalid <a class=\"xref\" href=\"../../../api/system.datetime\" data-linktype=\"relative-path\">DateTime</a> object, and returns that <a class=\"xref\" href=\"../../../api/system.datetime\" data-linktype=\"relative-path\">DateTime</a>:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">[IgnoreDataMember]\npublic DateTime LastPush\n{\n    get\n    {\n        return DateTime.ParseExact(JsonDate, &quot;yyyy-MM-ddTHH:mm:ssZ&quot;, CultureInfo.InvariantCulture);\n    }\n}\n</code></pre><p>Let&#39;s go over the new constructs above. The <code>IgnoreDataMember</code> attribute instructs the serializer\nthat this type should not be read to or written from any JSON object. This property contains only a\n<code>get</code> accessor. There is no <code>set</code> accessor. That&#39;s how you define a <em>read-only</em> property in C#. (Yes,\nyou can create <em>write-only</em> properties in C#, but their value is limited.) The <a class=\"xref\" href=\"../../../api/system.datetime#System_DateTime_ParseExact_System_String_System_String_System_IFormatProvider_\" data-linktype=\"relative-path\">ParseExact(String,String,IFormatProvider)</a>\nmethod parses a string and creates a <a class=\"xref\" href=\"../../../api/system.datetime\" data-linktype=\"relative-path\">DateTime</a> object using a provided date format, and adds additional \nmetadata to the <code>DateTime</code> using a <code>CultureInfo</code> object. If the parse operation fails, the\nproperty accessor throws an exception.</p>\n<p>To use <a class=\"xref\" href=\"../../../api/system.globalization.cultureinfo#System_Globalization_CultureInfo_InvariantCulture\" data-linktype=\"relative-path\">InvariantCulture</a>, you will need to add the <a class=\"xref\" href=\"../../../api/system.globalization\" data-linktype=\"relative-path\">System.Globalization</a> namespace to the <code>using</code> statements \nin <code>repo.cs</code>:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">using System.Globalization;\n</code></pre><p>Finally, add one more output statement in the console, and you&#39;re ready to build and run this app\nagain:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">Console.WriteLine(repo.LastPush);\n</code></pre><p>Your version should now match the finished version located\n<a href=\"https://github.com/dotnet/docs/tree/master/samples/csharp/getting-started/console-webapiclient\" data-linktype=\"external\">here</a>.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>This tutorial showed you how to make web requests, parse the result, and display properties of\nthose results. You&#39;ve also added new packages as dependencies in your project. You&#39;ve seen some of\nthe features of the C# language that support object-oriented techniques.</p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"51033ce2-7a53-4cdd-966d-9da15c8204d2\">\r\n<meta name=\"description\" content=\"This tutorial teaches you a number of features in .NET Core and the C# language.\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"03/06/2017\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net-core\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/1a27a36d2fe583e9f3732541eb90a19177a1c157/docs/csharp/tutorials/console-webapiclient.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/tutorials/console-webapiclient.md\">\r\n<meta name=\"document_id\" content=\"fe673707-4560-c4f7-695c-1d76580f40aa\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Creates a REST client using .NET Core | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"51033ce2-7a53-4cdd-966d-9da15c8204d2","description":"This tutorial teaches you a number of features in .NET Core and the C# language.","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"03/06/2017","ms.technology":"devlang-csharp","ms.prod":".net-core","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Robert C Jensen","author_email":"rob@computerlab.io","committer_name":"Robert C Jensen","comitter_email":"rob@computerlab.io","message":"fixes typo in code block","commit_sha":"1a27a36d2fe583e9f3732541eb90a19177a1c157","commit_date":"2017-03-08 00:35:44 -0500"},{"author_name":"Luke Latham","author_email":"GuardRex@users.noreply.github.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"dotnet new updates for MSBuild/csproj (#1649)","commit_sha":"abd4eadaede26fe144b5d8f249dd9b334e5a567f","commit_date":"2017-03-07 01:09:15 -0800"},{"author_name":"Ron Petrusha","author_email":"ronpet@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"Tutorials revised for *.csproj projects (#1488)","commit_sha":"8e7bde15f951a1f63e3c24937d2e4462ddd3c998","commit_date":"2017-02-04 15:12:57 -0500"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"updates suggested during the docs bug bash (#1380)","commit_sha":"32194f2f1a4b38209180da10a712ff0f51b0b709","commit_date":"2017-01-04 11:03:18 -0500"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Bhargav Nookala","author_email":"nooknb@gmail.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"Updating WebApiClient (#1304)","commit_sha":"0cd40cc5b839cc2b9dc39ba351e7f085ad641b81","commit_date":"2016-12-05 10:10:30 -0500"},{"author_name":"Tanguy Krotoff","author_email":"tkrotoff@gmail.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Small syntax fixes","commit_sha":"d5dc86d98292d7e705960fd66d7cef35ccc5b797","commit_date":"2016-11-23 14:39:32 +0100"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"renamed repo/fixed headings (#1186)","commit_sha":"15c55a87beb64f265a164db918c7721c7690fadf","commit_date":"2016-10-29 15:23:17 -0400"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update ci build for ubuntu (#891)","commit_sha":"ce52ada663c2ed9b8b3d10bc3d4dcb453abb79f7","commit_date":"2016-08-09 16:02:13 -0400"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update Samples section of contributing.md (#796)","commit_sha":"d82a5907ae4405358eccb9fd8b8dd68a3996fc74","commit_date":"2016-07-28 14:26:57 -0400"},{"author_name":"Tom Dykstra","author_email":"tdykstra@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"move tutorials folder to csharp folder (#704)","commit_sha":"9e4c8eafc7301549383306d9c679015a95f1406f","commit_date":"2016-06-29 12:23:39 -0700"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/r1b","display_name":"Robert Jensen","id":"5550520"},{"profile_url":"https://github.com/GuardRex","display_name":"Luke Latham","id":"1622880"},{"profile_url":"https://github.com/rpetrusha","display_name":"rpetrusha","id":"10886961"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/bnookala","display_name":"Bhargav Nookala","id":"87996"},{"profile_url":"https://github.com/tkrotoff","display_name":"Tanguy Krotoff","id":"643434"},{"profile_url":"https://github.com/tdykstra","display_name":"Tom Dykstra","id":"1569635"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/1a27a36d2fe583e9f3732541eb90a19177a1c157/docs/csharp/tutorials/console-webapiclient.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/tutorials/console-webapiclient.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/tutorials/console-webapiclient.md","document_id":"fe673707-4560-c4f7-695c-1d76580f40aa","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/tutorials/console-webapiclient","toc_asset_id":"articles/csharp/tutorials/toc.json","toc_rel":"toc.json","_op_ogTitle":"Creates a REST client using .NET Core","_op_displayDate":"2017-3-6","_op_displayDate_source":"2017-03-06T00:00:00Z","_op_wordCount":2852,"_op_rawTitle":"<h1 id=\"rest-client\" sourcefile=\"docs/csharp/tutorials/console-webapiclient.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">REST client</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/tutorials/console-webapiclient","fileRelativePath":"articles/csharp/tutorials/console-webapiclient.html"},"themesRelativePathToOutputRoot":"_themes/"}