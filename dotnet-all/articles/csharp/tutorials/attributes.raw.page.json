{"content":"<div><div class=\"content\">\n<p>Attributes provide a way of associating information with code in a declarative way. They can also provide a reusable element that can be applied to a variety of targets.</p>\n<p>Consider the <code>[Obsolete]</code> attribute. It can be applied to classes, structs, methods, constructors, and more. It <em>declares</em> that the element is obsolete. It&#39;s then up to the C#\ncompiler to look for this attribute, and do some action in response.</p>\n<p>In this tutorial, you&#39;ll be introduced to how to add attributes to your code, how to create and use your own attributes, and how to use some\nattributes that are built into .NET Core.</p>\n<h2 id=\"prerequisites\">Prerequisites</h2>\n<p>You’ll need to setup your machine to run .NET core. You can find the\ninstallation instructions on the <a href=\"https://www.microsoft.com/net/core\" data-linktype=\"external\">.NET Core</a>\npage.\nYou can run this application on Windows, Ubuntu Linux, macOS or in a Docker container. \nYou’ll need to install your favorite code editor. The descriptions below\nuse <a href=\"https://code.visualstudio.com/\" data-linktype=\"external\">Visual Studio Code</a> which is an open\nsource, cross platform editor. However, you can use whatever tools you are\ncomfortable with.</p>\n<h2 id=\"create-the-application\">Create the Application</h2>\n<p>Now that you&#39;ve installed all the tools, create a new .NET Core application. To use the command line generator, execute the following command in your favorite shell:</p>\n<p><code>dotnet new console</code></p>\n<p>This command will create barebones .NET core project files. You will need to execute <code>dotnet restore</code> to restore the dependencies needed to compile this project.</p>\n<p>To execute the program, use <code>dotnet run</code>. You should see &quot;Hello, World&quot; output to the console.</p>\n<h2 id=\"how-to-add-attributes-to-code\">How to add attributes to code</h2>\n<p>In C#, attributes are classes that inherit from the <code>Attribute</code> base class. Any class that inherits from <code>Attribute</code> can be used as a sort of &quot;tag&quot; on other pieces of code.\nFor instance, there is an attribute called <code>ObsoleteAttribute</code>. This is used to signal that code is obsolete and shouldn&#39;t be used anymore. You can place this attribute on a class,\nfor instance, by using square brackets.</p>\n<pre><code class=\"lang-csharp\" name=\"Obsolete attribute example\">[Obsolete]\npublic class MyClass\n{\n\n}\n</code></pre><p>Note that while the class is called <code>ObsoleteAttribute</code>, it&#39;s only necessary to use <code>[Obsolete]</code> in the code. This is a convention that C# follows.\nYou can use the full name <code>[ObsoleteAttribute]</code> if you choose.</p>\n<p>When marking a class obsolete, it&#39;s a good idea to provide some information as to <em>why</em> it&#39;s obsolete, and/or <em>what</em> to use instead. Do this by passing a string\nparameter to the Obsolete attribute.</p>\n<pre><code class=\"lang-csharp\" name=\"Obsolete attribute example with parameters\">[Obsolete(&quot;ThisClass is obsolete. Use ThisClass2 instead.&quot;)]\npublic class ThisClass\n{\n\n}\n</code></pre><p>The string is being passed as an argument to an <code>ObsoleteAttribute</code> constructor, just as if you were writing <code>var attr = new ObsoleteAttribute(&quot;some string&quot;)</code>.</p>\n<p>Parameters to an attribute constructor are limited to simple types/literals: <code>bool, int, double, string, Type, enums, etc</code> and arrays of those types.\nYou can not use an expression or a variable. You are free to use positional or named parameters.</p>\n<h2 id=\"how-to-create-your-own-attribute\">How to create your own attribute</h2>\n<p>Creating an attribute is as simple as inheriting from the <code>Attribute</code> base class.</p>\n<pre><code class=\"lang-csharp\" name=\"Create your own attribute\">public class MySpecialAttribute : Attribute\n{\n\n}\n</code></pre><p>With the above, I can now use <code>[MySpecial]</code> (or <code>[MySpecialAttribute]</code>) as an attribute elsewhere in the code base.</p>\n<pre><code class=\"lang-csharp\" name=\"Using your own attribute\">[MySpecial]\npublic class SomeOtherClass\n{\n\n}\n</code></pre><p>Attributes in the .NET base class library like <code>ObsoleteAttribute</code> trigger certain behaviors within the compiler. However, any attribute you create acts\nonly as metadata, and doesn&#39;t result in any code within the attribute class being executed. It&#39;s up to you to act\non that metadata elsewhere in your code (more on that later in the tutorial).</p>\n<p>There is a &#39;gotcha&#39; here to watch out for. As mentioned above, only certain types are allowed to be passed as arguments when using attributes. However, when creating an attribute type,\nthe C# compiler won&#39;t stop you from creating those parameters. In the below example, I&#39;ve created an attribute with a constructor that compiles just fine.</p>\n<pre><code class=\"lang-csharp\" name=\"Valid constructor used in an attribute\">public class GotchaAttribute : Attribute\n{\n    public GotchaAttribute(Foo myClass, string str) {\n        \n    }\n}\n</code></pre><p>However, you will be unable to use this constructor with attribute syntax.</p>\n<pre><code class=\"lang-csharp\" name=\"Invalid attempt to use the attribute constructor\">[Gotcha(new Foo(), &quot;test&quot;)] // does not compile\npublic class AttributeFail\n{\n\n}\n</code></pre><p>The above will cause a compiler error like <code>Attribute constructor parameter &#39;myClass&#39; has type &#39;Foo&#39;, which is not a valid attribute parameter type</code></p>\n<h2 id=\"how-to-restrict-attribute-usage\">How to restrict attribute usage</h2>\n<p>Attributes can be used on a number of &quot;targets&quot;. The above examples show them on classes, but they can also be used on:</p>\n<ul>\n<li>Assembly</li>\n<li>Class</li>\n<li>Constructor</li>\n<li>Delegate</li>\n<li>Enum</li>\n<li>Event</li>\n<li>Field</li>\n<li>GenericParameter</li>\n<li>Interface</li>\n<li>Method</li>\n<li>Module</li>\n<li>Parameter</li>\n<li>Property</li>\n<li>ReturnValue</li>\n<li>Struct</li>\n</ul>\n<p>When you create an attribute class, by default, C# will allow you to use that attribute on any of the possible attribute targets. If you want to restrict your attribute\nto certain targets, you can do so by using the <code>AttributeUsageAttribute</code> on your attribute class. That&#39;s right, an attribute on an attribute!</p>\n<pre><code class=\"lang-csharp\" name=\"Using your own attribute\">[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]\npublic class MyAttributeForClassAndStructOnly : Attribute\n{\n\n}\n</code></pre><p>If you attempt to put the above attribute on something that&#39;s not a class or a struct, you will get a compiler error\nlike <code>Attribute &#39;MyAttributeForClassAndStructOnly&#39; is not valid on this declaration type. It is only valid on &#39;class, struct&#39; declarations</code></p>\n<pre><code class=\"lang-csharp\" name=\"Using your own attribute\">public class Foo\n{\n    // if the below attribute was uncommented, it would cause a compiler error\n    // [MyAttributeForClassAndStructOnly]\n    public Foo() {\n\n    }\n}\n</code></pre><h2 id=\"how-to-use-attributes-attached-to-a-code-element\">How to use attributes attached to a code element</h2>\n<p>Attributes act as metadata. Without some outward force, they won&#39;t actually do anything.</p>\n<p>To find and act on attributes, <a href=\"../programming-guide/concepts/reflection\" data-linktype=\"relative-path\">Reflection</a> is generally needed. I won&#39;t cover Reflection in-depth in this tutorial, but the basic\nidea is that Reflection allows you to write code in C# that examines other code.</p>\n<p>For instance, you can use Reflection to get information about a class: </p>\n<pre><code class=\"lang-csharp\" name=\"Getting type information with Reflection\">TypeInfo typeInfo = typeof(MyClass).GetTypeInfo();\nConsole.WriteLine(&quot;The assembly qualified name of MyClass is &quot; + typeInfo.AssemblyQualifiedName);\n</code></pre><p>That will print out something like: <code>The assembly qualified name of MyClass is ConsoleApplication.MyClass, attributes, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null</code></p>\n<p>Once you have a <code>TypeInfo</code> object (or a <code>MemberInfo</code>, <code>FieldInfo</code>, etc), you can use the <code>GetCustomAttributes</code> method. This will return a collection of <code>Attribute</code> objects.\nYou can also use <code>GetCustomAttribute</code> and specify an Attribute type.</p>\n<p>Here&#39;s an example of using <code>GetCustomAttributes</code> on a <code>MemberInfo</code> instance for <code>MyClass</code> (which we saw earlier has an <code>[Obsolete]</code> attribute on it).</p>\n<pre><code class=\"lang-csharp\" name=\"Getting type information with Reflection\">var attrs = typeInfo.GetCustomAttributes();\nforeach(var attr in attrs)\n    Console.WriteLine(&quot;Attribute on MyClass: &quot; + attr.GetType().Name);\n</code></pre><p>That will print to console: <code>Attribute on MyClass: ObsoleteAttribute</code>. Try adding other attributes to <code>MyClass</code>.</p>\n<p>It&#39;s important to note that these <code>Attribute</code> objects are instantiated lazily. That is, they won&#39;t be instantiated until you use <code>GetCustomAttribute</code> or <code>GetCustomAttributes</code>.\nThey are also instantiated each time. Calling <code>GetCustomAttributes</code> twice in a row will return two different instances of <code>ObsoleteAttribute</code>.</p>\n<h2 id=\"common-attributes-in-the-base-class-library-bcl\">Common attributes in the base class library (BCL)</h2>\n<p>Attributes are used by many tools and frameworks. NUnit uses attributes like <code>[Test]</code> and <code>[TestFixture]</code> that are used by the NUnit test runner. ASP.NET MVC uses attributes like <code>[Authorize]</code>\nand provides an action filter framework to perform cross-cutting concerns on MVC actions. <a href=\"https://www.postsharp.net\" data-linktype=\"external\">PostSharp</a> uses the attribute syntax to allow aspect-oriented programming in C#.</p>\n<p>Here are a few notable attributes built into the .NET Core base class libraries:</p>\n<ul>\n<li><p><code>[Obsolete]</code>. This one was used in the above examples, and it lives in the <code>System</code> namespace. It is useful to provide declarative documentation about a changing code base. A message can be provided in the form of a string,\nand another boolean parameter can be used to escalate from a compiler warning to a compiler error.</p>\n</li>\n<li><p><code>[Conditional]</code>. This attribute is in the <code>System.Diagnostics</code> namespace. This attribute can be applied to methods (or attribute classes). You must pass a string to the constructor.\nIf that string matches a <code>#define</code> directive, then any calls to that method (but not the method itself) will be removed by the C# compiler. Typically this is used for debugging (diagnostics) purposes.</p>\n</li>\n<li><p><code>[CallerMemberName]</code>. This attribute can be used on parameters, and lives in the <code>System.Runtime.CompilerServices</code> namespace. This is an attribute that is used to inject the name\nof the method that is calling another method. This is typically used as a way to eliminate &#39;magic strings&#39; when implementing INotifyPropertyChanged in various UI frameworks. As an\nexample:</p>\n</li>\n</ul>\n<pre><code class=\"lang-csharp\" name=\"Using CallerMemberName when implementing INotifyPropertyChanged\">public class MyUIClass : INotifyPropertyChanged\n{\n    public event PropertyChangedEventHandler PropertyChanged;\n\n    public void ExecutePropertyChanged([CallerMemberName] string propertyName = null)\n    {\n        if(PropertyChanged != null)\n            PropertyChanged(this, new PropertyChangedEventArgs(propertyName));\n    }\n\n    private string _name;\n    public string Name {\n        get { return _name;}\n        set {\n            if(value != _name) {\n                _name = value;\n                ExecutePropertyChanged();   // notice that &quot;Name&quot; is not needed here explicitly\n            }\n        }\n    }\n}\n</code></pre><p>In the above code, you don&#39;t have to have a literal <code>&quot;Name&quot;</code> string. This can help prevent typo-related bugs and also makes for smoother refactoring/renaming.</p>\n<h2 id=\"summary\">Summary</h2>\n<p>Attributes bring declarative power to C#. But they are a form of code as meta-data, and don&#39;t act by themselves.</p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"mgroves\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"b152cf36-76e4-43a5-b805-1a1952e53b79\">\r\n<meta name=\"description\" content=\"Learn how attributes work in C#.\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core, C#, attributes\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"03/06/2017\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/abd4eadaede26fe144b5d8f249dd9b334e5a567f/docs/csharp/tutorials/attributes.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/tutorials/attributes.md\">\r\n<meta name=\"document_id\" content=\"47255217-a65d-f464-d29c-d434a0e8ed45\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"mgroves","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Attributes | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"b152cf36-76e4-43a5-b805-1a1952e53b79","description":"Learn how attributes work in C#.","keywords":".NET, .NET Core, C#, attributes","ms.topic":"article","ms.date":"03/06/2017","ms.technology":"devlang-csharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Luke Latham","author_email":"GuardRex@users.noreply.github.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"dotnet new updates for MSBuild/csproj (#1649)","commit_sha":"abd4eadaede26fe144b5d8f249dd9b334e5a567f","commit_date":"2017-03-07 01:09:15 -0800"},{"author_name":"Matthew D. Groves","author_email":"me@mgroves.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"Fix for wrong embedded snippet #71 (#1571)","commit_sha":"ddbbec9630360bc35b54d78cb4fc2d931ea86727","commit_date":"2017-02-18 21:58:04 -0500"},{"author_name":"Matthew D. Groves","author_email":"me@mgroves.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"#71 - attributes tutorial and sample code (also added attributes link… (#1462)","commit_sha":"43e4d802ffe4a89192249430e275be37b100173c","commit_date":"2017-02-13 12:06:46 -0500"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/mgroves","display_name":"Matthew D. Groves","id":"103484"},"contributors":[{"profile_url":"https://github.com/mgroves","display_name":"Matthew D. Groves"},{"profile_url":"https://github.com/GuardRex","display_name":"Luke Latham","id":"1622880"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/abd4eadaede26fe144b5d8f249dd9b334e5a567f/docs/csharp/tutorials/attributes.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/tutorials/attributes.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/tutorials/attributes.md","document_id":"47255217-a65d-f464-d29c-d434a0e8ed45","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/tutorials/attributes","toc_asset_id":"articles/csharp/tutorials/toc.json","toc_rel":"toc.json","_op_ogTitle":"Attributes","_op_displayDate":"2017-3-6","_op_displayDate_source":"2017-03-06T00:00:00Z","_op_wordCount":1437,"_op_rawTitle":"<h1 id=\"using-attributes-in-c\" sourcefile=\"docs/csharp/tutorials/attributes.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Using Attributes in C#</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/tutorials/attributes","fileRelativePath":"articles/csharp/tutorials/attributes.html"},"themesRelativePathToOutputRoot":"_themes/"}