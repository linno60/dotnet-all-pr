{"content":"<div><div class=\"content\">\n<h2 id=\"introduction\">Introduction</h2>\n<p>This tutorial teaches you a number of features in .NET Core and the C# language. You’ll learn:</p>\n<ul>\n<li>The basics of the .NET Core Command Line Interface (CLI)</li>\n<li>The structure of a C# Console Application</li>\n<li>Console I/O</li>\n<li>The basics of File I/O APIs in .NET Core</li>\n<li>The basics of the Task Asynchronous Programming Model in .NET Core</li>\n</ul>\n<p>You’ll build an application that reads a text file, and echoes the\ncontents of that text file to the console. The output to the console will\nbe paced to match reading it aloud. You can speed up or slow down the pace\nby pressing the ‘&lt;’ or ‘&gt;’ keys.</p>\n<p>There are a lot of features in this tutorial. Let’s build them one by one. </p>\n<h2 id=\"prerequisites\">Prerequisites</h2>\n<p>You’ll need to setup your machine to run .NET core. You can find the\ninstallation instructions on the <a href=\"https://www.microsoft.com/net/core\" data-linktype=\"external\">.NET Core</a>\npage. You can run this\napplication on Windows, Linux, macOS or in a Docker container. \nYou’ll need to install your favorite code editor. </p>\n<h2 id=\"create-the-application\">Create the Application</h2>\n<p>The first step is to create a new application. Open a command prompt and\ncreate a new directory for your application. Make that the current\ndirectory. Type the command <code>dotnet new console</code> at the command prompt. This\ncreates the starter files for a basic “Hello World” application.</p>\n<p>Before you start making modifications, let’s go through the steps to run\nthe simple Hello World application. After creating the application, type\n<code>dotnet restore</code> at the command prompt. This command runs the NuGet\npackage restore process. NuGet is a .NET package manager. This command\ndownloads any of the missing dependencies for your project. As this is a\nnew project, none of the dependencies are in place, so the first run will\ndownload the .NET Core framework. After this initial step, you will only\nneed to run <code>dotnet restore</code> when you add new dependent packages, or update\nthe versions of any of your dependencies. This process also creates the\nproject lock file (project.lock.json) in your project directory. This file\nhelps to manage the project dependencies. It contains the local location\nof all the project dependencies. You do not need to put the file in source\ncontrol; it will be generated when you run <code>dotnet restore</code>. </p>\n<p>After restoring packages, you run <code>dotnet build</code>. This executes the build\nengine and creates your application executable. Finally, you execute <code>dotnet run</code> to\nrun your application.  </p>\n<p>The simple Hello World application code is all in Program.cs. Open that\nfile with your favorite text editor. We’re about to make our first changes.\nAt the top of the file, see a using statement:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">using System;\n</code></pre><p>This statement tells the compiler that any types from the <code>System</code> namespace\nare in scope. Like other Object Oriented languages you may have used, C#\nuses namespaces to organize types. This hello world program is no\ndifferent. You can see that the program is enclosed in the\n<code>ConsoleApplication</code> namespace. That’s not a very descriptive name, so\nchange it to <code>TeleprompterConsole</code>:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">namespace TeleprompterConsole\n</code></pre><h2 id=\"reading-and-echoing-the-file\">Reading and Echoing the File</h2>\n<p>The first feature to add is to read a text file, and display all that text\nto the console. First, let’s add a text file. Copy the \n<a href=\"https://raw.githubusercontent.com/dotnet/docs/master/samples/csharp/getting-started/console-teleprompter/sampleQuotes.txt\" data-linktype=\"external\">sampleQuotes.txt</a>\nfile from the GitHub repository for this <a href=\"https://github.com/dotnet/docs/tree/master/samples/csharp/getting-started/console-teleprompter\" data-linktype=\"external\">sample</a> into your project directory. \nThis will serve as the script for your\napplication.</p>\n<p>Next, add the following method in your Program class (right below the <code>Main</code> \nmethod):</p>\n<pre class=\"loading\"><code class=\"lang-cs\">static IEnumerable&lt;string&gt; ReadFrom(string file)\n{\n    string line;\n    using (var reader = File.OpenText(file))\n    {\n        while ((line = reader.ReadLine()) != null)\n        {\n            yield return line;\n        }\n    }\n}\n</code></pre><p>This method uses types from two new namespaces. For this to compile you’ll \nneed to add the following two lines to the top of the file:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">using System.Collections.Generic;\nusing System.IO;\n</code></pre><p>The <code>IEnumerable&lt;T&gt;</code> interface is defined in the \n<code>System.Collections.Generic</code> namespace. The <a class=\"xref\" href=\"../../../api/system.io.file\" data-linktype=\"relative-path\">File</a> class is defined in the\n<code>System.IO</code> namespace.</p>\n<p>This method is a special type of C# method called an <em>Enumerator method</em>. \nEnumerator methods return sequences that are evaluated lazily. That means \neach item in the sequence is generated as it is requested by the code \nconsuming the sequence. Enumerator methods are methods that contain one or \nmore <code>yield return</code> statements. The object returned by the <code>ReadFrom</code> \nmethod contains the code to generate each item in the sequence. In this \nexample, that involves reading the next line of text from the source file, \nand returning that string. Each time the calling code requests the next \nitem from the sequence, the code reads the next line of text from the file\nand returns it. When the file has been completely read, the sequence \nindicates that there are no more items.</p>\n<p>There are two other C# syntax elements that may be new to you. The <code>using</code> \nstatement in this method manages resource cleanup. The variable that is\ninitialized in the <code>using</code> statement (<code>reader</code>, in this example) must\nimplement the <code>IDisposable</code> interface. The <a class=\"xref\" href=\"../../../api/system.idisposable\" data-linktype=\"relative-path\">IDisposable</a> interface\ndefines a single method, <code>Dispose</code>, that should be called when the\nresource should be released. The compiler generates that call when\nexecution reaches the closing brace of the <code>using</code> statement. The\ncompiler-generated code ensures that the resource is released even if an\nexception is thrown from the code in the block defined by the using\nstatement.</p>\n<p>The <code>reader</code> variable is defined using the <code>var</code> keyword. <code>var</code> defines an\n<em>implicitly typed local variable</em>. That means the type of the variable is\ndetermined by the compile time type of the object assigned to the\nvariable. Here, that is the return value from @System.IO.File.OpenText, which is\na <a class=\"xref\" href=\"../../../api/system.io.streamreader\" data-linktype=\"relative-path\">StreamReader</a> object.</p>\n<p>Now, let’s fill in the code to read the file in the <code>Main</code> method: </p>\n<pre class=\"loading\"><code class=\"lang-cs\">var lines = ReadFrom(&quot;sampleQuotes.txt&quot;);\nforeach (var line in lines)\n{\n    Console.WriteLine(line); \n}\n</code></pre><p>Run the program (using <code>dotnet run</code> and you can see every line printed out\nto the console).  </p>\n<h2 id=\"adding-delays-and-formatting-output\">Adding Delays and Formatting output</h2>\n<p>What you have is being displayed far too fast to read aloud. Now you need\nto add the delays in the output. As you start, you’ll be building some of\nthe core code that enables asynchronous processing. However, these first\nsteps will follow a few anti-patterns. The anti-patterns are pointed out\nin comments as you add the code, and the code will be updated in later\nsteps.</p>\n<p>There are two steps to this section. First, you’ll update the iterator\nmethod to return single words instead of entire lines. That’s done with\nthese modifications. Replace the <code>yield return line;</code> statement with the\nfollowing code:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var words = line.Split(&#39; &#39;);\nforeach (var word in words)\n{\n    yield return word + &quot; &quot;;\n}\nyield return Environment.NewLine;\n</code></pre><p>Next, you need to modify how you consume the lines of the file, and add a\ndelay after writing each word. Replace the <code>Console.WriteLine(line)</code> statement\nin the <code>Main</code> method with the following block:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">Console.Write(line);\nif (!string.IsNullOrWhiteSpace(line))\n{\n    var pause = Task.Delay(200);\n    // Synchronously waiting on a task is an\n    // anti-pattern. This will get fixed in later\n    // steps.\n    pause.Wait();\n}\n</code></pre><p>The <code>Task</code> class is in the <code>System.Threading.Tasks</code> namespace, so you need\nto add that <code>using</code> statement at the top of file:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">using System.Threading.Tasks;\n</code></pre><p>Run the sample, and check the output. Now, each single word is printed,\nfollowed by a 200 ms delay. However, the displayed output shows some\nissues because the source text file has several lines that have more than\n80 characters without a line break. That can be hard to read while it&#39;s\nscrolling by. That’s easy to fix. You’ll just keep track of the length of\neach line, and generate a new line whenever the line length reaches a\ncertain threshold. Declare a local variable after the declaration of\n<code>words</code> that holds the line length:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var lineLength = 0;\n</code></pre><p>Then, add the following code after the <code>yield return word + &quot; &quot;;</code> statement\n(before the closing brace):</p>\n<pre class=\"loading\"><code class=\"lang-cs\">lineLength += word.Length + 1;\nif (lineLength &gt; 70)\n{\n    yield return Environment.NewLine;\n    lineLength = 0;\n}\n</code></pre><p>Run the sample, and you’ll be able to read aloud at its pre-configured\npace.</p>\n<h2 id=\"async-tasks\">Async Tasks</h2>\n<p>In this final step, you’ll add the code to write the output asynchronously\nin one task, while also running another task to read input from the user\nif they want to speed up or slow down the text display. This has a few\nsteps in it and by the end, you’ll have all the updates that you need.\nThe first step is to create an asynchronous <a class=\"xref\" href=\"../../../api/system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> returning method that\nrepresents the code you’ve created so far to read and display the file.</p>\n<p>Add this method to your <code>Program</code> class (it’s taken from the body of your\n<code>Main</code> method):</p>\n<pre class=\"loading\"><code class=\"lang-cs\">private static async Task ShowTeleprompter()\n{\n    var words = ReadFrom(&quot;sampleQuotes.txt&quot;);\n    foreach (var line in words)\n    {\n        Console.Write(line);\n        if (!string.IsNullOrWhiteSpace(line))\n        {\n            await Task.Delay(200);\n        }\n    }\n}\n</code></pre><p>You’ll notice two changes. First, in the body of the method, instead of\ncalling <a class=\"xref\" href=\"../../../api/system.threading.tasks.task#System_Threading_Tasks_Task_Wait\" data-linktype=\"relative-path\">Wait()</a> to synchronously wait for a task to finish, this version\nuses the <code>await</code> keyword. In order to do that, you need to add the <code>async</code>\nmodifier to the method signature. This method returns a <code>Task</code>. Notice that\nthere are no return statements that return a <code>Task</code> object. Instead, that\n<code>Task</code> object is created by code the compiler generates when you use the\n<code>await</code> operator. You can imagine that this method returns when it reaches\nan <code>await</code>. The returned <code>Task</code> indicates that the work has not completed.\nThe method resumes when the awaited task completes. When it has executed\nto completion, the returned <code>Task</code> indicates that it is complete.\nCalling code can\nmonitor that returned <code>Task</code> to determine when it has completed.</p>\n<p>You can call this new method in your <code>Main</code> method:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">ShowTeleprompter().Wait();\n</code></pre><p>Here, in <code>Main</code>, the code does synchronously wait. You should use the\n<code>await</code> operator instead of synchronously waiting whenever possible. But,\nin a console application’s <code>Main</code> method, you cannot use the <code>await</code>\noperator. That would result in the application exiting before all tasks\nhave completed.</p>\n<p>Next, you need to write the second asynchronous method to read from the\nConsole and watch for the ‘&lt;’ and ‘&gt;’ keys. Here’s the method you add for\nthat task:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">private static async Task GetInput()\n{\n    var delay = 200;\n    Action work = () =&gt;\n    {\n        do {\n            var key = Console.ReadKey(true);\n            if (key.KeyChar == &#39;&gt;&#39;)\n            {\n                delay -= 10;\n            }\n            else if (key.KeyChar == &#39;&lt;&#39;)\n            {\n                delay += 10;\n            }\n        } while (true);\n    };\n    await Task.Run(work);\n}\n</code></pre><p>This creates a lambda expression to represent an <a class=\"xref\" href=\"../../../api/system.action\" data-linktype=\"relative-path\">Action</a> delegate that reads a key\nfrom the Console and modifies a local variable representing the delay when\nthe user presses the ‘&lt;’ or ‘&gt;’ keys. This method uses <a class=\"xref\" href=\"../../../api/system.console#System_Console_ReadKey\" data-linktype=\"relative-path\">ReadKey()</a>\nto block and wait for the user to press a key.</p>\n<p>To finish this feature, you need to create a new <code>async Task</code> returning\nmethod that starts both of these tasks (<code>GetInput</code> and \n<code>ShowTeleprompter</code>), and also manages the shared data between these two\ntasks.</p>\n<p>It’s time to create a class that can handle the shared data between these\ntwo tasks. This class contains two public properties: the delay, and a\nflag to indicate that the file has been completely read:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">namespace TeleprompterConsole\n{\n    internal class TelePrompterConfig\n    {\n        private object lockHandle = new object();\n        public int DelayInMilliseconds { get; private set; } = 200;\n\n        public void UpdateDelay(int increment) // negative to speed up\n        {\n            var newDelay = Min(DelayInMilliseconds + increment, 1000);\n            newDelay = Max(newDelay, 20);\n            lock (lockHandle)\n            {\n                DelayInMilliseconds = newDelay;\n            }\n        }\n    }\n}\n</code></pre><p>Put that class in a new file, and enclose that class in the\n<code>TeleprompterConsole</code> namespace as shown above. You’ll also need to add a <code>using static</code>\nstatement so that you can reference the <code>Min</code> and <code>Max</code> method without the\nenclosing class or namespace names. A <code>using static</code> statement imports the\nmethods from one class. This is in contrast with the <code>using</code> statements used\nup to this point that have imported all classes from a namespace.</p>\n<pre class=\"loading\"><code class=\"lang-cs\">using static System.Math;\n</code></pre><p>The other language feature that’s new is the <code>lock</code> statement. This\nstatement ensures that only a single thread can be in that code at any\ngiven time. If one thread is in the locked section, other threads must\nwait for the first thread to exit that section. The <code>lock</code> statement uses an\nobject that guards the lock section. This class follows a standard idiom\nto lock a private object in the class.</p>\n<p>Next, you need to update the <code>ShowTeleprompter</code> and <code>GetInput</code> methods to\nuse the new <code>config</code> object. Write one final <code>Task</code> returning <code>async</code> method to\nstart both tasks and exit when the first task finishes:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">private static async Task RunTeleprompter()\n{\n    var config = new TelePrompterConfig();\n    var displayTask = ShowTeleprompter(config);\n\n    var speedTask = GetInput(config);\n    await Task.WhenAny(displayTask, speedTask);\n}\n</code></pre><p>The one new method here is the <a class=\"xref\" href=\"../../../api/system.threading.tasks.task#System_Threading_Tasks_Task_WhenAny_System_Threading_Tasks_Task___\" data-linktype=\"relative-path\">WhenAny(Task[])</a> call. That creates a <code>Task</code>\nthat finishes as soon as any of the tasks in its argument list completes.</p>\n<p>Next, you need to update both the <code>ShowTeleprompter</code> and <code>GetInput</code> methods to\nuse the <code>config</code> object for the delay:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">private static async Task ShowTeleprompter(TelePrompterConfig config)\n{\n    var words = ReadFrom(&quot;sampleQuotes.txt&quot;);\n    foreach (var line in words)\n    {\n        Console.Write(line);\n        if (!string.IsNullOrWhiteSpace(line))\n        {\n            await Task.Delay(config.DelayInMilliseconds);\n        }\n    }\n    config.SetDone();\n}\n\nprivate static async Task GetInput(TelePrompterConfig config)\n{\n\n    Action work = () =&gt;\n    {\n        do {\n            var key = Console.ReadKey(true);\n            if (key.KeyChar == &#39;&gt;&#39;)\n                config.UpdateDelay(-10);\n            else if (key.KeyChar == &#39;&lt;&#39;)\n                config.UpdateDelay(10);\n        } while (!config.Done);\n    };\n    await Task.Run(work);\n}\n</code></pre><p>This new version of <code>ShowTeleprompter</code> calls a new method in the\n<code>TeleprompterConfig</code> class. Now, you need to update <code>Main</code> to call \n<code>RunTeleprompter</code> instead of <code>ShowTeleprompter</code>:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">RunTeleprompter().Wait();\n</code></pre><p>To finish, you&#39;ll need to add the\n<code>SetDone</code> method, and the <code>Done</code> property to the <code>TelePrompterConfig</code> class:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public bool Done =&gt; done;\n\nprivate bool done;\n\npublic void SetDone()\n{\n    done = true;    \n}\n</code></pre><h2 id=\"conclusion\">Conclusion</h2>\n<p>This tutorial showed you a number of the features around the C# language\nand the .NET Core libraries related to working in Console applications.\nYou can build on this knowledge to explore more about the language, and\nthe classes introduced here. You’ve seen the basics of File and Console\nI/O, blocking and non-blocking use of the Task based Asynchronous\nprogramming model, a tour of the C# language and how C# programs are\norganized and the .NET Core Command Line Interface and tools.</p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"883cd93d-50ce-4144-b7c9-2df28d9c11a0\">\r\n<meta name=\"description\" content=\"This tutorial teaches you a number of features in .NET Core and the C# language.\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"03/06/2017\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net-core\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/abd4eadaede26fe144b5d8f249dd9b334e5a567f/docs/csharp/tutorials/console-teleprompter.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/tutorials/console-teleprompter.md\">\r\n<meta name=\"document_id\" content=\"d45f523e-b9f4-0697-f3e8-1abe012c7cd7\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Console Application | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"883cd93d-50ce-4144-b7c9-2df28d9c11a0","description":"This tutorial teaches you a number of features in .NET Core and the C# language.","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"03/06/2017","ms.technology":"devlang-csharp","ms.prod":".net-core","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Luke Latham","author_email":"GuardRex@users.noreply.github.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"dotnet new updates for MSBuild/csproj (#1649)","commit_sha":"abd4eadaede26fe144b5d8f249dd9b334e5a567f","commit_date":"2017-03-07 01:09:15 -0800"},{"author_name":"Robert Jensen","author_email":"robert.cole.jensen@gmail.com","committer_name":"Phillip Carter","comitter_email":"phillip.carter@outlook.com","message":"uses raw version of sampleQuotes.txt in link (#1652)","commit_sha":"527d08b8743f6b2404506fc560266d6f418c4c2c","commit_date":"2017-03-06 22:21:44 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"update input file names for case sensitive file systems (#1299)","commit_sha":"be9b3689af4dd7d04d848243888f10b7dbba3d1e","commit_date":"2016-12-01 18:10:04 -0500"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"respond to remaining feedback on PR #1073","commit_sha":"325c8a9d01dcb824ee796ad8f8c3813a512f8b4c","commit_date":"2016-11-08 10:14:41 -0800"},{"author_name":"Bader Nasser","author_email":"badersur@users.noreply.github.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"Fix formatting console-teleprompter.md","commit_sha":"2fb692007350b6406fd427781082cdbef7578949","commit_date":"2016-11-08 10:14:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"renamed repo/fixed headings (#1186)","commit_sha":"15c55a87beb64f265a164db918c7721c7690fadf","commit_date":"2016-10-29 15:23:17 -0400"},{"author_name":"Petr Onderka","author_email":"gsvick@gmail.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"Fixed broken links (#1045)","commit_sha":"d10ce6a283195b4e24228e860505533a047afa45","commit_date":"2016-09-20 09:53:56 -0700"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update ci build for ubuntu (#891)","commit_sha":"ce52ada663c2ed9b8b3d10bc3d4dcb453abb79f7","commit_date":"2016-08-09 16:02:13 -0400"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update Samples section of contributing.md (#796)","commit_sha":"d82a5907ae4405358eccb9fd8b8dd68a3996fc74","commit_date":"2016-07-28 14:26:57 -0400"},{"author_name":"Sergei Ryabkov","author_email":"sryabkov@users.noreply.github.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"Update console-teleprompter.md (#771)","commit_sha":"b3179fc87ffeaad4ec0df3e54a1cfc74b507e9da","commit_date":"2016-07-08 13:01:05 -0400"},{"author_name":"Tom Dykstra","author_email":"tdykstra@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"move tutorials folder to csharp folder (#704)","commit_sha":"9e4c8eafc7301549383306d9c679015a95f1406f","commit_date":"2016-06-29 12:23:39 -0700"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/GuardRex","display_name":"Luke Latham","id":"1622880"},{"profile_url":"https://github.com/r1b","display_name":"Robert Jensen","id":"5550520"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/badersur","display_name":"Bader Nasser","id":"1686391"},{"profile_url":"https://github.com/svick","display_name":"Petr Onderka","id":"287848"},{"profile_url":"https://github.com/sryabkov","display_name":"Sergei Ryabkov","id":"178154"},{"profile_url":"https://github.com/tdykstra","display_name":"Tom Dykstra","id":"1569635"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/abd4eadaede26fe144b5d8f249dd9b334e5a567f/docs/csharp/tutorials/console-teleprompter.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/tutorials/console-teleprompter.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/tutorials/console-teleprompter.md","document_id":"d45f523e-b9f4-0697-f3e8-1abe012c7cd7","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/tutorials/console-teleprompter","toc_asset_id":"articles/csharp/tutorials/toc.json","toc_rel":"toc.json","_op_ogTitle":"Console Application","_op_displayDate":"2017-3-6","_op_displayDate_source":"2017-03-06T00:00:00Z","_op_wordCount":2335,"_op_rawTitle":"<h1 id=\"console-application\" sourcefile=\"docs/csharp/tutorials/console-teleprompter.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Console Application</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/tutorials/console-teleprompter","fileRelativePath":"articles/csharp/tutorials/console-teleprompter.html"},"themesRelativePathToOutputRoot":"_themes/"}