{"content":"<div><div class=\"content\">\n<h2 id=\"introduction\">Introduction</h2>\n<p>This tutorial introduces you to inheritance in C#. Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.</p>\n<h2 id=\"prerequisites\">Prerequisites</h2>\n<p>This tutorial assumes that you&#39;ve installed .NET Core. For installation instructions, see <a href=\"https://www.microsoft.com/net/core\" data-linktype=\"external\">.NET Core installation guide</a>. You also need a code editor. This tutorial uses <a href=\"https://code.visualstudio.com\" data-linktype=\"external\">Visual Studio Code</a>, although you can use any code editor of your choice.</p>\n<h2 id=\"running-the-examples\">Running the examples</h2>\n<p>To create and run the examples in this tutorial, you use the <a href=\"../../core/tools/dotnet\" data-linktype=\"relative-path\">dotnet</a> utility from the command line. Follow these steps for each example:</p>\n<ol>\n<li><p>Create a directory to store the example.</p>\n</li>\n<li><p>Enter the <a href=\"../../core/tools/dotnet-new\" data-linktype=\"relative-path\">dotnet new console</a> command at a command prompt to create a new .NET Core project.</p>\n</li>\n<li><p>Copy and paste the code from the example into your code editor.</p>\n</li>\n<li><p>Enter the <a href=\"../../core/tools/dotnet-restore\" data-linktype=\"relative-path\">dotnet restore</a> command from the command line to load or restore the project&#39;s dependencies.</p>\n</li>\n<li><p>Enter the <a href=\"../../core/tools/dotnet-run\" data-linktype=\"relative-path\">dotnet run</a> command to compile and execute the example.</p>\n</li>\n</ol>\n<h2 id=\"background-what-is-inheritance\">Background: What is inheritance?</h2>\n<p><em>Inheritance</em> is one of the fundamental attributes of object-oriented programming. It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class. The class whose members are inherited is called the <em>base class</em>. The class that inherits the members of the base class is called the <em>derived class</em>.</p>\n<p>C# and .NET support <em>single inheritance</em> only. That is, a class can only inherit from a single class. However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types. In other words, type <code>D</code> can inherit from type <code>C</code>, which inherits from type <code>B</code>, which inherits from the base class type <code>A</code>. Because inheritance is transitive, the members of type <code>A</code> are available to type <code>D</code>.</p>\n<p>Not all members of a base class are inherited by derived classes. The following members are not inherited:</p>\n<ul>\n<li><p><a href=\"../programming-guide/classes-and-structs/static-constructors\" data-linktype=\"relative-path\">Static constructors</a>, which initialize the static data of a class.</p>\n</li>\n<li><p><a href=\"../programming-guide/classes-and-structs/constructors\" data-linktype=\"relative-path\">Instance constructors</a>, which you call to create a new instance of the class. Each class must define its own constructors.</p>\n</li>\n<li><p><a href=\"../programming-guide/classes-and-structs/destructors\" data-linktype=\"relative-path\">Destructors</a>, which are called by the runtime&#39;s garbage collector to destroy instances of a class.</p>\n</li>\n</ul>\n<p>While all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility. A member&#39;s accessibility affects its visibility for derived classes as follows:</p>\n<ul>\n<li><p><a href=\"../language-reference/keywords/private\" data-linktype=\"relative-path\">Private</a> members are visible only in derived classes that are nested in their base class. Otherwise, they are not visible in derived classes. In the following example, <code>A.B</code> is a nested class that derives from <code>A</code>, and <code>C</code> derives from <code>A</code>. The private <code>A.value</code> field is visible in A.B. However, if you remove the comments from the <code>C.GetValue</code> method and attempt to compile the example, it produces compiler error CS0122: &quot;&#39;A.value&#39; is inaccessible due to its protection level.&quot;</p>\n<pre><code name=\"Inheritance\">using System;\n\npublic class A \n{\n   private int value = 10;\n\n   public class B : A\n   {\n       public int GetValue()\n       {\n           return this.value;\n       }     \n   }\n}\n\npublic class C : A\n{\n//    public int GetValue()\n//    {\n//        return this.value;\n//    }\n}\n\npublic class Example\n{\n    public static void Main(string[] args)\n    {\n        var b = new A.B();\n        Console.WriteLine(b.GetValue());\n    }\n}\n// The example displays the following output:\n//       10\n</code></pre></li>\n<li><p><a href=\"../language-reference/keywords/protected\" data-linktype=\"relative-path\">Protected</a> members are visible only in derived classes.</p>\n</li>\n<li><p><a href=\"../language-reference/keywords/protected\" data-linktype=\"relative-path\">Internal</a> members are visible only in derived classes that are located in the same assembly as the base class. They are not visible in derived classes located in a different assembly from the base class.</p>\n</li>\n<li><p><a href=\"../language-reference/keywords/protected\" data-linktype=\"relative-path\">Public</a> members are visible in derived classes and are part of the derived class&#39; public interface. Public inherited members can be called just as if they were defined in the derived class. In the following example, class <code>A</code> defines a method named <code>Method1</code>, and class <code>B</code> inherits from class <code>A</code>. The example then calls <code>Method1</code> as if it were an instance method on <code>B</code>.</p>\n</li>\n</ul>\n<pre><code name=\"Inheritance\">public class A\n{\n    public void Method1()\n    {\n        // Method implementation.\n    }\n}\n\npublic class B : A\n{ }\n\n\npublic class Example\n{\n    public static void Main()\n    {\n        B b = new B();\n        b.Method1();\n    }\n}\n</code></pre><p>Derived classes can also <em>override</em> inherited members by providing an alternate implementation. In order to be able to override a member, the member in the base class must be marked with the <a href=\"../language-reference/keywords/virtual\" data-linktype=\"relative-path\">virtual</a> keyword. By default, base class members are not marked as <code>virtual</code> and cannot be overridden. Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: &quot;<member> cannot override inherited member <member> because it is not marked virtual, abstract, or override.<p>\n<pre class=\"loading\"><code class=\"lang-cs\">   public class A\n   {\n      public void Method1()\n      {\n         // Do something.\n      }\n   }\n\n   public class B : A\n   {\n      public override void Method1()  // Generates CS0506.\n      {\n         // Do something else.\n      }\n   }\n</code></pre><p>In some cases, a derived class <em>must</em> override the base class implementation. Base class members marked with the <a href=\"../language-reference/keywords/abstract\" data-linktype=\"relative-path\">abstract</a> keyword require that derived classes override them. Attempting to compile the following example generates compiler error CS0534, &quot;<class> does not implement inherited abstract member <member>&#39;, because class <code>B</code> provides no implementation for <code>A.Method1</code>.<p>\n<pre class=\"loading\"><code class=\"lang-cs\">   public abstract class A\n   {\n      public abstract void Method1();\n   }\n\n   public class B : A                  // Generates CS0534.\n   {\n      public void Method3()\n      {\n         // Do something.\n      }\n   }\n</code></pre><p>Inheritance applies only to classes and interfaces. Other type categories (structs, delegates, and enums) do not support inheritance. Because of this, attempting to compile code like the following produces compiler error CS0527: &quot;Type &#39;ValueType&#39; in interface list is not an interface.&quot; The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.</p>\n<pre class=\"loading\"><code class=\"lang-cs\">   using System;\n\n   public struct ValueStructure : ValueType       // Generates CS0527.\n   {\n   }\n</code></pre><h2 id=\"implicit-inheritance\">Implicit inheritance</h2>\n<p>Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <a class=\"xref\" href=\"../../../api/system.object\" data-linktype=\"relative-path\">Object</a> or a type derived from it. This ensures that common functionality is available to any type.</p>\n<p>To see what implicit inheritance means, let&#39;s define a new class, <code>SimpleClass</code>, that is simply an empty class definition:</p>\n<pre><code name=\"Inheritance\">public class SimpleClass\n{}\n</code></pre><p>We can then use reflection (which lets us inspect a type&#39;s metadata to get information about that type) to get a list of the members that belong to the <code>SimpleClass</code> type. Although we haven&#39;t defined any members in our <code>SimpleClass</code> class, output from the example indicates that it actually has nine members. One of these is a parameterless (or default) constructor that is automatically supplied for the <code>SimpleClass</code> type by the C# compiler. The eight seven are members of <a class=\"xref\" href=\"../../../api/system.object\" data-linktype=\"relative-path\">Object</a>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.</p>\n<pre><code name=\"Inheritance\">using System;\nusing System.Reflection;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Type t = typeof(SimpleClass);\n      BindingFlags flags = BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | \n                           BindingFlags.NonPublic | BindingFlags.FlattenHierarchy;\n      MemberInfo[] members = t.GetMembers(flags);\n      Console.WriteLine($&quot;Type {t.Name} has {members.Length} members: &quot;);\n      foreach (var member in members) {\n         string access = &quot;&quot;;\n         string stat = &quot;&quot;; \n         var method = member as MethodBase;\n         if (method != null) {\n            if (method.IsPublic) \n               access = &quot; Public&quot;;\n            else if (method.IsPrivate)\n               access = &quot; Private&quot;;\n            else if (method.IsFamily)  \n               access = &quot; Protected&quot;;\n            else if (method.IsAssembly)\n               access = &quot; Internal&quot;;\n            else if (method.IsFamilyOrAssembly)\n               access = &quot; Protected Internal &quot;;\n            if (method.IsStatic)\n               stat = &quot; Static&quot;;\n         }\n         var output = $&quot;{member.Name} ({member.MemberType}): {access}{stat}, Declared by {member.DeclaringType}&quot;;\n         Console.WriteLine(output); \n\n      }\n   }\n}\n// The example displays the following output:\n//\tType SimpleClass has 9 members:\n//\tToString (Method):  Public, Declared by System.Object\n//\tEquals (Method):  Public, Declared by System.Object\n//\tEquals (Method):  Public Static, Declared by System.Object\n//\tReferenceEquals (Method):  Public Static, Declared by System.Object\n//\tGetHashCode (Method):  Public, Declared by System.Object\n//\tGetType (Method):  Public, Declared by System.Object\n//\tFinalize (Method):  Internal, Declared by System.Object\n//\tMemberwiseClone (Method):  Internal, Declared by System.Object\n//\t.ctor (Constructor):  Public, Declared by SimpleClass\n</code></pre><p>Implicit inheritance from the <a class=\"xref\" href=\"../../../api/system.object\" data-linktype=\"relative-path\">Object</a> class makes these methods available to the <code>SimpleClass</code> class:</p>\n<ul>\n<li><p>The public <code>ToString</code> method, which converts a <code>SimpleClass</code> object to its string representation, the fully qualified type name. In this case, the <code>ToString</code> method returns the string &quot;SimpleClass&quot;.</p>\n</li>\n<li><p>Three methods that test for equality of two objects: the public instance <code>Equals(Object)</code> method, the public static <code>Equals(Object, Object)</code> method, and the public static <code>ReferenceEquals(Object, Object)</code> method. By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.</p>\n</li>\n<li><p>The public <code>GetHashCode</code> method, which computes a value that allows an instance of the type to be used in hashed collections.</p>\n</li>\n<li><p>The public <code>GetType</code> method, which returns a <a class=\"xref\" href=\"../../../api/system.type\" data-linktype=\"relative-path\">Type</a> object that represents the <code>SimpleClass</code> type.</p>\n</li>\n<li><p>The protected <a class=\"xref\" href=\"../../../api/system.object#System_Object_Finalize\" data-linktype=\"relative-path\">Finalize()</a> method, which is designed to release unmanaged resources before an object&#39;s memory is reclaimed by the garbage collector.</p>\n</li>\n<li><p>The protected <a class=\"xref\" href=\"../../../api/system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a> method, which creates a shallow clone of the current object.</p>\n</li>\n</ul>\n<p>Because of implicit inheritance, we can call any inherited member from a <code>SimpleClass</code> object just as if it was actually a member defined in the <code>SimpleClass</code> class. For instance, the following example calls the <code>SimpleClass.ToString</code> method, which <code>SimpleClass</code> inherits from <a class=\"xref\" href=\"../../../api/system.object\" data-linktype=\"relative-path\">Object</a>.</p>\n<pre><code name=\"Inheritance\">using System;\n\npublic class SimpleClass\n{}\n\npublic class Example\n{\n    public static void Main()\n    {\n        SimpleClass sc = new SimpleClass();\n        Console.WriteLine(sc.ToString());\n    }\n}\n// The example displays the following output:\n//        SimpleClass\n</code></pre><p>The following table lists the categories of types that you can create in C# and the types from which they implicitly inherit. Each base type makes a different set of members available through inheritance to implicitly derived types.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Type category</th>\n<th style=\"text-align:center\">Implicitly inherits from...</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">class</td>\n<td style=\"text-align:center\"><a class=\"xref\" href=\"../../../api/system.object\" data-linktype=\"relative-path\">Object</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">struct</td>\n<td style=\"text-align:center\"><a class=\"xref\" href=\"../../../api/system.valuetype\" data-linktype=\"relative-path\">ValueType</a>, <a class=\"xref\" href=\"../../../api/system.object\" data-linktype=\"relative-path\">Object</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">enum</td>\n<td style=\"text-align:center\"><a class=\"xref\" href=\"../../../api/system.enum\" data-linktype=\"relative-path\">Enum</a>, System.ValueType, <a class=\"xref\" href=\"../../../api/system.object\" data-linktype=\"relative-path\">Object</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">delegate</td>\n<td style=\"text-align:center\"><a class=\"xref\" href=\"../../../api/system.multicastdelegate\" data-linktype=\"relative-path\">MulticastDelegate</a>, <a class=\"xref\" href=\"../../../api/system.delegate\" data-linktype=\"relative-path\">Delegate</a>, <a class=\"xref\" href=\"../../../api/system.object\" data-linktype=\"relative-path\">Object</a></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"inheritance-and-an-is-a-relationship\">Inheritance and an &quot;is a&quot; relationship</h2>\n<p>Ordinarily, inheritance is used to express an &quot;is a&quot; relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class. For example, the <code>Publication</code> class represents a publication of any kind, and the <code>Book</code> and <code>Magazine</code> classes represent specific types of publications.</p>\n<p>   [!NOTE] A class or struct can implement one more interfaces. While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a &quot;can do&quot; relationship) between an interface and its implementing type than inheritance. An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.</p>\n<p>Note that &quot;is a&quot; also expresses the relationship between a type and a specific instantiation of that type. In the following example, <code>Automobile</code> is a class that has three unique read-only properties: <code>Moke</code>, the manufacturer of the automobile; <code>Model</code>, the kind of automobile; and <code>Year</code>, its year of manufacture. Our <code>Automobile</code> class also has a constructor whose arguments are assigned to the property values, and it overrides the <a class=\"xref\" href=\"../../../api/system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a> method to produce a string that uniquely identifies the <code>Automobile</code> instance rather than the <code>Automobile</code> class.</p>\n<pre><code name=\"Inheritance\">using System;\n\npublic class Automobile\n{\n    public Automobile(string make, string model, int year)\n    {\n        if (make == null)\n           throw new ArgumentNullException(&quot;The make cannot be null.&quot;);\n        else if (String.IsNullOrWhiteSpace(make))\n           throw new ArgumentException(&quot;make cannot be an empty string or have space characters only.&quot;);\n        Make = make;\n\n        if (model == null)\n           throw new ArgumentNullException(&quot;The model cannot be null.&quot;);\n        else if (String.IsNullOrWhiteSpace(make))\n           throw new ArgumentException(&quot;model cannot be an empty string or have space characters only.&quot;);\n        Model = model;\n\n        if (year &lt; 1857 || year &gt; DateTime.Now.Year + 2)\n           throw new ArgumentException(&quot;The year is out of range.&quot;);\n        Year = year;\n    }\n\n    public string Make { get; }\n    \n    public string Model { get; }\n\n    public int Year { get; }\n\n    public override string ToString() =&gt; $&quot;{Year} {Make} {Model}&quot;;\n}\n</code></pre><p>In this case, we should not rely on inheritance to represent specific car makes and models. For example, we do not need to define a <code>Packard</code> type to represent automobiles manufactured by the Packard Motor Car Company. Instead, we can represent them by creating an <code>Automobile</code> object with the appropriate values passed to its class constructor, as the following example does.</p>\n<pre><code name=\"Inheritance\">using System;\n\npublic class Example\n{\n    public static void Main()\n    {\n        var packard = new Automobile(&quot;Packard&quot;, &quot;Custom Eight&quot;, 1948);\n        Console.WriteLine(packard);\n    }\n}\n// The example displays the following output:\n//        1948 Packard Custom Eight\n</code></pre><p>An is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.</p>\n<h2 id=\"designing-the-base-class-and-derived-classes\">Designing the base class and derived classes</h2>\n<p>Let&#39;s look at the process of designing a base class and its derived classes. In this section, we&#39;ll define a base class, <code>Publication</code>, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. We&#39;ll also define a <code>Book</code> class that derives from <code>Publication</code>. We could easily extend the example to define other derived classes, such as <code>Magazine</code>, <code>Journal</code>, <code>Newspaper</code>, and <code>Article</code>.</p>\n<h3 id=\"the-base-publication-class\">The base <code>Publication</code> class</h3>\n<p>In designing our <code>Publication</code> class, we need to make several design decisions:</p>\n<ul>\n<li><p>What members to include in our base <code>Publication</code> class, and whether the <code>Publication</code> members provide method implementations, or whether <code>Publication</code> is an abstract base class that serves as a template for its derived classes.</p>\n<p> In this case, the <code>Publication</code> class will provide method implementations. The <a href=\"#abstract\" data-linktype=\"self-bookmark\">Designing abstract base classes amd their derived classes</a> section contains an example that uses an abstract base class to define the methods that derived classes must override. Derived classes are free to provide any implementation that is suitable for the derived type.</p>\n<p> The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes. Therefore, we should add members to <code>Publication</code> if their code is likely to be shared by some or most specialized <code>Publication</code> types. If we fail to do this efficiently, we&#39;ll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class. The need to maintain duplicated code in multiple locations is a potential source of bugs.</p>\n<p> Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, we want to be sure that we include in the <code>Publication</code> class only the data and functionality that is common to all or to most publications. Derived classes then implement members that are unique to the particular kinds of publication that they represent.</p>\n</li>\n<li><p>How far to extend our class hierarchy. Do we want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes? For example, <code>Publication</code> could be a base class of <code>Periodical</code>, which in turn is a base class of <code>Magazine</code>, <code>Journal</code> and <code>Newspaper</code>.</p>\n<p> For our example, we&#39;ll use the simple hierarchy of a <code>Publication</code> class and a single derived classes, <code>Book</code>. We could easily extend the example to create a number of additional   classes that derive from <code>Publication</code>, such as <code>Magazine</code> and <code>Article</code>.</p>\n</li>\n<li><p>Whether it makes sense to instantiate the base class. If it does not, we should apply the <a href=\"../language-reference/keywords/abstract\" data-linktype=\"relative-path\">abstract</a> keyword to the class. If an attempt is made to instantiate a class marked with the <code>abstract</code> keyword by a direct call to its class constructor, the C# compiler generates error CS0144, &quot;Cannot create an instance of the abstract class or interface.&quot; If an attempt is made to instantiate the class by using reflection, the reflection method throws a <a class=\"xref\" href=\"../../../api/system.memberaccessexception\" data-linktype=\"relative-path\">MemberAccessException</a>. Otherwise, our <code>Publication</code> class can be instantiated by calling its class constructor.</p>\n<p> By default, a base class can be instantiated by calling its class constructor. Note that we do not have to explicitly define a class constructor. If one is not present in the base class&#39; source code, the C# compiler automatically provides a default (parameterless) constructor.</p>\n<p> For our example, we&#39;ll mark the <code>Publication</code> class as <a href=\"../language-reference/keywords/abstract\" data-linktype=\"relative-path\">abstract</a> so that it cannot be instantiated.</p>\n</li>\n<li><p>Whether derived classes must inherit the base class implementation of a particular members, or whether they have the option to override the base class implementation. We have to use the <a href=\"../language-reference/keywords/virtual\" data-linktype=\"relative-path\">virtual</a> keyword to allow derived classes to override a base class method. By default, methods defined in the base class are <em>not</em> overridable.</p>\n</li>\n<li><p>Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes. By default, any class can serve as a base class. We can apply the <a href=\"../language-reference/keywords/sealed\" data-linktype=\"relative-path\">sealed</a> keyword to indicate that a class cannot serve as a base class for any additional classes. Attempting to derive from a sealed class generated compiler error CS0509, &quot;cannot derive from sealed type <typename>&quot;.<p>\n<p> For our example, we&#39;ll mark our derived class as <code>sealed</code>.</p>\n</typename></li>\n</ul>\n<p>The following example shows the source code for the <code>Publication</code> class, as well as a <code>PublicationType</code> enumeration that is returned by the <code>Publication.PublicationType</code> property. In addition to the members that it inherits from <a class=\"xref\" href=\"../../../api/system.object\" data-linktype=\"relative-path\">Object</a>, the <code>Publication</code> class defines the following unique members and member overrides:</p>\n<pre><code name=\"Inheritance\">using System;\n\npublic enum PublicationType { Misc, Book, Magazine, Article };\n\npublic abstract class Publication\n{\n   private bool published = false;\n   private DateTime datePublished;\n   private int totalPages; \n\n   public Publication(string title, string publisher, PublicationType type)\n   {\n      if (publisher == null)\n         throw new ArgumentNullException(&quot;The publisher cannot be null.&quot;);\n      else if (String.IsNullOrWhiteSpace(publisher))\n         throw new ArgumentException(&quot;The publisher cannot consist only of whitespace.&quot;);\n      Publisher = publisher;\n  \n      if (title == null)\n         throw new ArgumentNullException(&quot;The title cannot be null.&quot;);\n      else if (String.IsNullOrWhiteSpace(title))\n         throw new ArgumentException(&quot;The title cannot consist only of whitespace.&quot;);\n      Title = title;\n\n      Type = type;\n   }\n\n   public string Publisher { get; }\n\n   public string Title { get; }\n\n   public PublicationType Type { get; }\n\n   public string CopyrightName { get; private set; }\n   \n   public int CopyrightDate\n   { get; private set; }\n\n   public int Pages\n   { get { return totalPages; }\n     set \n     {\n         if (value &lt;= 0)\n            throw new ArgumentOutOfRangeException(&quot;The number of pages cannot be zero or negative.&quot;);\n         totalPages = value;   \n     }\n   }\n\n   public string GetPublicationDate()\n   {\n      if (!published)\n         return &quot;NYP&quot;;\n      else\n         return datePublished.ToString(&quot;d&quot;);   \n   }\n   \n   public void Publish(DateTime datePublished)\n   {\n      published = true;\n      this.datePublished = datePublished;\n   }\n\n   public void Copyright(string copyrightName, int copyrightDate)\n   {\n      if (copyrightName == null)\n         throw new ArgumentNullException(&quot;The name of the copyright holder cannot be null.&quot;);\n      else if (String.IsNullOrWhiteSpace(copyrightName))\n         throw new ArgumentException(&quot;The name of the copyright holder cannot consist only of whitespace.&quot;);\n      CopyrightName = copyrightName;\n      \n      int currentYear = DateTime.Now.Year;\n      if (copyrightDate &lt; currentYear - 10 || copyrightDate &gt; currentYear + 2)\n         throw new ArgumentOutOfRangeException($&quot;The copyright year must be between {currentYear -10} and {currentYear + 1}&quot;);\n            CopyrightDate = copyrightDate;      \n   }\n\n   public override string ToString() =&gt; Title;\n}\n</code></pre><ul>\n<li><p>A constructor</p>\n<p>Because the <code>Publication</code> class is <code>abstract</code>, it cannot be instantiated directly from code like the following:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var publication = new Publication(&quot;Tiddlywinks for Experts&quot;, &quot;Fun and Games&quot;,\n                                  PublicationType.Book);\n</code></pre><p>However, its instance constructor can be called directly from derived class constructors, as the source code for the <code>Book</code> class shows.</p>\n</li>\n<li><p>Two publication-related properties</p>\n<p><code>Title</code> is a read-only <a class=\"xref\" href=\"../../../api/system.string\" data-linktype=\"relative-path\">String</a> property whose value is supplied by calling the <code>Publication</code> constructor, which stores the value in a private field named <code>pubTitle</code>.</p>\n<p><code>Pages</code> is a read-write <a class=\"xref\" href=\"../../../api/system.int32\" data-linktype=\"relative-path\">Int32</a> property that indicates how many total pages the publication has. The value is stored in a private field named <code>totalPages</code>. It must be a positive number or an <a class=\"xref\" href=\"../../../api/system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a> is thrown.</p>\n</li>\n<li><p>Publisher-related members</p>\n<p>Two read-only properties, <code>Publisher</code> and <code>Type</code>, return the value of the private <code>pubName</code> and <code>pubType</code> fields. The values are originally supplied by the call to the <code>Publication</code> class constructor.</p>\n</li>\n<li><p>Publishing-related members</p>\n<p>Two methods, <code>Publish</code> and <code>GetPublicationDate</code>, set and return the publication date. The <code>Publish</code> method sets a private  <code>published</code> flag to <code>true</code> when it is called and assigns the date passed to it as an argument to the private <code>datePublished</code> field. The <code>GetPublicationDate</code> method returns the string &quot;NYP&quot; if the <code>published</code> flag is <code>false</code>, and the value of the <code>datePublished</code> field if it is <code>true</code>.</p>\n</li>\n<li><p>Copyright-related members</p>\n<p>The <code>Copyright</code> method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the private <code>copyrName</code> and <code>copyrDate</code> fields. The values can be retrieved from the <code>CopyrightName</code> and <code>CopyrightDate</code> properties.</p>\n</li>\n<li><p>An override of the <code>ToString</code> method</p>\n<p>If a type does not override the <a class=\"xref\" href=\"../../../api/system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another. The <code>Publication</code> class overrides <a class=\"xref\" href=\"../../../api/system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a> to return the value of the <code>Title</code> property.</p>\n</li>\n</ul>\n<p>The following figure illustrates the relationship between our base <code>Publication</code> class and its implicitly inherited <a class=\"xref\" href=\"../../../api/system.object\" data-linktype=\"relative-path\">Object</a> class.</p>\n<p><img src=\"media/publication-class.jpg\" alt=\"The Object and Publication classes\" data-linktype=\"relative-path\"></p>\n<h3 id=\"the-book-class\">The <code>Book</code> class</h3>\n<p>The <code>Book</code> class represents a book as a specialized type of publication. The following example shows the source code for the <code>Book</code> class.</p>\n<pre><code name=\"Inheritance\">using System;\n\npublic sealed class Book : Publication\n{\n   public Book(string title, string author, string publisher) : \n          this(title, String.Empty, author, publisher)\n   { }\n\n   public Book(string title, string isbn, string author, string publisher) : base(title, publisher, PublicationType.Book)\n   {\n      // isbn argument must be a 10- or 13-character numeric string without &quot;-&quot; characters.\n      // We could also determine whether the ISBN is valid by comparing its checksum digit \n      // with a computed checksum.\n      //\n      if (! String.IsNullOrEmpty(isbn)) {\n        // Determine if ISBN length is correct.\n        if (! (isbn.Length == 10 | isbn.Length == 13))\n            throw new ArgumentException(&quot;The ISBN must be a 10- or 13-character numeric string.&quot;);\n        ulong nISBN = 0;\n        if (! UInt64.TryParse(isbn, out nISBN))\n            throw new ArgumentException(&quot;The ISBN can consist of numeric characters only.&quot;);\n      } \n      ISBN = isbn;\n\n      Author = author;\n   }\n     \n   public string ISBN { get; }\n\n   public string Author { get; }\n   \n   public Decimal Price { get; private set; }\n\n   // A three-digit ISO currency symbol.\n   public string Currency { get; private set; }\n   \n\n   // Returns the old price, and sets a new price.\n   public Decimal SetPrice(Decimal price, string currency)\n   {\n       if (price &lt; 0)\n          throw new ArgumentOutOfRangeException(&quot;The price cannot be negative.&quot;);\n       Decimal oldValue = Price;\n       Price = price;\n       \n       if (currency.Length != 3)\n          throw new ArgumentException(&quot;The ISO currency symbol is a 3-character string.&quot;);\n       Currency = currency;\n\n       return oldValue;      \n   }\n\n   public override bool Equals(object obj)\n   {\n      Book book = obj as Book;\n      if (book == null)\n         return false;\n      else\n         return ISBN == book.ISBN;   \n   }\n\n   public override int GetHashCode() =&gt; ISBN.GetHashCode();\n\n   public override string ToString() =&gt; $&quot;{(String.IsNullOrEmpty(Author) ? &quot;&quot; : Author + &quot;, &quot;)}{Title}&quot;; \n}\n</code></pre><p>In addition to the members that it inherits from <code>Publication</code>, the <code>Book</code> class defines the following unique members and member overrides:</p>\n<ul>\n<li><p>Two constructors</p>\n<p>The two <code>Book</code> constructors share three common parameters. Two, <em>title</em> and <em>publisher</em>, correspond to parameters of the <code>Publication</code> constructor. The third is <em>author</em>, which is stored to a private <code>authorName</code> field. One constructor includes an <em>isbn</em> parameter, which is stored to the private <code>id</code> field.</p>\n<p>The first constructor uses the <a href=\"../language-reference/keywords/this\" data-linktype=\"relative-path\">this</a> keyword to call the other constructor. This is a common pattern in defining constructors; constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.</p>\n<p>The second constructor uses the <a href=\"../language-reference/keywords/base\" data-linktype=\"relative-path\">base</a> keyword to pass the title and publisher name to the base class constructor. If you don&#39;t make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class&#39; default or parameterless constructor.</p>\n</li>\n<li><p>A read-only <code>ISBN</code> property, which returns the <code>Book</code> object&#39;s International Standard Book Number, a unique 10- or 13-digit number. The ISBN is supplied as an argument to one of the <code>Book</code> constructors and is stored in the private <code>id</code> field.</p>\n</li>\n<li><p>A read-only <code>Author</code> property. The author name is supplied as an argument to both <code>Book</code> constructors and is stored in the private <code>authorName</code> field.</p>\n</li>\n<li><p>Two read-only price-related properties, <code>Price</code> and <code>Currency</code>. Their values are provided as arguments in a <code>SetPrice</code> method call. The price is stored in a private field, <code>bookPrice</code>. The <code>Currency</code> property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar) and is stored in the private <code>ISOCurrencySymbol</code> field. ISO currency symbols can be retrieved from the <a class=\"xref\" href=\"../../../api/system.globalization.regioninfo#System_Globalization_RegionInfo_ISOCurrencySymbol\" data-linktype=\"relative-path\">ISOCurrencySymbol</a> property.</p>\n</li>\n<li><p>A <code>SetPrice</code> method, which sets the values of the <code>bookPrice</code> and <code>ISOCurrencySymbol</code> fields. These are the values returned by the <code>Price</code> and <code>Currency</code> properties.</p>\n</li>\n<li><p>Overrides to the <code>ToString</code> method (inherited from <code>Publication</code>) and the <a class=\"xref\" href=\"../../../api/system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a> and <a class=\"xref\" href=\"../../../api/system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a> methods (inherited from @System.Object).</p>\n<p>Unless it is overridden, the <a class=\"xref\" href=\"../../../api/system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a> method tests for reference equality. That is, two object variables are considered to be equal if they refer to the same object. In the case of the <code>Book</code> class, on the other hand, two <code>Book</code> objects should be equal if they have the same ISBN.</p>\n<p>When you override the <a class=\"xref\" href=\"../../../api/system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a> method, you must also override the <a class=\"xref\" href=\"../../../api/system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval. The hash code should return a value that&#39;s consistent with the test for equality. Since we&#39;ve overridden <a class=\"xref\" href=\"../../../api/system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a> to return <code>true</code> if the ISBN properties of two <code>Book</code> objects are equal, we return the hash code computed by calling the <a class=\"xref\" href=\"../../../api/system.string#System_String_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a> method of the string returned by the <code>ISBN</code> property.</p>\n</li>\n</ul>\n<p>The following figure illustrates the relationship between the <code>Book</code> class and <code>Publication</code>, its base class.</p>\n<p><img src=\"media/book-class.jpg\" alt=\"Publication and Book classes\" data-linktype=\"relative-path\"></p>\n<p>We can now instantiate a <code>Book</code> object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type <code>Publication</code> or of type <code>Book</code>, as the following example shows.</p>\n<pre><code name=\"Inheritance\">using System;\nusing static System.Console;\n\npublic class Example\n{\n   public static void Main()\n   {\n      var book = new Book(&quot;The Tempest&quot;,  &quot;0971655819&quot;, &quot;Shakespeare, William&quot;,\n                          &quot;Public Domain Press&quot;);\n      ShowPublicationInfo(book);\n      book.Publish(new DateTime(2016, 8, 18));\n      ShowPublicationInfo(book);\n\n      var book2 = new Book(&quot;The Tempest&quot;, &quot;Classic Works Press&quot;, &quot;Shakespeare, William&quot;);\n      Write($&quot;{book.Title} and {book2.Title} are the same publication: &quot; +\n            $&quot;{((Publication) book).Equals(book2)}&quot;);\n   }\n\n   public static void ShowPublicationInfo(Publication pub)\n   {\n       string pubDate = pub.GetPublicationDate();\n       WriteLine($&quot;{pub.Title}, &quot; +\n                 $&quot;{(pubDate == &quot;NYP&quot; ? &quot;Not Yet Published&quot; : &quot;published on &quot; + pubDate):d} by {pub.Publisher}&quot;); \n   }\n}\n// The example displays the following output:\n//        The Tempest, Not Yet Published by Public Domain Press\n//        The Tempest, published on 8/18/2016 by Public Domain Press\n//        The Tempest and The Tempest are the same publication: False\n</code></pre><h2 id=\"a-nameabstracta-designing-abstract-base-classes-and-their-derived-classes\"><a name=\"abstract\"></a> Designing abstract base classes and their derived classes</h2>\n<p>In the previous example, we defined a base class that provided an implementation for a number of methods to allow derived classes to share code. In many cases, however, the base class is not expected to provide an implementation. Instead, the base class is an <em>abstract class</em>; it serves as a template that defines the members that each derived class must implement. Typically in the case of an abstract base class, the implementation of each derived type is unique to that type.</p>\n<p>For example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape. The way in which these properties are calculated, however, depends completely on the specific shape. The formula for calculating the perimeter (or circumference) of a circle, for example, is very different from that of a triangle.</p>\n<p>The following example defines an abstract base class named <code>Shape</code> that defines two properties: <code>Area</code> and <code>Perimeter</code>. Note that, in addition to marking the class with the <a href=\"../language-reference/keywords/abstract\" data-linktype=\"relative-path\">abstract</a> keyword, each instance member is also marked with the <a href=\"../language-reference/keywords/abstract\" data-linktype=\"relative-path\">abstract</a> keyword. In this case, <code>Shape</code> also overrides the <a class=\"xref\" href=\"../../../api/system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a> method to return the name of the type, rather than its fully qualified name. And it defines two static members, <code>GetArea</code> and <code>GetPerimeter</code>, that allow callers to easily retrieve the area and perimeter of an instance of any derived class. When we pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.</p>\n<pre><code name=\"Inheritance\">using System;\n\npublic abstract class Shape\n{\n   public abstract double Area { get; }\n   \n   public abstract double Perimeter { get; }\n \n   public override string ToString() =&gt; GetType().Name;\n\n   public static double GetArea(Shape shape) =&gt; shape.Area;\n\n   public static double GetPerimeter(Shape shape) =&gt; shape.Perimeter;\n}\n</code></pre><p>We can then derive some classes from <code>Shape</code> that represent specific shapes. The following example defines three classes, <code>Triangle</code>, <code>Rectangle</code>, and <code>Circle</code>. Each uses a formula unique for that particular shape to compute the area and perimeter. Some of the derived classes also define properties, such as <code>Rectangle.Diagonal</code> and <code>Circle.Diameter</code>, that are unique to the shape that they represent.</p>\n<pre><code name=\"Inheritance\">using System;\n\npublic class Square : Shape\n{\n   public Square(double length)\n   {\n      Side = length;\n   }\n\n   public double Side { get; }  \n\n   public override double Area =&gt; Math.Pow(Side, 2); \n\n   public override double Perimeter =&gt; Side * 4;\n\n   public double Diagonal =&gt; Math.Round(Math.Sqrt(2) * Side, 2); \n}\n\npublic class Rectangle : Shape\n{\n   public Rectangle(double length, double width)\n   {\n      Length = length;\n      Width = width;\n   }\n\n   public double Length { get; }\n\n   public double Width { get; }\n\n   public override double Area =&gt; Length * Width;\n\n   public override double Perimeter =&gt; 2 * Length + 2 * Width;  \n\n   public bool IsSquare() =&gt; Length == Width;\n\n   public double Diagonal =&gt; Math.Round(Math.Sqrt(Math.Pow(Length, 2) + Math.Pow(Width, 2)), 2); \n}\n\npublic class Circle : Shape\n{\n   public Circle(double radius)\n   {\n      Radius = radius;\n   } \n\n   public override double Area =&gt; Math.Round(Math.Pow(Math.PI * Radius, 2), 2); \n\n   public override double Perimeter =&gt; Math.Round(Math.PI * 2 * Radius, 2); \n\n   // Define a circumference, since it&#39;s the more familiar term.\n   public double Circumference =&gt; Perimeter; \n\n   public double Radius { get; }\n\n   public double Diameter =&gt; Radius * 2; \n}\n</code></pre><p>The following example uses objects derived from <code>Shape</code>. It instantiates an array of objects derived from <code>Shape</code> and calls the static methods of the <code>Shape</code> class, which wraps return <code>Shape</code> property values. Note that the runtime retrieves values from the overridden properties of the derived types. The example also casts each <code>Shape</code> object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of <code>Shape</code>. </p>\n<pre><code name=\"Inheritance\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Shape[] shapes = { new Rectangle(10, 12), new Square(5),\n                        new Circle(3) };\n      foreach (var shape in shapes) {\n         Console.WriteLine($&quot;{shape}: area, {Shape.GetArea(shape)}; &quot; +\n                           $&quot;perimeter, {Shape.GetPerimeter(shape)}&quot;);\n         var rect = shape as Rectangle;\n         if (rect != null) {\n            Console.WriteLine($&quot;   Is Square: {rect.IsSquare()}, Diagonal: {rect.Diagonal}&quot;);\n            continue;\n         }\n         var sq = shape as Square;\n         if (sq != null) {\n            Console.WriteLine($&quot;   Diagonal: {sq.Diagonal}&quot;);\n            continue;\n         }\n      }   \n   }\n}\n// The example displays the following output:\n//         Rectangle: area, 120; perimeter, 44\n//            Is Square: False, Diagonal: 15.62\n//         Square: area, 25; perimeter, 20\n//            Diagonal: 7.07\n//         Circle: area, 88.83; perimeter, 18.85\n</code></pre><h2 id=\"see-also\">See also</h2>\n<p><a href=\"../tour-of-csharp/classes-and-objects\" data-linktype=\"relative-path\">Classes and objects</a><br>\n<a href=\"../programming-guide/classes-and-structs/inheritance\" data-linktype=\"relative-path\">Inheritance (C# Programming Guide)</a></p>\n</member></class></member></member></div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"rpetrusha\">\r\n<meta name=\"ms.author\" content=\"ronpet\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc.json\">\r\n<meta name=\"ms.devlang\" content=\"dotnet\">\r\n<meta name=\"ms.assetid\" content=\"aeb68c74-0ea0-406f-9fbe-2ce02d47ef31\">\r\n<meta name=\"description\" content=\"Learn to use inheritance in C# libraries and applications.\">\r\n<meta name=\"keywords\" content=\"inheritance (C#), base classes, derived classes, abstract base classes\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"03/06/2017\">\r\n<meta name=\"ms.technology\" content=\".net-core-technologies\">\r\n<meta name=\"ms.prod\" content=\".net-core\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-21 01:42 AM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/abd4eadaede26fe144b5d8f249dd9b334e5a567f/docs/csharp/tutorials/inheritance.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/csharp/tutorials/inheritance.md\">\r\n<meta name=\"document_id\" content=\"ee95f6b7-364a-857d-eaa1-eca9634902b5\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc.json\">\r\n","rawMetadata":{"author":"rpetrusha","ms.author":"ronpet","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Inheritance in C# | Microsoft Docs","ms.devlang":"dotnet","ms.assetid":"aeb68c74-0ea0-406f-9fbe-2ce02d47ef31","description":"Learn to use inheritance in C# libraries and applications.","keywords":"inheritance (C#), base classes, derived classes, abstract base classes","ms.topic":"article","ms.date":"03/06/2017","ms.technology":".net-core-technologies","ms.prod":".net-core","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Luke Latham","author_email":"GuardRex@users.noreply.github.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"dotnet new updates for MSBuild/csproj (#1649)","commit_sha":"abd4eadaede26fe144b5d8f249dd9b334e5a567f","commit_date":"2017-03-07 01:09:15 -0800"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Final corrections, corrected code snippet tag.","commit_sha":"8bb45bc026130892186f88e25940df0a10f39b26","commit_date":"2016-12-14 12:28:23 -0800"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Addressed additional comments","commit_sha":"19940ead1425b191756a856368061e67c4f597b6","commit_date":"2016-12-13 14:42:34 -0800"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Revisions to inheritance topic.","commit_sha":"efa646afdafaab6eae2683418a9b8088ca6e2a4d","commit_date":"2016-12-13 14:23:21 -0800"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Corrected another bad code snippet tag.","commit_sha":"903302577768cb8c59a2c0e79ebb97b5735a03c4","commit_date":"2016-12-09 10:57:19 -0800"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Fixed bad code reference","commit_sha":"6dc3f118f6f86f471b3ff221becc3f3fcce6d17b","commit_date":"2016-12-09 10:10:20 -0800"},{"author_name":"rpetrusha","author_email":"ronpet@microsoft.com","committer_name":"rpetrusha","comitter_email":"ronpet@microsoft.com","message":"Text, images, code for inheritance tutorial","commit_sha":"330ce47200678b92e980f8376b7aa36467dd0fa9","commit_date":"2016-12-08 18:03:38 -0800"}],"updated_at":"2017-03-21 01:42 AM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/rpetrusha","display_name":"rpetrusha","id":"10886961"},"contributors":[{"profile_url":"https://github.com/rpetrusha","display_name":"rpetrusha"},{"profile_url":"https://github.com/GuardRex","display_name":"Luke Latham","id":"1622880"}],"update_at":"3/21/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/abd4eadaede26fe144b5d8f249dd9b334e5a567f/docs/csharp/tutorials/inheritance.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/csharp/tutorials/inheritance.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/tutorials/inheritance.md","document_id":"ee95f6b7-364a-857d-eaa1-eca9634902b5","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/tutorials/inheritance","toc_asset_id":"articles/csharp/tutorials/toc.json","toc_rel":"toc.json","_op_ogTitle":"Inheritance in C#","_op_displayDate":"2017-3-6","_op_displayDate_source":"2017-03-06T00:00:00Z","_op_wordCount":5040,"_op_rawTitle":"<h1 id=\"inheritance-in-c-and-net\" sourcefile=\"docs/csharp/tutorials/inheritance.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Inheritance in C# and .NET</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/tutorials/inheritance","fileRelativePath":"articles/csharp/tutorials/inheritance.html"},"themesRelativePathToOutputRoot":"_themes/"}