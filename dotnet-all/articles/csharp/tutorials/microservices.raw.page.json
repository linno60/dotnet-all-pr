{"content":"<div><div class=\"content\">\n<h2 id=\"introduction\">Introduction</h2>\n<p>This tutorial details the tasks necessary to build and deploy\nan ASP.NET Core microservice in a Docker container. During the course\nof this tutorial, you&#39;ll learn:</p>\n<ul>\n<li>How to generate an ASP.NET Core application using Yeoman</li>\n<li>How to create a development Docker environment</li>\n<li>How to build a Docker image based on an existing image.</li>\n<li>How to deploy your service into a Docker container.</li>\n</ul>\n<p>Along the way, you&#39;ll also see some C# language features:</p>\n<ul>\n<li>How to convert C# objects into JSON payloads.</li>\n<li>How to build immutable Data Transfer Objects</li>\n<li>How to process incoming HTTP Requests and generate the HTTP Response</li>\n<li>How to work with nullable value types</li>\n</ul>\n<p>You can retrieve the code from our <a href=\"https://github.com/dotnet/docs/tree/master/samples/csharp/getting-started/WeatherMicroservice\" data-linktype=\"external\">GitHub repository.</a></p>\n<h3 id=\"why-docker\">Why Docker?</h3>\n<p>Docker makes it easy to create standard machine images to\nhost your services in a data center, or the public cloud. Docker\nenables you to configure the image, and replicate it as needed to\nscale the installation of your application.</p>\n<p>All the code in this tutorial will work in any .NET Core environment.\nThe additional tasks for a Docker installation will work for an ASP.NET\nCore application. </p>\n<h2 id=\"prerequisites\">Prerequisites</h2>\n<p>You’ll need to setup your machine to run .NET core. You can find the\ninstallation instructions on the <a href=\"https://www.microsoft.com/net/core\" data-linktype=\"external\">.NET Core</a>\npage.\nYou can run this application on Windows, Ubuntu Linux, macOS or in a Docker container. \nYou’ll need to install your favorite code editor. The descriptions below\nuse <a href=\"https://code.visualstudio.com/\" data-linktype=\"external\">Visual Studio Code</a> which is an open\nsource, cross platform editor. However, you can use whatever tools you are\ncomfortable with.</p>\n<p>You&#39;ll also need to install the Docker engine. See the \n<a href=\"http://www.docker.com/products/docker\" data-linktype=\"external\">Docker Installation page</a> \nfor instructions for your platform.\nDocker can be installed in many Linux distributions, macOS, or Windows. The page\nreferenced above contains sections to each of the available installations.</p>\n<p>Most components to be installed are done by a package manager. If you have node.js&#39;s package manager <code>npm</code> installed you can skip this step. \nOtherwise install the latest NodeJs from <a href=\"https://nodejs.org\" data-linktype=\"external\">nodejs.org</a> which will install the npm package manager. </p>\n<p>At this point you will need to install a number of command line tools that support\nASP.NET core development. The command line templates use Yeoman, Bower,\nGrunt, and Gulp. If you have them installed that is good, otherwise type the following into your favorite shell:</p>\n<p><code>npm install -g yo bower grunt-cli gulp</code></p>\n<p>The <code>-g</code> option indicates that it is a global install, and those tools are\navailable system wide. (A local install scopes the package to a single\nproject). Once you&#39;ve installed those core tools, you need to install\nthe yeoman asp.net template generators:</p>\n<p><code>npm install -g generator-aspnet</code></p>\n<h2 id=\"create-the-application\">Create the Application</h2>\n<p>Now that you&#39;ve installed all the tools, create a new asp.net core\napplication. To use the command line generator, execute the following\nyeoman command in your favorite shell:</p>\n<p><code>yo aspnet</code></p>\n<p>This command prompts you to select what Type of application you want to\ncreate. For this microservice, you want the simplest, most lightweight\nweb application possible, so select &#39;Empty Web Application&#39;. The template\nwill prompt you for a name. Select &#39;WeatherMicroservice&#39;. </p>\n<p>The template creates eight files for you:</p>\n<ul>\n<li>A .gitignore, customized for asp.net core applications.</li>\n<li>A Startup.cs file. This contains the basis of the application.</li>\n<li>A Program.cs file. This contains the entry point of the application.</li>\n<li>A WeatherMicroservice.csproj file. This is the build file for the application.</li>\n<li>A Dockerfile. This script creates a Docker image for the application.</li>\n<li>A README.md. This contains links to other asp.net core resources.</li>\n<li>A web.config file. This contains basic configuration information.</li>\n<li>A runtimeconfig.template.json file. This contains debugging settings used by IDEs.</li>\n</ul>\n<p>Now you can run the template generated application. That&#39;s done using a series\nof tools from the command line. The <code>dotnet</code> command runs the tools necessary\nfor .NET development. Each verb executes a different command</p>\n<p>The first step is to restore all the dependencies:</p>\n<pre class=\"loading\"><code class=\"lang-console\">dotnet restore\n</code></pre><p>Dotnet restore uses the NuGet package manager to install all the necessary packages\ninto the application directory. It also generates a project.json.lock file. This\nfile contains information about each package that is referenced. After restoring\nall the dependencies, you build the application:</p>\n<pre class=\"loading\"><code class=\"lang-console\">dotnet build\n</code></pre><p>And once you build the application, you run it from the command line:</p>\n<pre class=\"loading\"><code class=\"lang-console\">dotnet run\n</code></pre><p>The default configuration listens to <a href=\"http://localhost:5000\" data-linktype=\"external\">http://localhost:5000</a>. You can open a\nbrowser and navigate to that page and see a &quot;Hello World!&quot; message.</p>\n<h3 id=\"anatomy-of-an-aspnet-core-application\">Anatomy of an ASP.NET Core application</h3>\n<p>Now that you&#39;ve built the application, let&#39;s look at how this functionality\nis implemented. There are two of the generated files that are particularly\ninteresting at this point: project.json and Startup.cs. </p>\n<p>Project.json contains information about the project. The two nodes you&#39;ll\noften work with are &#39;dependencies&#39; and &#39;frameworks&#39;. The\ndependencies node lists all the packages that are needed for this application.\nAt the moment, this is a small node, needing only the packages that run the\nweb server.</p>\n<p>The &#39;frameworks&#39; node specifies the versions and configurations of the .NET\nframework that will run this application.</p>\n<p>The application is implemented in Startup.cs. This file contains the startup\nclass.</p>\n<p>The two methods are called by the asp.net core infrastructure to configure\nand run the application. The <code>ConfigureServices</code> method describes the services that are\nnecessary for this application. You&#39;re building a lean microservice, so it doesn&#39;t\nneed to configure any dependencies. The <code>Configure</code> method configures the handlers\nfor incoming HTTP Requests. The template generates a simple handler that responds\nto any request with the text &#39;Hello World!&#39;.</p>\n<h2 id=\"build-a-microservice\">Build a microservice</h2>\n<p>The service you&#39;re going to build will deliver weather reports from anywhere\naround the globe. In a production application, you&#39;d call some service\nto retrieve weather data. For our sample, we&#39;ll generate a random weather\nforecast. </p>\n<p>There are a number of tasks you&#39;ll need to perform in order to implement\nour random weather service:</p>\n<ul>\n<li>Parse the incoming request to read the latitude and longitude.</li>\n<li>Generate some random forecast data.</li>\n<li>Convert that random forecast data from C# objects into JSON packets.</li>\n<li>Set the response header to indicate that your service sends back JSON.</li>\n<li>Write the response.</li>\n</ul>\n<p>The next sections walk you through each of these steps.</p>\n<h3 id=\"parsing-the-query-string\">Parsing the Query String.</h3>\n<p>You&#39;ll begin by parsing the query string. The service will accept \n&#39;lat&#39; and &#39;long&#39; arguments on the query string in this form:</p>\n<p><code>http://localhost:5000/?lat=-35.55&amp;long=-12.35</code>  </p>\n<p>All the changes you need to make are in the lambda expression\ndefined as the argument to <code>app.Run</code> in your startup class.</p>\n<p>The argument on the lambda expression is the <code>HttpContext</code> for the\nrequest. One of its properties is the <code>Request</code> object. The <code>Request</code>\nobject has a <code>Query</code> property that contains a dictionary of all the\nvalues on the query string for the request. The first addition is to\nfind the latitude and longitude values:</p>\n<pre><code class=\"lang-csharp\" name=\"ReadQueryString\" title=\"read variables from the query string\">var latString = context.Request.Query[&quot;lat&quot;].FirstOrDefault();\nvar longString = context.Request.Query[&quot;long&quot;].FirstOrDefault();\n</code></pre><p>The Query dictionary values are <code>StringValue</code> type. That type can\ncontain a collection of strings. For your weather service, each\nvalue is a single string. That&#39;s why there&#39;s the call to <code>FirstOrDefault()</code>\nin the code above. </p>\n<p>Next, you need to convert the strings to doubles. The method you&#39;ll use\nto convert the string to a double is <code>double.TryParse()</code>:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">bool TryParse(string s, out double result);\n</code></pre><p>This method leverages C# out parameters to indicate if the input string\ncan be converted to a double. If the string does represent a valid\nrepresentation for a double, the method returns true, and the <code>result</code>\nargument contains the value. If the string does not represent a valid\ndouble, the method returns false.</p>\n<p>You can adapt that API with the use of an <em>extension method</em> that returns\na <em>nullable double</em>. A <em>nullable value type</em> is a type that represents\nsome value type, and can also hold a missing, or null value. A nullable\ntype is represented by appending the <code>?</code> character to the type declaration. </p>\n<p>Extension methods are methods that are defined as static methods, but\nby adding the <code>this</code> modifier on the first parameter, can be called as\nthough they are members of that class. Extension methods may only be\ndefined in static classes. Here&#39;s the definition of the class containing\nthe extension method for parse:</p>\n<pre><code class=\"lang-csharp\" name=\"TryParseExtension\" title=\"try parse to a nullable\">public static class Extensions\n{\n    public static double? TryParse(this string input)\n    {\n        double result;\n        if (double.TryParse(input, out result))\n        {\n            return result;\n        }\n        else\n        {\n            return default(double?);\n        }\n    }\n}\n</code></pre><p>The <code>default(double?)</code> expression returns the default value for the\n<code>double?</code> type. That default value is the null (or missing) value.</p>\n<p>You can use this extension method to convert the query string arguments\ninto the double type:</p>\n<pre><code class=\"lang-csharp\" name=\"UseTryParse\" title=\"Use the try parse extension method\">var latitude = latString.TryParse();\nvar longitude = longString.TryParse();\n</code></pre><p>To easily test the parsing code, update the response to include the values\nof the arguments:</p>\n<pre><code class=\"lang-csharp\" name=\"WriteResponse\" title=\"Write the output response\">await context.Response.WriteAsync($&quot;Retrieving Weather for lat: {latitude}, long: {longitude}&quot;);                \n</code></pre><p>At this point, you can run the web application and see if your parsing\ncode is working. Add values to the web request in a browser, and you should see\nthe updated results.</p>\n<h3 id=\"build-a-random-weather-forecast\">Build a random weather forecast</h3>\n<p>Your next task is to build a random weather forecast. Let&#39;s start with a data\ncontainer that holds the values you&#39;d want for a weather forecast:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">public class WeatherReport\n{\n    private static readonly string[] PossibleConditions = new string[]\n    {\n        &quot;Sunny&quot;,\n        &quot;Mostly Sunny&quot;,\n        &quot;Partly Sunny&quot;,\n        &quot;Partly Cloudy&quot;,\n        &quot;Mostly Cloudy&quot;,\n        &quot;Rain&quot;\n    };\n\n    public int HiTemperature { get; }\n    public int LoTemperature { get; }\n    public int AverageWindSpeed { get; }\n    public string Conditions { get; }\n}\n</code></pre><p>Next, build a constructor that randomly sets those values. This constructor uses\nthe values for the latitude and longitude to seed the Random number generator. That\nmeans the forecast for the same location is the same. If you change the arguments for\nthe latitude and longitude, you&#39;ll get a different forecast (because you start with a \ndifferent seed.)</p>\n<pre><code class=\"lang-csharp\" name=\"WeatherReportConstructor\" title=\"Weather Report Constructor\">public WeatherReport(double latitude, double longitude, int daysInFuture)\n{\n    var generator = new Random((int)(latitude + longitude) + daysInFuture);\n\n    HiTemperature = generator.Next(40, 100);\n    LoTemperature = generator.Next(0, HiTemperature);\n    AverageWindSpeed = generator.Next(0, 45);\n    Conditions = PossibleConditions[generator.Next(0, PossibleConditions.Length - 1)];\n}\n</code></pre><p>You can now generate the 5-day forecast in your response method:</p>\n<pre><code class=\"lang-csharp\" name=\"GenerateRandomReport\" title=\"Generate a random weather report\">if (latitude.HasValue &amp;&amp; longitude.HasValue)\n{\n    var forecast = new List&lt;WeatherReport&gt;();\n    for (var days = 1; days &lt; 6; days++)\n    {\n        forecast.Add(new WeatherReport(latitude.Value, longitude.Value, days));\n    }\n    var json = JsonConvert.SerializeObject(forecast, Formatting.Indented);\n    context.Response.ContentType = &quot;application/json; charset=utf-8&quot;;\n    await context.Response.WriteAsync(json);\n}\n</code></pre><h3 id=\"build-the-json-response\">Build the JSON response.</h3>\n<p>The final code task on the server is to convert the WeatherReport array\ninto a JSON packet, and send that back to the client. Let&#39;s start by creating\nthe JSON packet. You&#39;ll add the NewtonSoft JSON Serializer to the\nlist of dependencies. You can do that using the <code>dotnet</code> CLI:</p>\n<pre class=\"loading\"><code>dotnet add package Newtonsoft.Json\n</code></pre><p>Then, you can use the <code>JsonConvert</code> class to write the object to a string:</p>\n<pre><code class=\"lang-csharp\" name=\"ConvertToJson\" title=\"Convert objects to JSON\">var json = JsonConvert.SerializeObject(forecast, Formatting.Indented);\ncontext.Response.ContentType = &quot;application/json; charset=utf-8&quot;;\nawait context.Response.WriteAsync(json);\n</code></pre><p>The code above converts the forecast object (a list of <code>WeatherForecast</code>\nobjects) into a JSON packet. After you&#39;ve constructed the response packet,\nyou set the content type to <code>application/json</code>, and write the string.</p>\n<p>The application now runs and returns random forecasts.</p>\n<h2 id=\"build-a-docker-image\">Build a Docker image</h2>\n<p>Our final task is to run the application in Docker. We&#39;ll create a\nDocker container that runs a Docker image that represents our application.</p>\n<p>A <strong><em>Docker Image</em></strong> is a file that defines the environment for running the application.</p>\n<p>A <strong><em>Docker Container</em></strong> represents a running instance of a Docker image.</p>\n<p>By analogy, you can think of the <em>Docker Image</em> as a <em>class</em>, and the\n<em>Docker Container</em> as an object, or an instance of that class.  </p>\n<p>The Dockerfile created by the asp.net template will serve\nfor our purposes. Let&#39;s go over its contents.</p>\n<p>The first line specifies the source image:</p>\n<pre class=\"loading\"><code>FROM microsoft/dotnet:1.1-sdk-msbuild\n</code></pre><p>Docker allows you to configure a machine image based on a\nsource template. That means you don&#39;t have to supply all\nthe machine parameters when you start, you only need to\nsupply any changes. The changes here will be to include\nour application.</p>\n<p>In this first sample, we&#39;ll use the <code>1.1-sdk-msbuild</code> version of\nthe dotnet image. This is the easiest way to create a working Docker\nenvironment. This image include the dotnet core runtime, and the dotnet SDK. \nThat makes it easier to get started and build, but does create a larger image.</p>\n<p>The next five lines setup and build your application:</p>\n<pre class=\"loading\"><code>WORKDIR /app\n\n# copy csproj and restore as distinct layers\n\nCOPY WeatherMicroservice.csproj .\nRUN dotnet restore\n\n# copy and build everything else\n\nCOPY . .\n\n# RUN dotnet restore\nRUN dotnet publish -c Release -o out\n</code></pre><p>This will copy the project file from the  current directory to the docker VM, and restore\nall the packages. Using the dotnet CLI means that the Docker image must include the\n.NET Core SDK. After that, the rest of your application gets copied, and the dotnet\npublish command builds and packages your application.</p>\n<p>The final line of the file runs the application:</p>\n<pre class=\"loading\"><code>ENTRYPOINT [&quot;dotnet&quot;, &quot;out/WeatherMicroservice.dll&quot;, &quot;--server.urls&quot;, &quot;http://0.0.0.0:5000&quot;]\n</code></pre><p>This configured port is referenced in the <code>--server.urls</code>\nargument to <code>dotnet</code> on the last  line of the Dockerfile. The <code>ENTRYPOINT</code> command\ninforms Docker  what command and command line options start the service. </p>\n<h2 id=\"building-and-running-the-image-in-a-container\">Building and running the image in a container.</h2>\n<p>Let&#39;s build an image and run the service inside a Docker container. You don&#39;t want\nall the files from your local directory copied into the image. Instead, you&#39;ll\nbuild the application in the container. You&#39;ll create a <code>.dockerignore</code> file\nto specify the directories that are not copied into the image. You don&#39;t want\nany of the build assets copied. Specify the build and publish directories\nin the <code>.dockerignore</code> file:</p>\n<pre class=\"loading\"><code>bin/*\nobj/*\nout/*\n</code></pre><p>You build the image\nusing the docker build command. Run the following command from the directory containing your code.</p>\n<pre class=\"loading\"><code class=\"lang-console\">docker build -t weather-microservice .\n</code></pre><p>This command builds the container image based on all the information in your Dockerfile. The <code>-t</code>\nargument provides a tag, or name, for this container image. In the command line above, the\ntag used for the Docker container is <code>weather-microservice</code>. When this command completes,\nyou have a container ready to run your new service. </p>\n<div class=\"NOTE\"><h5>Note</h5><p>The copy command will copy all built assets, as well as the source for your application.\nYou should remove the <code>obj</code>, <code>bin</code>, and <code>out</code> directories from your local machine\nbefore building your Docker image.</p>\n</div>\n<p>Run the following command to start\nthe container and launch your service:</p>\n<pre class=\"loading\"><code class=\"lang-console\">docker run -d -p 80:5000 --name hello-docker weather-microservice\n</code></pre><p>The <code>-d</code> option means to run the container detached from the current terminal. That means you\nwon&#39;t see the command output in your terminal. The <code>-p</code> option indicates the port mapping between\nthe service and the host. Here it says that any incoming request on port 80 should be forwarded\nto port 5000 on the container. Using 5000 matches the port your service is listening on from\nthe command line arguments specified in the Dockerfile above. The <code>--name</code> argument\nnames your running container. It&#39;s a convenient name you can use to work with that\ncontainer. </p>\n<p>You can see if the image is running by checking the command:</p>\n<pre class=\"loading\"><code class=\"lang-console\">docker ps\n</code></pre><p>If your container is running, you&#39;ll see a line that lists\nit in the running processes. (It may be the only one).</p>\n<p>You can test your service by opening a browser and navigating to localhost, and\nspecifying a latitude and longitude:</p>\n<pre class=\"loading\"><code>http://localhost/?lat=35.5&amp;long=40.75\n</code></pre><h2 id=\"attaching-to-a-running-container\">Attaching to a running container</h2>\n<p>When you ran your sevice in a command window, you could see diagnostic information printed\nfor each request. You don&#39;t see that information when your container is running in detached\nmode. The Docker attach command enables you to attach to a running container so that you\ncan see the log information.  Run this command from a command window:</p>\n<pre class=\"loading\"><code class=\"lang-console\">docker attach --sig-proxy=false hello-docker\n</code></pre><p>The <code>--sig-proxy=false</code> argument means that <code>Ctrl-C</code> commands do not get sent to the\ncontainer process, but rather stop the <code>docker attach</code> command. The final argument\nis the name given to the container in the <code>docker run</code> command. </p>\n<div class=\"NOTE\"><h5>Note</h5><p>You can also use the docker assigned container ID to refer to any container. If you\ndidn&#39;t specify a name for your container in <code>docker run</code> you must use the container id.</p>\n</div>\n<p>Open a browser and navigate to your service. You&#39;ll see the diagnostic messages in\nthe command windows from the attached running container.</p>\n<p>Press <code>Ctrl-C</code> to stop the attach process.</p>\n<p>When you are done working with your container, you can stop it:</p>\n<pre class=\"loading\"><code class=\"lang-console\">docker stop hello-docker\n</code></pre><p>The container and image is still available for you to restart.  If you want to remove\nthe container from your machine, you use this command:</p>\n<pre class=\"loading\"><code class=\"lang-console\">docker rm hello-docker\n</code></pre><p>If you want to remove unused images from your machine, you use this command:</p>\n<pre class=\"loading\"><code class=\"lang-console\">docker rmi hello-docker\n</code></pre><h2 id=\"conclusion\">Conclusion</h2>\n<p>In this tutorial, you built an asp.net core microservice, and added a few\nsimple features.</p>\n<p>You built a docker container image for that service, and ran that container on\nyour machine. You attached a terminal window to the service, and saw the\ndiagnostic messages from your service.</p>\n<p>Along the way, you saw several features of the C# language in action.</p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc.json\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"87e93838-a363-4813-b859-7356023d98ed\">\r\n<meta name=\"description\" content=\"Learn to create asp.net core services that run in Docker containers\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core, Docker, C#, ASP.NET, Microservice\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"02/03/2017\">\r\n<meta name=\"ms.technology\" content=\"dotnet-docker\">\r\n<meta name=\"ms.prod\" content=\".net-core\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-21 01:42 AM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/3f10ca847d8e869e2ecffa91f23c4d3248be9fe9/docs/csharp/tutorials/microservices.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/csharp/tutorials/microservices.md\">\r\n<meta name=\"document_id\" content=\"02399a18-d6a2-92a7-3b1f-5a1fdeab2bec\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"toc.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Microservices hosted in Docker | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"87e93838-a363-4813-b859-7356023d98ed","description":"Learn to create asp.net core services that run in Docker containers","keywords":".NET, .NET Core, Docker, C#, ASP.NET, Microservice","ms.topic":"article","ms.date":"02/03/2017","ms.technology":"dotnet-docker","ms.prod":".net-core","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update the docker getting started topic. (#1503)","commit_sha":"3f10ca847d8e869e2ecffa91f23c4d3248be9fe9","commit_date":"2017-03-07 08:10:23 -0500"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"updates suggested during the docs bug bash (#1380)","commit_sha":"32194f2f1a4b38209180da10a712ff0f51b0b709","commit_date":"2017-01-04 11:03:18 -0500"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"William Wegerson","author_email":"github_ww@wegerson.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"The C# MicroServices tutorial left out an install of node.js's npm manager; added link to node.js. (#1219)","commit_sha":"fa800cc7ae1bf13f665e0aefe4b7571d7456dedd","commit_date":"2016-11-15 16:39:04 -0500"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"renamed repo/fixed headings (#1186)","commit_sha":"15c55a87beb64f265a164db918c7721c7690fadf","commit_date":"2016-10-29 15:23:17 -0400"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update docker tutorial (#899)","commit_sha":"ee1abc373ccbe139ce7d025fa85b853d21ab76f5","commit_date":"2016-08-15 16:41:18 -0400"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update ci build for ubuntu (#891)","commit_sha":"ce52ada663c2ed9b8b3d10bc3d4dcb453abb79f7","commit_date":"2016-08-09 16:02:13 -0400"},{"author_name":"Nicolás Herrera","author_email":"nicoherreraf@hotmail.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"style of \"GitHub repository\" link was wrong (#880)","commit_sha":"d2228a00e27109eac87c2553fd4165eda28962aa","commit_date":"2016-08-07 22:43:55 -0700"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update Samples section of contributing.md (#796)","commit_sha":"d82a5907ae4405358eccb9fd8b8dd68a3996fc74","commit_date":"2016-07-28 14:26:57 -0400"},{"author_name":"Tom Dykstra","author_email":"tdykstra@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"move tutorials folder to csharp folder (#704)","commit_sha":"9e4c8eafc7301549383306d9c679015a95f1406f","commit_date":"2016-06-29 12:23:39 -0700"}],"updated_at":"2017-03-21 01:42 AM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/CheetahChrome","display_name":"William Wegerson","id":"1110966"},{"profile_url":"https://github.com/nicolocodev","display_name":"Nicolás Herrera","id":"4001191"},{"profile_url":"https://github.com/tdykstra","display_name":"Tom Dykstra","id":"1569635"}],"update_at":"3/21/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/3f10ca847d8e869e2ecffa91f23c4d3248be9fe9/docs/csharp/tutorials/microservices.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/csharp/tutorials/microservices.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/tutorials/microservices.md","document_id":"02399a18-d6a2-92a7-3b1f-5a1fdeab2bec","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/tutorials/microservices","toc_asset_id":"articles/csharp/tutorials/toc.json","toc_rel":"toc.json","_op_ogTitle":"Microservices hosted in Docker","_op_displayDate":"2017-2-3","_op_displayDate_source":"2017-02-03T00:00:00Z","_op_wordCount":2799,"_op_rawTitle":"<h1 id=\"microservices-hosted-in-docker\" sourcefile=\"docs/csharp/tutorials/microservices.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Microservices hosted in Docker</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/tutorials/microservices","fileRelativePath":"articles/csharp/tutorials/microservices.html"},"themesRelativePathToOutputRoot":"_themes/"}