{"content":"<div><div class=\"content\">\n<p><a href=\"modern-events\" data-linktype=\"relative-path\">Previous</a></p>\n<p>Developers that are new to the .NET Core platform often struggle\nwhen deciding between a design based on <code>delegates</code> and a design\nbased on <code>events</code>. This is a difficult concept, because the two\nlanguage features are very similar. Events are even built using\nthe language support for delegates. </p>\n<p>They both offer a late binding scenario: they enable scenarios\nwhere a component communicates by calling a method that is only\nknown at runtime. They both support single and multiple subscriber\nmethods. You may find this referred to as singlecast and multicast\nsupport. They both support similar syntax for adding and removing\nhandlers. Finally, raising an event and calling a delegate use exactly the same method call syntax. They even both support the same <code>Invoke()</code>\nmethod syntax for use with the <code>?.</code> operator.</p>\n<p>With all those similarities, it is easy to have trouble determining when\nto use which.</p>\n<h2 id=\"listening-to-events-is-optional\">Listening to Events is Optional</h2>\n<p>The most important consideration in determining which language feature\nto use is whether or not there must be an attached subscriber. If your\ncode must call the code supplied by the subscriber, you should\nuse a design based on delegates. If your code can complete all its\nwork without calling any subscribers, you should use a\ndesign based on events. </p>\n<p>Consider the examples built during this section. The code you built\nusing <code>List.Sort()</code> must be given a comparer function in order to\nproperly sort the elements. LINQ queries must be supplied with delegates\nin order to determine what elements to return. Both used a design built\nwith delegates.</p>\n<p>Consider the <code>Progress</code> event. It reports progress on a task.\nThe task continues to proceed whether or not there are any listeners.\nThe <code>FileSearcher</code> is another example. It would still search and find\nall the files that were sought, even with no event subscribers attached.\nUX controls still work correctly, even when there are no subscribers\nlistening to the events. They both use designs based on events.</p>\n<h2 id=\"return-values-require-delegates\">Return Values Require Delegates</h2>\n<p>Another consideration is the method prototype you would want for your\ndelegate method. As you&#39;ve seen, the delegates used for events all\nhave a void return type. You&#39;ve also seen that there are idioms to\ncreate event handlers that do pass information back to event sources\nthrough modifying properties of the event argument object. While these\nidioms do work, they are not as natural as returning a value from a\nmethod.</p>\n<p>Notice that these two heuristics may often both be present: If your\ndelegate method returns a value, it will likely impact the algorithm\nin some way.</p>\n<h2 id=\"event-listeners-often-have-longer-lifetimes\">Event Listeners Often Have Longer Lifetimes</h2>\n<p>This is a slightly weaker justification. However, you may find that\nevent-based designs are more natural when the event source will be\nraising events over a long period of time. You can see examples of\nthis for UX controls on many systems. Once you subscribe to an event,\nthe event source may raise events throughout the lifetime of the program.\n(You can unsubscribe from events when you no longer need them.)</p>\n<p>Contrast that with many delegate-based designs, where a delegate is\nused as an argument to a method, and the delegate is not used after that\nmethod returns.</p>\n<h2 id=\"evaluate-carefully\">Evaluate Carefully</h2>\n<p>The above considerations are not hard and fast rules. Instead, they\nrepresent guidance that can help you decide which choice is best for\nyour particular usage. Because they are similar, you can even\nprototype both, and consider which would be more natural to work\nwith. They both handle late binding scenarios well. Use the one\nthat communicates your design the best.</p>\n</div></div>","outputRootRelativePath":"../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"0fdc8629-2fdb-4a7c-a433-5b9d04eaf911\">\r\n<meta name=\"description\" content=\"Distinguising Delegates and Events\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"06/20/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/distinguish-delegates-events.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/distinguish-delegates-events.md\">\r\n<meta name=\"document_id\" content=\"4248aa3f-9f1e-cfa2-659b-da7fecf5d378\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":"Distinguising Delegates and Events | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"0fdc8629-2fdb-4a7c-a433-5b9d04eaf911","description":"Distinguising Delegates and Events","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"06/20/2016","ms.technology":"devlang-csharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"update names per naming guidelines. (#1012)","commit_sha":"59cb2f6799814e37aa02ca35e719329a8af49a20","commit_date":"2016-09-08 14:53:56 -0400"},{"author_name":"Petr Onderka","author_email":"gsvick@gmail.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@users.noreply.github.com","message":"Corrected titles and headings (#690)","commit_sha":"17cac6e7690fd2b08d9f5f73060056d14bca13d2","commit_date":"2016-06-28 12:36:36 -0700"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"Rich Lander","comitter_email":"rlander@microsoft.com","message":"Promote csharp from languages (#644)","commit_sha":"2d44b7e04c0fe2ca136ba6dfa9fc3a4368365ec8","commit_date":"2016-06-26 08:30:56 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/svick","display_name":"Petr Onderka","id":"287848"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/distinguish-delegates-events.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/distinguish-delegates-events.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/distinguish-delegates-events.md","document_id":"4248aa3f-9f1e-cfa2-659b-da7fecf5d378","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/distinguish-delegates-events","toc_asset_id":"articles/toc.json","toc_rel":"../toc.json","_op_ogTitle":"Distinguising Delegates and Events","_op_displayDate":"2016-6-20","_op_displayDate_source":"2016-06-20T00:00:00Z","_op_wordCount":594,"_op_rawTitle":"<h1 id=\"distinguising-delegates-and-events\" sourcefile=\"docs/csharp/distinguish-delegates-events.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Distinguising Delegates and Events</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/distinguish-delegates-events","fileRelativePath":"articles/csharp/distinguish-delegates-events.html"},"themesRelativePathToOutputRoot":"_themes/"}