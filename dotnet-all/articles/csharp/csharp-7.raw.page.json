{"content":"<div><div class=\"content\">\n<p>C# 7 adds a number of new features to the C# language:</p>\n<ul>\n<li><a href=\"#out-variables\" data-linktype=\"self-bookmark\"><code>out</code> variables</a>:<ul>\n<li>You can declare <code>out</code> values inline as arguments to the method where they are used.</li>\n</ul>\n</li>\n<li><a href=\"#tuples\" data-linktype=\"self-bookmark\">Tuples</a><ul>\n<li>You can create lightweight, unnamed types that contain multiple public fields. Compilers and IDE tools understand the semantics of these types.</li>\n</ul>\n</li>\n<li><a href=\"#pattern-matching\" data-linktype=\"self-bookmark\">Pattern Matching</a><ul>\n<li>You can create branching logic based on arbitrary types and values of the members of those types.</li>\n</ul>\n</li>\n<li><a href=\"#ref-locals-and-returns\" data-linktype=\"self-bookmark\"><code>ref</code> locals and returns</a><ul>\n<li>Method arguments and local variables can be references to other storage.</li>\n</ul>\n</li>\n<li><a href=\"#local-functions\" data-linktype=\"self-bookmark\">Local Functions</a><ul>\n<li>You can nest functions inside other functions to limit their scope and visibility.</li>\n</ul>\n</li>\n<li><a href=\"#more-expression-bodied-members\" data-linktype=\"self-bookmark\">More expression-bodied members</a><ul>\n<li>The list of members that can be authored using expressions has grown.</li>\n</ul>\n</li>\n<li><a href=\"#throw-expressions\" data-linktype=\"self-bookmark\"><code>throw</code> Expressions</a><ul>\n<li>You can throw exceptions in code constructs that previously were not allowed because <code>throw</code> was a statement. </li>\n</ul>\n</li>\n<li><a href=\"#generalized-async-return-types\" data-linktype=\"self-bookmark\">Generalized async return types</a><ul>\n<li>Methods declared with the <code>async</code> modifier can return other types in addition to <code>Task</code> and <code>Task&lt;T&gt;</code>.</li>\n</ul>\n</li>\n<li><a href=\"#numeric-literal-syntax-improvements\" data-linktype=\"self-bookmark\">Numeric literal syntax improvements</a><ul>\n<li>New tokens improve readability for numeric constants.</li>\n</ul>\n</li>\n</ul>\n<p>The remainder of this topic discusses each of the features. For each feature,\nyou&#39;ll learn the reasoning behind it. You&#39;ll learn the syntax. You&#39;ll see\nsome sample scenarios where using the new feature will make you more \nproductive as a developer. </p>\n<h2 id=\"out-variables\"><code>out</code> variables</h2>\n<p>The existing syntax that supports <code>out</code> parameters has been improved\nin this version.  </p>\n<p>Previously, you would need to separate the declaration of the out variable\nand its initialization into two different statements:</p>\n<pre><code class=\"lang-csharp\" name=\"OutVariableOldStyle\" title=\"classic out variable declaration\">int numericResult;\nif (int.TryParse(input, out numericResult))\n    WriteLine(numericResult);\nelse\n    WriteLine(&quot;Could not parse input&quot;);\n\n</code></pre><p>You can now declare <code>out</code> variables in the argument list of a method call,\nrather than writing a separate declaration statement:</p>\n<pre><code class=\"lang-csharp\" name=\"OutVariableDeclarations\" title=\"Out variable declarations\">if (int.TryParse(input, out int result))\n    WriteLine(result);\nelse\n    WriteLine(&quot;Could not parse input&quot;);\n</code></pre><p>You may want to specify the type of the <code>out</code> variable for clarity,\nas shown above. However, the language does support using an implicitly\ntyped local variable:</p>\n<pre><code class=\"lang-csharp\" name=\"OutVarVariableDeclarations\" title=\"Implicitly typed Out variable\">if (int.TryParse(input, out var answer))\n    WriteLine(answer);\nelse\n    WriteLine(&quot;Could not parse input&quot;);\n</code></pre><ul>\n<li>The code is easier to read. <ul>\n<li>You declare the out variable where you use it, not on another line above.</li>\n</ul>\n</li>\n<li>No need to assign an initial value.<ul>\n<li>By declaring the <code>out</code> variable where it is used in a method call, you can&#39;t accidentally use it before it is assigned.</li>\n</ul>\n</li>\n</ul>\n<p>The most common use for this feature will be the <code>Try</code> pattern. In this\npattern, a method returns a <code>bool</code> indicating success or failure and an\n<code>out</code> variable that provides the result if the method succeeds.</p>\n<p>When using the <code>out</code> variable declaration, the declared variable &quot;leaks&quot; into the outer scope of the if statement. This allows you to use the variable afterwards:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">if (!int.TryParse(input, out int result))\n{    \n    return null;\n}\n\nreturn result;\n</code></pre><h2 id=\"tuples\">Tuples</h2>\n<p>C# provides a rich syntax for classes and structs that is used to explain\nyour design intent. But sometimes that rich syntax requires extra\nwork with minimal benefit. You may often write methods that need a simple\nstructure containing more than one data element. To support these scenarios\n<em>tuples</em> were added to C#. Tuples are lightweight data structures\nthat contain multiple fields to represent the data members.\nThe fields are not validated, and you cannot define your own methods</p>\n<div class=\"NOTE\"><h5>Note</h5><p>Tuples were available before C# 7 as an API, but had many limitations.\nMost importantly, the members of these tuples were named \n<code>Item1</code>, <code>Item2</code> and so on. The language support enables semantic names\nfor the fields of a Tuple.</p>\n</div>\n<p>You can create a tuple by assigning each member to a value:</p>\n<pre><code class=\"lang-csharp\" name=\"UnnamedTuple\" title=\"Unnamed tuple\">var letters = (&quot;a&quot;, &quot;b&quot;);\n</code></pre><p>That assignment creates a tuple whose members are <code>Item1</code> and <code>Item2</code>,\nfollowing the existing <a class=\"xref\" href=\"../../api/system.tuple\" data-linktype=\"relative-path\">Tuple</a> syntax.\nYou can modify that assignment to create a tuple that provides semantic\nnames to each of the members of the tuple:</p>\n<pre><code class=\"lang-csharp\" name=\"NamedTuple\" title=\"Named tuple\">(string Alpha, string Beta) namedLetters = (&quot;a&quot;, &quot;b&quot;);\n</code></pre><div class=\"NOTE\"><h5>Note</h5><p>The new tuples features require the <code>System.ValueTuple</code> type. For Visual Studio 15\nPreview 5 and earlier preview releases, you must add the NuGet package &quot;System.ValueTuple&quot;,\navailable in the pre-release stream.</p>\n</div>\n<p>The <code>namedLetters</code> tuple contains fields referred to as <code>Alpha</code> and\n<code>Beta</code>. In a tuple assignment, you can also specify the names of the fields\non the right-hand side of the assignment:</p>\n<pre><code class=\"lang-csharp\" name=\"ImplicitNamedTuple\" title=\"Implicitly named tuple\">var alphabetStart = (Alpha: &quot;a&quot;, Beta: &quot;b&quot;);\n</code></pre><p>The language allows you to specify names for the fields on both the\nleft and right-hand side of the assignment:</p>\n<pre><code class=\"lang-csharp\" name=\"NamedTupleConflict\" title=\"Named tuple conflict\">(string First, string Second) firstLetters = (Alpha: &quot;a&quot;, Beta: &quot;b&quot;);\n</code></pre><p>The line above generates a warning, <code>CS8123</code>, telling you that the names on the right\nside of the assignment, <code>Alpha</code> and <code>Beta</code> are ignored because they conflict\nwith the names on the left side, <code>First</code> and <code>Second</code>.</p>\n<p>The examples above show the basic syntax to declare tuples. Tuples are\nmost useful as return types for <code>private</code> and <code>internal</code> methods. Tuples\nprovide a simple syntax for those methods to return multiple discrete values:\nYou save the work of authoring a <code>class</code> or a <code>struct</code> that\ndefines the type returned. There is no need for creating a new type.</p>\n<p>Creating a tuple is more efficient and more productive.\nIt is a simpler, lightweight syntax to define a data structure that carries\nmore than one value. The example method below returns the minimum and maximum\nvalues found in a sequence of integers:</p>\n<pre><code class=\"lang-csharp\" name=\"TupleReturningMethod\" title=\"Tuple returning method\">private static (int Max, int Min) Range(IEnumerable&lt;int&gt; numbers)\n{\n    int min = int.MaxValue;\n    int max = int.MinValue;\n    foreach(var n in numbers)\n    {\n        min = (n &lt; min) ? n : min;\n        max = (n &gt; max) ? n : max;\n    }\n    return (max, min);\n}\n</code></pre><p>Using tuples in this way offers several advantages:</p>\n<ul>\n<li>You save the work of authoring a <code>class</code> or a <code>struct</code> that defines the type returned. </li>\n<li>You do not need to create new type.</li>\n<li>The language enhancements removes the need to call the <a class=\"xref\" href=\"../../api/system.tuple#System_Tuple_Create__1___0_\" data-linktype=\"relative-path\">Create&lt;T1&gt;(T1)</a> methods.</li>\n</ul>\n<p>The declaration for the method provides the names for the fields of the\ntuple that is returned. When you call the method, the return value is a \ntuple whose fields are <code>Max</code> and <code>Min</code>:</p>\n<pre><code class=\"lang-csharp\" name=\"CallingTupleMethod\" title=\"Calling a tuple returning method\">var range = Range(numbers);\n</code></pre><p>There may be times when you want to unpackage the members of a tuple that\nwere returned from a method.  You can do that by declaring separate variables\nfor each of the values in the tuple. This is called <em>deconstructing</em> the tuple:</p>\n<pre><code class=\"lang-csharp\" name=\"CallingWithDeconstructor\" title=\"Deconstructing a tuple\">(int max, int min) = Range(numbers);\n</code></pre><!-- Add wildcards here, if they are in C# 7\n-->\n\n<p>You can also provide a similar deconstruction for any type in .NET. This is\ndone by writing a <code>Deconstruct</code> method as a member of the class. That\n<code>Deconstruct</code> method provides a set of <code>out</code> arguments for each of the\nproperties you want to extract. Consider\nthis <code>Point</code> class that provides a deconstructor method that extracts\nthe <code>X</code> and <code>Y</code> coordinates:</p>\n<pre><code class=\"lang-csharp\" name=\"PointWithDeconstruction\" title=\"Point with deconstruction method\">public class Point\n{\n    public Point(double x, double y)\n    {\n        this.X = x;\n        this.Y = y;\n    }\n\n    public double X { get; }\n    public double Y { get; }\n\n    public void Deconstruct(out double x, out double y)\n    {\n        x = this.X;\n        y = this.Y;\n    }\n}\n</code></pre><p>You can extract the individual fields by assigning a tuple to a <code>Point</code>:</p>\n<pre><code class=\"lang-csharp\" name=\"DeconstructPoint\" title=\"Deconstruct a point\">var p = new Point(3.14, 2.71);\n(double X, double Y) = p;\n</code></pre><p>You are not bound by the names defined in the <code>Deconstruct</code> method. You\ncan rename the extract variables as part of the assignment:  </p>\n<pre><code class=\"lang-csharp\" name=\"DeconstructNames\" title=\"Deconstruct with new names\">(double horizontalDistance, double verticalDistance) = p;\n</code></pre><p>You can learn more in depth about tuples in the\n<a href=\"tuples\" data-linktype=\"relative-path\">tuples topic</a>.</p>\n<h2 id=\"pattern-matching\">Pattern matching</h2>\n<p><em>Pattern matching</em> is a feature that allows you to implement method dispatch on\nproperties other than the type of an object. You&#39;re probably already familiar\nwith method dispatch based on the type of an object. In Object Oriented programming,\nvirtual and override methods provide language syntax to implement method dispatching\nbased on an object&#39;s type. Base and Derived classes provide different implementations. \nPattern matching expressions extend this concept so that you can easily\nimplement similar dispatch patterns for types and data elements that are\nnot related through an inheritance hierarchy. </p>\n<p>Pattern matching supports <code>is</code> expressions and <code>switch</code> expressions. Each\nenables inspecting an object and its properties to determine if that object\nsatisfies the sought pattern. You use the <code>when</code> keyword to specify additional\nrules to the pattern.</p>\n<h3 id=\"is-expressions\"><code>is</code> expressions</h3>\n<p>The <code>is</code> pattern expressions extend the familiar <code>is</code> operator\nto query a object beyond its type.</p>\n<p>Let&#39;s start with a simple scenario. We&#39;ll add capabilities to this scenario\nthat demonstrate how pattern matching expressions make algorithms that work\nwith unrelated types easy. We&#39;ll start with a method that computes the sum\nof a number of die rolls:</p>\n<pre><code class=\"lang-csharp\" name=\"SumDieRolls\" title=\"Sum die rolls\">public static int DiceSum(IEnumerable&lt;int&gt; values)\n{\n    return values.Sum();\n}\n</code></pre><p>You might quickly find that you need to find the sum of die rolls where\nsome of the rolls are made with more than one die. Part of the input\nsequence may be multiple results instead of a single number:</p>\n<pre><code class=\"lang-csharp\" name=\"SumDieRollsWithGroups\" title=\"Sum die rolls with groups\">public static int DiceSum2(IEnumerable&lt;object&gt; values)\n{\n    var sum = 0;\n    foreach(var item in values)\n    {\n        if (item is int val)\n            sum += val;\n        else if (item is IEnumerable&lt;object&gt; subList)\n            sum += DiceSum2(subList);\n    }\n    return sum;\n}\n</code></pre><p>The <code>is</code> pattern expression works quite well in this scenario. As part of\nchecking the type, you write a variable initialization. This creates\na new variable of the validated runtime type.</p>\n<p>As you keep extending these scenarios, you may find that you build more\n<code>if</code> and <code>else if</code> statements. Once that becomes unwieldy, you&#39;ll likely\nwant to switch to <code>switch</code> pattern expressions.</p>\n<h3 id=\"switch-statement-updates\"><code>switch</code> statement updates</h3>\n<p>The <em>match expression</em> has a familiar syntax, based on the <code>switch</code>\nstatement already part of the C# language. Let&#39;s translate the existing code\nto use a match expression before adding new cases: </p>\n<pre><code class=\"lang-csharp\" name=\"SumUsingSwitch\" title=\"Sum using switch\">public static int DiceSum3(IEnumerable&lt;object&gt; values)\n{\n    var sum = 0;\n    foreach (var item in values)\n    {\n        switch (item)\n        {\n            case int val:\n                sum += val;\n                break;\n            case IEnumerable&lt;object&gt; subList:\n                sum += DiceSum3(subList);\n                break;\n        }\n    }\n    return sum;\n}\n</code></pre><p>The match expressions have a slightly different syntax than the <code>is</code> expressions, where\nyou declare the type and variable at the beginning of the <code>case</code> expression.</p>\n<p>The match expressions also support constants. This can save time by\nfactoring out simple cases:</p>\n<pre><code class=\"lang-csharp\" name=\"SwitchWithConstants\" title=\"Switch with constants\">public static int DiceSum4(IEnumerable&lt;object&gt; values)\n{\n    var sum = 0;\n    foreach (var item in values)\n    {\n        switch (item)\n        {\n            case 0:\n                break;\n            case int val:\n                sum += val;\n                break;\n            case IEnumerable&lt;object&gt; subList when subList.Any():\n                sum += DiceSum4(subList);\n                break;\n            case IEnumerable&lt;object&gt; subList:\n                break;\n            case null:\n                break;\n            default:\n                throw new InvalidOperationException(&quot;unknown item type&quot;);\n        }\n    }\n    return sum;\n}\n</code></pre><p>The code above adds cases for <code>0</code> as a special case of <code>int</code>, and <code>null</code>\nas a special case when there is no input. This demonstrates one important\nnew feature in switch pattern expressions: the order of the <code>case</code>\nexpressions now matters. The <code>0</code> case must appear before the general <code>int</code>\ncase. Otherwise, the first pattern to match would be the <code>int</code> case,\neven when the value is <code>0</code>. If you acccidentally order match expressions such\nthat a later case has already been handled, the compiler will flag that\nand generate an error.</p>\n<p>This same behavior enables the special case for an empty input sequence.\nYou can see that the case for an <code>IEnumerable</code> item that has elements\nmust appear before the general <code>IEnumerable</code> case.</p>\n<p>This version has also added a <code>default</code> case. The <code>default</code> case is always\nevaluated last, regardless of the order it appears in the source. For that\nreason, convention is to put the <code>default</code> case last.</p>\n<p>Finally, let&#39;s add one last <code>case</code> for a new style of die. Some games\nuse percentile dice to represent larger ranges of numbers. </p>\n<div class=\"NOTE\"><h5>Note</h5><p>Two 10-sided percentile dice can represent every number from 0\nthrough 99. One die has sides labelled <code>00</code>, <code>10</code>, <code>20</code>, ... <code>90</code>. The other\ndie has sides labeled <code>0</code>, <code>1</code>, <code>2</code>, ... <code>9</code>. Add the two die values\ntogether and you can get every number from 0 through 99.</p>\n</div>\n<p>To add this kind of die to your collection, first define a type to represent\nthe percentile die:</p>\n<pre><code class=\"lang-csharp\" name=\"18_PercentileDie\" title=\"Percentile Die type\">public struct PercentileDie\n{\n    public int Value { get; }\n    public int Multiplier { get; }\n\n    public PercentileDie(int multiplier, int value)\n    {\n        this.Value = value;\n        this.Multiplier = multiplier;\n    }\n}\n</code></pre><p>Then, add a <code>case</code> match expression for the new type:</p>\n<pre><code class=\"lang-csharp\" name=\"SwitchWithNewTypes\" title=\"Include Percentile Die type\">public static int DiceSum5(IEnumerable&lt;object&gt; values)\n{\n    var sum = 0;\n    foreach (var item in values)\n    {\n        switch (item)\n        {\n            case 0:\n                break;\n            case int val:\n                sum += val;\n                break;\n            case PercentileDie die:\n                sum += die.Multiplier * die.Value;\n                break;\n            case IEnumerable&lt;object&gt; subList when subList.Any():\n                sum += DiceSum5(subList);\n                break;\n            case IEnumerable&lt;object&gt; subList:\n                break;\n            case null:\n                break;\n            default:\n                throw new InvalidOperationException(&quot;unknown item type&quot;);\n        }\n    }\n    return sum;\n}\n</code></pre><p>The new syntax for pattern matching expressions makes it easier to create\ndispatch algorithms based on an object&#39;s type, or other properties, using\na clear and concise syntax. Pattern matching expressions enable these\nconstructs on data types that are unrelated by inheritance.</p>\n<p>You can learn more about pattern matching in the topic\ndedicated to <a href=\"pattern-matching\" data-linktype=\"relative-path\">pattern matching in C#</a>.</p>\n<h2 id=\"ref-locals-and-returns\">Ref locals and returns</h2>\n<p>This feature enables algorithms that use and return references\nto variables defined elsewhere. One example is working with\nlarge matrices, and finding a single location with certain\ncharacteristics. One method would return the two indices for\na single location in the matrix:</p>\n<pre><code class=\"lang-csharp\" name=\"FindReturningIndices\" title=\"Find returning indices\">public static (int i, int j) Find(int[,] matrix, Func&lt;int, bool&gt; predicate)\n{\n    for (int i = 0; i &lt; matrix.GetLength(0); i++)\n        for (int j = 0; j &lt; matrix.GetLength(1); j++)\n            if (predicate(matrix[i, j]))\n                return (i, j);\n    return (-1, -1); // Not found\n}\n</code></pre><p>There are many issues with this code. First of all, it&#39;s a public\nmethod that&#39;s returning a tuple. The language supports this, but\nuser defined types (either classes or structs) are preferred\nfor public APIs.</p>\n<p>Second, this method is returning the indices to the item in the matrix.\nThat leads callers to write code that uses those indices to dereference\nthe matrix and modify a single element:</p>\n<pre><code class=\"lang-csharp\" name=\"UpdateItemFromIndices\" title=\"Update Item From Indices\">var indices = MatrixSearch.Find(matrix, (val) =&gt; val == 42);\nConsole.WriteLine(indices);\nmatrix[indices.i, indices.j] = 24;\n</code></pre><p>You&#39;d rather write a method that returns a <em>reference</em>\nto the element of the matrix that you want to change. You could only accomplish\nthis by using unsafe code and returning a pointer to an <code>int</code> in previous versions.</p>\n<p>Let&#39;s walk through a series of changes to demonstrate the ref local feature\nand show how to create a method that returns a reference to internal storage.\nAlong the way, you&#39;ll learn the rules of the ref return and ref local feature that\nprotects you from accidentally misusing it.</p>\n<p>Start by modifying the <code>Find</code> method declaration so that it returns a <code>ref int</code>\ninstead of a tuple. Then, modify the return statement so it returns the value\nstored in the matrix instead of the two indices:</p>\n<pre class=\"loading\"><code class=\"lang-csharp\">// Note that this won&#39;t compile. \n// Method declaration indicates ref return,\n// but return statement specifies a value return.\npublic static ref int Find2(int[,] matrix, Func&lt;int, bool&gt; predicate)\n{\n    for (int i = 0; i &lt; matrix.GetLength(0); i++)\n        for (int j = 0; j &lt; matrix.GetLength(1); j++)\n            if (predicate(matrix[i, j]))\n                return matrix[i, j];\n    throw new InvalidOperationException(&quot;Not found&quot;);\n}\n</code></pre><p>When you declare that a method returns a <code>ref</code> variable, you must also\nadd the <code>ref</code> keyword to each return statement. That indicates return\nby reference, and helps developers reading the code later remember that\nthe method returns by reference:</p>\n<pre><code class=\"lang-csharp\" name=\"FindReturningRef\" title=\"Find returning by reference\">public static ref int Find3(int[,] matrix, Func&lt;int, bool&gt; predicate)\n{\n    for (int i = 0; i &lt; matrix.GetLength(0); i++)\n        for (int j = 0; j &lt; matrix.GetLength(1); j++)\n            if (predicate(matrix[i, j]))\n                return ref matrix[i, j];\n    throw new InvalidOperationException(&quot;Not found&quot;);\n}\n</code></pre><p>Now that the method returns a reference to the integer value in the\nmatrix, you need to modify where it&#39;s called.  The <code>var</code> declaration\nmeans that <code>valItem</code> is now an <code>int</code> rather than a tuple:</p>\n<pre><code class=\"lang-csharp\" name=\"AssignRefReturnToValue\" title=\"Assign ref return to value\">var valItem = MatrixSearch.Find3(matrix, (val) =&gt; val == 42);\nConsole.WriteLine(valItem);\nvalItem = 24;\nConsole.WriteLine(matrix[4, 2]);\n</code></pre><p>The second <code>WriteLine</code> statement in the example above prints out the value <code>42</code>,\nnot <code>24</code>. The variable <code>valItem</code> is an <code>int</code>, not a <code>ref int</code>. The <code>var</code>\nkeyword enables the compiler to specify the type, but will not implicitly\nadd the <code>ref</code> modifier. Instead, the value referred to by the <code>ref return</code>\nis <em>copied</em> to the variable on the left-hand side of the assignment. The\nvariable is not a <code>ref</code> local.</p>\n<p>In order to get the result you want, you need to add the <code>ref</code> modifier\nto the local variable declaration to make the variable a reference when\nthe return value is a reference:</p>\n<pre><code class=\"lang-csharp\" name=\"AssignRefReturn\" title=\"Assign ref return\">ref var item = ref MatrixSearch.Find3(matrix, (val) =&gt; val == 42);\nConsole.WriteLine(item);\nitem = 24;\nConsole.WriteLine(matrix[4, 2]);\n</code></pre><p>Now, the second <code>WriteLine</code> statement in the example above will print \nout the value <code>24</code>, indicating that the storage in the matrix has been\nmodified. The local variable has been declared with the <code>ref</code> modifier,\nand it will take a <code>ref</code> return. You must initialize a <code>ref</code> variable when\nit is declared, you cannot split the declaration and the initialization.</p>\n<p>The C# language has two other rules that protect you from misusing\nthe <code>ref</code> locals and returns:</p>\n<ul>\n<li>You cannot assign a value to a <code>ref</code> variable.<ul>\n<li>That disallows statements like <code>ref int i = sequence.Count();</code></li>\n</ul>\n</li>\n<li>You cannot return a <code>ref</code> to a variable whose lifetime does not extend beyond the execution of the method.<ul>\n<li>That means you cannot return a reference to a local variable, or similar scope.</li>\n</ul>\n</li>\n</ul>\n<p>These rules ensure that you cannot accidentally mix value variables and\nreference variables. They also ensure that you cannot have a reference\nvariable refer to storage that is a candidate for garbage collection.</p>\n<p>The addition of ref locals and ref returns enable algorithms that are more\nefficient by avoiding copying values, or performing dereferencing operations\nmultiple times. </p>\n<h2 id=\"local-functions\">Local functions</h2>\n<p>Many designs for classes include methods that are called from only\none location. These additional private methods keep each method small\nand focused. However, they can make it harder to understand a class\nwhen reading it the first time. These methods must be understood\noutside of the context of the single calling location.</p>\n<p>For those designs, <em>local functions</em> enable you to declare methods\ninside the context of another method. This makes it easier for readers\nof the class to see that the local method is only called from the context\nin which is it declared.</p>\n<p>There are two very common use cases for local functions: public iterator\nmethods and public async methods. Both types of methods generate\ncode that reports errors later than programmers might expect. In\nthe case of iterator methods, any exceptions are observed only\nwhen calling code that enumerates the returned sequence. In the case\nof async methods, any exceptions are only observed when the returned\n<code>Task</code> is awaited.</p>\n<p>Let&#39;s start with an iterator method:</p>\n<pre><code class=\"lang-csharp\" name=\"IteratorMethod\" title=\"Iterator method\">public static IEnumerable&lt;char&gt; AlphabetSubset(char start, char end)\n{\n    if ((start &lt; &#39;a&#39;) || (start &gt; &#39;z&#39;))\n        throw new ArgumentOutOfRangeException(paramName: nameof(start), message: &quot;start must be a letter&quot;);\n    if ((end &lt; &#39;a&#39;) || (end &gt; &#39;z&#39;))\n        throw new ArgumentOutOfRangeException(paramName: nameof(end), message: &quot;end must be a letter&quot;);\n\n    if (end &lt;= start)\n        throw new ArgumentException($&quot;{nameof(end)} must be greater than {nameof(start)}&quot;);\n    for (var c = start; c &lt; end; c++)\n        yield return c;\n}\n</code></pre><p>Examine the code below that calls the iterator method incorrectly:</p>\n<pre><code class=\"lang-csharp\" name=\"CallIteratorMethod\" title=\"Call iterator method\">var resultSet = Iterator.AlphabetSubset(&#39;f&#39;, &#39;a&#39;);\nConsole.WriteLine(&quot;iterator created&quot;);\nforeach (var thing in resultSet)\n    Console.Write($&quot;{thing}, &quot;);\n</code></pre><p>The exception is thrown when <code>resultSet</code> is iterated, not when <code>resultSet</code> is created.\nIn this contained example, most developers could quickly diagnose the\nproblem. However, in larger codebases, the code that creates an iterator\noften isn&#39;t as close to the code that enumerates the result. You can\nrefactor the code so that the public method validates all arguments,\nand a private method generates the enumeration:</p>\n<pre><code class=\"lang-csharp\" name=\"IteratorMethodRefactored\" title=\"Iterator method refactored\">public static IEnumerable&lt;char&gt; AlphabetSubset2(char start, char end)\n{\n    if ((start &lt; &#39;a&#39;) || (start &gt; &#39;z&#39;))\n        throw new ArgumentOutOfRangeException(paramName: nameof(start), message: &quot;start must be a letter&quot;);\n    if ((end &lt; &#39;a&#39;) || (end &gt; &#39;z&#39;))\n        throw new ArgumentOutOfRangeException(paramName: nameof(end), message: &quot;end must be a letter&quot;);\n\n    if (end &lt;= start)\n        throw new ArgumentException($&quot;{nameof(end)} must be greater than {nameof(start)}&quot;);\n    return alphabetSubsetImplementation(start, end);\n}\n\nprivate static IEnumerable&lt;char&gt; alphabetSubsetImplementation(char start, char end)\n{ \n    for (var c = start; c &lt; end; c++)\n        yield return c;\n}\n</code></pre><p>This refactored version will throw exceptions immediately because the public\nmethod is not an iterator method; only the private method uses the\n<code>yield return</code> syntax. However, there are potential problems with this\nrefactoring. The private method should only be called from the public\ninterface method, because otherwise all argument validation is skipped.\nReaders of the class must discover this fact by reading the entire class\nand searching for any other references to the <code>alphabetSubsetImplementation</code> \nmethod.</p>\n<p>You can make that design intent more clear by declaring the \n<code>alphabetSubsetImplementation</code> as a local function inside the public\nAPI method:</p>\n<pre><code class=\"lang-csharp\" name=\"22_IteratorMethodLocal\" title=\"Iterator method with local function\">public static IEnumerable&lt;char&gt; AlphabetSubset3(char start, char end)\n{\n    if ((start &lt; &#39;a&#39;) || (start &gt; &#39;z&#39;))\n        throw new ArgumentOutOfRangeException(paramName: nameof(start), message: &quot;start must be a letter&quot;);\n    if ((end &lt; &#39;a&#39;) || (end &gt; &#39;z&#39;))\n        throw new ArgumentOutOfRangeException(paramName: nameof(end), message: &quot;end must be a letter&quot;);\n\n    if (end &lt;= start)\n        throw new ArgumentException($&quot;{nameof(end)} must be greater than {nameof(start)}&quot;);\n\n    return alphabetSubsetImplementation();\n\n    IEnumerable&lt;char&gt; alphabetSubsetImplementation()\n    {\n        for (var c = start; c &lt; end; c++)\n            yield return c;\n    }\n}\n</code></pre><p>The version above makes it clear that the local method is referenced\nonly in the context of the outer method. The rules for local functions\nalso ensure that a developer can&#39;t accidentally call the local function\nfrom another location in the class and bypass the argument validation.</p>\n<p>The same technique can be employed with <code>async</code> methods to ensure that\nexceptions arising from argument validation are thrown before the asynchronous\nwork begins:</p>\n<pre><code class=\"lang-csharp\" name=\"TaskExample\" title=\"Task returning method with local function\">public Task&lt;string&gt; PerformLongRunningWork(string address, int index, string name)\n{\n    if (string.IsNullOrWhiteSpace(address))\n        throw new ArgumentException(message: &quot;An address is required&quot;, paramName: nameof(address));\n    if (index &lt; 0)\n        throw new ArgumentOutOfRangeException(paramName: nameof(index), message: &quot;The index must be non-negative&quot;);\n    if (string.IsNullOrWhiteSpace(name))\n        throw new ArgumentException(message: &quot;You must supply a name&quot;, paramName: nameof(name));\n\n    return longRunningWorkImplementation();\n\n    async Task&lt;string&gt; longRunningWorkImplementation()\n    {\n        var interimResult = await FirstWork(address);\n        var secondResult = await SecondStep(index, name);\n        return $&quot;The results are {interimResult} and {secondResult}. Enjoy.&quot;;\n    }\n}\n</code></pre><div class=\"NOTE\"><h5>Note</h5><p>Some of the designs that are supported by local functions\ncould also be accomplished using <em>lambda expressions</em>. Those\ninterested can <a href=\"local-functions-vs-lambdas\" data-linktype=\"relative-path\">read more about the differences</a></p>\n</div>\n<h2 id=\"more-expression-bodied-members\">More expression-bodied members</h2>\n<p>C# 6 introduced <a href=\"csharp-6#expression-bodied-function-members\" data-linktype=\"relative-path\">expression-bodied members</a>\nfor member functions, and read-only properties. C# 7 expands the allowed\nmembers that can be implemented as expressions. In C# 7, you can implement\n<em>constructors</em>, <em>finalizers</em>, and <code>get</code> and <code>set</code> accessors on <em>properties</em>\nand <em>indexers</em>. The following code shows examples of each:</p>\n<pre><code class=\"lang-csharp\" name=\"ExpressionBodiedMembers\" title=\"new expression-bodied members\">// Expression-bodied constructor\npublic ExpressionMembersExample(string label) =&gt; this.Label = label;\n\n// Expression-bodied finalizer\n~ExpressionMembersExample() =&gt; Console.Error.WriteLine(&quot;Finalized!&quot;);\n\nprivate string label;\n\n// Expression-bodied get / set accessors.\npublic string Label\n{\n    get =&gt; label;\n    set =&gt; this.label = value ?? &quot;Default label&quot;;\n}\n</code></pre><div class=\"NOTE\"><h5>Note</h5><p>This example does not need a finalizer, but it is shown\nto demonstrate the syntax. You should not implement a\nfinalizer in your class unless it is necessary to  release\nunmanaged resources. You should also consider using the\n<a class=\"xref\" href=\"../../api/system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> class instead\nof managing unmanaged resources directly.</p>\n</div>\n<p>These new locations for expression-bodied members represent\nan important milestone for the C# language: These features\nwere implemented by community members working on the open-source\n<a href=\"https://github.com/dotnet/Roslyn\" data-linktype=\"external\">Roslyn</a> project.</p>\n<h2 id=\"throw-expressions\">Throw expressions</h2>\n<p>In C#, <code>throw</code> has always been a statement. Because <code>throw</code> is a statement,\nnot an expression, there were C# constructs where you could not use it. These\nincluded conditional expressions, null coalescing expressions, and some lambda\nexpressions. The addition of expression-bodied members adds more locations\nwhere <code>throw</code> expressions would be useful. So that you can write any of these\nconstructs, C# 7 introduces <em>throw expressions</em>.</p>\n<p>The syntax is the same as you&#39;ve always used for <code>throw</code> statements. The only difference\nis that now you can place them in new locations, such as in a conditional expression:</p>\n<pre><code class=\"lang-csharp\" name=\"Throw_ExpressionExample\" title=\"conditional throw expressions\">public string Name\n{\n    get =&gt; name;\n    set =&gt; name = value ?? \n        throw new ArgumentNullException(paramName: nameof(value), message: &quot;New name must not be null&quot;);\n}\n</code></pre><p>This features enables using throw expressions in initialization expressions:</p>\n<pre><code class=\"lang-csharp\" name=\"ThrowInInitialization\" title=\"conditional throw expressions\">private ConfigResource loadedConfig = LoadConfigResourceOrDefault() ?? \n    throw new InvalidOperationException(&quot;Could not load config&quot;);\n</code></pre><p>Previously, those initializations would need to be in a constructor, with the\nthrow statements in the body of the constructor:</p>\n<pre><code class=\"lang-csharp\" name=\"ThrowInConstructor\" title=\"throw statements\">public ApplicationOptions()\n{\n    loadedConfig = LoadConfigResourceOrDefault();\n    if (loadedConfig == null)\n        throw new InvalidOperationException(&quot;Could not load config&quot;);\n\n}\n</code></pre><div class=\"NOTE\"><h5>Note</h5><p>Both of the preceding constructs will cause exceptions to be thrown during\nthe construction of an object. Those are often difficult to recover from.\nFor that reason, designs that throw exceptions during construction are\ndiscouraged.</p>\n</div>\n<h2 id=\"generalized-async-return-types\">Generalized async return types</h2>\n<p>Returning a <code>Task</code> object from async methods can introduce\nperformance bottlenecks in certain paths. <code>Task</code> is a reference\ntype, so using it means allocating an object. In cases where a\nmethod declared with the <code>async</code> modifier returns a cached result, or\ncompletes synchronously, the extra allocations can become a significant\ntime cost in performance critical sections of code. It can become\nvery costly if those allocations occur in tight loops.</p>\n<p>The new language feature means that async methods may return other\ntypes in addition to <code>Task</code>, <code>Task&lt;T&gt;</code> and <code>void</code>. The returned type\nmust still satisfy the async pattern, meaning a <code>GetAwaiter</code> method\nmust be accessible. As one concrete example, the <code>ValueTask</code> type\nhas been added to the .NET framework to make use of this new language\nfeature: </p>\n<pre><code class=\"lang-csharp\" name=\"UsingValueTask\" title=\"Using ValueTask\">public async ValueTask&lt;int&gt; Func()\n{\n    await Task.Delay(100);\n    return 5;\n}\n</code></pre><div class=\"NOTE\"><h5>Note</h5><p>You need to add the pre-release NuGet package <code>System.Threading.Tasks.Extensions</code>\nin order to use <code>ValueTask</code> in Visual Studio 15 Preview 5.</p>\n</div>\n<p>A simple optimization would be to use <code>ValueTask</code> in places where\n<code>Task</code> would be used before. However, if you want to perform extra\noptimizations by hand, you can cache results from async work and\nreuse the result in subsequent calls. The <code>ValueTask</code> struct has a constructor\nwith a <code>Task</code> parameter so that you can construct a <code>ValueTask</code> from the\nreturn value of any existing async method:</p>\n<pre><code class=\"lang-csharp\" name=\"AsyncOptimizedValueTask\" title=\"Return async result or cached value\">public ValueTask&lt;int&gt; CachedFunc()\n{\n    return (cache) ? new ValueTask&lt;int&gt;(cacheResult) : new ValueTask&lt;int&gt;(loadCache());\n}\nprivate bool cache = false;\nprivate int cacheResult;\nprivate async Task&lt;int&gt; loadCache()\n{\n    // simulate async work:\n    await Task.Delay(100);\n    cache = true;\n    cacheResult = 100;\n    return cacheResult;\n}\n</code></pre><p>As with all performance recommendations, you should benchmark\nboth versions before making large scale changes to your code.</p>\n<h2 id=\"numeric-literal-syntax-improvements\">Numeric literal syntax improvements</h2>\n<p>Misreading numeric constants can make it harder to understand\ncode when reading it for the first time. This often\noccurs when those numbers are used as bit masks or other symbolic\nrather than numeric values. C# 7 includes two new features to\nmake it easier to write numbers in the most readable fashion\nfor the intended use: <em>binary literals</em>, and <em>digit separators</em>.</p>\n<p>For those times when you are creating bit masks, or whenever a\nbinary representation of a number makes the most readable code,\nwrite that number in binary:</p>\n<pre><code class=\"lang-csharp\" name=\"BinaryConstants\" title=\"Binary constants\">public const int One =  0b0001;\npublic const int Two =  0b0010;\npublic const int Four = 0b0100;\npublic const int Eight = 0b1000;\n</code></pre><p>The <code>0b</code> at the beginning of the constant indicates that the\nnumber is written as a binary number.</p>\n<p>Binary numbers can get very long, so it&#39;s often easier to see\nthe bit patterns by introducing the <code>_</code> as a digit separator:</p>\n<pre><code class=\"lang-csharp\" name=\"ThousandSeparators\" title=\"Thousands separators\">public const int Sixteen =   0b0001_0000;\npublic const int ThirtyTwo = 0b0010_0000;\npublic const int SixtyFour = 0b0100_0000;\npublic const int OneHundredTwentyEight = 0b1000_0000;\n</code></pre><p>The digit separator can appear anywhere in the constant. For base 10\nnumbers, it would be common to use it as a thousands separator:</p>\n<pre><code class=\"lang-csharp\" name=\"LargeIntegers\" title=\"Large integer\">public const long BillionsAndBillions = 100_000_000_000;\n</code></pre><p>The digit separator can be used with <code>decimal</code>, <code>float</code> and <code>double</code>\ntypes as well:</p>\n<pre><code class=\"lang-csharp\" name=\"OtherConstants\" title=\"non-integral constants\">public const double AvogadroConstant = 6.022_140_857_747_474e23;\npublic const decimal GoldenRatio = 1.618_033_988_749_894_848_204_586_834_365_638_117_720_309_179M;\n</code></pre><p>Taken together, you can declare numeric constants with much more\nreadability.</p>\n</div></div>","outputRootRelativePath":"../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"../toc2.json\">\r\n<meta name=\"apiPlatform\" content=\"dotnet\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"fd41596d-d0c2-4816-b94d-c4d00a5d0243\">\r\n<meta name=\"description\" content=\"Get an overview of the new features coming in the upcoming version 7 of the C# language.\">\r\n<meta name=\"keywords\" content=\"C#, .NET, .NET Core, Latest Features, What&#39;s New\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"12/21/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\"visual-studio-dev-15\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/948cd15de7e250735ece199ccd7affb3d98b4c7b/docs/csharp/csharp-7.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/csharp-7.md\">\r\n<meta name=\"document_id\" content=\"9a6074f8-c6db-4874-107e-0159a1a0c031\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","apiPlatform":"dotnet","title":"What's New in C# 7 | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"fd41596d-d0c2-4816-b94d-c4d00a5d0243","description":"Get an overview of the new features coming in the upcoming version 7 of the C# language.","keywords":"C#, .NET, .NET Core, Latest Features, What's New","ms.topic":"article","ms.date":"12/21/2016","ms.technology":"devlang-csharp","ms.prod":"visual-studio-dev-15","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"David Pine","author_email":"IEvangelist@users.noreply.github.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Rephrased based on review feedback","commit_sha":"948cd15de7e250735ece199ccd7affb3d98b4c7b","commit_date":"2017-03-10 07:19:08 -0600"},{"author_name":"David Pine","author_email":"IEvangelist@users.noreply.github.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Added note about variable scope","commit_sha":"4415b037fc75e174b0f549ecb6e0f294dd240f45","commit_date":"2017-03-09 16:09:43 -0600"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update pattern matching to fix a couple small issues (#1612)","commit_sha":"d970e86efce5ecd437532909b337539222df6f5f","commit_date":"2017-03-06 15:45:58 -0500"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"switching xref syntax (#1346)","commit_sha":"16d7af196144ed0ec97eb1a438646bedcea45c2d","commit_date":"2017-02-18 22:07:12 -0800"},{"author_name":"David M Pine","author_email":"IEvangelist@users.noreply.github.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"Minor correction in the opening sentence on Tuples (#1458)","commit_sha":"c081058c61915a01fe8a8a7dcfb8b6ae2356cb79","commit_date":"2017-01-26 06:01:33 -0800"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"expression-bodied should be hyphenated (#1384)","commit_sha":"7ac95fa4b2aac81b2e8d33cedf2faf36a0bbf210","commit_date":"2017-01-05 10:03:42 -0500"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"updates suggested during the docs bug bash (#1380)","commit_sha":"32194f2f1a4b38209180da10a712ff0f51b0b709","commit_date":"2017-01-04 11:03:18 -0500"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update What's new for C# 7 (#1351)","commit_sha":"84779e5cb8c7f6afcfc2c023ab3c7dd01fd93fa0","commit_date":"2016-12-22 16:39:45 -0500"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Create detailed article on C# tuples (#1284)","commit_sha":"c48f48654e65345fbc88f391778515627d4e6cff","commit_date":"2016-11-29 17:47:48 -0500"},{"author_name":"Jon Canning","author_email":"jon.canning@gmail.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"Fix typo (#1267)","commit_sha":"96a512551797c6d1343ebecbcd1d64014f251112","commit_date":"2016-11-18 08:44:55 -0800"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"New in csharp7 (#1188)","commit_sha":"1442cbafa04d57e7eb864c0697afef01413db168","commit_date":"2016-11-13 15:54:48 -0500"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"fixed broken anchors (#1194)","commit_sha":"b20713600d7c3ddc31be5885733a1e8910ede8c6","commit_date":"2016-11-02 20:45:13 -0700"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"renamed repo/fixed headings (#1186)","commit_sha":"15c55a87beb64f265a164db918c7721c7690fadf","commit_date":"2016-10-29 15:23:17 -0400"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Create outlines for csharp 7 (#1115)","commit_sha":"ada1b8f1252962556e42f180046b9b019307622c","commit_date":"2016-10-06 21:10:34 -0400"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update C# Guide section. (#782)","commit_sha":"fcf7f3ea67de6ebe6bfb8472ad786c471ac45e2e","commit_date":"2016-08-30 19:20:46 -0400"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/IEvangelist","display_name":"David M Pine","id":"7679720"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/JonCanning","display_name":"Jon Canning","id":"671232"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/948cd15de7e250735ece199ccd7affb3d98b4c7b/docs/csharp/csharp-7.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/csharp-7.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/csharp-7.md","document_id":"9a6074f8-c6db-4874-107e-0159a1a0c031","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/csharp-7","toc_asset_id":"articles/toc.json","toc_rel":"../toc.json","_op_ogTitle":"What's New in C# 7","_op_displayDate":"2016-12-21","_op_displayDate_source":"2016-12-21T00:00:00Z","_op_wordCount":4584,"_op_rawTitle":"<h1 id=\"whats-new-in-c-7\" sourcefile=\"docs/csharp/csharp-7.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">What&#39;s new in C# 7</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/csharp/csharp-7","fileRelativePath":"articles/csharp/csharp-7.html"},"themesRelativePathToOutputRoot":"_themes/"}