{"content":"<div><div class=\"content\">\n<p><a href=\"expression-trees-interpreting\" data-linktype=\"relative-path\">Previous -- Interpreting Expressions</a></p>\n<p>All the expression trees you&#39;ve seen so far have been created\nby the C# compiler. All you had to do was create a lambda expression\nthat was assigned to a variable typed as an <code>Expression&lt;Func&lt;T&gt;&gt;</code> or\nsome similar type. That&#39;s not the only way to create an expression\ntree. For many scenarios you may find that you need to build an\nexpression in memory at runtime. </p>\n<p>Building Expression Trees is complicated by the fact that those\nexpression trees are immutable. Being immutable means that you must\nbuild the tree from the leaves up to the root. The APIs you&#39;ll use to\nbuild expression trees reflect this fact: The methods you&#39;ll use to\nbuild a node take all its children as arguments. Let&#39;s walk through\na few examples to show you the techniques.</p>\n<h2 id=\"creating-nodes\">Creating Nodes</h2>\n<p>Let&#39;s start relatively simply again. We&#39;ll use the addition\nexpression I&#39;ve been working with throughout these sections:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">Expression&lt;Func&lt;int&gt;&gt; sum = () =&gt; 1 + 2;\n</code></pre><p>To construct that expression tree, you must construct the leaf nodes.\nThe leaf nodes are constants, so you can use the <code>Expression.Constant</code>\nmethod to create the nodes:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var one = Expression.Constant(1, typeof(int));\nvar two = Expression.Constant(2, typeof(int));\n</code></pre><p>Next, you&#39;ll build the addition expression:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var addition = Expression.Add(one, two);\n</code></pre><p>Once you&#39;ve got the addition expression, you can create the lambda\nexpression:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var lamdba = Expression.Lambda(addition);\n</code></pre><p>This is a very simple LambdaExpression, because it contains no arguments.\nLater in this section, you&#39;ll see how to map arguments to parameters\nand build more complicated expressions.</p>\n<p>For expressions that are as simple as this one, you may combine all the\ncalls into a single statement:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var lambda = Expression.Lambda(\n    Expression.Add(\n        Expression.Constant(1, typeof(int)),\n        Expression.Constant(2, typeof(int))\n    )\n);\n</code></pre><h2 id=\"building-a-tree\">Building a Tree</h2>\n<p>That&#39;s the basics of building an expression tree in memory. More\ncomplex trees generally mean more node types, and more nodes in the\ntree. Let&#39;s run through one more example and show two more node types\nthat you will typically build when you create expression trees:\nthe argument nodes, and method call nodes.</p>\n<p>Let&#39;s build an expression tree to create this expression:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">Expression&lt;Func&lt;double, double, double&gt;&gt; distanceCalc =\n    (x, y) =&gt; Math.Sqrt(x * x + y * y);\n</code></pre><p>You&#39;ll start by creating parameter expressions for <code>x</code> and <code>y</code>:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var xParameter = Expression.Parameter(typeof(double), &quot;x&quot;);\nvar yParameter = Expression.Parameter(typeof(double), &quot;y&quot;);\n</code></pre><p>Creating the multiplication and addition expressions follows the pattern\nyou&#39;ve already seen:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var xSquared = Expression.Multiply(xParameter, xParameter);\nvar ySquared = Expression.Multiply(yParameter, yParameter);\nvar sum = Expression.Add(xSquared, ySquared);\n</code></pre><p>Next, you need to create a method call expression for the call to\n<code>Math.Sqrt</code>.</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var sqrtMethod = typeof(Math).GetMethod(&quot;Sqrt&quot;, new[] { typeof(double) });\nvar distance = Expression.Call(sqrtMethod, sum);\n</code></pre><p>And  then finally, you put the method call into a lambda expression,\nand make sure to define the arguments to the lambda expression:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">var distanceLambda = Expression.Lambda(\n    distance,\n    xParameter,\n    yParameter);\n</code></pre><p>In this more complicated example, you see a couple more techniques that\nyou will often need to create expression trees.</p>\n<p>First, you need to create the objects that represent parameters or\nlocal variables before you use them. Once you&#39;ve created those objects,\nyou can use them in your expression tree wherever you need.</p>\n<p>Second, you need to use a subset of the Reflection APIs to create a <code>MethodInfo</code> object\nso that you can create an expression tree to access that method. You must limit\nyourself to the subset of the Reflection APIs that are available on the .NET Core platform. Again,\nthese techniques will extend to other expression trees.</p>\n<h2 id=\"building-code-in-depth\">Building Code In Depth</h2>\n<p>You aren&#39;t limited in what you can build using these APIs. However, the more\ncomplicated expression tree that you want to build, the more difficult\nthe code is to manage and to read. </p>\n<p>Let&#39;s build an expression tree that is the equivalent of this code:</p>\n<pre class=\"loading\"><code class=\"lang-cs\">Func&lt;int, int&gt; factorialFunc = (n) =&gt;\n{\n    var res = 1;\n    while (n &gt; 1)\n    {\n        res = res * n;\n        n--;\n    }\n    return res;\n};\n</code></pre><p>Notice above that I did not build the expression tree, but simply the delegate. Using\nthe <code>Expression</code> class, you can&#39;t build statement lambdas. Here&#39;s the code that is required\nto build the same functionality. It&#39;s complicated by the fact that there isn&#39;t an API to build\na <code>while</code> loop, instead you need to build a loop that contains a conditional test, and a label\ntarget to break out of the loop. </p>\n<pre class=\"loading\"><code class=\"lang-cs\">var nArgument = Expression.Parameter(typeof(int), &quot;n&quot;);\nvar result = Expression.Variable(typeof(int), &quot;result&quot;);\n\n// Creating a label that represents the return value\nLabelTarget label = Expression.Label(typeof(int));\n\nvar initializeResult = Expression.Assign(result, Expression.Constant(1));\n\n// This is the inner block that performs the multiplication,\n// and decrements the value of &#39;n&#39;\nvar block = Expression.Block(\n    Expression.Assign(result,\n        Expression.Multiply(result, nArgument)),\n    Expression.PostDecrementAssign(nArgument)\n);\n\n// Creating a method body.\nBlockExpression body = Expression.Block(\n    new[] { result },\n    initializeResult,\n    Expression.Loop(\n        Expression.IfThenElse(\n            Expression.GreaterThan(nArgument, Expression.Constant(1)),\n            block,\n            Expression.Break(label, result)\n        ),\n        label\n    )\n);\n</code></pre><p>The code to build the expression tree for the factorial function is quite a bit longer,\nmore complicated, and it&#39;s riddled with labels and break statements and other elements\nwe&#39;d like to avoid in our everyday coding tasks. </p>\n<p>For this section, I&#39;ve also updated the visitor code to visit every node in this expression\ntree and write out information about the nodes that are created in this sample. You can see\nthe code in <a href=\"https://github.com/dotnet/docs/tree/master/samples/csharp/expression-trees\" data-linktype=\"external\">the samples section</a>.\nYou can experiment for yourself: build it and run the samples.</p>\n<h2 id=\"examining-the-apis\">Examining the APIs</h2>\n<p>The expression tree APIs are some of the more difficult to navigate in\n.NET Core, but that&#39;s fine. Their purpose is a rather complex undertaking: writing code that generates\ncode at runtime. They are necessarily complicated to provide a balance between supporting\nall the control structures available in the C# language and keeping the surface area\nof the APIs as small as reasonable. This balance means that many control structures are\nrepresented not by their C# constructs, but by constructs that represent the underlying\nlogic that the compiler generates from these higher level constructs. </p>\n<p>Also, at this time, there are C# expressions that cannot be built directly\nusing <code>Expression</code> class methods. In general, these will be the newest operators\nand expressions added in C# 5 and C# 6. (For example, <code>async</code> expressions cannot be built, and\nthe new <code>?.</code> operator cannot be directly created.)</p>\n<p><a href=\"expression-trees-translating\" data-linktype=\"relative-path\">Next -- Translating Expressions</a></p>\n</div></div>","outputRootRelativePath":"../../","pageMetadata":"<meta name=\"author\" content=\"BillWagner\">\r\n<meta name=\"ms.author\" content=\"wiwagn\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-all/api/toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"csharp\">\r\n<meta name=\"ms.assetid\" content=\"542754a9-7f40-4293-b299-b9f80241902c\">\r\n<meta name=\"description\" content=\"Building Expression Trees\">\r\n<meta name=\"keywords\" content=\".NET, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"06/20/2016\">\r\n<meta name=\"ms.technology\" content=\"devlang-csharp\">\r\n<meta name=\"ms.prod\" content=\".net\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2016-12-15 06:00 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/expression-trees-building.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/expression-trees-building.md\">\r\n<meta name=\"document_id\" content=\"bab31eae-972a-aae7-0836-7019ccf27b1e\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../toc2.json\">\r\n","rawMetadata":{"author":"BillWagner","ms.author":"wiwagn","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Building Expression Trees | Microsoft Docs","ms.devlang":"csharp","ms.assetid":"542754a9-7f40-4293-b299-b9f80241902c","description":"Building Expression Trees","keywords":".NET, .NET Core","ms.topic":"article","ms.date":"06/20/2016","ms.technology":"devlang-csharp","ms.prod":".net","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"renamed repo/fixed headings (#1186)","commit_sha":"15c55a87beb64f265a164db918c7721c7690fadf","commit_date":"2016-10-29 15:23:17 -0400"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update ci build for ubuntu (#891)","commit_sha":"ce52ada663c2ed9b8b3d10bc3d4dcb453abb79f7","commit_date":"2016-08-09 16:02:13 -0400"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"Rich Lander","comitter_email":"rlander@microsoft.com","message":"Promote csharp from languages (#644)","commit_sha":"2d44b7e04c0fe2ca136ba6dfa9fc3a4368365ec8","commit_date":"2016-06-26 08:30:56 -0700"}],"updated_at":"2016-12-15 06:00 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},"contributors":[{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"}],"update_at":"12/15/2016"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/csharp/expression-trees-building.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/csharp/expression-trees-building.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/csharp/expression-trees-building.md","document_id":"bab31eae-972a-aae7-0836-7019ccf27b1e","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/expression-trees-building","toc_asset_id":"articles/toc.json","toc_rel":"../toc.json","_op_ogTitle":"Building Expression Trees","_op_displayDate":"2016-6-20","_op_displayDate_source":"2016-06-20T00:00:00Z","_op_wordCount":1034,"_op_rawTitle":"<h1 id=\"building-expression-trees\" sourcefile=\"docs/csharp/expression-trees-building.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Building Expression Trees</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/csharp/expression-trees-building","fileRelativePath":"articles/csharp/expression-trees-building.html"},"themesRelativePathToOutputRoot":"_themes/"}