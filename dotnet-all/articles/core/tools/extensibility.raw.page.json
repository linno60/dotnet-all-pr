{"content":"<div><div class=\"content\">\n<h2 id=\"overview\">Overview</h2>\n<p>This document will cover the main ways how to extend the CLI tools and explain the scenarios that drive each of them. \nIt will the outline how to consume the tools as well as provide short notes on how to build both types of tools. </p>\n<h2 id=\"how-to-extend-cli-tools\">How to extend CLI tools</h2>\n<p>The CLI tools can be extended in three main ways:</p>\n<ol>\n<li>Via NuGet packages on a per-project basis</li>\n<li>Via NuGet packages with custom targets  </li>\n<li>Via the system&#39;s PATH</li>\n</ol>\n<p>The three extensibility mechanisms outlined above are not exclusive; you can use all or just one or combine them. Which one to pick \ndepends largely on what is the goal you are trying to achieve with your extension.</p>\n<h2 id=\"per-project-based-extensibility\">Per-project based extensibility</h2>\n<p>Per-project tools are <a href=\"../deploying/index\" data-linktype=\"relative-path\">framework-dependented deployments</a> that are distributed as NuGet packages. Tools are \nonly available in the context of the project that references them and for which they are restored; invocation outside \nof the context of the project (for example, outside of the directory that contains the project) will fail as the command will \nnot be able to be found.</p>\n<p>These tools are perfect for build servers, since nothing outside of the project file is needed. The build process \nruns restore for the project it builds and tools will be available. Language projects, such as F#, are also in this \ncategory; after all, each project can only be written in one specific language. </p>\n<p>Finally, this extensibility model provides support for creation of tools that need access to the built output of the \nproject. For instance, various Razor view tools in <a href=\"https://www.asp.net/\" data-linktype=\"external\">ASP.NET</a> MVC applications fall into this \ncategory. </p>\n<h3 id=\"consuming-per-project-tools\">Consuming per-project tools</h3>\n<p>Consuming these tools requires you to add a <code>&lt;DotNetCliToolReference&gt;</code> element for each tool you want to use to your project file. Inside the <code>&lt;DotNetCliToolReference&gt;</code> element, you reference the package in which the tool resides and you specify the version you need. After running <code>dotnet restore</code>, the tool and its dependencies are restored. </p>\n<p>For tools that need to load the build output of the project for execution, there is usually another dependency which is \nlisted under the regular dependencies in the project file. Since CLI uses MSBuild as its build engine, it is recommended that these parts of the tool be written as custom MSBuild targets and tasks since that way they can take part in the overall build process. Also, they can get any and all data easily that is produced via the build, for example the location of the output files, the current configuration being built etc. All of this information becomes a set of MSBuild properties that can be read from any target. We will see how to add a custom target using NuGet later in this document. </p>\n<p>Let&#39;s review an example of adding a simple tools-only tool to a simple project. Given an example command called \n<code>dotnet-api-search</code> that allows you to search through the NuGet packages for the specified \nAPI, here is a console application&#39;s project file that uses that tool:</p>\n<pre class=\"loading\"><code class=\"lang-xml\">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;\n  &lt;PropertyGroup&gt;\n    &lt;OutputType&gt;Exe&lt;/OutputType&gt;\n    &lt;TargetFramework&gt;netcoreapp1.1/TargetFramework&gt;\n  &lt;/PropertyGroup&gt;\n\n  &lt;!-- The tools reference --&gt;\n  &lt;ItemGroup&gt;\n    &lt;DotNetCliToolReference Include=&quot;dotnet-api-search&quot; Version=&quot;1.0.0&quot; /&gt;\n  &lt;/ItemGroup&gt;\n&lt;/Project&gt;\n</code></pre><p>The <code>&lt;DotNetCliToolReference&gt;</code> element is structured in a similar way as the <code>&lt;PackageReference&gt;</code> element. It needs the package ID of the package containing the tool and its version at the very least. </p>\n<h3 id=\"building-tools\">Building tools</h3>\n<p>As mentioned, tools are just portable console applications. You would build one as you would build any console application. \nAfter you build it, you would use <a href=\"dotnet-pack\" data-linktype=\"relative-path\"><code>dotnet pack</code></a> command to create a NuGet package (nupkg) that contains \nyour code, information about its dependencies and so on. The package name can be whatever the author wants, but the \napplication inside, the actual tool binary, has to conform to the convention of <code>dotnet-&lt;command&gt;</code> in order for <code>dotnet</code> \nto be able to invoke it. </p>\n<div class=\"NOTE\"><h5>Note</h5><p>In pre-RC3 versions of the .NET Core command-line tools, the <code>dotnet pack</code> command had a bug that caused the <code>runtime.config.json</code> to not be packed with the tool. Lacking that file results in errors at runtime. If you encounter this behavior, be sure to update to the latest tooling and try the <code>dotnet pack</code> again. </p>\n</div>\n<p>Since tools are portable applications, the user consuming the tool has to have the version of the .NET Core libraries \nthat the tool was built against in order to run the tool. Any other dependency that the tool uses and that is not \ncontained within the .NET Core libraries is restored and placed in the NuGet cache. The entire tool is, therefore, run \nusing the assemblies from the .NET Core libraries as well as assemblies from the NuGet cache. </p>\n<p>These kind of tools have a dependency graph that is completely separate from the dependency graph of the project that \nuses them. The restore process will first restore the project&#39;s dependencies, and will then restore each of the tools and \ntheir dependencies. </p>\n<p>You can find richer examples and different combinations of this in the <a href=\"https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestProjects\" data-linktype=\"external\">.NET Core CLI repo</a>. \nYou can also see the <a href=\"https://github.com/dotnet/cli/tree/rel/1.0.0-preview2/TestAssets/TestPackages\" data-linktype=\"external\">implementation of tools used</a> in the same repo. </p>\n<h3 id=\"custom-targets\">Custom targets</h3>\n<p>NuGet has had the capability to package custom MSBuild target and props files for a while now and you can find the official documentation on this on the <a href=\"https://docs.microsoft.com/nuget/create-packages/creating-a-package#including-msbuild-props-and-targets-in-a-package\" data-linktype=\"external\">NuGet documentation site</a>. With the move in the CLI to using MSBuild, the same mechanism of extensibility applies to .NET Core projects. You would use this type of extensiblity when you want to extend the build process or when you want to access any of the artifacts in the build process, such as generated files or inspect the configuration under which the build is invoked etc. </p>\n<p>The sample target&#39;s project file is included below for reference. It shows how to use the new <code>csproj</code> syntax for instructing <code>dotnet pack</code> command what to package to place the targets files as well as assemblies into the <code>build</code> folder inside the package. Take note of the <code>&lt;ItemGroup&gt;</code> below that has the <code>Label</code> property set to &quot;dotnet pack instructions&quot;. </p>\n<pre class=\"loading\"><code class=\"lang-xml\">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;\n  &lt;PropertyGroup&gt;\n    &lt;Description&gt;Sample Packer&lt;/Description&gt;\n    &lt;VersionPrefix&gt;0.1.0-preview&lt;/VersionPrefix&gt;\n    &lt;TargetFramework&gt;netstandard1.3&lt;/TargetFramework&gt;\n    &lt;DebugType&gt;portable&lt;/DebugType&gt;\n    &lt;AssemblyName&gt;SampleTargets.PackerTarget&lt;/AssemblyName&gt;\n  &lt;/PropertyGroup&gt;\n  &lt;ItemGroup&gt;\n    &lt;EmbeddedResource Include=&quot;Resources\\Pkg\\dist-template.xml;compiler\\resources\\**\\*&quot; Exclude=&quot;bin\\**;obj\\**;**\\*.xproj;packages\\**&quot; /&gt;\n    &lt;None Include=&quot;build\\SampleTargets.PackerTarget.targets&quot; /&gt;\n  &lt;/ItemGroup&gt;\n  &lt;ItemGroup Label=&quot;dotnet pack instructions&quot;&gt;\n    &lt;Content Include=&quot;build\\*.targets;$(OutputPath)\\*.dll;$(OutputPath)\\*.json&quot;&gt;\n      &lt;Pack&gt;true&lt;/Pack&gt;\n      &lt;PackagePath&gt;build\\&lt;/PackagePath&gt;\n    &lt;/Content&gt;\n  &lt;/ItemGroup&gt;\n  &lt;ItemGroup&gt;\n    &lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyModel&quot; Version=&quot;1.0.1-beta-000933&quot;/&gt;\n    &lt;PackageReference Include=&quot;Microsoft.Build.Framework&quot; Version=&quot;0.1.0-preview-00028-160627&quot; /&gt;\n    &lt;PackageReference Include=&quot;Microsoft.Build.Utilities.Core&quot; Version=&quot;0.1.0-preview-00028-160627&quot; /&gt;\n    &lt;PackageReference Include=&quot;Newtonsoft.Json&quot; Version=&quot;9.0.1&quot; /&gt;\n  &lt;/ItemGroup&gt;\n  &lt;ItemGroup /&gt;\n  &lt;PropertyGroup Label=&quot;Globals&quot;&gt;\n    &lt;ProjectGuid&gt;463c66f0-921d-4d34-8bde-7c9d0bffaf7b&lt;/ProjectGuid&gt;\n  &lt;/PropertyGroup&gt;\n  &lt;PropertyGroup Condition=&quot; &#39;$(TargetFramework)&#39; == &#39;netstandard1.3&#39; &quot;&gt;\n    &lt;DefineConstants&gt;$(DefineConstants);NETSTANDARD1_3&lt;/DefineConstants&gt;\n  &lt;/PropertyGroup&gt;\n  &lt;PropertyGroup Condition=&quot; &#39;$(Configuration)&#39; == &#39;Release&#39; &quot;&gt;\n    &lt;DefineConstants&gt;$(DefineConstants);RELEASE&lt;/DefineConstants&gt;\n  &lt;/PropertyGroup&gt;\n&lt;/Project&gt;\n</code></pre><p>Consuming custom targets is done by providing a <code>&lt;PackageReference&gt;</code> that points to the package and its version inside the project that is being extended. Unlike the tools, the custom targets package does get included into the consuming project&#39;s dependency closure. </p>\n<p>Using the custom target depends solely on how you configure it. Since it is the usual MSBuild target, it can depend on a given target, run after another target and can also be manually invoked using the <code>dotnet msbuild /t:&lt;target-name&gt;</code> command. </p>\n<p>However, if you wish to provide a better user experience to your users, you can combine per-project tools and custom targets. In this scenario, the per-project tool would essentially just accept whatever needed parameters and would translate that into the required <code>dotnet msbuild</code> invocation that would execute the target. You can see a sample of this kind of synergy on the <a href=\"https://github.com/dotnet/MVPSummitHackathon2016\" data-linktype=\"external\">MVP Summit 2016 Hackathon samples</a> repo in the <a href=\"https://github.com/dotnet/MVPSummitHackathon2016/tree/master/dotnet-packer\" data-linktype=\"external\"><code>dotnet-packer</code></a> project. </p>\n<h3 id=\"path-based-extensibility\">PATH-based extensibility</h3>\n<p>PATH-based extensibility is usually used for development machines where you need a tool that conceptually covers more \nthan a single project. The main drawback of this extensions mechanism is that it is tied to the machine where the \ntool exists. If you need it on another machine, you would have to deploy it.</p>\n<p>This pattern of CLI toolset extensibility is very simple. As covered in the <a href=\"index\" data-linktype=\"relative-path\">.NET Core CLI overview</a>, <code>dotnet</code> driver \ncan run any command that is named after the <code>dotnet-&lt;command&gt;</code> convention. The default resolution logic will first \nprobe several locations and will finally fall to the system PATH. If the requested command exists in the system PATH \nand is a binary that can be invoked, <code>dotnet</code> driver will invoke it. </p>\n<p>The binary can be pretty much anything that the operating system can execute. On Unix systems, this means anything that \nhas the execute bit set via <code>chmod +x</code>. On Windows it means anything that Windows knows how to run. </p>\n<p>As an example, let&#39;s take a look at a very simple implementation of a <code>dotnet clean</code> command. We will use <code>bash</code> to \nimplement this command. The command will simply delete the <code>bin/</code> and <code>obj/</code> directories in the current directory. If \nthe <code>--lock</code> argument is passed to it, it will also delete <code>project.lock.json</code> file. The entirety of the command is \ngiven below. </p>\n<pre class=\"loading\"><code class=\"lang-bash\">#!/bin/bash\n\n# Delete the bin and obj dirs\nrm -rf bin/ obj/\n\nLOCK_FILE=$1\nif [[ &quot;$LOCK_FILE&quot; = &quot;--lock&quot; ]]; then\n    rm project.lock.json\nfi\n\n\necho &quot;Cleaning complete...&quot;\n</code></pre><p>On macOS, we can save this script as <code>dotnet-clean</code> and set its executable bit with <code>chmod +x dotnet-clean</code>. We can then \ncreate a symbolic link to it in <code>/usr/local/bin</code> using the command <code>ln -s dotnet-clean /usr/local/bin/</code>. This will make \nit possible to invoke the clean command using the <code>dotnet clean</code> syntax. You can test this by creating an app, running \n<code>dotnet build</code> on it and then running <code>dotnet clean</code>. </p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>The .NET Core CLI tools allow three main extensibility points. The per-project tools are contained within the project&#39;s \ncontext, but they allow easy installation through restoration. Custom targets allow you to easily extend the build process with custom tasks. PATH-based tools are good for general, cross-project tools that are usable on a single machine. </p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"blackdwarf\">\r\n<meta name=\"ms.author\" content=\"mairaw\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"dotnet\">\r\n<meta name=\"ms.assetid\" content=\"fffc3400-aeb9-4c07-9fea-83bc8dbdcbf3\">\r\n<meta name=\"description\" content=\".NET Core CLI extensibility model\">\r\n<meta name=\"keywords\" content=\"CLI, extensibility, custom commands, .NET Core\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"02/06/2017\">\r\n<meta name=\"ms.technology\" content=\"dotnet-cli\">\r\n<meta name=\"ms.prod\" content=\".net-core\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-15 06:14 PM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/c2722327c3ca213309cae5e0d0417b0f0e9ea514/docs/core/tools/extensibility.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/master/docs/core/tools/extensibility.md\">\r\n<meta name=\"document_id\" content=\"20ce7c3f-94ce-50ea-e1e8-6b831b76f752\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"blackdwarf","ms.author":"mairaw","manager":"wpickett","breadcrumb_path":"/dotnet/toc.json","title":".NET Core CLI extensibility model | Microsoft Docs","ms.devlang":"dotnet","ms.assetid":"fffc3400-aeb9-4c07-9fea-83bc8dbdcbf3","description":".NET Core CLI extensibility model","keywords":"CLI, extensibility, custom commands, .NET Core","ms.topic":"article","ms.date":"02/06/2017","ms.technology":"dotnet-cli","ms.prod":".net-core","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":":boom: removing preview3 folder (#1650)","commit_sha":"c2722327c3ca213309cae5e0d0417b0f0e9ea514","commit_date":"2017-03-07 03:26:34 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"change version label (#1526)","commit_sha":"796df1549a7553aa93158598d62338c02d4df73e","commit_date":"2017-02-09 23:56:10 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Maira Wenzel","comitter_email":"mairaw@microsoft.com","message":"preparing changes for RC3 release","commit_sha":"d9ef9b8388bc854e087e0beccdb4785ed7e0f804","commit_date":"2017-01-27 11:43:14 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"added links between versions (#1424)","commit_sha":"2ad428dcda9ef213a8487c35a48b33929259abba","commit_date":"2017-01-20 23:55:05 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"fix broken-links for app-types document (#1203)","commit_sha":"aeb199a9aeb1584570ad2a2942e2f22c75a59616","commit_date":"2016-11-03 11:48:48 -0700"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"Updates to the CLI commands reference (#1129)","commit_sha":"c6ee3f5663d0a3f62914e8de474cca4d15340c9d","commit_date":"2016-10-14 18:03:07 -0400"},{"author_name":"Petr Onderka","author_email":"gsvick@gmail.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"Fix tool naming convention (#857)","commit_sha":"cef21668d6653622084b648ee252d5c03e17b562","commit_date":"2016-08-02 15:10:19 -0400"},{"author_name":"Petr Onderka","author_email":"gsvick@gmail.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"Fixed links (#628)","commit_sha":"e69e28b9e7400cc3dfa87faf660c3f2eab0aae90","commit_date":"2016-06-25 08:50:38 -0400"},{"author_name":"Tom Dykstra","author_email":"tdykstra@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"toc changes for .net core guide section (#609)","commit_sha":"a77454a141ed46eaeeda25dc723476fdb4e542e9","commit_date":"2016-06-24 15:15:55 -0400"}],"updated_at":"2017-03-15 06:14 PM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/blackdwarf","display_name":"Zlatko Knezevic","id":"3115004"},"contributors":[{"profile_url":"https://github.com/blackdwarf","display_name":"Zlatko Knezevic"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"},{"profile_url":"https://github.com/svick","display_name":"Petr Onderka","id":"287848"},{"profile_url":"https://github.com/tdykstra","display_name":"Tom Dykstra","id":"1569635"}],"update_at":"3/15/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/c2722327c3ca213309cae5e0d0417b0f0e9ea514/docs/core/tools/extensibility.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/master/docs/core/tools/extensibility.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/core/tools/extensibility.md","document_id":"20ce7c3f-94ce-50ea-e1e8-6b831b76f752","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet/articles/core/tools/extensibility","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":".NET Core CLI extensibility model","_op_displayDate":"2017-2-6","_op_displayDate_source":"2017-02-06T00:00:00Z","_op_wordCount":1578,"_op_rawTitle":"<h1 id=\"net-core-cli-extensibility-model\" sourcefile=\"docs/core/tools/extensibility.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">.NET Core CLI extensibility model</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet/articles/core/tools/extensibility","fileRelativePath":"articles/core/tools/extensibility.html"},"themesRelativePathToOutputRoot":"_themes/"}