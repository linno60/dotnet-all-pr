{"content":"<div><div class=\"content\">\n<p>Console applications are used for many purposes; from simple querying of a status to long running document image processing tasks. In any case, the ability to start up and scale these applications are met with limitations of hardware acquisitions, startup times or running multiple instances.</p>\n<p>Moving your console applications to use Docker and Windows Server containers allows for starting these applications from a clean state, enabling them to perform the operation and then shutdown cleanly. This topic will show the steps needed to move a console application to a Windows based container and start it using a PowerShell script.</p>\n<p>The sample console application is a simple example which takes an argument, a question in this case, and returns a random answer. This could take a <code>customer_id</code> and process their taxes, or create a thumbnail for an <code>image_url</code> argument.</p>\n<p>In addition to the answer, the <code>Environment.MachineName</code> has been added to the response to show the difference between running the application locally and in a Windows container. When running the application locally, your local machine name should be returned and when running in a Windows Container; the container session id is returned.</p>\n<p>The complete example is available in the <a href=\"https://github.com/dotnet/docs/tree/master/samples/framework/docker/ConsoleRandomAnswerGenerator\" data-linktype=\"external\">dotnet/core-docs repository on GitHub</a>.</p>\n<p>You need to be familiar with some Docker terms before you begin working\non moving your application to a container.</p>\n<blockquote><p>A <em>Docker image</em> is a read-only template that defines the environment\nfor a running container, including the operating system (OS), system components, and application(s).</p>\n</blockquote>\n<p>One important feature of Docker images is that images are composed from a\nbase image. Each new image adds a small set of features to an existing\nimage. </p>\n<blockquote><p>A <em>Docker container</em> is a running instance of an image. </p>\n</blockquote>\n<p>You scale an application by running the same image in many containers.\nConceptually, this is similar to running the same application in multiple\nhosts.</p>\n<p>You can learn more about the Docker architecture by reading the \n<a href=\"https://docs.docker.com/engine/understanding-docker/\" data-linktype=\"external\">Docker Overview</a>\non the Docker site. </p>\n<p>Moving your console application is a matter of a few steps.</p>\n<ol>\n<li><a href=\"#building-the-application\" data-linktype=\"self-bookmark\">Build the application</a></li>\n<li><a href=\"#creating-the-dockerfile\" data-linktype=\"self-bookmark\">Creating a Dockerfile for the image</a></li>\n<li><a href=\"#creating-the-image\" data-linktype=\"self-bookmark\">Process to build and run the Docker container</a></li>\n</ol>\n<h2 id=\"prerequisites\">Prerequisites</h2>\n<p>Windows containers are supported on <a href=\"https://www.microsoft.com/en-us/software-download/windows10/\" data-linktype=\"external\">Windows 10 Anniversary Update</a> or \n<a href=\"https://www.microsoft.com/en-us/cloud-platform/windows-server\" data-linktype=\"external\">Windows Server 2016</a>.</p>\n<div class=\"NOTE\"><h5>Note</h5><p>If you are using Windows Server 2016, you must enable containers manually since the Docker for Windows installer will not enable the feature. Make sure all updates have run for the OS and then follow the instructions from the <a href=\"https://msdn.microsoft.com/virtualization/windowscontainers/deployment/deployment\" data-linktype=\"external\">Container Host Deployment</a> article to install the containers and Docker features.</p>\n</div>\n<p>You need to have Docker for Windows, version 1.12 Beta 26 or higher to support Windows containers. By default, Docker enables Linux based containers; switch to Windows containers by right clicking the Docker icon in the system tray and select <strong>Switch to Windows containers</strong>. Docker will run the process to change and a restart may be required.</p>\n<p><img src=\"media/console/switchcontainer.png\" alt=\"Windows-Containers\" data-linktype=\"relative-path\"></p>\n<h2 id=\"building-the-application\">Building the application</h2>\n<p>Typically console applications are distributed through an installer, FTP, or File Share deployment. When deploying to a container, the assets need to be compiled and staged to a location that can be used when the Docker image is created.</p>\n<p>In <em>build.ps1</em>, the script uses <a href=\"https://msdn.microsoft.com/library/dd393574.aspx\" data-linktype=\"external\">MSBuild</a> to compile the application to complete the task of building the assets. There are a few parameters passed to MSBuild to finalize the needed assets. The name of the project file or solution to be compiled, the location for the output and finally the configuration (Release or Debug).</p>\n<p>In the call to <code>Invoke-MSBuild</code> the <code>OutputPath</code> is set to <strong>publish</strong> and  <code>Configuration</code> set to <strong>Release</strong>. </p>\n<pre class=\"loading\"><code>function Invoke-MSBuild ([string]$MSBuildPath, [string]$MSBuildParameters) {\n    Invoke-Expression &quot;$MSBuildPath $MSBuildParameters&quot;\n}\n\nInvoke-MSBuild -MSBuildPath &quot;MSBuild.exe&quot; -MSBuildParameters &quot;.\\ConsoleRandomAnswerGenerator.csproj /p:OutputPath=.\\publish /p:Configuration=Release&quot;\n</code></pre><h2 id=\"creating-the-dockerfile\">Creating the Dockerfile</h2>\n<p>The base image used for a console .NET Framework application is <code>microsoft/windowsservercore</code>, publicly available on <a href=\"https://hub.docker.com/r/microsoft/windowsservercore/\" data-linktype=\"external\">Docker Hub</a>. The base image contains a minimal installation of Windows Server 2016, .NET Framework 4.6.2 and serves as the base OS image for Windows Containers.</p>\n<pre class=\"loading\"><code>FROM microsoft/windowsservercore\nADD publish/ /\nENTRYPOINT ConsoleRandomAnswerGenerator.exe\n</code></pre><p>The first line in the Dockerfile designates the base image using the <a href=\"https://docs.docker.com/engine/reference/builder/#/from\" data-linktype=\"external\"><code>FROM</code></a> instruction. Next, <a href=\"https://docs.docker.com/engine/reference/builder/#/add\" data-linktype=\"external\"><code>ADD</code></a> in the file copies the application assets from the <strong>publish</strong> folder to root folder of the container and last; setting the <a href=\"https://docs.docker.com/engine/reference/builder/#/entrypoint\" data-linktype=\"external\"><code>ENTRYPOINT</code></a> of the image states that this is the command or application that will run when the container starts. </p>\n<h2 id=\"creating-the-image\">Creating the image</h2>\n<p>In order to create the Docker image, the following code is added to the <em>build.ps1</em> script. When the script is run, the <code>console-random-answer-generator</code> image is created using the assets compiled from MSBuild defined in the <a href=\"#building-the-application\" data-linktype=\"self-bookmark\">Building the application</a> section.</p>\n<pre class=\"loading\"><code>$ImageName=&quot;console-random-answer-generator&quot;\n\nfunction Invoke-Docker-Build ([string]$ImageName, [string]$ImagePath, [string]$DockerBuildArgs = &quot;&quot;) {\n    echo &quot;docker build -t $ImageName $ImagePath $DockerBuildArgs&quot;\n    Invoke-Expression &quot;docker build -t $ImageName $ImagePath $DockerBuildArgs&quot;\n}\n\nInvoke-Docker-Build -ImageName $ImageName -ImagePath &quot;.&quot;\n</code></pre><p>Run the script using <code>.\\build.ps1</code> from the PowerShell command prompt.</p>\n<p>When the build is complete, using the <code>docker images</code> command from a command line or PowerShell prompt; you&#39;ll see that the image is created and ready to be run.</p>\n<pre class=\"loading\"><code>REPOSITORY                        TAG                 IMAGE ID            CREATED             SIZE\nconsole-random-answer-generator   latest              8f7c807db1b5        8 seconds ago       7.33 GB\n</code></pre><h2 id=\"running-the-container\">Running the container</h2>\n<p>You can start the container from the command line using the Docker commands.</p>\n<pre class=\"loading\"><code>docker run console-random-answer-generator &quot;Are you a square container?&quot;\n</code></pre><p>The output is</p>\n<pre class=\"loading\"><code>The answer to your question: &#39;Are you a square container?&#39; is Concentrate and ask again on (70C3D48F4343)\n</code></pre><p>If you run the <code>docker ps -a</code> command from PowerShell, you can see that the container still exists.</p>\n<pre class=\"loading\"><code>CONTAINER ID        IMAGE                             COMMAND                  CREATED             STATUS                          \n70c3d48f4343        console-random-answer-generator   &quot;cmd /S /C ConsoleRan&quot;   2 minutes ago       Exited (0) About a minute ago      \n</code></pre><p>The STATUS column shows at &quot;About a minute ago&quot;, the application was complete and could be shut down. If the command was run a hundred times, there would be a hundred containers left static with no work to do. In the beginning scenario the ideal operation was to do the work and shutdown or cleanup. To accomplish that workflow, adding the <code>--rm</code> option to the <code>docker run</code> command will remove the container as soon as the <code>Exited</code> signal is received.</p>\n<pre class=\"loading\"><code>docker run --rm console-random-answer-generator &quot;Are you a square container?&quot;\n</code></pre><p>Running the command with this option and then looking at the output of <code>docker ps -a</code> command; notice that the container id (the <code>Environment.MachineName</code>) is not in the list.</p>\n<h3 id=\"running-the-container-using-powershell\">Running the container using PowerShell</h3>\n<p>In the sample project files there is also a <em>run.ps1</em> which is an example of how to use PowerShell to run the application accepting the arguments.</p>\n<p>To run, open PowerShell and use the following command:</p>\n<pre class=\"loading\"><code>.\\run.ps1 &quot;Is this easy or what?&quot;\n</code></pre><h2 id=\"summary\">Summary</h2>\n<p>Just by adding a Dockerfile and publishing the application, you can containerize your .NET Framework console applications and now take the advantage of running multiple instances, clean start and stop and more Windows Server 2016 capabilities without making any changes to the application code at all.</p>\n</div></div>","outputRootRelativePath":"../../../","pageMetadata":"<meta name=\"author\" content=\"spboyer\">\r\n<meta name=\"ms.author\" content=\"dotnetcontent\">\r\n<meta name=\"manager\" content=\"wpickett\">\r\n<meta name=\"breadcrumb_path\" content=\"/dotnet-internal/toc2.json\">\r\n<meta name=\"ms.devlang\" content=\"dotnet\">\r\n<meta name=\"ms.assetid\" content=\"85cca1d5-c9a4-4eb2-93e6-4f878de07fd7\">\r\n<meta name=\"description\" content=\"Learn how to take an existing .NET Framework console application and run it in a Windows Docker container.\">\r\n<meta name=\"keywords\" content=\".NET, Container, Console, Applications\">\r\n<meta name=\"ms.topic\" content=\"article\">\r\n<meta name=\"ms.date\" content=\"09/28/2016\">\r\n<meta name=\"ms.technology\" content=\"vs-ide-deployment\">\r\n<meta name=\"ms.prod\" content=\".net-framework-4.6\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"docs-internal\">\r\n<meta name=\"version\" content=\"0\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.docs-internal\">\r\n<meta name=\"updated_at\" content=\"2017-03-21 01:42 AM\">\r\n<meta name=\"gitcommit\" content=\"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/framework/docker/console.md\">\r\n<meta name=\"original_content_git_url\" content=\"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/framework/docker/console.md\">\r\n<meta name=\"document_id\" content=\"d36d92e0-269e-cac5-b40e-e050a94013d1\">\r\n<meta name=\"pagetype\" content=\"Conceptual\">\r\n<meta name=\"toc_rel\" content=\"../../toc2.json\">\r\n","rawMetadata":{"author":"spboyer","ms.author":"dotnetcontent","manager":"wpickett","breadcrumb_path":"/dotnet-internal/toc.json","title":"Running Console applications in Docker | Microsoft Docs","ms.devlang":"dotnet","ms.assetid":"85cca1d5-c9a4-4eb2-93e6-4f878de07fd7","description":"Learn how to take an existing .NET Framework console application and run it in a Windows Docker container.","keywords":".NET, Container, Console, Applications","ms.topic":"article","ms.date":"09/28/2016","ms.technology":"vs-ide-deployment","ms.prod":".net-framework-4.6","search.ms_sitename":"Docs","search.ms_docsetname":"docs-internal","version":0,"_op_canonicalUrlPrefix":"https://docs.microsoft.com/en-us/dotnet-internal/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":false,"depot_name":"MSDN.docs-internal","_op_gitCommitHistory":[{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Metadata updates (#1313)","commit_sha":"90fe68f7f3c4b46502b5d3770b1a2d57c6af748a","commit_date":"2016-12-09 12:40:41 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Absolute urls and other fixes (#1281)","commit_sha":"f7dffe4885b331cec8d37f3cc5c9163f69c3b4c9","commit_date":"2016-11-22 12:57:26 -0800"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"renamed repo/fixed headings (#1186)","commit_sha":"15c55a87beb64f265a164db918c7721c7690fadf","commit_date":"2016-10-29 15:23:17 -0400"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"improving flow of the sentence (#1125)","commit_sha":"8f08a57743b8b00fc12d73b886c72378aa0cd263","commit_date":"2016-10-10 13:42:56 -0700"},{"author_name":"Maira Wenzel","author_email":"mairaw@microsoft.com","committer_name":"Bill Wagner","comitter_email":"wiwagn@microsoft.com","message":"a few edits for the docker console topic (#1100)","commit_sha":"893a673406baebaec86d9af025270cbfab4e4260","commit_date":"2016-10-05 14:05:18 -0400"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Running aspnet mvc in docker (#1090)","commit_sha":"6b9ae37f4053d292c21b02f9e7f93ccd32a78976","commit_date":"2016-09-30 18:58:03 -0400"},{"author_name":"Shayne Boyer","author_email":"spboyer@live.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Running .NET Framework Console in Containers (#1092)","commit_sha":"977a36355ac84189e18eb88220f8fcebd3288d49","commit_date":"2016-09-30 18:22:25 -0400"},{"author_name":"Bill Wagner","author_email":"wiwagn@microsoft.com","committer_name":"GitHub","comitter_email":"noreply@github.com","message":"Update TOC for Docker (#1088)","commit_sha":"e14a28e7908c76eec7ef4efd7d762ab1825a973a","commit_date":"2016-09-30 17:42:49 -0400"}],"updated_at":"2017-03-21 01:42 AM","_op_gitContributorInformation":{"author":{"profile_url":"https://github.com/spboyer","display_name":"Shayne Boyer","id":"7681382"},"contributors":[{"profile_url":"https://github.com/spboyer","display_name":"Shayne Boyer"},{"profile_url":"https://github.com/mairaw","display_name":"Maira Wenzel","id":"12971179"},{"profile_url":"https://github.com/BillWagner","display_name":"Bill Wagner","id":"493969"}],"update_at":"3/21/2017"},"gitcommit":"https://github.com/dotnet/docs-internal/blob/90fe68f7f3c4b46502b5d3770b1a2d57c6af748a/docs/framework/docker/console.md","original_content_git_url":"https://github.com/dotnet/docs-internal/blob/tianzhXamarin/docs/framework/docker/console.md","open_to_public_contributors":false,"content_git_url":"https://github.com/dotnet/docs/blob/master/docs/framework/docker/console.md","document_id":"d36d92e0-269e-cac5-b40e-e050a94013d1","layout":"Conceptual","pagetype":"Conceptual","canonical_url":"https://docs.microsoft.com/en-us/dotnet-all/articles/framework/docker/console","toc_asset_id":"articles/toc.json","toc_rel":"../../toc.json","_op_ogTitle":"Running Console applications in Docker","_op_displayDate":"2016-9-28","_op_displayDate_source":"2016-09-28T00:00:00Z","_op_wordCount":1127,"_op_rawTitle":"<h1 id=\"running-console-applications-in-windows-containers\" sourcefile=\"docs/framework/docker/console.md\" sourcestartlinenumber=\"15\" sourceendlinenumber=\"15\">Running console applications in Windows containers</h1>","_op_searchScope":[".NET"],"_op_canonicalUrl":"https://docs.microsoft.com/en-us/dotnet-all/articles/framework/docker/console","fileRelativePath":"articles/framework/docker/console.html"},"themesRelativePathToOutputRoot":"_themes/"}